# 1 "firmware/myproject.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 362 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/autopilot_ssdm_op.h" 1
# 105 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/autopilot_ssdm_op.h"
extern "C" {






    void _ssdm_op_IfRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_IfWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_StreamRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_StreamWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned _ssdm_StreamSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_ReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Read(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_WriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Write(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_NbReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_CanReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_NbWriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_CanWriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));




    void _ssdm_op_MemShiftRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_PrintNone(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_PrintInt(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_PrintDouble(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_Wait(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Poll(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_Return(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_op_SpecSynModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecTopModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProcessDecl(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProcessDef(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecConnection(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecChannel(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecSensitive(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecModuleInst(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPortMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecReset(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPlatform(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecClockDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPowerDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    int _ssdm_op_SpecRegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    int _ssdm_op_SpecRegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecLoopName(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecLoopTripCount(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    int _ssdm_op_SpecStateBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    int _ssdm_op_SpecStateEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecInterface(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPipeline(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecDataflowPipeline(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_op_SpecLatency(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecParallel(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProtocol(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecOccurrence(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecResource(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecResourceLimit(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecCHCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecFUCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecIFCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecIPCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecMemCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecExt(...) __attribute__ ((nothrow)) __attribute__((overloadable));




    void _ssdm_SpecArrayDimSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_RegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_RegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_InlineAll(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineLoop(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_Inline(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineSelf(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineRegion(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecArrayMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecArrayPartition(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecArrayReshape(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecStream(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecStable(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecStableContent(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecBindPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPipoDepth(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecExpr(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecExprBalance(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecDependence(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecLoopMerge(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecLoopFlatten(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecLoopRewind(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecFuncInstantiation(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecFuncBuffer(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecFuncExtract(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecConstant(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_DataPack(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecDataPack(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecBitsMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecLicense(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void __xilinx_ip_top(...) __attribute__ ((nothrow)) __attribute__((overloadable));


}
# 2 "<built-in>" 2
# 1 "firmware/myproject.cpp" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/iostream" 1 3
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/iostream" 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 1 3
# 236 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 258 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 508 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/os_defines.h" 1 3
# 39 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 394 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 395 "/usr/include/features.h" 2 3 4
# 480 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 481 "/usr/include/features.h" 2 3 4
# 502 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 576 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 577 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 578 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 503 "/usr/include/features.h" 2 3 4
# 526 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 527 "/usr/include/features.h" 2 3 4
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/os_defines.h" 2 3
# 509 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/cpu_defines.h" 1 3
# 512 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 39 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/iostream" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 1 3
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ios" 1 3
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ios" 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/iosfwd" 1 3
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/iosfwd" 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stringfwd.h" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stringfwd.h" 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/memoryfwd.h" 1 3
# 47 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{
# 63 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 52 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stringfwd.h" 3
  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;




  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;





  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;


}




}
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/iosfwd" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/postypes.h" 1 3
# 39 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/postypes.h" 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwchar" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 119 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 31 "/usr/include/wchar.h" 2 3 4




# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 62 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 36 "/usr/include/wchar.h" 2 3 4


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stdarg.h" 1 3 4
# 30 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 39 "/usr/include/wchar.h" 2 3 4




typedef __gnuc_va_list va_list;








# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 52 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 53 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 2 3 4

typedef __mbstate_t mbstate_t;
# 54 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 55 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 58 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 61 "/usr/include/wchar.h" 2 3 4
# 90 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern size_t wcslcpy (wchar_t *__restrict __dest,
         const wchar_t *__restrict __src, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2))) ;



extern size_t wcslcat (wchar_t *__restrict __dest,
         const wchar_t *__restrict __src, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2))) ;



extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) noexcept (true);


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) noexcept (true);



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) noexcept (true);

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) noexcept (true);




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) noexcept (true);



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) noexcept (true);







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) noexcept (true);




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) noexcept (true);


extern wchar_t *wcsdup (const wchar_t *__s) noexcept (true)
  __attribute__ ((__malloc__)) ;
# 189 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     noexcept (true) __attribute__ ((__pure__));
# 199 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     noexcept (true) __attribute__ ((__pure__));





extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     noexcept (true) __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     noexcept (true) __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     noexcept (true) __attribute__ ((__pure__));
# 226 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
     noexcept (true) __attribute__ ((__pure__));
# 237 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
     noexcept (true) __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) noexcept (true);


extern size_t wcslen (const wchar_t *__s) noexcept (true) __attribute__ ((__pure__));
# 258 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
     noexcept (true) __attribute__ ((__pure__));





extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__));
# 278 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
     noexcept (true) __attribute__ ((__pure__));



extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) noexcept (true);



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     noexcept (true);


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) noexcept (true);




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     noexcept (true);





extern wint_t btowc (int __c) noexcept (true);



extern int wctob (wint_t __c) noexcept (true);



extern int mbsinit (const mbstate_t *__ps) noexcept (true) __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) noexcept (true);


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) noexcept (true);


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) noexcept (true);
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) noexcept (true);
# 362 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) noexcept (true);



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) noexcept (true);





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) noexcept (true);



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) noexcept (true);






extern int wcwidth (wchar_t __c) noexcept (true);



extern int wcswidth (const wchar_t *__s, size_t __n) noexcept (true);





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) noexcept (true);



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);
# 422 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) noexcept (true);



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) noexcept (true);
# 437 "/usr/include/wchar.h" 3 4
extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);
# 455 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) noexcept (true);



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     noexcept (true);




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     noexcept (true);



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) noexcept (true);





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     noexcept (true);



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) noexcept (true);






extern long int wcstol (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_wcstol");


extern unsigned long int wcstoul (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_wcstoul");



__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_wcstoll");



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_wcstoull");




__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_wcstoll");


__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_wcstoull");
# 561 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true);

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) noexcept (true);

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) noexcept (true);

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true);





extern long int wcstol_l (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_wcstol_l");



extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_wcstoul_l");




__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_wcstoll_l");




__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_wcstoull_l");
# 630 "/usr/include/wchar.h" 3 4
extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     noexcept (true);

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     noexcept (true);

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);
# 649 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) noexcept (true);



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) noexcept (true);
# 667 "/usr/include/wchar.h" 3 4
extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);
# 689 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) noexcept (true);



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     noexcept (true);
# 718 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) ;





extern int fwide (__FILE *__fp, int __mode) noexcept (true);






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     noexcept (true) ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     noexcept (true) ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     noexcept (true) ;
# 795 "/usr/include/wchar.h" 3 4
extern int fwscanf (__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc23_fwscanf")


                                                          ;
extern int wscanf (const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc23_wscanf")

                                                          ;
extern int swscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc23_swscanf")


                                                          ;
# 851 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     noexcept (true) ;
# 875 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc23_vfwscanf")


                                                          ;
extern int vwscanf (const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc23_vwscanf")

                                                          ;
extern int vswscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc23_vswscanf")


                                                          ;
# 935 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 990 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 1016 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 1026 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) noexcept (true);




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) noexcept (true);
# 1073 "/usr/include/wchar.h" 3 4
}
# 45 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwchar" 2 3
# 62 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/postypes.h" 2 3
# 68 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 88 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 74 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ios" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/exception" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/exception" 3

#pragma GCC visibility push(default)



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception.h" 1 3
# 35 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/exception" 2 3

extern "C++" {

namespace std
{


  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 102 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));
# 111 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/exception" 3
}

namespace __gnu_cxx
{
# 133 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception_ptr.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception_defines.h" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception_ptr.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cxxabi_init_exception.h" 1 3
# 35 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3
# 51 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 3
typedef long int ptrdiff_t;
# 118 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/__stddef_max_align_t.h" 1 3
# 35 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 119 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 2 3
# 39 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cxxabi_init_exception.h" 2 3
# 50 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception_ptr.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/typeinfo" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/typeinfo" 3



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/hash_bytes.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 136 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception_ptr.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/new" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/new" 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/exception" 1 3
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 120 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));






void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 168 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/new" 3
inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 216 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/new" 3
#pragma GCC visibility pop
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 117 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 144 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }

  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {
# 206 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/exception_ptr.h" 3
      return exception_ptr();

    }


}

}

#pragma GCC visibility pop
# 144 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/exception" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/nested_exception.h" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/nested_exception.h" 3
#pragma GCC visibility push(default)







# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/move.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/move.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/concept_check.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/concept_check.h" 3
# 35 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{
# 56 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }






    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 91 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 180 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 312 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 340 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile && >
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args...) >
    : public true_type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args......) >
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };
# 712 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };
# 747 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __bool_constant<__is_assignable(_Tp, _Up)>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, __bool_constant<
        __is_trivially_constructible(_Tp, _Args...)>>::type
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<is_default_constructible<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };

  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };

  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };

  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };

  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };
# 1452 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };
# 1509 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1590 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1694 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;
# 1744 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };
# 1781 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };
# 1820 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 1840 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 1879 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }
# 2072 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };

  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };


  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };



  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };
# 2351 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<typename...> using __void_t = void;
# 2364 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2408 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename remove_cv<
      typename remove_reference<_Tp>::type>::type>::type
    { };

  template<typename _Tp>
    inline
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };
# 2613 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
  template<typename _Result, typename _Ret, typename = void>
    struct __is_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>
    : __or_<is_void<_Ret>, is_convertible<typename _Result::type, _Ret>>::type
    { };

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuch {
    __nonesuch() = delete;
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
# 2974 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/type_traits" 3
}
# 56 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 72 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 116 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 136 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 176 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {



      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/nested_exception.h" 2 3

extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }


  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 145 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/exception" 2 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ios" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/char_traits.h" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/char_traits.h" 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 1 3
# 60 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/functexcept.h" 1 3
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cpp_type_traits.h" 1 3
# 36 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cpp_type_traits.h" 3
# 67 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 278 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 408 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 62 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/type_traits.h" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 63 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/numeric_traits.h" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 54 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 53) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 15);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 308);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_pair.h" 1 3
# 65 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_pair.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 76 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


                    constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };




  struct __nonesuch_no_braces : std::__nonesuch {
    explicit __nonesuch_no_braces(const __nonesuch&) = delete;
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };







  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 252 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;

      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 280 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch_no_braces&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch_no_braces&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
    is_assignable<_T2&, const _U2&>>::value,
    pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
    is_assignable<_T2&, _U2&&>>::value,
    pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };






  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline





    void

    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 521 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 541 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_pair.h" 3
}
# 65 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator_base_types.h" 1 3
# 63 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{
# 89 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 143 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 177 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
# 231 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator_base_types.h" 3
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator_base_funcs.h" 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/debug/assertions.h" 1 3
# 66 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


                                ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }
# 200 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    inline _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {


      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {



      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 1 3
# 66 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ptr_traits.h" 1 3
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }


  template<typename _Ptr>
    constexpr typename std::pointer_traits<_Ptr>::element_type*
    __to_address(const _Ptr& __ptr)
    { return std::__to_address(__ptr.operator->()); }
# 199 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ptr_traits.h" 3
}
# 67 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 100 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;
# 127 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }





      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>

        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




                           iterator_type
      base() const
      { return current; }
# 168 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
                           reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }
# 182 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
                           pointer
      operator->() const
      { return std::__addressof(operator*()); }






                           reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






                           reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






                           reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






                           reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






                           reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







                           reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






                           reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







                           reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






                           reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 300 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
# 390 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }
# 425 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 454 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 489 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 531 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 546 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 580 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 622 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 641 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 692 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 737 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 761 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 861 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    { return __it.base(); }
# 1006 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;


      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>

 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

                           iterator_type
      base() const
      { return _M_current; }

                           reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

                           pointer
      operator->() const
      { return _M_current; }

                           move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

                           move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

                           move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

                           move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

                           move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

                           move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

                           move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

                           move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

                           reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }



  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 1272 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_iterator.h" 3
}
# 68 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 2 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/debug/debug.h" 1 3
# 48 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 70 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 2 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/predefined_ops.h" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>

      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };


  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>

        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>

    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 118 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
# 148 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 164 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {





                                                       ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 192 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _Tp>

    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
# 216 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _Tp>

    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
# 240 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>

    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 262 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>

    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    inline _Iterator
    __niter_base(_Iterator __it)
    { return __it; }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
 static _Tp*
 __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
        && __is_pointer<_II>::__value
        && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
         _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 444 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 477 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
 static _Tp*
 __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
        && __is_pointer<_BI1>::__value
        && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 620 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 656 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
# 722 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



                                                     ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 782 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {



      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __is_pointer<_II1>::__value
        && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>
 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
 static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 982 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




                                                                  ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }
# 1037 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {






                                                       ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1069 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1219 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
# 1233 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
                                                       ;
                                                       ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1255 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {



                                                       ;
                                                       ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1298 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






                                                       ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1331 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 1433 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algobase.h" 3
}
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/char_traits.h" 2 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwchar" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwchar" 3
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/char_traits.h" 2 3





namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 61 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
                         int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
                         std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
                         const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      if (__n == 0)
 return __s1;
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{
# 270 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {






 if (__n == 0)
   return 0;
 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {




 return __builtin_strlen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {






 if (__n == 0)
   return 0;
 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {






 if (__n == 0)
   return 0;
 else
   return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {





   return wcslen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {






 if (__n == 0)
   return 0;
 else
   return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}





# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdint" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdint" 3








# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stdint.h" 1 3
# 63 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stdint.h" 3
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h" 3 4
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
# 42 "/usr/include/stdint.h" 2 3 4





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 60 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 76 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 90 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 64 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stdint.h" 2 3
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 504 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return __c == eof() ? int_type(0xfffd) : int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ios" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/localefwd.h" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/localefwd.h" 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++locale.h" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/clocale" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) noexcept (true);


extern struct lconv *localeconv (void) noexcept (true);
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) noexcept (true);
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) noexcept (true);



extern void freelocale (locale_t __dataset) noexcept (true);






extern locale_t uselocale (locale_t __dataset) noexcept (true);







}
# 43 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/clocale" 2 3








namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/localefwd.h" 2 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cctype" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     noexcept (true) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     noexcept (true) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     noexcept (true) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) noexcept (true);
extern int isalpha (int) noexcept (true);
extern int iscntrl (int) noexcept (true);
extern int isdigit (int) noexcept (true);
extern int islower (int) noexcept (true);
extern int isgraph (int) noexcept (true);
extern int isprint (int) noexcept (true);
extern int ispunct (int) noexcept (true);
extern int isspace (int) noexcept (true);
extern int isupper (int) noexcept (true);
extern int isxdigit (int) noexcept (true);



extern int tolower (int __c) noexcept (true);


extern int toupper (int __c) noexcept (true);




extern int isblank (int) noexcept (true);




extern int isctype (int __c, int __mask) noexcept (true);






extern int isascii (int __c) noexcept (true);



extern int toascii (int __c) noexcept (true);



extern int _toupper (int) noexcept (true);
extern int _tolower (int) noexcept (true);
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) noexcept (true);
extern int isalpha_l (int, locale_t) noexcept (true);
extern int iscntrl_l (int, locale_t) noexcept (true);
extern int isdigit_l (int, locale_t) noexcept (true);
extern int islower_l (int, locale_t) noexcept (true);
extern int isgraph_l (int, locale_t) noexcept (true);
extern int isprint_l (int, locale_t) noexcept (true);
extern int ispunct_l (int, locale_t) noexcept (true);
extern int isspace_l (int, locale_t) noexcept (true);
extern int isupper_l (int, locale_t) noexcept (true);
extern int isxdigit_l (int, locale_t) noexcept (true);

extern int isblank_l (int, locale_t) noexcept (true);



extern int __tolower_l (int __c, locale_t __l) noexcept (true);
extern int tolower_l (int __c, locale_t __l) noexcept (true);


extern int __toupper_l (int __c, locale_t __l) noexcept (true);
extern int toupper_l (int __c, locale_t __l) noexcept (true);
# 327 "/usr/include/ctype.h" 3 4
}
# 43 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cctype" 2 3
# 62 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 55 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ios" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/atomicity.h" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/atomicity.h" 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr.h" 1 3
# 30 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 1 3
# 35 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 32 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 33 "/usr/include/sched.h" 2 3 4





typedef __pid_t pid_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 80 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 3 4
struct sched_param
{
  int sched_priority;
};
# 81 "/usr/include/x86_64-linux-gnu/bits/sched.h" 2 3 4

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) noexcept (true);


extern int unshare (int __flags) noexcept (true);


extern int sched_getcpu (void) noexcept (true);


extern int getcpu (unsigned int *, unsigned int *) noexcept (true);


extern int setns (int __fd, int __nstype) noexcept (true);


}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     noexcept (true);
extern cpu_set_t *__sched_cpualloc (size_t __count) noexcept (true) ;
extern void __sched_cpufree (cpu_set_t *__set) noexcept (true);

}
# 45 "/usr/include/sched.h" 2 3 4






extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     noexcept (true);


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) noexcept (true);


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) noexcept (true);


extern int sched_getscheduler (__pid_t __pid) noexcept (true);


extern int sched_yield (void) noexcept (true);


extern int sched_get_priority_max (int __algorithm) noexcept (true);


extern int sched_get_priority_min (int __algorithm) noexcept (true);



extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) noexcept (true);
# 130 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) noexcept (true);


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) noexcept (true);


}
# 23 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 23 "/usr/include/x86_64-linux-gnu/bits/timex.h" 2 3 4



struct timex
{
# 58 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;

};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) noexcept (true) __attribute__ ((__nonnull__ (2)));
# 90 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
}
# 34 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 38 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 47 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 48 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) noexcept (true);



extern time_t time (time_t *__timer) noexcept (true);


extern double difftime (time_t __time1, time_t __time0)
     noexcept (true) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) noexcept (true);
# 100 "/usr/include/time.h" 3 4
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp)
   noexcept (true) __attribute__ ((__nonnull__ (1, 3, 4)));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     noexcept (true);






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) noexcept (true);



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) noexcept (true);






extern struct tm *gmtime (const time_t *__timer) noexcept (true);



extern struct tm *localtime (const time_t *__timer) noexcept (true);
# 155 "/usr/include/time.h" 3 4
extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) noexcept (true);



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) noexcept (true);
# 180 "/usr/include/time.h" 3 4
extern char *asctime (const struct tm *__tp) noexcept (true);



extern char *ctime (const time_t *__timer) noexcept (true);
# 198 "/usr/include/time.h" 3 4
extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) noexcept (true);



extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) noexcept (true);
# 218 "/usr/include/time.h" 3 4
extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) noexcept (true);



extern int daylight;
extern long int timezone;
# 247 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) noexcept (true);
# 264 "/usr/include/time.h" 3 4
extern time_t timelocal (struct tm *__tp) noexcept (true);







extern int dysize (int __year) noexcept (true) __attribute__ ((__const__));
# 282 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);


extern int clock_getres (clockid_t __clock_id, struct timespec *__res) noexcept (true);


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     noexcept (true) __attribute__ ((__nonnull__ (2)));
# 324 "/usr/include/time.h" 3 4
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);
# 339 "/usr/include/time.h" 3 4
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) noexcept (true);




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) noexcept (true);


extern int timer_delete (timer_t __timerid) noexcept (true);



extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) noexcept (true);


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     noexcept (true);
# 377 "/usr/include/time.h" 3 4
extern int timer_getoverrun (timer_t __timerid) noexcept (true);






extern int timespec_get (struct timespec *__ts, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 400 "/usr/include/time.h" 3 4
extern int timespec_getres (struct timespec *__ts, int __base)
     noexcept (true);
# 426 "/usr/include/time.h" 3 4
extern int getdate_err;
# 435 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 449 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 24 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 31 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 3 4
struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };
# 32 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 3 4
extern "C" {
extern long int __sysconf (int __name) noexcept (true);
}
# 34 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 104 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 124 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 159 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 197 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) noexcept (true);
# 233 "/usr/include/pthread.h" 3 4
extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);
# 243 "/usr/include/pthread.h" 3 4
extern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,
                                 clockid_t __clockid,
     const struct timespec *__abstime);
# 269 "/usr/include/pthread.h" 3 4
extern int pthread_detach (pthread_t __th) noexcept (true);



extern pthread_t pthread_self (void) noexcept (true) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  noexcept (true) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_setsigmask_np (pthread_attr_t *__attr,
           const __sigset_t *sigmask);




extern int pthread_attr_getsigmask_np (const pthread_attr_t *__attr,
           __sigset_t *sigmask);







extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     noexcept (true) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     noexcept (true);




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) noexcept (true);


extern int pthread_setconcurrency (int __level) noexcept (true);



extern int pthread_yield (void) noexcept (true);

extern int pthread_yield (void) noexcept (true) __asm__ ("" "sched_yield")
  __attribute__ ((__deprecated__ ("pthread_yield is deprecated, use sched_yield instead")));
# 489 "/usr/include/pthread.h" 3 4
extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 509 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 521 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




struct __cancel_jmp_buf_tag
{
  __jmp_buf __cancel_jmp_buf;
  int __mask_was_saved;
};

typedef struct
{
  struct __cancel_jmp_buf_tag __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 557 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 697 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
                            ;
# 709 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
                         ;
# 732 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
                            ;
# 745 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
                         ;



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
                             __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;
# 773 "/usr/include/pthread.h" 3 4
extern int __sigsetjmp (struct __jmp_buf_tag __env[1],
   int __savemask) noexcept (true);






extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,
        clockid_t __clockid,
        const struct timespec *__restrict
        __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 835 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_consistent_np (pthread_mutex_t *) noexcept (true) __asm__ ("" "pthread_mutex_consistent") __attribute__ ((__nonnull__ (1)))

  __attribute__ ((__deprecated__ ("pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent")));
# 874 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_getrobust_np (pthread_mutexattr_t *, int *) noexcept (true) __asm__ ("" "pthread_mutexattr_getrobust") __attribute__ ((__nonnull__ (1)))


  __attribute__ ((__deprecated__ ("pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust")));







extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *, int) noexcept (true) __asm__ ("" "pthread_mutexattr_setrobust") __attribute__ ((__nonnull__ (1)))


  __attribute__ ((__deprecated__ ("pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust")));
# 967 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
# 1004 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 1023 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
# 1051 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 1071 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) noexcept (true) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1145 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 1171 "/usr/include/pthread.h" 3 4
extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __clockid_t __clock_id,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 4)));
# 1194 "/usr/include/pthread.h" 3 4
extern int pthread_condattr_init (pthread_condattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1230 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1297 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) noexcept (true);


extern void *pthread_getspecific (pthread_key_t __key) noexcept (true);


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer)
  noexcept (true) ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     noexcept (true) __attribute__ ((__nonnull__ (2)));
# 1332 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) noexcept (true);
# 1346 "/usr/include/pthread.h" 3 4
}
# 36 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 2 3
# 47 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 236 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
# 246 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 658 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 807 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/atomicity.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 2 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/string" 1 3
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/string" 3




# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/allocator.h" 1 3
# 46 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/allocator.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/new_allocator.h" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
 new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();
# 111 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/new_allocator.h" 3
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      {







 ::operator delete(__p);
      }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p) { __p->~_Up(); }
# 151 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/allocator.h" 2 3
# 57 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 67 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/allocator.h" 3
  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;

      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p) { __p->~_Up(); }

    };
# 107 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/allocator.h" 3
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
 allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return false; }



  template<typename _Tp>
    class allocator<const _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {
# 264 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/allocator.h" 3
 return false;

      }
    };



}
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/string" 2 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ostream_insert.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ostream_insert.h" 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cxxabi_forced.h" 1 3
# 35 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   if (true)
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   if (false)
     {
       __out._M_setstate(__ios_base::badbit);
                              ;
     }
   if (false)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/string" 2 3



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_function.h" 1 3
# 63 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 104 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 166 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 350 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };


  template<typename _Tp>
    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
                           bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
 if (__builtin_constant_p (__x > __y))
   return __x > __y;
 return (long unsigned int)__x > (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
                           bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
 if (__builtin_constant_p (__x < __y))
   return __x < __y;
 return (long unsigned int)__x < (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
                           bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
 if (__builtin_constant_p (__x >= __y))
   return __x >= __y;
 return (long unsigned int)__x >= (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
                           bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
 if (__builtin_constant_p (__x <= __y))
   return __x <= __y;
 return (long unsigned int)__x <= (long unsigned int)__y;
      }
    };
# 761 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {

      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
# 854 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_function.h" 3
  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };
# 978 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:

      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }


      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>

    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:

      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }


      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>

    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 1055 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp, _Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };


  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 1178 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/backward/binders.h" 1 3
# 60 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{
# 107 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1369 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_function.h" 2 3
# 49 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/string" 2 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/range_access.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/range_access.h" 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/initializer_list" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/range_access.h" 2 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }
# 324 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/range_access.h" 3
}
# 52 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/string" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/alloc_traits.h" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/alloc_traits.h" 3



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 1 3
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 static auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 299 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 314 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 326 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 341 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 354 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p, 0); }
# 366 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 377 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 434 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 448 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
# 460 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 472 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 484 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };

  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };

  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;


}
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::__to_address(__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::__to_address(__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 158 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/alloc_traits.h" 3
  };


}
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 2 3
# 52 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



namespace __cxx11 {
# 76 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    private:




      typedef const_iterator __const_iterator;
# 139 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      struct _Alloc_hider : allocator_type
      {




 _Alloc_hider(pointer __dat, const _Alloc& __a)
 : allocator_type(__a), _M_p(__dat) { }

 _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 : allocator_type(std::move(__a)), _M_p(__dat) { }


 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 298 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)"),

       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string&);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 450 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, npos));
      }







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 481 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 499 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }
# 514 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }
# 529 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 541 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 609 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }
# 656 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {


  if (__str.size() <= _S_local_capacity)
    {
      _M_destroy(_M_allocated_capacity);
      _M_data(_M_local_data());
      _M_set_length(0);
    }
  else
    {
      const auto __len = __str.size();
      auto __alloc = __str._M_get_allocator();

      auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
      _M_destroy(_M_allocated_capacity);
      _M_data(__ptr);
      _M_capacity(__len);
      _M_set_length(__len);
    }
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 713 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 731 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (__str._M_is_local())
   {

     if (__str.size())
       this->_S_copy(_M_data(), __str._M_data(), __str.size());
     _M_set_length(__str.size());
   }
 else if (_Alloc_traits::_S_propagate_on_move_assign()
     || _Alloc_traits::_S_always_equal()
     || _M_get_allocator() == __str._M_get_allocator())
   {

     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {

      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
   assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }
# 825 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 954 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 967 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {
# 985 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 1016 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 1045 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
                                  ;
 return _M_data()[__pos];
      }
# 1062 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


                                  ;

                                                                   ;
 return _M_data()[__pos];
      }
# 1083 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
 return _M_data()[__n];
      }
# 1104 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
                           ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
                           ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
                           ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
                           ;
 return operator[](this->size() - 1);
      }
# 1167 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1220 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1237 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
                                        ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
                               ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1279 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1303 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }
# 1348 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
# 1379 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1402 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1418 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
                                        ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1434 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
                               ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1451 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1464 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1532 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
                                                         ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1574 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
                                                           ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1610 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
                                                         ;
 this->insert(__p - begin(), __l.begin(), __l.size());
      }
# 1630 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1653 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n = npos)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1676 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1695 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1719 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1737 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
                                                         ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1797 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_check(__pos, "basic_string::erase");
 if (__n == npos)
   this->_M_set_length(__pos);
 else if (__n != 0)
   this->_M_erase(__pos, _M_limit(__pos, __n));
 return *this;
      }
# 1816 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1835 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 if (__last == end())
   this->_M_set_length(__pos);
 else
   this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
                           ;
 _M_erase(size() - 1, 1);
      }
# 1879 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1901 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1926 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
                                         ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1951 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1975 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1993 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 2013 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 2035 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
                               ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 2056 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 2081 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                        ;
                                             ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 2113 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 2172 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
# 2231 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 2269 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 2279 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 2289 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }
# 2301 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      const _CharT*
      data() const noexcept
      { return _M_data(); }
# 2320 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2336 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2350 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2382 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const noexcept
      {
                               ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2399 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2412 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2446 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2460 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2477 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2491 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2526 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2540 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
                               ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2560 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2575 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2610 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2624 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
                               ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2644 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2658 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2693 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const noexcept;
# 2707 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
                               ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2725 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
      noexcept;
# 2740 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2775 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const noexcept;
# 2789 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
                               ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2807 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
      noexcept;
# 2823 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2842 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2935 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2961 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos) const;
# 2979 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const noexcept;
# 3003 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 3030 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;


      template<typename, typename, typename> friend class basic_stringbuf;
    };
}
# 5925 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 6046 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 6093 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 6131 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 6169 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 6207 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 6245 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 6283 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 6303 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 6321 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 6344 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 6361 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}




# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/string_conversions.h" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/string_conversions.h" 3








# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 3
# 75 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) noexcept (true) ;



extern double atof (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 159 "/usr/include/stdlib.h" 3 4
extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));






extern long int strtol (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtol")


     __attribute__ ((__nonnull__ (1)));
extern unsigned long int strtoul (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoul")



     __attribute__ ((__nonnull__ (1)));

__extension__
extern long long int strtoq (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoll")


     __attribute__ ((__nonnull__ (1)));
__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoull")



     __attribute__ ((__nonnull__ (1)));

__extension__
extern long long int strtoll (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoll")


     __attribute__ ((__nonnull__ (1)));
__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoull")



     __attribute__ ((__nonnull__ (1)));
# 278 "/usr/include/stdlib.h" 3 4
extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 298 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 316 "/usr/include/stdlib.h" 3 4
extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 340 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));





extern long int strtol_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtol_l")



     __attribute__ ((__nonnull__ (1, 4)));
extern unsigned long int strtoul_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtoul_l")




     __attribute__ ((__nonnull__ (1, 4)));
__extension__
extern long long int strtoll_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtoll_l")




     __attribute__ ((__nonnull__ (1, 4)));
__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtoull_l")




     __attribute__ ((__nonnull__ (1, 4)));
# 415 "/usr/include/stdlib.h" 3 4
extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 436 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 457 "/usr/include/stdlib.h" 3 4
extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 505 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) noexcept (true) ;


extern long int a64l (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;
# 103 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 134 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;






# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;







typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{



  return ((__uint16_t) ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8)));

}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{



  return ((((__bsx) & 0xff000000u) >> 24) | (((__bsx) & 0x00ff0000u) >> 8) | (((__bsx) & 0x0000ff00u) << 8) | (((__bsx) & 0x000000ffu) << 24));

}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{



  return ((((__bsx) & 0xff00000000000000ull) >> 56) | (((__bsx) & 0x00ff000000000000ull) >> 40) | (((__bsx) & 0x0000ff0000000000ull) >> 24) | (((__bsx) & 0x000000ff00000000ull) >> 8) | (((__bsx) & 0x00000000ff000000ull) << 8) | (((__bsx) & 0x0000000000ff0000ull) << 24) | (((__bsx) & 0x000000000000ff00ull) << 40) | (((__bsx) & 0x00000000000000ffull) << 56));

}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4






typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 102 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 230 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
}
# 515 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) noexcept (true);


extern void srandom (unsigned int __seed) noexcept (true);





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) noexcept (true) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) noexcept (true);

extern void srand (unsigned int __seed) noexcept (true);



extern int rand_r (unsigned int *__seed) noexcept (true);







extern double drand48 (void) noexcept (true);
extern double erand48 (unsigned short int __xsubi[3]) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) noexcept (true);
extern long int nrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) noexcept (true);
extern long int jrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) noexcept (true);
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) noexcept (true) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern __uint32_t arc4random (void)
     noexcept (true) ;


extern void arc4random_buf (void *__buf, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern __uint32_t arc4random_uniform (__uint32_t __upper_bound)
     noexcept (true) ;




extern void *malloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
                                         ;

extern void *calloc (size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__)) ;


extern void free (void *__ptr) noexcept (true);







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__))

                       ;


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) ;




# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) noexcept (true);





}
# 707 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
                                         ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
                                         ;



extern void abort (void) noexcept (true) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     noexcept (true) __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 749 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void _Exit (int __status) noexcept (true) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) noexcept (true);
# 814 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 827 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 837 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 849 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 859 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 870 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 881 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 891 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 901 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 913 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 923 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
                              ;
# 940 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) noexcept (true) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) noexcept (true) __attribute__ ((__const__)) ;
extern long int labs (long int __x) noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     noexcept (true) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
# 1012 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) noexcept (true);


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) noexcept (true);


extern int wctomb (char *__s, wchar_t __wchar) noexcept (true);



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) noexcept (true)
                                      ;

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     noexcept (true)

                                    ;






extern int rpmatch (const char *__response) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 1099 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) noexcept (true);



extern int unlockpt (int __fd) noexcept (true);




extern char *ptsname (int __fd) noexcept (true) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) ;


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1155 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1156 "/usr/include/stdlib.h" 2 3 4
# 1167 "/usr/include/stdlib.h" 3 4
}
# 76 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 2 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/std_abs.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/std_abs.h" 3
# 46 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }







  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }
# 107 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/std_abs.h" 3
}
}
# 78 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 2 3
# 121 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/string_conversions.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwchar" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwchar" 3
# 43 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/string_conversions.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 28 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 29 "/usr/include/stdio.h" 2 3 4

extern "C" {




# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 3 4
typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 42 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 45 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 48 "/usr/include/stdio.h" 2 3 4
# 85 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 129 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 130 "/usr/include/stdio.h" 2 3 4
# 149 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) noexcept (true);

extern int rename (const char *__old, const char *__new) noexcept (true);



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) noexcept (true);
# 176 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) noexcept (true);






extern int fclose (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 194 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) ;
# 206 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) ;



extern char *tmpnam (char[20]) noexcept (true) ;




extern char *tmpnam_r (char __s[20]) noexcept (true) ;
# 228 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   noexcept (true) __attribute__ ((__malloc__)) ;






extern int fflush (FILE *__stream);
# 245 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 255 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 264 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__nonnull__ (3)));
# 289 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) __attribute__ ((__nonnull__ (3)));




extern FILE *fdopen (int __fd, const char *__modes) noexcept (true)
  __attribute__ ((__malloc__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) noexcept (true)
  __attribute__ ((__malloc__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  noexcept (true) __attribute__ ((__malloc__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) ;





extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) noexcept (true)
  __attribute__ ((__nonnull__ (1)));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void setlinebuf (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...) __attribute__ ((__nonnull__ (1)));




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) noexcept (true);





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nonnull__ (1)));




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) noexcept (true);



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__nonnull__ (1)));




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) noexcept (true);
# 442 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc23_fscanf") __attribute__ ((__nonnull__ (1)));


extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc23_scanf") ;

extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc23_sscanf");
# 490 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__nonnull__ (1)));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__scanf__, 2, 0)));






extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc23_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__nonnull__ (1)));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc23_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc23_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 575 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream) __attribute__ ((__nonnull__ (1)));
extern int getc (FILE *__stream) __attribute__ ((__nonnull__ (1)));





extern int getchar (void);






extern int getc_unlocked (FILE *__stream) __attribute__ ((__nonnull__ (1)));
extern int getchar_unlocked (void);
# 600 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 611 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));
extern int putc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));





extern int putchar (int __c);
# 627 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));







extern int putc_unlocked (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream) __attribute__ ((__nonnull__ (1)));


extern int putw (int __w, FILE *__stream) __attribute__ ((__nonnull__ (2)));







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
                                                          __attribute__ ((__nonnull__ (3)));
# 667 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));
# 677 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
                                                   __attribute__ ((__nonnull__ (3)));
# 694 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) __attribute__ ((__nonnull__ (4)));
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) __attribute__ ((__nonnull__ (4)));







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) __attribute__ ((__nonnull__ (3)));







extern int fputs (const char *__restrict __s, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (2)));





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (4)));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) __attribute__ ((__nonnull__ (4)));
# 755 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream) __attribute__ ((__nonnull__ (2)));
# 766 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (4)));
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (4)));







extern int fseek (FILE *__stream, long int __off, int __whence)
  __attribute__ ((__nonnull__ (1)));




extern long int ftell (FILE *__stream) __attribute__ ((__nonnull__ (1)));




extern void rewind (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 803 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence)
  __attribute__ ((__nonnull__ (1)));




extern __off_t ftello (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 829 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos)
  __attribute__ ((__nonnull__ (1)));




extern int fsetpos (FILE *__stream, const fpos_t *__pos) __attribute__ ((__nonnull__ (1)));
# 851 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence)
  __attribute__ ((__nonnull__ (1)));
extern __off64_t ftello64 (FILE *__stream) __attribute__ ((__nonnull__ (1)));
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos)
  __attribute__ ((__nonnull__ (1)));
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos) __attribute__ ((__nonnull__ (1)));



extern void clearerr (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern int feof (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern int ferror (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern void clearerr_unlocked (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));
extern int feof_unlocked (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));
extern int ferror_unlocked (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));







extern void perror (const char *__s) __attribute__ ((__cold__));




extern int fileno (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int fileno_unlocked (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 897 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream) __attribute__ ((__nonnull__ (1)));





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) ;






extern char *ctermid (char *__s) noexcept (true)
                                     ;





extern char *cuserid (char *__s)
                                     ;




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int ftrylockfile (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void funlockfile (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 959 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 983 "/usr/include/stdio.h" 3 4
}
# 43 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 2 3
# 96 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;


  using ::gets;

  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 3
namespace __gnu_cxx
{
# 175 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/string_conversions.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cerrno" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) noexcept (true) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;


# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4



}
# 43 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cerrno" 2 3
# 45 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*__errno_location ())) { (*__errno_location ()) = 0; }
 ~_Save_errno() { if ((*__errno_location ()) == 0) (*__errno_location ()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      struct _Range_chk {
   static bool
   _S_chk(_TRet, std::false_type) { return false; }

   static bool
   _S_chk(_TRet __val, std::true_type)
   {
     return __val < _TRet(__numeric_traits<int>::__min)
       || __val > _TRet(__numeric_traits<int>::__max);
   }
      };

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
   || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 6401 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }






  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}






# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/functional_hash.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/functional_hash.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{
# 49 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type ;
      typedef _Arg argument_type ;
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 124 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };
# 187 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 6627 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };
# 6740 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.h" 3
}
# 53 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/string" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.tcc" 1 3
# 43 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 if (true)
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 if (false)
   {
     _M_dispose();
                            ;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid"));


 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 if (true)
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 if (false)
   {
     _M_dispose();
                            ;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
                                             ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1155 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
                                      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      const size_type __size = this->size();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__pos >= __size)
 return npos;

      const _CharT __elem0 = __s[0];
      const _CharT* const __data = data();
      const _CharT* __first = __data + __pos;
      const _CharT* const __last = __data + __size;
      size_type __len = __size - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __s, __n) == 0)
     return __first - __data;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const noexcept
    {
                                    ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
                                    ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
                                              ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   if (false)
     {
       __in._M_setstate(__ios_base::badbit);
                              ;
     }
   if (false)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   if (true)
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   if (false)
     {
       __in._M_setstate(__ios_base::badbit);
                              ;
     }
   if (false)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
# 1607 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_string.tcc" 3
  extern template class basic_string<char>;







  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);



  extern template class basic_string<wchar_t>;





  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/string" 2 3
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{
# 62 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    locale() throw();
# 126 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 282 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 298 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 333 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 371 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 402 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 438 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   if (true)
     { delete this; }
   if (false)
     { }
 }
    }

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;

  protected:
    class __shim;
  };
# 483 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   if (true)
     { delete this; }
   if (false)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 641 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 668 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 682 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 699 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 718 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 732 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 761 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 775 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 788 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.tcc" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      if (true)
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      if (false)
 {
   _M_impl->_M_remove_reference();
                          ;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      if (true)
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      if (false)
 {
   __tmp->_M_remove_reference();
                          ;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      if (true)
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      if (false)
 {
   delete [] __c;
                          ;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 852 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_classes.h" 2 3
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 2 3




# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/system_error" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/system_error" 3






# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/error_constants.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/error_constants.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cerrno" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cerrno" 3
# 35 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/error_constants.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  enum class errc
    {
      address_family_not_supported = 97,
      address_in_use = 98,
      address_not_available = 99,
      already_connected = 106,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,


      bad_message = 74,


      broken_pipe = 32,
      connection_aborted = 103,
      connection_already_in_progress = 114,
      connection_refused = 111,
      connection_reset = 104,
      cross_device_link = 18,
      destination_address_required = 89,
      device_or_resource_busy = 16,
      directory_not_empty = 39,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 36,
      function_not_supported = 38,
      host_unreachable = 113,


      identifier_removed = 43,


      illegal_byte_sequence = 84,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 90,
      network_down = 100,
      network_reset = 102,
      network_unreachable = 101,
      no_buffer_space = 105,
      no_child_process = 10,


      no_link = 67,


      no_lock_available = 37,


      no_message_available = 61,


      no_message = 42,
      no_protocol_option = 92,
      no_space_on_device = 28,


      no_stream_resources = 63,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 88,


      not_a_stream = 60,


      not_connected = 107,
      not_enough_memory = 12,


      not_supported = 95,



      operation_canceled = 125,


      operation_in_progress = 115,
      operation_not_permitted = 1,
      operation_not_supported = 95,
      operation_would_block = 11,


      owner_dead = 130,


      permission_denied = 13,


      protocol_error = 71,


      protocol_not_supported = 93,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 35,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,


      state_not_recoverable = 131,



      stream_timeout = 62,



      text_file_busy = 26,


      timed_out = 110,
      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 40,


      value_too_large = 75,


      wrong_protocol_type = 91
    };


}
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/system_error" 2 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/stdexcept" 1 3
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;


    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;


    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;

    virtual ~underflow_error() noexcept;
  };




}
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/system_error" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };
# 71 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/system_error" 3
  inline namespace _V2 {


  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 110 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }

    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }
  };


  __attribute__ ((__const__)) const error_category& system_category() noexcept;
  __attribute__ ((__const__)) const error_category& generic_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;

  template<typename _Tp>
    struct hash;



  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    friend class hash<error_code>;

    int _M_value;
    const error_category* _M_cat;
  };


  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }

  error_condition make_error_condition(errc) noexcept;



  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };


  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }

  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }

  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }







  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}



namespace std __attribute__ ((__visibility__ ("default")))
{





  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e._M_value);
 return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
      }
    };
# 415 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/system_error" 3
}
# 47 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 2147483647,
      _S_ios_fmtflags_min = ~2147483647
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 2147483647,
      _S_ios_openmode_min = ~2147483647
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 2147483647,
      _S_ios_iostate_min = ~2147483647
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc __e) noexcept
  { return error_code(static_cast<int>(__e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc __e) noexcept
  { return error_condition(static_cast<int>(__e), iostream_category()); }
# 228 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
  class ios_base
  {
# 246 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
  public:
# 255 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;



    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 489 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 506 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 518 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

                                                             ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
                                                                ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 631 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 647 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 664 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 690 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 741 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 753 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 764 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 775 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 794 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 810 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 831 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 848 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 862 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ios" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 1 3
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3








namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 121 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
        advance(istreambuf_iterator<_CharT2>&, _Distance);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 215 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 232 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 245 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 257 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 269 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 290 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 304 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 322 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 344 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 363 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 378 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 403 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 430 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 456 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 470 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 488 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 504 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 515 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 535 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 551 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 561 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 582 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      virtual void
      imbue(const locale& __loc __attribute__ ((__unused__)))
      { }
# 597 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 608 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 620 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 633 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      virtual int
      sync() { return 0; }
# 655 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 671 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 693 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 706 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 730 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      virtual int_type
      pbackfail(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }
# 748 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 774 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      virtual int_type
      overflow(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 790 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 3
      [[__deprecated__("stossc is deprecated, use sbumpc instead")]]

      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);





}


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/streambuf.tcc" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 863 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/streambuf" 2 3
# 44 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ios" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwctype" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwctype" 3
# 50 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {







extern int iswalnum (wint_t __wc) noexcept (true);





extern int iswalpha (wint_t __wc) noexcept (true);


extern int iswcntrl (wint_t __wc) noexcept (true);



extern int iswdigit (wint_t __wc) noexcept (true);



extern int iswgraph (wint_t __wc) noexcept (true);




extern int iswlower (wint_t __wc) noexcept (true);


extern int iswprint (wint_t __wc) noexcept (true);




extern int iswpunct (wint_t __wc) noexcept (true);




extern int iswspace (wint_t __wc) noexcept (true);




extern int iswupper (wint_t __wc) noexcept (true);




extern int iswxdigit (wint_t __wc) noexcept (true);





extern int iswblank (wint_t __wc) noexcept (true);
# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
extern wctype_t wctype (const char *__property) noexcept (true);



extern int iswctype (wint_t __wc, wctype_t __desc) noexcept (true);






extern wint_t towlower (wint_t __wc) noexcept (true);


extern wint_t towupper (wint_t __wc) noexcept (true);

}
# 39 "/usr/include/wctype.h" 2 3 4





extern "C" {



typedef const __int32_t *wctrans_t;



extern wctrans_t wctrans (const char *__property) noexcept (true);


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) noexcept (true);







extern int iswalnum_l (wint_t __wc, locale_t __locale) noexcept (true);





extern int iswalpha_l (wint_t __wc, locale_t __locale) noexcept (true);


extern int iswcntrl_l (wint_t __wc, locale_t __locale) noexcept (true);



extern int iswdigit_l (wint_t __wc, locale_t __locale) noexcept (true);



extern int iswgraph_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswlower_l (wint_t __wc, locale_t __locale) noexcept (true);


extern int iswprint_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswpunct_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswspace_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswupper_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswxdigit_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswblank_l (wint_t __wc, locale_t __locale) noexcept (true);



extern wctype_t wctype_l (const char *__property, locale_t __locale)
     noexcept (true);



extern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)
     noexcept (true);






extern wint_t towlower_l (wint_t __wc, locale_t __locale) noexcept (true);


extern wint_t towupper_l (wint_t __wc, locale_t __locale) noexcept (true);



extern wctrans_t wctrans_l (const char *__property, locale_t __locale)
     noexcept (true);


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      locale_t __locale) noexcept (true);



}
# 51 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwctype" 2 3
# 80 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cctype" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cctype" 3
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/ctype_base.h" 1 3
# 36 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;

    static const mask blank = _ISblank;

  };


}
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 2 3






# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/streambuf_iterator.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 49 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
 advance(istreambuf_iterator<_CharT2>&, _Distance);

    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {
 int_type __c = _M_get();
# 139 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/streambuf_iterator.h" 3
 return traits_type::to_char_type(__c);
      }


      istreambuf_iterator&
      operator++()
      {



                        ;

 _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {



                        ;

 istreambuf_iterator __old = *this;
 __old._M_c = _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 int_type __ret = _M_c;
 if (_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = _M_sbuf->sgetc()))
   _M_sbuf = 0;
 return __ret;
      }

      bool
      _M_at_eof() const
      { return _S_is_eof(_M_get()); }

      static bool
      _S_is_eof(int_type __c)
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(__c, __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, __eof)
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   __first._M_c = __eof;
 }

      return __first;
    }

  template<typename _CharT, typename _Distance>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        void>::__type
    advance(istreambuf_iterator<_CharT>& __i, _Distance __n)
    {
      if (__n == 0)
 return;

                               ;


                           ;

      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      streambuf_type* __sb = __i._M_sbuf;
      while (__n > 0)
 {
   streamsize __size = __sb->egptr() - __sb->gptr();
   if (__size > __n)
     {
       __sb->__safe_gbump(__n);
       break;
     }

   __sb->__safe_gbump(__size);
   __n -= __size;
   if (traits_type::eq_int_type(__sb->underflow(), __eof))
     {


                      ;
       break;
     }
 }

      __i._M_c = __eof;
    }




}
# 49 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 71 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 930 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 963 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1013 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1030 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1046 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1063 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1083 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1106 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1133 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
      { return __c; }
# 1159 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault __attribute__((__unused__)), char* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1185 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1218 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1229 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1253 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1272 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1290 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1308 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1325 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1342 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1358 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1375 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1395 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1417 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1440 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1466 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { }
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1539 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1669 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1707 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1721 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1735 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1748 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1779 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1792 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1805 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1822 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1834 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1847 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1860 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1873 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}
# 1951 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1972 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1998 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2035 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2095 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2138 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2211 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2274 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2292 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2313 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2331 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2373 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2436 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2461 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { }
# 2509 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2567 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 3
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.tcc" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     if (true)
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     if (false)
       {
  delete __tmp;
                         ;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      if (true)
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      if (false)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
                          ;
 }
    }
# 139 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __num_traits::__is_signed)
   ? -static_cast<__unsigned_type>(__num_traits::__min)
   : __num_traits::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative && __num_traits::__is_signed)
       __v = __num_traits::__min;
     else
       __v = __num_traits::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }
# 1206 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2656 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/locale_facets.h" 2 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
                          ;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.tcc" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = std::__addressof(use_facet<__ctype_type>(__loc));
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = std::__addressof(use_facet<__num_put_type>(__loc));
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = std::__addressof(use_facet<__num_get_type>(__loc));
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/basic_ios.h" 2 3
# 45 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ios" 2 3
# 39 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{
# 57 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      __ostream_type&
      flush();
# 357 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      pos_type
      tellp();
# 368 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 425 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 444 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 454 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 473 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 495 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 537 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 588 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 600 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }


  template<typename _Ch, typename _Up>
    basic_ostream<_Ch, _Up>&
    __is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_ostream_impl
    {
      using __ostream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_ostream_impl =
    decltype(__is_convertible_to_basic_ostream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>
    {
      using __ostream_type =
 __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream
    : __is_convertible_to_basic_ostream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Ostream, typename _Tp, typename = void>
    struct __is_insertable : false_type {};

  template<typename _Ostream, typename _Tp>
    struct __is_insertable<_Ostream, _Tp,
      __void_t<decltype(declval<_Ostream&>()
          << declval<const _Tp&>())>>
        : true_type {};

  template<typename _Ostream>
    using __rvalue_ostream_type =
      typename __is_convertible_to_basic_ostream<
 _Ostream>::__ostream_type;
# 674 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 3
  template<typename _Ostream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,
         __is_convertible_to_basic_ostream<_Ostream>,
         __is_insertable<
    __rvalue_ostream_type<_Ostream>,
    const _Tp&>>::value,
         __rvalue_ostream_type<_Ostream>>::type
    operator<<(_Ostream&& __os, const _Tp& __x)
    {
      __rvalue_ostream_type<_Ostream> __ret_os = __os;
      __ret_os << __x;
      return __ret_os;
    }



}


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ostream.tcc" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     if (true)
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     if (false)
       {
  this->_M_setstate(ios_base::badbit);
                         ;
       }
     if (false)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   if (true)
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   if (true)
     { _M_write(__s, __n); }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      if (true)
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      if (true)
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (true)
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (true)
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   if (true)
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   if (false)
     {
       __out._M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 694 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ostream" 2 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/iostream" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 1 3
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 57 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      int_type
      get();
# 315 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      int_type
      peek();
# 485 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      unget();
# 555 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      int
      sync();
# 570 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      pos_type
      tellg();
# 585 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);


  template<typename _Ch, typename _Up>
    basic_istream<_Ch, _Up>&
    __is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_istream_impl
    {
      using __istream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_istream_impl =
    decltype(__is_convertible_to_basic_istream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_istream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>
    {
      using __istream_type =
 __do_is_convertible_to_basic_istream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_istream
    : __is_convertible_to_basic_istream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Istream, typename _Tp, typename = void>
    struct __is_extractable : false_type {};

  template<typename _Istream, typename _Tp>
    struct __is_extractable<_Istream, _Tp,
       __void_t<decltype(declval<_Istream&>()
           >> declval<_Tp>())>>
    : true_type {};

  template<typename _Istream>
    using __rvalue_istream_type =
      typename __is_convertible_to_basic_istream<
 _Istream>::__istream_type;
# 972 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 3
  template<typename _Istream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,
         __is_convertible_to_basic_istream<_Istream>,
         __is_extractable<
    __rvalue_istream_type<_Istream>,
    _Tp&&>>::value,
         __rvalue_istream_type<_Istream>>::type
    operator>>(_Istream&& __is, _Tp&& __x)
    {
      __rvalue_istream_type<_Istream> __ret_is = __is;
      __ret_is >> std::forward<_Tp>(__x);
      return __ret_is;
    }



}


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/istream.tcc" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 if (true)
   {
     if (__in.tie())
       __in.tie()->flush();
     if (!__noskip && bool(__in.flags() & ios_base::skipws))
       {
  const __int_type __eof = traits_type::eof();
  __streambuf_type* __sb = __in.rdbuf();
  __int_type __c = __sb->sgetc();

  const __ctype_type& __ct = __check_facet(__in._M_ctype);
  while (!traits_type::eq_int_type(__c, __eof)
         && __ct.is(ctype_base::space,
      traits_type::to_char_type(__c)))
    __c = __sb->snextc();




  if (traits_type::eq_int_type(__c, __eof))
    __err |= ios_base::eofbit;
       }
   }
 if (false)
   {
     __in._M_setstate(ios_base::badbit);
                            ;
   }
 if (false)
   { __in._M_setstate(ios_base::badbit); }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     if (true)
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     if (false)
       {
  this->_M_setstate(ios_base::badbit);
                         ;
       }
     if (false)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   if (true)
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::failbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 521 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   if (false)
     {
       __in._M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   if (false)
     {
       __in._M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 992 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/istream" 2 3
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/iostream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 60 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 2 "firmware/myproject.cpp" 2

# 1 "firmware/myproject.h" 1



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_fixed.h" 1








# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_common.h" 1
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_common.h"
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_decl.h" 1
# 54 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_decl.h"
enum ap_q_mode {
  AP_RND,
  AP_RND_ZERO,
  AP_RND_MIN_INF,
  AP_RND_INF,
  AP_RND_CONV,
  AP_TRN,
  AP_TRN_ZERO,
};
# 76 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_decl.h"
enum ap_o_mode {
  AP_SAT,
  AP_SAT_ZERO,
  AP_SAT_SYM,
  AP_WRAP,
  AP_WRAP_SM,
};
# 133 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_decl.h"
template <int _AP_W, bool _AP_S>
struct ap_int_base;

template <int _AP_W>
struct ap_int;

template <int _AP_W>
struct ap_uint;

template <int _AP_W, bool _AP_S>
struct ap_range_ref;

template <int _AP_W, bool _AP_S>
struct ap_bit_ref;

template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref;

template <int _AP_W, int _AP_I, bool _AP_S = true, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed_base;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_ufixed;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref;


enum BaseMode { AP_BIN = 2, AP_OCT = 8, AP_DEC = 10, AP_HEX = 16 };
# 187 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_decl.h"
typedef signed long long ap_slong;
typedef unsigned long long ap_ulong;


enum {
  _AP_SIZE_char = 8,
  _AP_SIZE_short = sizeof(short) * 8,
  _AP_SIZE_int = sizeof(int) * 8,
  _AP_SIZE_long = sizeof(long) * 8,
  _AP_SIZE_ap_slong = sizeof(ap_slong) * 8
};
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_common.h" 2
# 164 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_common.h"
enum { CHAR_IS_SIGNED = (char)-1 < 0 };


namespace _ap_type {
template <typename _Tp>
struct is_signed {
  static const bool value = _Tp(-1) < _Tp(1);
};

template <typename _Tp>
struct is_integral {
  static const bool value = false;
};





template <> struct is_integral<bool> { static const bool value = true; };
template <> struct is_integral<char> { static const bool value = true; };
template <> struct is_integral<signed char> { static const bool value = true; };
template <> struct is_integral<unsigned char> { static const bool value = true; };
template <> struct is_integral<short> { static const bool value = true; };
template <> struct is_integral<unsigned short> { static const bool value = true; };
template <> struct is_integral<int> { static const bool value = true; };
template <> struct is_integral<unsigned int> { static const bool value = true; };
template <> struct is_integral<long> { static const bool value = true; };
template <> struct is_integral<unsigned long> { static const bool value = true; };
template <> struct is_integral<ap_slong> { static const bool value = true; };
template <> struct is_integral<ap_ulong> { static const bool value = true; };


template <bool, typename _Tp = void>
struct enable_if {};

template <typename _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const<_Tp const> {
  typedef _Tp type;
};
}
# 507 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_common.h"
template <int _AP_N, bool _AP_S>
struct ssdm_int;

template <int _AP_N>
struct ssdm_int<_AP_N, true> {
  typedef int __attribute__((bitwidth(_AP_N))) DataType;
  int V __attribute__((bitwidth(_AP_N)));
  inline __attribute__((always_inline)) ssdm_int<_AP_N, true>() = default;
                inline __attribute__((always_inline)) ssdm_int<_AP_N, true>(int o __attribute__((bitwidth(_AP_N)))):V(o){};
};

template <int _AP_N>
struct ssdm_int<_AP_N, false> {
  typedef unsigned __attribute__((bitwidth(_AP_N))) DataType;
  unsigned V __attribute__((bitwidth(_AP_N)));
  inline __attribute__((always_inline)) ssdm_int<_AP_N, false>() = default;
                inline __attribute__((always_inline)) ssdm_int<_AP_N, false>(unsigned o __attribute__((bitwidth(_AP_N)))):V(o){};
};
# 575 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_common.h"
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/autopilot_ssdm_bits.h" 1
# 576 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_common.h" 2

extern "C" void _ssdm_string2bits(...);
# 587 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_common.h"
static inline unsigned char guess_radix(const char* s) {
  unsigned char rd = 10;
  const char* p = s;

  if (p[0] == '-' || p[0] == '+') ++p;

  if (p[0] == '0') {
    if (p[1] == 'b' || p[1] == 'B') {
      rd = 2;
    } else if (p[1] == 'o' || p[1] == 'O') {
      rd = 8;
    } else if (p[1] == 'x' || p[1] == 'X') {
      rd = 16;
    } else if (p[1] == 'd' || p[1] == 'D') {
      rd = 10;
    }
  }
  return rd;
}







typedef __fp16 half;
# 710 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_common.h"
inline __attribute__((always_inline)) ap_ulong doubleToRawBits(double pf) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline __attribute__((always_inline)) unsigned int floatToRawBits(float pf) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline __attribute__((always_inline)) unsigned short halfToRawBits(half pf) {

  union {
    unsigned short __L;
    half __D;
  } LD;
  LD.__D = pf;
  return LD.__L;



}


inline __attribute__((always_inline)) double rawBitsToDouble(ap_ulong pi) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline __attribute__((always_inline)) float rawBitsToFloat(unsigned long pi) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline __attribute__((always_inline)) half rawBitsToHalf(unsigned short pi) {

  union {
    unsigned short __L;
    half __D;
  } LD;
  LD.__L = pi;
  return LD.__D;






}
# 10 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_fixed.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h" 1
# 16 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_int.h" 1
# 11 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_int.h"
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h" 1
# 56 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_N, bool _AP_S>
struct retval;


template <int _AP_N>
struct retval<_AP_N, true> {
  typedef ap_slong Type;
};

template <int _AP_N>
struct retval<_AP_N, false> {
  typedef ap_ulong Type;
};


template <>
struct retval<1, true> {
  typedef signed char Type;
};

template <>
struct retval<1, false> {
  typedef unsigned char Type;
};


template <>
struct retval<2, true> {
  typedef short Type;
};

template <>
struct retval<2, false> {
  typedef unsigned short Type;
};


template <>
struct retval<3, true> {
  typedef long Type;
};

template <>
struct retval<3, false> {
  typedef unsigned long Type;
};

template <>
struct retval<4, true> {
  typedef long Type;
};

template <>
struct retval<4, false> {
  typedef unsigned long Type;
};




template <int _AP_W2, bool _AP_S2>
struct _ap_int_factory;
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,true> { typedef ap_int<_AP_W2> type; };
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,false> { typedef ap_uint<_AP_W2> type; };

template <int _AP_W, bool _AP_S>
struct ap_int_base : public ssdm_int<_AP_W, _AP_S> {
 private:
                inline __attribute__((always_inline)) __attribute__((nodebug)) int countLeadingOnes() const {




    return 0;

  }

 public:
  typedef ssdm_int<_AP_W, _AP_S> Base;







  typedef typename retval<(((_AP_W + 7) / 8) > (8) ? ((_AP_W + 7) / 8) : (8)), _AP_S>::Type RetType;

  static const int width = _AP_W;
  static const bool sign_flag = _AP_S;

  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };


    typedef ap_int_base<mult_w, mult_s> mult_base;
    typedef ap_int_base<plus_w, plus_s> plus_base;
    typedef ap_int_base<minus_w, minus_s> minus_base;
    typedef ap_int_base<logic_w, logic_s> logic_base;
    typedef ap_int_base<div_w, div_s> div_base;
    typedef ap_int_base<mod_w, mod_s> mod_base;
    typedef ap_int_base<_AP_W, _AP_S> arg1_base;

    typedef typename _ap_int_factory<mult_w, mult_s>::type mult;
    typedef typename _ap_int_factory<plus_w, plus_s>::type plus;
    typedef typename _ap_int_factory<minus_w, minus_s>::type minus;
    typedef typename _ap_int_factory<logic_w, logic_s>::type logic;
    typedef typename _ap_int_factory<div_w, div_s>::type div;
    typedef typename _ap_int_factory<mod_w, mod_s>::type mod;
    typedef typename _ap_int_factory<_AP_W, _AP_S>::type arg1;
    typedef bool reduce;
  };





  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base() = default;


  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op.V) {
    Base::V = op.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }
# 218 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const bool op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const char op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const signed char op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const unsigned char op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const short op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const unsigned short op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const int op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const unsigned int op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const long op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const unsigned long op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const ap_slong op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const ap_ulong op):Base(op) { Base::V = op; }




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(half op) {
    ap_int_base<_AP_W, _AP_S> t((float)op);
    Base::V = t.V;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(float op) {
    const int BITS = 23 + 8 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = floatToRawBits(op);
    bool is_neg = ({ __typeof__(reg.V) __Val2__ = reg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), BITS - 1); __Result__; });

    ap_int_base<8 + 1, true> exp = 0;
    exp.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 23, BITS - 2); __Result__; });
    exp = exp - ((1 << (8 - 1)) - 1);

    ap_int_base<23 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 23 - 1); __Result__; });

    (static_cast<void>(0));


    man.V = ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 23); __Result__; });


    if ((reg.V & 0x7ffffffful) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 23 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 23 + 2) {
          ap_int_base<23 + 2, true> man_shift;
          man_shift.V = (man.V >> sh_amt);






          Base::V = man_shift.V;
        } else {



            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {



          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(double op) {
    const int BITS = 52 + 11 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = doubleToRawBits(op);
    bool is_neg = ({ __typeof__(reg.V) __Val2__ = reg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), BITS - 1); __Result__; });

    ap_int_base<11 + 1, true> exp, bias = ((1 << (11 - 1)) - 1);
    exp.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, BITS - 2); __Result__; });
    exp = exp - bias;

    ap_int_base<52 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });

    (static_cast<void>(0));


    man.V = ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });


    if ((reg.V & 0x7fffffffffffffffull) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 52 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 52 + 2) {
          ap_int_base<23 + 2, true> man_shift;
          man_shift.V = (man.V >> sh_amt);






          Base::V = man_shift.V;
        } else {



           Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {



          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    op.checkOverflowCsimFix(_AP_W, _AP_S);
    Base::V = op.to_ap_int_base().V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const ap_range_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = (ref.get()).V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const ap_bit_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = ref.operator bool();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref) {
    const ap_int_base<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>::_AP_WR,
                      false>
        tmp = ref.get();
    Base::V = tmp.V;
  }
# 397 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const char* s) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_W, _AP_S,
                      AP_TRN, AP_WRAP, 0, true);
    Base::V = t;
  }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const char* s, signed char rd) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_W, _AP_S,
                      AP_TRN, AP_WRAP, 0, true);
    Base::V = t;
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = (val.get()).V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = val.operator bool();
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base read() volatile {

    ap_int_base ret;
    ret.V = Base::V;
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {

    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const ap_int_base<_AP_W, _AP_S>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(const volatile ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }


  ap_int_base& operator=(const ap_int_base<_AP_W, _AP_S>& op2) = default;
# 491 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(bool op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(signed char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(unsigned char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(short op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(unsigned short op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(int op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(unsigned int op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(long op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(unsigned long op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(ap_slong op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(ap_ulong op) { Base::V = op; return *this; }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (bool)op2;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (ap_int_base<_AP_W2, false>(op2)).V;
    return *this;
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op2) {
    Base::V = op2.get().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = (bool)op;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;
    return *this;
  }





                inline __attribute__((always_inline)) __attribute__((nodebug)) operator RetType() const { return (RetType)(Base::V); }




                inline __attribute__((always_inline)) __attribute__((nodebug)) bool to_bool() const { return (bool)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) char to_char() const { return (char)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) signed char to_schar() const { return (signed char)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned char to_uchar() const { return (unsigned char)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) short to_short() const { return (short)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned short to_ushort() const { return (unsigned short)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) int to_int() const { return (int)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned to_uint() const { return (unsigned)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) long to_long() const { return (long)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned long to_ulong() const { return (unsigned long)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_slong to_int64() const { return (ap_slong)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) half to_half() const { return (float)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) float to_float() const { return (float)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) double to_double() const { return (double)(Base::V); }
# 596 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const volatile { return _AP_W; }
                inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const { return _AP_W; }


                inline __attribute__((always_inline)) __attribute__((nodebug)) bool iszero() const { return Base::V == 0; }


                inline __attribute__((always_inline)) __attribute__((nodebug)) bool is_zero() const { return Base::V == 0; }


                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool sign() const {
    if (_AP_S &&
        ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }))
      return true;
    else
      return false;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void clear(int i) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void invert(int i) {
                                                           ;
    bool val = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    if (val)
      Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    else
      Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool test(int i) const {
                                                           ;
    return ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
  }


                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& get() { return *this; }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(int i) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(int i, bool v) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& lrotate(int n) {
                                                              ;


    __typeof__(Base::V) l_p = Base::V << n;
    __typeof__(Base::V) r_p = Base::V >> (_AP_W - n);
    Base::V = l_p | r_p;



    return *this;
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& rrotate(int n) {
                                                              ;


    __typeof__(Base::V) l_p = Base::V << (_AP_W - n);
    __typeof__(Base::V) r_p = Base::V >> n;
    Base::V = l_p | r_p;



    return *this;
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& reverse() {
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
    return *this;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void set_bit(int i, bool v) {
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) bool get_bit(int i) const {
    return (bool)({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void b_not() { Base::V = ~Base::V; }

  template<typename T>
                inline __attribute__((always_inline)) __attribute__((nodebug)) void checkOverflowBaseC(T val) {
# 767 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
    (void)val;

    return;
  }

                inline __attribute__((always_inline)) __attribute__((nodebug)) bool checkOverflowCsim(int _ap_w2, bool _ap_s2,
          bool print = true) const {
# 817 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
      (void)_ap_w2;
      (void)_ap_s2;
      (void)print;

      return 0;
  }
# 851 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator *=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V *= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator +=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V += op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator -=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V -= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator /=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V /= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator %=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V %= op2.V; return *this; }
# 869 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator &=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V &= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator |=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V |= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator ^=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V ^= op2.V; return *this; }





  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator++() {
    operator+=((ap_int_base<1, false>)1);
    return *this;
  }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator--() {
    operator-=((ap_int_base<1, false>)1);
    return *this;
  }




  inline __attribute__((always_inline)) __attribute__((nodebug)) const typename RType<_AP_W,_AP_S>::arg1 operator++(int) {
    ap_int_base t = *this;
    operator+=((ap_int_base<1, false>)1);
    return t;
  }
  inline __attribute__((always_inline)) __attribute__((nodebug)) const typename RType<_AP_W,_AP_S>::arg1 operator--(int) {
    ap_int_base t = *this;
    operator-=((ap_int_base<1, false>)1);
    return t;
  }




                inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W,_AP_S>::arg1 operator+() const { return *this; }


                inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<1, false>::minus operator-() const {
    return ap_int_base<1, false>(0) - *this;
  }




                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!() const { return Base::V == 0; }





                inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W,_AP_S>::arg1 operator~() const {
    ap_int_base<_AP_W, _AP_S> r(0);
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>(sh);
    } else
      return operator<<(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r(0);
    r.V = Base::V << op2.to_uint();
    return r;
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<(sh);
    }
    return operator>>(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r(0);
    r.V = Base::V >> op2.to_uint();
    return r;
  }
# 980 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator<<=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>=(sh);
    } else
      return operator<<=(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator<<=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V <<= op2.to_uint();
    return *this;
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator>>=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<=(sh);
    }
    return operator>>=(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator>>=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V >>= op2.to_uint();
    return *this;
  }
# 1029 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V == op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return !(Base::V == op2.V);
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V < op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V >= op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V > op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V <= op2.V;
  }




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ap_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ap_range_ref<_AP_W, _AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }
# 1138 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W, _AP_S> operator[](int index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W, _AP_S> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator[](int index) const {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator[](const ap_int_base<_AP_W2, _AP_S2>& index) const {
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index.to_int());
    return br.to_bool();
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W, _AP_S> bit(int index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W, _AP_S> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool bit(int index) const {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool bit(const ap_int_base<_AP_W2, _AP_S2>& index) const {
    return bit(index.to_int());
  }
# 1205 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
                inline __attribute__((always_inline)) __attribute__((nodebug)) int countLeadingZeros() const {

    if (_AP_W <= 32) {
      ap_int_base<32, false> t(-1UL), x;
      x.V = ({ typename _ap_type::remove_const<__typeof__(this->V)>::type __Result__ = 0; __typeof__(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
      t.V = ({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __typeof__(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, _AP_W - 1); __Result__; });
      return t.V == 0 ? _AP_W : __builtin_ctz(t.V);
    } else if (_AP_W <= 64) {
      ap_int_base<64, false> t(-1ULL);
      ap_int_base<64, false> x;
      x.V = ({ typename _ap_type::remove_const<__typeof__(this->V)>::type __Result__ = 0; __typeof__(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
      t.V = ({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __typeof__(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, _AP_W - 1); __Result__; });
      return t.V == 0 ? _AP_W : __builtin_ctzll(t.V);
    } else {
      enum { __N = (_AP_W + 63) / 64 };
      int NZeros = 0;
      int i = 0;
      bool hitNonZero = false;
      for (i = 0; i < __N - 1; ++i) {
        ap_int_base<64, false> t;
        t.V = ({ typename _ap_type::remove_const<__typeof__(this->V)>::type __Result__ = 0; __typeof__(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - i * 64 - 64, _AP_W - i * 64 - 1); __Result__; });
        NZeros += hitNonZero ? 0 : (t.V == 0 ? 64 : __builtin_clzll(t.V));
        hitNonZero |= (t.V != 0);
      }
      if (!hitNonZero) {
        ap_int_base<64, false> t(-1ULL);
        enum { REST = (_AP_W - 1) % 64 };
        ap_int_base<64, false> x;
        x.V = ({ typename _ap_type::remove_const<__typeof__(this->V)>::type __Result__ = 0; __typeof__(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, REST); __Result__; });
        t.V = ({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __typeof__(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 63 - REST, 63); __Result__; });
        NZeros += t.V == 0 ? _AP_W % 64 : __builtin_clzll(t.V);
      }
      return NZeros;
    }



  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(const ap_int_base<_AP_W2, _AP_S2>& a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(ap_int_base<_AP_W2, _AP_S2>& a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this), a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator&(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this & a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator|(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this | a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator^(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this ^ a2.get();
  }

  template <int _AP_W3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(const ap_int_base<_AP_W3, false>& val) {
    Base::V = val.V;
  }





  inline __attribute__((always_inline)) __attribute__((nodebug)) bool and_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_and_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool nand_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_nand_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool or_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool nor_reduce() const { return !(({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); })); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool xor_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool xnor_reduce() const {
    return !(({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }));
  }
# 1445 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) char* to_string(signed char rd = 2, bool sign = _AP_S) const {
    (void)(rd);
    (void)(sign);
    return 0;
  }

};
# 1506 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base ret(0); ret.V = lhs.V * rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base ret(0); ret.V = lhs.V + rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base ret(0); ret.V = lhs.V - rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret(0); ret.V = lhs.V & rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret(0); ret.V = lhs.V | rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret(0); ret.V = lhs.V ^ rhs.V; return ret; }
# 1525 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::div_base ret(0); ret.V = op.V / op2.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mod_base ret(0); ret.V = op.V % op2.V; return ret; }
# 1553 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) PTR_TYPE* operator +(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op + op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) PTR_TYPE* operator +(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 + i_op; }
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) PTR_TYPE* operator -(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op - op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) PTR_TYPE* operator -(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 - i_op; }
# 1582 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator *(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator *(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator /(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator /(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator +(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator +(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator -(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator -(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator *(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator *(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator /(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator /(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator +(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator +(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator -(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator -(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
# 1607 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator *(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator *(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator /(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator /(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator +(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator +(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator -(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator -(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
# 1639 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op * ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op + ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op - ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op / ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op % ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op & ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op | ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op ^ ap_int_base<1, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op * ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op + ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op - ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op / ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op % ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op & ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op | ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op ^ ap_int_base<8, CHAR_IS_SIGNED>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op * ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op + ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op - ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op / ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op % ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op & ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op | ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op ^ ap_int_base<8, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op * ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op + ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op - ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op / ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op % ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op & ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op | ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op ^ ap_int_base<8, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op * ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op + ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op - ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op / ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op % ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op & ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op | ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op ^ ap_int_base<_AP_SIZE_short, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op * ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op + ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op - ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op / ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op % ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op & ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op | ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op ^ ap_int_base<_AP_SIZE_short, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op * ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op + ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op - ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op / ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op % ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op & ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op | ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op ^ ap_int_base<_AP_SIZE_int, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op * ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op + ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op - ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op / ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op % ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op & ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op | ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op ^ ap_int_base<_AP_SIZE_int, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op * ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op + ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op - ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op / ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op % ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op & ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op | ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op ^ ap_int_base<_AP_SIZE_long, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op * ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op + ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op - ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op / ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op % ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op & ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op | ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op ^ ap_int_base<_AP_SIZE_long, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, false>(i_op); }
# 1678 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
# 1702 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
# 1733 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op += ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op -= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op *= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op /= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op %= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op &= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op |= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op ^= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >>= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <<= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op += ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op -= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op *= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op /= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op %= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op &= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op |= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op ^= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >>= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <<= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op += ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op -= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op *= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op /= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op %= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op &= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op |= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op ^= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >>= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <<= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op += ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op -= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op *= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op /= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op %= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op &= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op |= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op ^= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >>= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <<= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op += ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op -= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op *= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op /= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op %= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op &= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op |= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op ^= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >>= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <<= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op += ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op -= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op *= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op /= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op %= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op &= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op |= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op ^= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >>= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <<= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op += ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op -= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op *= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op /= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op %= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op &= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op |= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op ^= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >>= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <<= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op += ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op -= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op *= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op /= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op %= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op &= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op |= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op ^= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >>= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <<= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op += ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op -= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op *= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op /= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op %= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op &= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op |= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op ^= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >>= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <<= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op += ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op -= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op *= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op /= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op %= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op &= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op |= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op ^= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >>= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <<= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1766 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half& operator +=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half& operator -=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half& operator *=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half& operator /=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 /= op_rt; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float& operator +=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float& operator -=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float& operator *=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float& operator /=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 /= op_rt; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double& operator +=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double& operator -=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double& operator *=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double& operator /=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 /= op_rt; }
# 1794 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1831 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; }
# 1861 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) + op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) - op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) * op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) / op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) % op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) & op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) | op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) ^ op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) >> op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) << op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<_AP_W2, false>(op2); }
# 1892 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator +=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator -=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator *=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator /=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator %=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator >>=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator <<=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 1924 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator &=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator |=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator ^=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 1943 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(op2.operator ap_int_base<_AP_W2, false>()); }
# 1970 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) + op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) - op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) * op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) / op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) % op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) & op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) | op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) ^ op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >> op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) << op2; }
# 2001 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator +=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator -=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator *=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator /=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator %=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator >>=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator <<=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 2033 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator &=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator |=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator ^=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 2052 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 == ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) == op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 != ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) != op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 > ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) > op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >= op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 < ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) < op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) <= op2; }
# 2159 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_base.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 == op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() == op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 != op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() != op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 > op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() > op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 >= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() >= op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 < op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() < op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 <= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() <= op2; }
# 12 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_int.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h" 1
# 27 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {
  enum {
    _AP_WR = _AP_W1 + _AP_W2,
  };

  _AP_T1& mbv1;
  _AP_T2& mbv2;

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& ref)
      : mbv1(ref.mbv1), mbv2(ref.mbv2) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) {}

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> Part1;
    Part1.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    mbv1.set(Part1);
    ap_int_base<_AP_W2, false> Part2;
    Part2.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2 - 1); __Result__; });
    mbv2.set(Part2);
    return *this;
  }
# 70 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(bool val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(signed char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(unsigned char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(unsigned short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(unsigned int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(unsigned long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(ap_slong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(ap_ulong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(half val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(float val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(double val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }





  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(const ap_bit_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }
  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(const ap_range_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((const ap_int_base<_AP_W3, false>)(val));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(
      const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&
          val) {
    return operator=(val.to_ap_int_base());
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(
      const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((ap_ulong)(bool)(val));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_int_base<_AP_WR, false>() const { return get(); }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_ulong() const { return get().to_uint64(); }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                       ap_range_ref<_AP_W3, _AP_S3> >
  operator,(const ap_range_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_range_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_range_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(*this, a2);
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(volatile ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const volatile ap_int_base<_AP_W3, _AP_S3> &a2) {

    ap_int_base<_AP_W3, _AP_S3> op(a2);
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(op));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
  operator,(const ap_bit_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_bit_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                       ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >
  operator,(const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                         ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >(
        *this, const_cast<ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<
      _AP_WR, ap_concat_ref, _AP_W3,
      af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
  operator,(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, _AP_W3,
        af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<
            af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_WR, ap_concat_ref, 1,
                    af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
      operator,(const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>
                    &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, 1,
        af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(
            a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator&(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() & a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator|(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() | a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator^(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() ^ a2;
  }
# 258 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_WR, false> get() const {
    ap_int_base<_AP_WR, false> tmpVal(0);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W2, false> v2(mbv2);
    ap_int_base<_AP_W1, false> v1(mbv1);
    tmpVal.V = ({ typename _ap_type::remove_const<__typeof__(tmpVal.V)>::type __Result__ = 0; __typeof__(tmpVal.V) __Val2__ = tmpVal.V; __typeof__(v2.V) __Repl2__ = v2.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, W_ref2 - 1); __Result__; });
    tmpVal.V =
        ({ typename _ap_type::remove_const<__typeof__(tmpVal.V)>::type __Result__ = 0; __typeof__(tmpVal.V) __Val2__ = tmpVal.V; __typeof__(v1.V) __Repl2__ = v1.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    return tmpVal;
  }

  template <int _AP_W3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(const ap_int_base<_AP_W3, false>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> tmpVal1;
    tmpVal1.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    mbv1.set(tmpVal1);
    ap_int_base<_AP_W2, false> tmpVal2;
    tmpVal2.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2 - 1); __Result__; });
    mbv2.set(tmpVal2);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const { return mbv1.length() + mbv2.length(); }
};




template <int _AP_W, bool _AP_S>
struct ap_range_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_ulong() const { return to_uint64(); }
# 339 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(bool val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(signed char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(unsigned char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(unsigned short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(unsigned int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(unsigned long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(ap_slong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(ap_ulong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(half val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(float val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(double val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(const ap_range_ref& val) {
    return operator=((const ap_int_base<_AP_W, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    return operator=(val.to_ap_int_base());
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug))
  ap_concat_ref<_AP_W, ap_range_ref, _AP_W, ap_int_base<_AP_W, _AP_S> >
  operator,(ap_int_base<_AP_W, _AP_S>& a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W,
                         ap_int_base<_AP_W, _AP_S> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<
      _AP_W, ap_range_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, ap_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop == hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop < hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop <= hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<=(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= op2.V;
    return *this;
  };



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator~() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (~ret);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator!() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (!ret);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator+() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator-() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (-ret);
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int to_int() const {
    return (int)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned to_uint() const {
    ap_int_base<_AP_W, false> t;
    t.V = d_bv.V;
    return (unsigned)(({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) long to_long() const {
    return (long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned long to_ulong() const {
    ap_int_base<_AP_W, false> t;
    t.V = d_bv.V;
    return (unsigned long)(({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_slong to_int64() const {
    return (ap_slong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ulong to_uint64() const {
    ap_int_base<_AP_W, false> t;
    t.V = d_bv.V;
    return (ap_ulong)(({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool and_reduce() const {
    bool ret = true;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret &= ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool or_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret |= ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool xor_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret ^= ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }
# 720 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) char* to_string(signed char radix = 2) const {
    (void)(radix);
    return 0;
  }

};
# 760 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
template <int _AP_W, bool _AP_S>
struct ap_bit_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int d_index;

 public:

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator bool() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool to_bool() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }
# 798 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(bool val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(char val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(signed char val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(unsigned char val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(short val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(unsigned short val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(int val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(unsigned int val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(long val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(unsigned long val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(ap_slong val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(ap_ulong val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
# 820 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(half val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(float val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(double val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }




  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(val.V != 0));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_int_base<_AP_W2, false>)val);
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(const ap_bit_ref& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<
      1, ap_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        1, ap_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() != op.get();
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool get() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool get() { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  template <int _AP_W3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(const ap_int_base<_AP_W3, false>& val) {
    operator=(val);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator~() const {
    bool bit = ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; });
    return bit ? false : true;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const { return 1; }

  template <typename _RT>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator&=(const _RT& r) {
    operator=(get() & ap_int_base<1, false>(r));
    return *this;
  }

  template <typename _RT>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator|=(const _RT& r) {
    operator=(get() | ap_int_base<1, false>(r));
    return *this;
  }

  template <typename _RT>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator^=(const _RT& r) {
    operator=(get() ^ ap_int_base<1, false>(r));
    return *this;
  }





  inline __attribute__((always_inline)) __attribute__((nodebug)) char* to_string() const { return 0; }

};
# 1036 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }






template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1095 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::plus operator +(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::minus operator -(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mult operator *(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::div operator /(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mod operator %(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::plus operator +(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::minus operator -(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mult operator *(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::div operator /(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mod operator %(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::plus operator +(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::minus operator -(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mult operator *(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::div operator /(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mod operator %(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::div operator /(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::plus operator +(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::minus operator -(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mult operator *(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::div operator /(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mod operator %(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::plus operator +(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::minus operator -(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mult operator *(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::div operator /(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mod operator %(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::plus operator +(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::minus operator -(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mult operator *(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::div operator /(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mod operator %(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::plus operator +(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::minus operator -(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mult operator *(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::div operator /(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mod operator %(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::plus operator +(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::minus operator -(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mult operator *(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::div operator /(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mod operator %(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::plus operator +(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::minus operator -(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mult operator *(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::div operator /(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mod operator %(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::plus operator +(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::minus operator -(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mult operator *(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::div operator /(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mod operator %(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::plus operator +(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::minus operator -(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mult operator *(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::div operator /(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mod operator %(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
# 1118 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator &(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator |(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator ^(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator >>(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator <<(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator &(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator |(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator ^(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator >>(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator <<(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator &(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator |(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator ^(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator >>(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator <<(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator &(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator |(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator ^(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator >>(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator <<(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator &(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator |(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator &(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator |(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator ^(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator >>(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator <<(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator &(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator |(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator &(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator |(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator ^(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator >>(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator <<(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator &(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator |(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator &(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator |(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator ^(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator >>(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator <<(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator &(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator |(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator ^(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator >>(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator <<(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
# 1146 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())+( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())-( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())*( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::div operator /(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())/( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())%( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())&( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())|( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())^( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())>>( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())<<( rhs.operator ap_int_base<_AP_W2, false>()); }
# 1195 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::plus operator +( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() + rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::minus operator -( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() - rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mult operator *( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() * rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::div operator /( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() / rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mod operator %( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() % rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator &( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() & rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator |( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() | rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator ^( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() ^ rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator >>( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() >> rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator <<( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() << rhs.get(); }
# 1342 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 1, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 1, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 1, false> operator,( bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op2); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op1); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 1, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 1, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 1, false> operator,( bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<8 + 1, false> operator,( char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op2); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op1); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 8, false> operator,( char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<8 + 1, false> operator,( signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op2); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op1); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + 1, true> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 8, false> operator,( signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<8 + 1, false> operator,( unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op2); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op1); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 8, false> operator,( unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_short + 1, false> operator,( short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_short, false> operator,( short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_short + 1, false> operator,( unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_short, false> operator,( unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_int + 1, false> operator,( int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_int, false> operator,( int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_int + 1, false> operator,( unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_int, false> operator,( unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_long + 1, false> operator,( long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_long, false> operator,( long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_long + 1, false> operator,( unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_long, false> operator,( unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
# 1366 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_ref.h"
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }

template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
# 13 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_int.h" 2




template <int _AP_W>
struct ap_int : ap_int_base<_AP_W, true> {
  typedef ap_int_base<_AP_W, true> Base;

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int() = default;
  template <int _AP_W2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_int<_AP_W2>& op): Base((ap_int_base<_AP_W2, true>)op){



    op.checkOverflowCsim(_AP_W, true);

    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const volatile ap_int<_AP_W2>& op) {
    const_cast<const ap_int<_AP_W2>& >(op).checkOverflowCsim(_AP_W, true);
    Base::V = op.V;
  }

  template <int _AP_W2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_uint<_AP_W2>& op): Base((ap_int_base<_AP_W2, false>)op){



    op.checkOverflowCsim(_AP_W, true);

    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const volatile ap_uint<_AP_W2>& op) {
    const_cast<const ap_uint<_AP_W2>& >(op).checkOverflowCsim(_AP_W, true);
    Base::V = op.V;
  }




                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned V __attribute__((bitwidth(_AP_W))), bool raw): Base(0) {
    Base::V = V;
    (void)(raw);
  }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op) {

  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}







  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(bool val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(char val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(signed char val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned char val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(short val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned short val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(int val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned int val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(long val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned long val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(ap_slong val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(ap_ulong val):Base(val){ this->checkOverflowBaseC(val); }

                ap_int(double val) : Base(val) {}
                ap_int(float val) : Base(val) {}
  ap_int(half val) : Base(val) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const char* s, signed char rd) : Base(s, rd) {}




  ap_int &operator=(const ap_int<_AP_W> &op2) = default;
# 161 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_int.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int& operator=(const volatile ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const ap_int<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const volatile ap_int<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

};




template <int _AP_W>
struct ap_uint : ap_int_base<_AP_W, false> {
  typedef ap_int_base<_AP_W, false> Base;

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint() = default;
  template <int _AP_W2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_uint<_AP_W2>& op):Base((ap_int_base<_AP_W2, false>)op) {
    op.checkOverflowCsim(_AP_W, false);

  }

  template <int _AP_W2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_int<_AP_W2>& op):Base((ap_int_base<_AP_W2, true>)op) {
    op.checkOverflowCsim(_AP_W, false);

  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const volatile ap_uint<_AP_W2>& op) {
    const_cast<const ap_uint<_AP_W2>& >(op).checkOverflowCsim(_AP_W, false);
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const volatile ap_int<_AP_W2>& op) {
    const_cast<const ap_int<_AP_W2>& >(op).checkOverflowCsim(_AP_W, false);
    Base::V = op.V;
  }




                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned V __attribute__((bitwidth(_AP_W))), bool raw):Base(0) {
    Base::V = V;
    (void)(raw);
  }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op) {

  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}






  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(bool val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(char val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(signed char val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned char val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(short val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned short val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(int val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned int val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(long val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned long val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(ap_slong val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(ap_ulong val):Base(val) { this->checkOverflowBaseC(val); }

                ap_uint(double val) : Base(val) {}
                ap_uint(float val) : Base(val) {}
  ap_uint(half val) : Base(val) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const char* s, signed char rd) : Base(s, rd) {}





  ap_uint &operator=(const ap_uint<_AP_W> &op2) = default;
# 317 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_int.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint& operator=(const volatile ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const ap_uint<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const volatile ap_uint<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

};
# 352 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_int.h"
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_special.h" 1
# 20 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_special.h"
namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 48 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_special.h"
template <int _AP_W>
class complex<ap_int<_AP_W> > {
 public:
  typedef ap_int<_AP_W> _Tp;
  typedef _Tp value_type;




  __attribute__((nodebug)) complex() = default;


  __attribute__((nodebug)) complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  __attribute__((nodebug)) complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  __attribute__((nodebug)) const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  __attribute__((nodebug)) void real(_Tp __val) { _M_real = __val; }

  __attribute__((nodebug)) void imag(_Tp __val) { _M_imag = __val; }



  __attribute__((nodebug)) complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 181 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_int_special.h"
template <int _AP_W>
inline __attribute__((nodebug)) bool operator==(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W>
inline __attribute__((nodebug)) bool operator==(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W>
inline __attribute__((nodebug)) bool operator!=(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W>
inline __attribute__((nodebug)) bool operator!=(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 353 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_int.h" 2
# 17 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h" 2
# 87 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
template <int _AP_W2, int _AP_I2, bool _AP_S2>
struct _ap_fixed_factory;
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, true> {
  typedef ap_fixed<_AP_W2, _AP_I2> type;
};
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, false> {
  typedef ap_ufixed<_AP_W2, _AP_I2> type;
};
# 108 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct ap_fixed_base : ssdm_int<_AP_W, _AP_S> {
 public:
  typedef ssdm_int<_AP_W, _AP_S> Base;
  static const int width = _AP_W;
  static const int iwidth = _AP_I;
  static const ap_q_mode qmode = _AP_Q;
  static const ap_o_mode omode = _AP_O;


  template <int _AP_W2, int _AP_I2, bool _AP_S2>
  struct RType {
    enum {
      _AP_F = _AP_W - _AP_I,
      F2 = _AP_W2 - _AP_I2,
      mult_w = _AP_W + _AP_W2,
      mult_i = _AP_I + _AP_I2,
      mult_s = _AP_S || _AP_S2,
      plus_w = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
               1 + ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      plus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1 +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      minus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,

      div_w = _AP_S2 + _AP_W + ((F2) > (0) ? (F2) : (0)),



      div_i = _AP_S2 + _AP_I + F2,
      div_s = _AP_S || _AP_S2,
      logic_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      logic_i = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };

    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> lhs;
    typedef ap_fixed_base<_AP_W2, _AP_I2, _AP_S2> rhs;

    typedef ap_fixed_base<mult_w, mult_i, mult_s> mult_base;
    typedef ap_fixed_base<plus_w, plus_i, plus_s> plus_base;
    typedef ap_fixed_base<minus_w, minus_i, minus_s> minus_base;
    typedef ap_fixed_base<logic_w, logic_i, logic_s> logic_base;
    typedef ap_fixed_base<div_w, div_i, div_s> div_base;
    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1_base;

    typedef typename _ap_fixed_factory<mult_w, mult_i, mult_s>::type mult;
    typedef typename _ap_fixed_factory<plus_w, plus_i, plus_s>::type plus;
    typedef typename _ap_fixed_factory<minus_w, minus_i, minus_s>::type minus;
    typedef typename _ap_fixed_factory<logic_w, logic_i, logic_s>::type logic;
    typedef typename _ap_fixed_factory<div_w, div_i, div_s>::type div;
    typedef typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type arg1;
  };

 private:
# 295 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
                      inline __attribute__((always_inline)) __attribute__((nodebug)) void report() {}




                      inline __attribute__((always_inline)) __attribute__((nodebug)) void overflow_adjust(bool underflow, bool overflow, bool lD,
                              bool sign) {
    if (!underflow && !overflow) return;
    if (_AP_O == AP_WRAP) {
      if (_AP_N == 0) return;
      if (_AP_S) {


        Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
        if (_AP_N > 1) {

          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
        }
      } else {

        ap_int_base<_AP_W, false> mask(-1);
        Base::V =
            ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 1); __Result__; });
      }
    } else if (_AP_O == AP_SAT_ZERO) {
      Base::V = 0;
    } else if (_AP_O == AP_WRAP_SM && _AP_S) {
      bool Ro = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
      if (_AP_N == 0) {
        if (lD != Ro) {
          Base::V = ~Base::V;
          Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(lD) __Repl2__ = !!lD; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
        }
      } else {
        if (_AP_N == 1 && sign != Ro) {
          Base::V = ~Base::V;
        } else if (_AP_N > 1) {
          bool lNo = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - _AP_N); __Result__; });
          if (lNo == sign) Base::V = ~Base::V;
          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
        }
        Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
      }
    } else {
      if (_AP_S) {
        if (overflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          Base::V = ~Base::V;
        } else if (underflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          if (_AP_O == AP_SAT_SYM) Base::V |= 1;
        }
      } else {
        if (overflow)
          Base::V = ~(ap_int_base<_AP_W, false>(0).V);
        else if (underflow)
          Base::V = 0;
      }
    }
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool quantization_adjust(bool qb, bool r, bool s) {
    bool carry = (bool)({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    if (_AP_Q == AP_TRN) return false;
    if (_AP_Q == AP_RND_ZERO)
      qb &= s || r;
    else if (_AP_Q == AP_RND_MIN_INF)
      qb &= r;
    else if (_AP_Q == AP_RND_INF)
      qb &= !s || r;
    else if (_AP_Q == AP_RND_CONV)
      qb &= ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 0); __Result__; }) || r;
    else if (_AP_Q == AP_TRN_ZERO)
      qb = s && (qb || r);
    Base::V += qb;
    return carry && (!(bool)({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }));
  }


                      inline __attribute__((always_inline)) __attribute__((nodebug)) int countLeadingOnes() const {




    return 0;

  }

 public:



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base() = default;


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op):Base(op.V) {

    operator=(op);



    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op.V) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp(0);
    tmp.V = op.V;

    operator=(tmp);



    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }
# 458 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const char* s) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_I, _AP_S, _AP_Q,
                      _AP_O, _AP_N, true);
    Base::V = t;
  }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const char* s, signed char rd) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_I, _AP_S, _AP_Q,
                      _AP_O, _AP_N, true);
    Base::V = t;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    *this = ((bool)op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
    *this = (ap_int_base<_AP_W2 + _AP_W3, false>(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (bool(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }
# 526 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const bool x) { ap_fixed_base<(1), (1), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const char x) { ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const signed char x) { ap_fixed_base<(8), (8), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const unsigned char x) { ap_fixed_base<(8), (8), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const unsigned short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const unsigned int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const unsigned long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const ap_slong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const ap_ulong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)> tmp; tmp.V = x; *this = tmp; }







          __attribute__((nodebug)) ap_fixed_base(double d) {
    ap_int_base<64, false> ireg;
    ireg.V = doubleToRawBits(d);
    bool isneg = ({ __typeof__(ireg.V) __Val2__ = ireg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 63); __Result__; });

    ap_int_base<11 + 1, true> exp, bias = ((1 << (11 - 1)) - 1);
    ap_int_base<11, false> exp_tmp;
    exp_tmp.V = ({ typename _ap_type::remove_const<__typeof__(ireg.V)>::type __Result__ = 0; __typeof__(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, 52 + 11 - 1); __Result__; });
    exp = exp_tmp - bias;
    ap_int_base<52 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<__typeof__(ireg.V)>::type __Result__ = 0; __typeof__(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });


    (static_cast<void>(0));

    man.V = ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });
    if (isneg) man = -man;
    if ((ireg.V & 0x7fffffffffffffffLL) == 0) {
      Base::V = 0;
    } else {
      int _AP_W2 = 52 + 2, _AP_I2 = exp.V + 2, _AP_F = _AP_W - _AP_I,
          F2 = _AP_W2 - _AP_I2;
      bool _AP_S2 = true,
           QUAN_INC = F2 > _AP_F &&
                      !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));
      bool carry = false;

      unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
      if (F2 == _AP_F)
        Base::V = man.V;
      else if (F2 > _AP_F) {
        if (sh_amt < 52 + 2)
          Base::V = man.V >> sh_amt;
        else {
          Base::V = isneg ? -1 : 0;
        }
        if ((_AP_Q != AP_TRN) && !((_AP_Q == AP_TRN_ZERO) && !_AP_S2)) {
          bool qb = (F2 - _AP_F > _AP_W2) ? isneg : (bool)({ __typeof__(man.V) __Val2__ = man.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), F2 - _AP_F - 1); __Result__; });

          bool r =
              (F2 > _AP_F + 1)
                  ? ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, (F2 - _AP_F - 2 < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1)); __Result__; }) != 0


                  : false;
          carry = quantization_adjust(qb, r, isneg);
        }
      } else {
        Base::V = man.V;
        if (sh_amt < _AP_W)
          Base::V = Base::V << sh_amt;
        else
          Base::V = 0;
      }

      if ((_AP_O != AP_WRAP || _AP_N != 0) &&
          ((!_AP_S && _AP_S2) ||
           _AP_I - _AP_S <
               _AP_I2 - _AP_S2 +
                   (QUAN_INC ||
                    (_AP_S2 && (_AP_O == AP_SAT_SYM))))) {
        bool deleted_zeros = _AP_S2 ? true : !carry, deleted_ones = true;
        bool neg_src = isneg;
        bool lD = false;
        int pos1 = F2 - _AP_F + _AP_W;
        int pos2 = F2 - _AP_F + _AP_W + 1;
        bool newsignbit = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
        if (pos1 < _AP_W2 && pos1 >= 0)

          lD = (man.V >> pos1) & 1;
        if (pos1 < _AP_W2) {
          bool Range1_all_ones = true;
          bool Range1_all_zeros = true;
          bool Range2_all_ones = true;
          ap_int_base<52 + 2, false> Range2;
          ap_int_base<52 + 2, false> all_ones(-1);

          if (pos2 >= 0 && pos2 < _AP_W2) {


            Range2.V = man.V;
            Range2.V >>= pos2;
            Range2_all_ones = Range2 == (all_ones >> pos2);
          } else if (pos2 < 0)
            Range2_all_ones = false;
          if (pos1 >= 0 && pos2 < _AP_W2) {
            Range1_all_ones = Range2_all_ones && lD;
            Range1_all_zeros = !Range2.V && !lD;
          } else if (pos2 == _AP_W2) {
            Range1_all_ones = lD;
            Range1_all_zeros = !lD;
          } else if (pos1 < 0) {
            Range1_all_zeros = !man.V;
            Range1_all_ones = false;
          }

          deleted_zeros =
              deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
          deleted_ones =
              carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
          neg_src = isneg && !(carry && Range1_all_ones);
        } else
          neg_src = isneg && newsignbit;
        bool neg_trg = _AP_S && newsignbit;
        bool overflow = (neg_trg || !deleted_zeros) && !isneg;
        bool underflow = (!neg_trg || !deleted_ones) && neg_src;
        if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
          underflow |=
              neg_src &&
              (_AP_W > 1 ? ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0
                         : true);
        overflow_adjust(underflow, overflow, lD, neg_src);
      }
    }
    report();
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(float d) { *this = ap_fixed_base(double(d)); }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(half d) { *this = ap_fixed_base(double(d)); }
# 800 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {

    const int _AP_F = _AP_W - _AP_I;
    const int F2 = _AP_W2 - _AP_I2;
    const int QUAN_INC =
          F2 > _AP_F && !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));

    if (!op) Base::V = 0;
    bool carry = false;
    bool signbit = ({ __typeof__(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    bool isneg = signbit && _AP_S2;
    if (F2 == _AP_F)
      Base::V = op.V;
    else if (F2 > _AP_F) {
      unsigned int sh_amt = F2 - _AP_F;

      if (sh_amt < _AP_W2) {
        Base::V = op.V >> sh_amt;
      } else {
        Base::V = isneg ? -1 : 0;
      }
      if (_AP_Q != AP_TRN && !(_AP_Q == AP_TRN_ZERO && !_AP_S2)) {
        bool qbit = ({ __typeof__(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), F2 - _AP_F - 1); __Result__; });

        bool qb = (F2 - _AP_F > _AP_W2) ? _AP_S2 && signbit : qbit;
        enum { hi = ((F2 - _AP_F - 2) < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1) };

        bool r = (F2 > _AP_F + 1) ? (({ typename _ap_type::remove_const<__typeof__(op.V)>::type __Result__ = 0; __typeof__(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, hi); __Result__; }) != 0) : false;
        carry = quantization_adjust(qb, r, isneg);
      }
    } else {
      unsigned sh_amt = _AP_F - F2;

      if (sh_amt < _AP_W) {
        if (_AP_W > _AP_W2) {

          Base::V = op.V;
          Base::V <<= sh_amt;
        } else {

          Base::V = op.V << sh_amt;
        }
      } else {
        Base::V = 0;
      }
    }

    if ((_AP_O != AP_WRAP || _AP_N != 0) &&
        ((!_AP_S && _AP_S2) ||
         _AP_I - _AP_S <
             _AP_I2 - _AP_S2 +
                 (QUAN_INC || (_AP_S2 && _AP_O == AP_SAT_SYM)))) {
      bool deleted_zeros = _AP_S2 ? true : !carry;
      bool deleted_ones = true;
      bool neg_src = isneg;
      bool newsignbit = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
      enum { pos1 = F2 - _AP_F + _AP_W, pos2 = F2 - _AP_F + _AP_W + 1 };
      bool lD = (pos1 < _AP_W2 && pos1 >= 0) ? ({ __typeof__(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), pos1); __Result__; })
                                             : false;
      if (pos1 < _AP_W2) {
        bool Range1_all_ones = true;
        bool Range1_all_zeros = true;
        bool Range2_all_ones = true;
        ap_int_base<_AP_W2, false> all_ones(-1);

        if (pos2 < _AP_W2 && pos2 >= 0) {
          ap_int_base<_AP_W2, false> Range2(0);
          Range2.V = ({ typename _ap_type::remove_const<__typeof__(op.V)>::type __Result__ = 0; __typeof__(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos2, _AP_W2 - 1); __Result__; });
          Range2_all_ones = Range2 == (all_ones >> pos2);
        } else if (pos2 < 0) {
          Range2_all_ones = false;
        }

        if (pos1 >= 0 && pos2 < _AP_W2) {
          ap_int_base<_AP_W2, false> Range1(0);
          Range1.V = ({ typename _ap_type::remove_const<__typeof__(op.V)>::type __Result__ = 0; __typeof__(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos1, _AP_W2 - 1); __Result__; });
          Range1_all_ones = Range1 == (all_ones >> pos1);
          Range1_all_zeros = !Range1.V;
        } else if (pos2 == _AP_W2) {
          Range1_all_ones = lD;
          Range1_all_zeros = !lD;
        } else if (pos1 < 0) {
          Range1_all_zeros = !op.V;
          Range1_all_ones = false;
        }

        deleted_zeros =
            deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
        deleted_ones =
            carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
        neg_src = isneg && !(carry && Range1_all_ones);
      } else
        neg_src = isneg && newsignbit;
      bool neg_trg = _AP_S && newsignbit;
      bool overflow = (neg_trg || !deleted_zeros) && !isneg;
      bool underflow = (!neg_trg || !deleted_ones) && neg_src;
      if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
        underflow |=
            neg_src &&
            (_AP_W > 1 ? ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0
                       : true);

      overflow_adjust(underflow, overflow, lD, neg_src);
    }
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator=(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(const_cast<const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(op));
    return *this;
  }


                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& setBits(ap_ulong bv) {

    Base::V = bv;
    return *this;
  }


  static inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base bitsToFixed(ap_ulong bv) {

    ap_fixed_base t;

    t.V = bv;



    return t;
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) void checkOverflowCsimFix(int _ap_w2, bool _ap_s2) const {
# 973 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
      (void)_ap_w2;
      (void)_ap_s2;

      return;
  }





                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> to_ap_int_base(
      bool Cnative = true) const {
    ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> ret(0);
    if (_AP_I == 0) {
      ret.V = 0;
    } else if (_AP_I > 0 && _AP_I <= _AP_W) {
      ret.V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - _AP_I, _AP_W - 1); __Result__; });
    } else if (_AP_I > _AP_W) {
      ret.V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 1); __Result__; });
      ret.V <<= (_AP_I - _AP_W);
    }
# 1002 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
    if (Cnative && _AP_I < _AP_W) {

      if (_AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }) && (_AP_I < _AP_W) &&
          (({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_I < 0 ? _AP_W - 1 : _AP_W - _AP_I - 1); __Result__; }) != (unsigned long)0))


        ret = ret + 1;
    } else {

    }
    return ret;
  };

 public:
  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_int_base<_AP_W2, _AP_S2>() const {
    return ap_int_base<_AP_W2, _AP_S2>(to_ap_int_base());
  }


                      inline __attribute__((always_inline)) __attribute__((nodebug)) char to_char() const { return to_ap_int_base().to_char(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) int to_int() const { return to_ap_int_base().to_int(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned to_uint() const { return to_ap_int_base().to_uint(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_slong to_int64() const { return to_ap_int_base().to_int64(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ulong to_uint64() const { return to_ap_int_base().to_uint64(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int<_AP_I> to_ap_int() const { return ap_int<_AP_I>(to_ap_int_base()); }



  inline __attribute__((always_inline)) __attribute__((nodebug)) double to_double() const {




    enum { BITS = 52 + 11 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp(0);
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1 << (11 - 1)) - 1);
    int lsb_index = _AP_W - l - 1 - 52;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<__typeof__(tmp.V)>::type __Result__ = 0; __typeof__(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ __typeof__(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    ap_ulong m = 0;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (ap_ulong)(tmp.V >> (lsb_index - 1))
                           : (ap_ulong)(tmp.V << (1 - lsb_index));
    } else {
      m = (ap_ulong)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;


    if (({ __typeof__(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 52 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52 + 11 - 1); __Result__; });


    return rawBitsToDouble(m);
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) float to_float() const {




    enum { BITS = 23 + 8 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1 << (8 - 1)) - 1);
    int lsb_index = _AP_W - l - 1 - 23;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<__typeof__(tmp.V)>::type __Result__ = 0; __typeof__(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ __typeof__(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    unsigned long m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned long)(tmp.V >> (lsb_index - 1))
                           : (unsigned long)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned long)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (({ __typeof__(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 23 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });
    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 23 + 8 - 1); __Result__; });

    return rawBitsToFloat(m);
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) half to_half() const {




    enum { BITS = 10 + 5 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1 << (5 - 1)) - 1);
    int lsb_index = _AP_W - l - 1 - 10;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<__typeof__(tmp.V)>::type __Result__ = 0; __typeof__(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ __typeof__(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    unsigned short m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned short)(tmp.V >> (lsb_index - 1))
                           : (unsigned short)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned short)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (({ __typeof__(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 10 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });
    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 10, 10 + 5 - 1); __Result__; });

    return rawBitsToHalf(m);
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) operator long double() const { return (long double)to_double(); }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator double() const { return to_double(); }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator float() const { return to_float(); }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator half() const { return to_half(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator bool() const { return (bool)Base::V != 0; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator char() const { return (char)to_int(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator signed char() const { return (signed char)to_int(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator unsigned char() const { return (unsigned char)to_uint(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator short() const { return (short)to_int(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator unsigned short() const { return (unsigned short)to_uint(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator int() const { return to_int(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator unsigned int() const { return to_uint(); }



                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator long() const { return (long)to_int64(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator unsigned long() const { return (unsigned long)to_uint64(); }






                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_ulong() const { return to_uint64(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_slong() const { return to_int64(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const { return _AP_W; };
# 1231 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
                      inline __attribute__((always_inline)) __attribute__((nodebug)) int countLeadingZeros() const {


    if (_AP_W <= 32) {
      ap_int_base<32, false> t(-1ULL);
      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);
      return t.V == 0 ? _AP_W : __builtin_ctz(t.V);
    } else if (_AP_W <= 64) {
      ap_int_base<64, false> t(-1ULL);
      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);
      return t.V == 0 ? _AP_W : __builtin_ctzll(t.V);
    } else {
      enum {__N = (_AP_W + 63) / 64};
      int NZeros = 0;
      int i = 0;
      bool hitNonZero = false;
      for (i = 0; i < __N - 1; ++i) {
        ap_int_base<64, false> t;
        t.range(0, 63) = this->range(_AP_W - i * 64 - 64, _AP_W - i * 64 - 1);
        NZeros += hitNonZero ? 0 : (t.V == 0 ? 64 : __builtin_clzll(t.V));
        hitNonZero |= (t != 0);
      }
      if (!hitNonZero) {
        ap_int_base<64, false> t(-1ULL);
        t.range(63 - (_AP_W - 1) % 64, 63) = this->range(0, (_AP_W - 1) % 64);
        NZeros += t.V == 0 ? _AP_W % 64 : __builtin_clzll(t.V);
      }
      return NZeros;
    }



  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::mult operator*(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::mult_base r(0), t(0);
    r.V = Base::V;
    t.V = op2.V;
    r.V *= op2.V;
    return r;
  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::div operator/(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::div_base r;
# 1301 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
        ap_fixed_base<_AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)),_AP_I, _AP_S> t(*this);



        r.V = t.V / op2.V;
# 1334 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
    return r;
  }
# 1349 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::plus_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V + rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::minus_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V - rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V & rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V | rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V ^ rhs.V; return ret; }
# 1367 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator *=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator *(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator /=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator /(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator +=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator +(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator -=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator -(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator &=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator &(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator |=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator |(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator ^=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator ^(op2); return *this; }





  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator++() {
    operator+=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator--() {
    operator-=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) const ap_fixed_base operator++(int) {
    ap_fixed_base r(*this);
    operator++();
    return r;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) const ap_fixed_base operator--(int) {
    ap_fixed_base r(*this);
    operator--();
    return r;
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type operator+() { return *this; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) typename _ap_fixed_factory<_AP_W + 1, _AP_I + 1, true>::type operator-() const {
    ap_fixed_base<_AP_W + 1, _AP_I + 1, true> r(*this);
    r.V = -r.V;
    return r;
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> getNeg() {
    ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> r(*this);
    r.V = -r.V;
    return r;
  }



                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!() const { return Base::V == (unsigned long)0; }




                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S> operator~() const {
    ap_fixed_base<_AP_W, _AP_I, _AP_S> r(0);
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_SHIFT>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift() const {
    ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r(0);
    r.V = Base::V;
    return r;
  }

  template <int _AP_SHIFT>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift() const {
    ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r(0);
    r.V = Base::V;
    return r;
  }





                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator<<(unsigned int sh) const {
    ap_fixed_base r(0);
    r.V = Base::V << sh;
# 1485 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
    return r;
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator>>(unsigned int sh) const {
    ap_fixed_base r(0);
    r.V = Base::V >> sh;
# 1507 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
    return r;
  }


                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator<<(int sh) const {
    ap_fixed_base r(0);
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator>>(ush);
    } else {
      return operator<<(ush);
    }
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator>>(int sh) const {
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator<<(ush);
    } else {
      return operator>>(ush);
    }
  }


  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator<<(const ap_int_base<_AP_W2, true>& op2) const {


    int sh = op2.to_int();
    return operator<<(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    int sh = op2.to_int();
    return operator>>(sh);
  }


  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator<<(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator>>(sh);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator<<(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator<<(op2.to_ap_int_base());
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator>>(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator>>(op2.to_ap_int_base());
  }





                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator<<=(const int sh) {
    *this = operator<<(sh);
    return *this;
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator<<=(const unsigned int sh) {
    *this = operator<<(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator<<=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator<<=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }


                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator>>=(const int sh) {
    *this = operator>>(sh);
    return *this;
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator>>=(const unsigned int sh) {
    *this = operator>>(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator>>=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator>>=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }
# 1651 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V > op2.V; else if (_AP_F > F2) return Base::V > ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V > op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V < op2.V; else if (_AP_F > F2) return Base::V < ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V < op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V >= op2.V; else if (_AP_F > F2) return Base::V >= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V >= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V <= op2.V; else if (_AP_F > F2) return Base::V <= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V <= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V == op2.V; else if (_AP_F > F2) return Base::V == ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V == op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V != op2.V; else if (_AP_F > F2) return Base::V != ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V != op2.V; return false; }





  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(double d) const { return to_double() > d; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(double d) const { return to_double() < d; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(double d) const { return to_double() >= d; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(double d) const { return to_double() <= d; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(double d) const { return to_double() == d; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(double d) const { return to_double() != d; }


  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      unsigned index) {
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator[](unsigned index) const {
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index); __Result__; });
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      unsigned index) {
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool bit(unsigned index) const {
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index); __Result__; });
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> get_bit(
      const ap_int_base<_AP_W2, true>& index) {
    (static_cast<void>(0));

    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        this, index.to_int() + _AP_W - _AP_I);
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool get_bit(int index) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index + _AP_W - _AP_I); __Result__; });

  }
# 1737 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool get_bit(const ap_int_base<_AP_W2, true>& index) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index.to_int() + _AP_W - _AP_I); __Result__; });

  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(int Hi,
                                                                      int Lo) {
    (static_cast<void>(0));
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      int Hi, int Lo) const {
    (static_cast<void>(0));
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        const_cast<ap_fixed_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool is_zero() const { return Base::V == (unsigned long)0; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool is_neg() const {
    if (_AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; })) return true;
    return false;
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) int wl() const { return _AP_W; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) int iwl() const { return _AP_I; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_q_mode q_mode() const { return _AP_Q; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_o_mode o_mode() const { return _AP_O; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) int n_bits() const { return _AP_N; }
# 1920 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) char* to_string(unsigned char radix = 2, bool sign = _AP_S) const {
    (void)(radix);
    (void)(sign);
    return 0;
  }

};

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void b_not(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
  ret.V = ~op.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void b_and(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V & op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void b_or(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V | op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void b_xor(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V ^ op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void neg(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
  ap_fixed_base<_AP_W2 + !_AP_S2, _AP_I2 + !_AP_S2, true, _AP_Q2, _AP_O2,
                _AP_N2>
      t(0);
  t.V = -op.V;
  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void lshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F2 = _AP_W2 - _AP_I2,
    _AP_I3 = ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)),
    _AP_W3 = _AP_I3 + F2,
  };

  ap_fixed_base<_AP_W3, _AP_I3, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t(0);
  t.V = op.V;
  t.V <<= i;

  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void rshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F = _AP_W - _AP_I,
    F2 = _AP_W2 - _AP_I2,
    F3 = ((F) > (F2) ? (F) : (F2)),
    _AP_W3 = _AP_I2 + F3,
    sh = F - F2,
  };

  ap_fixed_base<_AP_W3, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t(0);
  t.V = op.V;
  if (sh >= 0)
    t.V <<= (int) sh;
  t.V >>= i;

  ret = t;
}
# 2372 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ==(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator !=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator !=(op); }
# 2460 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::plus operator +( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::minus operator -( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::mult operator *( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::div operator /( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator &( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator |( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator ^( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator +=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator +=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator -=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator -=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator *=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator *=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator /=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator /=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator &=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator &=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator |=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator |=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator ^=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator ^=(op.to_ap_int_base()); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ==(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ==(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator !=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <=(op); }




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator==(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator!=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>=(op1);
}
# 11 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_fixed.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_ref.h" 1
# 25 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int d_index;

 public:
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref(
      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {






  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) operator bool() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }



  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(bool val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; });
    return *this;
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(const af_bit_ref& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=(val != 0);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=(ap_int_base<_AP_W2 + _AP_W3, false>(val));
  }




  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(*this,
                                                                        op);
  }

  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<
      1, af_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        1, af_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() != op.get();
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator~() const {
    bool bit = ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; });
    return bit ? false : true;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool get() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const { return 1; }





  inline __attribute__((always_inline)) __attribute__((nodebug)) char* to_string() const { return 0; }

};
# 212 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref(
      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}




  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {
# 242 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_ref.h"
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {
# 254 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_ref.h"
  }
# 266 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const bool val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const signed char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const unsigned char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const unsigned short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const unsigned int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const unsigned long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const ap_slong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const ap_ulong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const half val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const float val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const double val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }



  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }



  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }




  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const af_range_ref& val) {
    ap_int_base<_AP_W, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    const ap_int_base<_AP_W2 + _AP_W3, false> tmp(val);
    return operator=(tmp);
  }




  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator<(op2));
  }





  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, op);
  }


  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                    af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, af_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_ulong() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret.to_uint64();
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> to_ap_int_base() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) char to_char() const {
    return (char)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int to_int() const {
    return (int)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned to_uint() const {
    return (unsigned)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) long to_long() const {
    return (long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned long to_ulong() const {
    return (unsigned long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_slong to_int64() const {
    return (ap_slong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ulong to_uint64() const {
    return (ap_ulong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator~() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (~ret);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator!() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (!ret);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator+() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator-() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (-ret);
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }
# 615 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) char* to_string(signed char rd = 2) const {
     (void)(rd);
    return 0;
  }

};
# 679 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
# 725 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<1, false>(op); }
# 12 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_fixed.h" 2





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed : ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed() = default;


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                      _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                               _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 66 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {
    Base::V = V;
    (void)(raw);
  }
# 101 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}





                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(bool v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(signed char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(short v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned short v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(int v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned int v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(long v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned long v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(ap_slong v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(ap_ulong v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(half v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(float v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(double v) : Base(v) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const char* s, signed char rd) : Base(s, rd) {}







  ap_fixed &
  operator=(const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &op) = default;
# 168 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_fixed.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed& operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }
};





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_ufixed : ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed() = default;


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                       _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                                _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 237 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {
    Base::V = V;
    (void)(raw);
  }
# 269 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}




                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(bool v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(signed char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(short v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned short v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(int v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned int v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(long v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned long v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(ap_slong v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(ap_ulong v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(half v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(float v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(double v) : Base(v) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const char* s, signed char rd) : Base(s, rd) {}



  ap_ufixed &
  operator=(const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &op) = default;
# 327 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_fixed.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed& operator=(
      const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O,
                                                 _AP_N>& op) volatile {
    Base::V = op.V;
  }
};
# 365 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_fixed.h"
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_special.h" 1
# 20 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_special.h"
namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 48 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  __attribute__((nodebug)) complex() = default;


  __attribute__((nodebug)) complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  __attribute__((nodebug)) complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const __attribute__((nodebug)) _Tp& real() const { return _M_real; }
  const __attribute__((nodebug)) _Tp& imag() const { return _M_imag; }







  __attribute__((nodebug)) void real(_Tp __val) { _M_real = __val; }

  __attribute__((nodebug)) void imag(_Tp __val) { _M_imag = __val; }



  __attribute__((nodebug)) complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator=(const complex<_Up> &__z) {
    auto tmp1 = __z;
    complex<_Tp> tmp2 = {tmp1.real(), tmp1.imag()};
    *this = tmp2;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 190 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  __attribute__((nodebug)) complex() = default;


  __attribute__((nodebug)) complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  __attribute__((nodebug)) complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const __attribute__((nodebug)) _Tp& real() const { return _M_real; }
  const __attribute__((nodebug)) _Tp& imag() const { return _M_imag; }







  __attribute__((nodebug)) void real(_Tp __val) { _M_real = __val; }

  __attribute__((nodebug)) void imag(_Tp __val) { _M_imag = __val; }



  __attribute__((nodebug)) complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator=(const complex<_Up> &__z) {
    auto tmp1 = __z;
    complex<_Tp> tmp2 = {tmp1.real(), tmp1.imag()};
    *this = tmp2;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 323 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/etc/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator==(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator==(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator!=(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator!=(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator==(
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator==(
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator!=(
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator!=(
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 366 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_fixed.h" 2
# 5 "firmware/myproject.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_int.h" 1
# 6 "firmware/myproject.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/hls_stream.h" 1
# 12 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/hls_stream.h"
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/hls_stream_39.h" 1
# 23 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/hls_stream_39.h"
namespace hls {
# 49 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/hls_stream_39.h"
template<typename __STREAM_T__, int DEPTH=0>
class stream;

template<typename __STREAM_T__>
class stream<__STREAM_T__, 0>
{
  public:
    using value_type = __STREAM_T__;

    inline __attribute__((always_inline)) __attribute__((nodebug)) stream() {
    }

    inline __attribute__((always_inline)) __attribute__((nodebug)) stream(const char* name) {
      (void)(name);
    }


  private:
    inline __attribute__((always_inline)) __attribute__((nodebug)) stream(const stream< __STREAM_T__ >& chn):V(chn.V) {
    }

    inline __attribute__((always_inline)) __attribute__((nodebug)) stream& operator= (const stream< __STREAM_T__ >& chn) {
        V = chn.V;
        return *this;
    }

  public:

    inline __attribute__((always_inline)) __attribute__((nodebug)) void operator >> (__STREAM_T__& rdata) {
        read(rdata);
    }

    inline __attribute__((always_inline)) __attribute__((nodebug)) void operator << (const __STREAM_T__& wdata) {
        write(wdata);
    }


  public:

    inline __attribute__((always_inline)) __attribute__((nodebug)) bool empty() const {
        return !__fpga_fifo_not_empty(&V);
    }

    inline __attribute__((always_inline)) __attribute__((nodebug)) bool full() const {
        return !__fpga_fifo_not_full(&V);
    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) void read(__STREAM_T__& dout) {
        __fpga_fifo_pop(&V, &dout);
    }


    inline __attribute__((noinline)) __attribute__((nodebug)) bool read_dep(__STREAM_T__& dout, volatile bool flag) {
        __fpga_fifo_pop(&V, &dout);
        return flag;
    }

    inline __attribute__((always_inline)) __attribute__((nodebug)) __STREAM_T__ read() {
        __STREAM_T__ tmp;
        read(tmp);
        return tmp;
    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) bool read_nb(__STREAM_T__& dout) {
        __STREAM_T__ tmp;

        if (__fpga_fifo_nb_pop(&V, &tmp)) {
            dout = tmp;
            return true;
        } else {
            return false;
        }
    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) void write(const __STREAM_T__& din) {
        __fpga_fifo_push(&V, &din);
    }


    inline __attribute__((noinline)) __attribute__((nodebug)) bool write_dep(const __STREAM_T__& din, volatile bool flag) {
        __fpga_fifo_push(&V, &din);
        return flag;
    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) bool write_nb(const __STREAM_T__& din) {
        return __fpga_fifo_nb_push(&V, &din);
    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned size() const {
        return __fpga_fifo_size(&V);
    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned capacity() const {
        return __fpga_fifo_capacity(&V);
    }


    void set_name(const char* name) { (void)(name); }

  public:
    __STREAM_T__ V __attribute__((no_ctor));
};

template<typename __STREAM_T__, int DEPTH>
class stream : public stream<__STREAM_T__, 0> {
  public:
    inline __attribute__((always_inline)) __attribute__((nodebug)) stream() {
#pragma HLS stream variable=this depth=DEPTH
 }

    inline __attribute__((always_inline)) __attribute__((nodebug)) stream(const char* name) {
#pragma HLS stream variable=this depth=DEPTH
 (void)(name);
    }
};
}
# 13 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/hls_stream.h" 2
# 7 "firmware/myproject.h" 2

# 1 "firmware/defines.h" 1




# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_int.h" 1
# 6 "firmware/defines.h" 2
# 1 "firmware/nnet_utils/nnet_types.h" 1



# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__));


}
# 5 "firmware/nnet_utils/nnet_types.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstddef" 1 3
# 43 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstddef" 3







# 1 "/tools/Xilinx/Vitis_HLS/2024.1/lnx64/tools/clang-3.9-csynth/lib/clang/7.0.0/include/stddef.h" 1 3
# 51 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstddef" 2 3


namespace std
{

  using ::max_align_t;
}
# 6 "firmware/nnet_utils/nnet_types.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 3
# 7 "firmware/nnet_utils/nnet_types.h" 2

namespace nnet {


template <typename T, unsigned N> struct array {
    typedef T value_type;
    static const unsigned size = N;

    T data[N];

    T &operator[](size_t pos) { return data[pos]; }

    const T &operator[](size_t pos) const { return data[pos]; }

    array &operator=(const array &other) {
        if (&other == this)
            return *this;

        ({ bool _AssertPred = N == other.size && "Array sizes must match."; __builtin_assume(_AssertPred); });

        for (unsigned i = 0; i < N; i++) {
#pragma HLS UNROLL
 data[i] = other[i];
        }
        return *this;
    }
};


template <typename T, unsigned N, T (*func)(T)> class lookup_table {
  public:
    lookup_table(T from, T to) : range_start(from), range_end(to), base_div(ap_uint<16>(N) / T(to - from)) {
        T step = (range_end - range_start) / ap_uint<16>(N);
        for (size_t i = 0; i < N; i++) {
            T num = range_start + ap_uint<16>(i) * step;
            T sample = func(num);
            samples[i] = sample;
        }
    }

    T operator()(T n) const {
        int index = (n - range_start) * base_div;
        if (index < 0)
            index = 0;
        else if (index > N - 1)
            index = N - 1;
        return samples[index];
    }

  private:
    T samples[N];
    const T range_start, range_end;
    ap_fixed<20, 16> base_div;
};

}
# 7 "firmware/defines.h" 2

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 3
# 9 "firmware/defines.h" 2
# 42 "firmware/defines.h"
typedef ap_fixed<16,6> input_t;
typedef ap_fixed<16,6> model_default_t;
typedef ap_fixed<16,6> layer2_t;
typedef ap_fixed<16,6> conv1d_weight_t;
typedef ap_fixed<16,6> conv1d_bias_t;
typedef ap_fixed<16,6> layer3_t;
typedef ap_fixed<18,8> conv1d_relu_table_t;
typedef ap_fixed<16,6> layer4_t;
typedef ap_fixed<16,6> batch_normalization_scale_t;
typedef ap_fixed<16,6> batch_normalization_bias_t;
typedef ap_fixed<16,6> layer5_t;
typedef ap_fixed<16,6> layer6_t;
typedef ap_fixed<16,6> conv1d_1_weight_t;
typedef ap_fixed<16,6> conv1d_1_bias_t;
typedef ap_fixed<16,6> layer7_t;
typedef ap_fixed<18,8> conv1d_1_relu_table_t;
typedef ap_fixed<16,6> layer8_t;
typedef ap_fixed<16,6> batch_normalization_1_scale_t;
typedef ap_fixed<16,6> batch_normalization_1_bias_t;
typedef ap_fixed<16,6> layer9_t;
typedef ap_fixed<16,6> layer11_t;
typedef ap_fixed<16,6> dense_weight_t;
typedef ap_fixed<16,6> dense_bias_t;
typedef ap_uint<1> layer11_index;
typedef ap_fixed<16,6> layer12_t;
typedef ap_fixed<18,8> dense_relu_table_t;
typedef ap_fixed<16,6> layer13_t;
typedef ap_fixed<16,6> batch_normalization_2_scale_t;
typedef ap_fixed<16,6> batch_normalization_2_bias_t;
typedef ap_fixed<16,6> layer14_t;
typedef ap_fixed<16,6> dense_1_weight_t;
typedef ap_fixed<16,6> dense_1_bias_t;
typedef ap_uint<1> layer14_index;
typedef ap_fixed<16,6> layer15_t;
typedef ap_fixed<18,8> dense_1_relu_table_t;
typedef ap_fixed<16,6> layer16_t;
typedef ap_fixed<16,6> batch_normalization_3_scale_t;
typedef ap_fixed<16,6> batch_normalization_3_bias_t;
typedef ap_fixed<16,6> layer17_t;
typedef ap_fixed<16,6> dense_2_weight_t;
typedef ap_fixed<16,6> dense_2_bias_t;
typedef ap_uint<1> layer17_index;
typedef ap_fixed<16,6> result_t;
typedef ap_fixed<18,8> dense_2_softmax_table_t;
typedef ap_fixed<18,8,AP_RND,AP_SAT> dense_2_softmax_exp_table_t;
typedef ap_fixed<18,8,AP_RND,AP_SAT> dense_2_softmax_inv_table_t;
# 9 "firmware/myproject.h" 2




void myproject(
    input_t input_1[120*1],
    result_t layer18_out[20]
);
# 4 "firmware/myproject.cpp" 2
# 1 "firmware/parameters.h" 1




# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_int.h" 1
# 6 "firmware/parameters.h" 2

# 1 "firmware/nnet_utils/nnet_code_gen.h" 1



# 1 "firmware/nnet_utils/nnet_helpers.h" 1




# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/algorithm" 1 3
# 59 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/algorithm" 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/utility" 1 3
# 59 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/utility" 3
# 69 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/utility" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_relops.h" 1 3
# 67 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace rel_ops
  {
# 85 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }


}
# 70 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/utility" 2 3








namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };
# 144 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/utility" 3
  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp2>(__pair.second); }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(const std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }
# 289 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/utility" 3
  template<size_t... _Indexes> struct _Index_tuple { };
# 298 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/utility" 3
  template<size_t _Num>
    struct _Build_index_tuple
    {

      template<typename, size_t... _Indices>
        using _IdxTuple = _Index_tuple<_Indices...>;

      using __type = __make_integer_seq<_IdxTuple, size_t, _Num>;



    };
# 394 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/utility" 3
}
# 61 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/algorithm" 2 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 1 3
# 59 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 3
# 60 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/algorithmfwd.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/algorithmfwd.h" 3








namespace std __attribute__ ((__visibility__ ("default")))
{
# 195 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);
# 224 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>

    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>

    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>

    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>

    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>

    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>

    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>

    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>

    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>

    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>

    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>

    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>

    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>

    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>

    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 565 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
# 594 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);



  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>

    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>

    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>

    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>

    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);



}
# 61 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 1 3
# 62 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare& __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return std::__is_heap_until(__first, __n, __comp) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __n, __cmp) == __n;
    }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      return std::__is_heap(__first, std::move(__comp),
       std::distance(__first, __last));
    }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare& __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 152 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;
                                                     ;
                                                  ;

      __gnu_cxx::__ops::_Iter_less_val __comp;
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __comp);
    }
# 187 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;
                                                                  ;
                                                               ;

      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 269 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                         ;
                                                     ;
                                                     ;
                                              ;

      if (__last - __first > 1)
 {
   --__last;
   __gnu_cxx::__ops::_Iter_less_iter __comp;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 302 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



                                                     ;
                                                                  ;
                                                         ;
                                                           ;

      if (__last - __first > 1)
 {
   typedef __decltype(__comp) _Cmp;
   __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
   --__last;
   std::__pop_heap(__first, __last, __last, __cmp);
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 358 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__make_heap(__first, __last, __comp);
    }
# 384 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                                  ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__make_heap(__first, __last, __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 420 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;
                                              ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__sort_heap(__first, __last, __comp);
    }
# 447 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                                  ;
                                                           ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__sort_heap(__first, __last, __cmp);
    }
# 475 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last), __comp);
    }
# 503 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {



                                                     ;
                                                                  ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last), __cmp);
    }
# 527 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 540 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    {



                                                     ;
                                                                  ;

      const auto __dist = std::distance(__first, __last);
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __dist, __cmp) == __dist;
    }



}
# 62 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tempbuf.h" 1 3
# 60 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tempbuf.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_construct.h" 1 3
# 63 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 87 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new(static_cast<void*>(__p)) _T1; }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }
# 233 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_construct.h" 3
}
# 61 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tempbuf.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 83 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   if (true)
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      if (true)
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      if (false)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
                          ;
 }
    }


}
# 63 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 2 3



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/uniform_int_dist.h" 1 3
# 35 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/uniform_int_dist.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 1 3
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
# 158 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 382 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -9223372036854775807L - 1; }

      static constexpr long
      max() noexcept { return 9223372036854775807L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 9223372036854775807L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1593 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435e-38F; }

      static constexpr float
      max() noexcept { return 3.40282347e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282347e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209290e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return 2.2250738585072014e-308; }

      static constexpr double
      max() noexcept { return 1.7976931348623157e+308; }


      static constexpr double
      lowest() noexcept { return -1.7976931348623157e+308; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return 2.2204460492503131e-16; }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return 4.9406564584124654e-324; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 2.2250738585072014e-308L; }

      static constexpr long double
      max() noexcept { return 1.7976931348623157e+308L; }


      static constexpr long double
      lowest() noexcept { return -1.7976931348623157e+308L; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 2.2204460492503131e-16L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 4.9406564584124654e-324L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 36 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/uniform_int_dist.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace __detail
  {

    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      }
  }






  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument must be an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
                                 ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

 friend bool
 operator!=(const param_type& __p1, const param_type& __p2)
 { return !(__p1 == __p2); }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
# 264 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
# 348 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }




}
# 67 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, (void) ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
# 202 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
  return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 423 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 471 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 506 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 523 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 541 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 556 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {




                                                     ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 580 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      if (__first == __last)
 return true;
      ++__first;
      return std::none_of(__first, __last, __pred);
    }
# 601 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {






                                                     ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 668 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






                                                     ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 700 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 734 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 797 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {





      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 825 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {
# 840 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }
# 894 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





                                                     ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 927 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 993 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





                                                     ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1023 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {






                                                     ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {




      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1178 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



                                                     ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1205 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {





                                                     ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
# 1432 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



                                                       ;
                                                      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
# 1469 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result)
    {




                                                       ;
                                                      ;

      return std::copy(__first, __middle,
         std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1546 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
# 1649 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 1735 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
# 1755 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                     ;
                                                     ;
                                                                   ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
# 1784 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
# 1809 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                     ;
                                                                  ;
                                                                   ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2021 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {





                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2075 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




                                                                  ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2105 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {





                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2176 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {






                                                                  ;
                                                                  ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2212 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {







                    ;

                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
# 2245 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val)
    {




                                                                  ;
                                                                  ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
# 2278 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {





                    ;

                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
   _DistanceType;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
# 2572 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {





                                                  ;
                                                 ;
                                                     ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
# 2613 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {






                                                               ;
                                                              ;
                                                                  ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result));


    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2785 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first2, __first1))
   return false;
 else if (__comp(__first1, __first2))
   ++__first1;
 else
   {
     ++__first1;
     ++__first2;
   }

      return __first2 == __last2;
    }
# 2824 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
# 2838 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 2868 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
# 2884 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 2903 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 2952 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;
                                                     ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 2984 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;
                                                                  ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 3052 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;
                                                     ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 3084 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;
                                                                  ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, (void)++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3134 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






                                                     ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
# 3168 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






                                                     ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }
# 3207 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3221 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
# 3250 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
                                                     ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 3274 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {





                                                     ;
                                                                  ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 3299 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _Tp>

    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {



      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3320 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>

    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>

    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 3400 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>

    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
                                                     ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 3428 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>

    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {





                                                     ;
                                                                  ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>

    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>

    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>

    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>

    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>

    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>

    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3540 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {






                                                       ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3571 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {






                                                       ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
# 3767 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _IntType, typename _UniformRandomBitGenerator>
    pair<_IntType, _IntType>
    __gen_two_uniform_ints(_IntType __b0, _IntType __b1,
      _UniformRandomBitGenerator&& __g)
    {
      _IntType __x
 = uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
      return std::make_pair(__x / __b1, __x % __b1);
    }
# 3789 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {



                                                     ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;

      typedef typename remove_reference<_UniformRandomNumberGenerator>::type
 _Gen;
      typedef typename common_type<typename _Gen::result_type, __ud_type>::type
 __uc_type;

      const __uc_type __urngrange = __g.max() - __g.min();
      const __uc_type __urange = __uc_type(__last - __first);

      if (__urngrange / __urange >= __urange)

      {
 _RandomAccessIterator __i = __first + 1;





 if ((__urange % 2) == 0)
 {
   __distr_type __d{0, 1};
   std::iter_swap(__i++, __first + __d(__g));
 }





 while (__i != __last)
 {
   const __uc_type __swap_range = __uc_type(__i - __first) + 1;

   const pair<__uc_type, __uc_type> __pospos =
     __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);

   std::iter_swap(__i++, __first + __pospos.first);
   std::iter_swap(__i++, __first + __pospos.second);
 }

 return;
      }

      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }
# 3874 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


                                                     ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
# 3895 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




                                                     ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 3919 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




                                                     ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 3950 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 3990 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4022 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4047 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





                                                     ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 4072 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




                                                     ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 4095 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




                                                     ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 4135 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4174 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






                                                       ;
                                                       ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
# 4209 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




                                                     ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 4242 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




                                                     ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
# 4290 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





                                                     ;

      for (; __first != __last; ++__first, (void)++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4327 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






                                                       ;

      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4360 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4392 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4424 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




                                                     ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4455 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, (void) ++__first)
 *__first = __gen();
      return __first;
    }
# 4491 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4531 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4564 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



                                                     ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
# 4599 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {



                                                     ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
# 4639 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4672 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {





                                                       ;
                                                      ;
                                                     ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 4710 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {






                                                       ;
                                                      ;
                                                                  ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4746 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {





                                                    ;
                                                   ;
                                                     ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 4785 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {






                                                    ;
                                                   ;
                                                                  ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4822 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 4852 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {






                                                     ;
                                                                  ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 4913 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
# 4930 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 4963 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
# 4980 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5027 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 5061 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {






                                                     ;
                                                                  ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5130 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
# 5150 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5180 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
# 5200 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5251 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
# 5269 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 5300 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
# 5318 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5373 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
# 5391 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 5424 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
# 5442 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5503 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
# 5523 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 5554 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
# 5575 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>

    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
# 5607 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>

    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
                                                     ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5632 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>

    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;
                                                                  ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>

    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
# 5671 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>

    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
                                                     ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5696 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>

    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;
                                                                  ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 5841 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_algo.h" 3
}
# 63 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/algorithm" 2 3
# 6 "firmware/nnet_utils/nnet_helpers.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 1 3
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/codecvt.h" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 273 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
      friend class messages<char>;

    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };






  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
      friend class messages<wchar_t>;

    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };
# 467 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/codecvt.h" 3
  template<>
    class codecvt<char16_t, char, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }


      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char, mbstate_t>
    : public codecvt<char16_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<char16_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char, mbstate_t>
    : public codecvt<char32_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<char32_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };





  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;





}
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 3
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/basic_file.h" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/basic_file.h" 3


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++io.h" 1 3
# 35 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++io.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdio" 3
# 36 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/c++io.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


}
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/x86_64-pc-linux-gnu/bits/basic_file.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0) throw ();


      __basic_file(__basic_file&& __rv, __c_lock* = 0) noexcept
      : _M_cfile(__rv._M_cfile), _M_cfile_created(__rv._M_cfile_created)
      {
 __rv._M_cfile = nullptr;
 __rv._M_cfile_created = false;
      }

      __basic_file& operator=(const __basic_file&) = delete;
      __basic_file& operator=(__basic_file&&) = delete;

      void
      swap(__basic_file& __f) noexcept
      {
 std::swap(_M_cfile, __f._M_cfile);
 std::swap(_M_cfile_created, __f._M_cfile_created);
      }


      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);

      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode) throw ();

      __basic_file*
      close();

      __attribute__ ((__pure__)) bool
      is_open() const throw ();

      __attribute__ ((__pure__)) int
      fd() throw ();

      __attribute__ ((__pure__)) __c_file*
      file() throw ();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way) throw ();

      int
      sync();

      streamsize
      showmanyc();
    };


}
# 43 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 79 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {

      template<typename _Tp>
 using __chk_state = __and_<is_copy_assignable<_Tp>,
       is_copy_constructible<_Tp>,
       is_default_constructible<_Tp>>;

      static_assert(__chk_state<typename _Traits::state_type>::value,
      "state_type must be CopyAssignable, CopyConstructible"
      " and DefaultConstructible");

      static_assert(is_same<typename _Traits::pos_type,
       fpos<typename _Traits::state_type>>::value,
      "pos_type must be fpos<state_type>");

    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;

      friend class ios_base;

    protected:


      __c_lock _M_lock;


      __file_type _M_file;


      ios_base::openmode _M_mode;


      __state_type _M_state_beg;




      __state_type _M_state_cur;



      __state_type _M_state_last;


      char_type* _M_buf;






      size_t _M_buf_size;


      bool _M_buf_allocated;
# 155 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      bool _M_reading;
      bool _M_writing;







      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;






      char* _M_ext_buf;




      streamsize _M_ext_buf_size;






      const char* _M_ext_next;
      char* _M_ext_end;






      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }






      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();


      basic_filebuf(const basic_filebuf&) = delete;
      basic_filebuf(basic_filebuf&&);





      virtual
      ~basic_filebuf()
      { this->close(); }


      basic_filebuf& operator=(const basic_filebuf&) = delete;
      basic_filebuf& operator=(basic_filebuf&&);
      void swap(basic_filebuf&);






      bool
      is_open() const throw()
      { return _M_file.is_open(); }
# 304 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 314 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      __filebuf_type*
      open(const std::string& __s, ios_base::openmode __mode)
      { return open(__s.c_str(), __mode); }
# 344 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      __filebuf_type*
      close();

    protected:
      void
      _M_allocate_internal_buffer();

      void
      _M_destroy_internal_buffer() throw();


      virtual streamsize
      showmanyc();






      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 376 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());



      bool
      _M_convert_to_external(char_type*, streamsize);
# 396 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);

      int
      _M_get_ext_pos(__state_type &__state);

      virtual int
      sync();

      virtual void
      imbue(const locale& __loc);

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);


      bool
      _M_terminate_output();
# 442 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
 const bool __testin = _M_mode & ios_base::in;
 const bool __testout = (_M_mode & ios_base::out
    || _M_mode & ios_base::app);

 if (__testin && __off > 0)
   this->setg(_M_buf, _M_buf, _M_buf + __off);
 else
   this->setg(_M_buf, _M_buf, _M_buf);

 if (__testout && __off == 0 && _M_buf_size > 1 )
   this->setp(_M_buf, _M_buf + _M_buf_size - 1);
 else
   this->setp(0, 0);
      }
    };
# 475 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 502 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 512 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 528 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      explicit
      basic_ifstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 552 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      basic_ifstream(const basic_ifstream&) = delete;

      basic_ifstream(basic_ifstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __istream_type::set_rdbuf(&_M_filebuf); }
# 566 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      ~basic_ifstream()
      { }




      basic_ifstream&
      operator=(const basic_ifstream&) = delete;

      basic_ifstream&
      operator=(basic_ifstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ifstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 598 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 624 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 644 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 677 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 700 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 727 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 737 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 754 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      explicit
      basic_ofstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 778 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      basic_ofstream(const basic_ofstream&) = delete;

      basic_ofstream(basic_ofstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __ostream_type::set_rdbuf(&_M_filebuf); }
# 792 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      ~basic_ofstream()
      { }




      basic_ofstream&
      operator=(const basic_ofstream&) = delete;

      basic_ofstream&
      operator=(basic_ofstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ofstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 824 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 850 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 870 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 903 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 926 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 954 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }






      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      explicit
      basic_fstream(const std::string& __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 1000 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      basic_fstream(const basic_fstream&) = delete;

      basic_fstream(basic_fstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __iostream_type::set_rdbuf(&_M_filebuf); }
# 1014 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      ~basic_fstream()
      { }




      basic_fstream&
      operator=(const basic_fstream&) = delete;

      basic_fstream&
      operator=(basic_fstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_fstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 1046 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 1072 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1093 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1128 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };



  template <class _CharT, class _Traits>
    inline void
    swap(basic_filebuf<_CharT, _Traits>& __x,
  basic_filebuf<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ifstream<_CharT, _Traits>& __x,
  basic_ifstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ofstream<_CharT, _Traits>& __x,
  basic_ofstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_fstream<_CharT, _Traits>& __x,
  basic_fstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }



}


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/fstream.tcc" 1 3
# 38 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/fstream.tcc" 3




namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !_M_buf)
 {
   _M_buf = new char_type[_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] _M_buf;
   _M_buf = 0;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = 0;
      _M_ext_buf_size = 0;
      _M_ext_next = 0;
      _M_ext_end = 0;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(0), _M_buf_size(8192),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }


  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf(basic_filebuf&& __rhs)
    : __streambuf_type(__rhs),
    _M_lock(), _M_file(std::move(__rhs._M_file), &_M_lock),
    _M_mode(std::__exchange(__rhs._M_mode, ios_base::openmode(0))),
    _M_state_beg(std::move(__rhs._M_state_beg)),
    _M_state_cur(std::move(__rhs._M_state_cur)),
    _M_state_last(std::move(__rhs._M_state_last)),
    _M_buf(std::__exchange(__rhs._M_buf, nullptr)),
    _M_buf_size(std::__exchange(__rhs._M_buf_size, 1)),
    _M_buf_allocated(std::__exchange(__rhs._M_buf_allocated, false)),
    _M_reading(std::__exchange(__rhs._M_reading, false)),
    _M_writing(std::__exchange(__rhs._M_writing, false)),
    _M_pback(__rhs._M_pback),
    _M_pback_cur_save(std::__exchange(__rhs._M_pback_cur_save, nullptr)),
    _M_pback_end_save(std::__exchange(__rhs._M_pback_end_save, nullptr)),
    _M_pback_init(std::__exchange(__rhs._M_pback_init, false)),
    _M_codecvt(__rhs._M_codecvt),
    _M_ext_buf(std::__exchange(__rhs._M_ext_buf, nullptr)),
    _M_ext_buf_size(std::__exchange(__rhs._M_ext_buf_size, 0)),
    _M_ext_next(std::__exchange(__rhs._M_ext_next, nullptr)),
    _M_ext_end(std::__exchange(__rhs._M_ext_end, nullptr))
    {
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>&
    basic_filebuf<_CharT, _Traits>::
    operator=(basic_filebuf&& __rhs)
    {
      this->close();
      __streambuf_type::operator=(__rhs);
      _M_file.swap(__rhs._M_file);
      _M_mode = std::__exchange(__rhs._M_mode, ios_base::openmode(0));
      _M_state_beg = std::move(__rhs._M_state_beg);
      _M_state_cur = std::move(__rhs._M_state_cur);
      _M_state_last = std::move(__rhs._M_state_last);
      _M_buf = std::__exchange(__rhs._M_buf, nullptr);
      _M_buf_size = std::__exchange(__rhs._M_buf_size, 1);
      _M_buf_allocated = std::__exchange(__rhs._M_buf_allocated, false);
      _M_ext_buf = std::__exchange(__rhs._M_ext_buf, nullptr);
      _M_ext_buf_size = std::__exchange(__rhs._M_ext_buf_size, 0);
      _M_ext_next = std::__exchange(__rhs._M_ext_next, nullptr);
      _M_ext_end = std::__exchange(__rhs._M_ext_end, nullptr);
      _M_reading = std::__exchange(__rhs._M_reading, false);
      _M_writing = std::__exchange(__rhs._M_writing, false);
      _M_pback_cur_save = std::__exchange(__rhs._M_pback_cur_save, nullptr);
      _M_pback_end_save = std::__exchange(__rhs._M_pback_end_save, nullptr);
      _M_pback_init = std::__exchange(__rhs._M_pback_init, false);
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
      return *this;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    swap(basic_filebuf& __rhs)
    {
      __streambuf_type::swap(__rhs);
      _M_file.swap(__rhs._M_file);
      std::swap(_M_mode, __rhs._M_mode);
      std::swap(_M_state_beg, __rhs._M_state_beg);
      std::swap(_M_state_cur, __rhs._M_state_cur);
      std::swap(_M_state_last, __rhs._M_state_last);
      std::swap(_M_buf, __rhs._M_buf);
      std::swap(_M_buf_size, __rhs._M_buf_size);
      std::swap(_M_buf_allocated, __rhs._M_buf_allocated);
      std::swap(_M_ext_buf, __rhs._M_ext_buf);
      std::swap(_M_ext_buf_size, __rhs._M_ext_buf_size);
      std::swap(_M_ext_next, __rhs._M_ext_next);
      std::swap(_M_ext_end, __rhs._M_ext_end);
      std::swap(_M_reading, __rhs._M_reading);
      std::swap(_M_writing, __rhs._M_writing);
      std::swap(_M_pback_cur_save, __rhs._M_pback_cur_save);
      std::swap(_M_pback_end_save, __rhs._M_pback_end_save);
      std::swap(_M_pback_init, __rhs._M_pback_init);
    }


  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = 0;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       _M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close()
    {
      if (!this->is_open())
 return 0;

      bool __testfail = false;
      {

 struct __close_sentry
 {
   basic_filebuf *__fb;
   __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }
   ~__close_sentry ()
   {
     __fb->_M_mode = ios_base::openmode(0);
     __fb->_M_pback_init = false;
     __fb->_M_destroy_internal_buffer();
     __fb->_M_reading = false;
     __fb->_M_writing = false;
     __fb->_M_set_buffer(-1);
     __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
   }
 } __cs (this);

 if (true)
   {
     if (!_M_terminate_output())
       __testfail = true;
   }
 if (false)
   {
     _M_file.close();
                            ;
   }
 if (false)
   { __testfail = true; }
      }

      if (!_M_file.close())
 __testfail = true;

      if (__testfail)
 return 0;
      else
 return this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();







   if (__check_facet(_M_codecvt).encoding() >= 0)

     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      __builtin_memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid"));


   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend = this->eback();
    if (_M_ext_next < _M_ext_end)
      __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
      _M_ext_end, _M_ext_next,
      this->eback(),
      this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>
     (_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file"));

     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file"));

   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file"));

 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }


   const bool __testpb = _M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__testout)
 {
          if (_M_reading)
            {
              _M_destroy_pback();
              const int __gptr_off = _M_get_ext_pos(_M_state_last);
              if (_M_seek(__gptr_off, ios_base::cur, _M_state_last)
                  == pos_type(off_type(-1)))
                return __ret;
            }
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));


   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));

     }
 }
      return __elen == __plen;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsgetn(_CharT* __s, streamsize __n)
    {

      streamsize __ret = 0;
      if (_M_pback_init)
 {
   if (__n > 0 && this->gptr() == this->eback())
     {
       *__s++ = *this->gptr();
       this->gbump(1);
       __ret = 1;
       --__n;
     }
   _M_destroy_pback();
 }
      else if (_M_writing)
 {
   if (overflow() == traits_type::eof())
     return __ret;
   _M_set_buffer(-1);
   _M_writing = false;
 }




      const bool __testin = _M_mode & ios_base::in;
      const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

      if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
   && __testin)
 {

   const streamsize __avail = this->egptr() - this->gptr();
   if (__avail != 0)
     {
       traits_type::copy(__s, this->gptr(), __avail);
       __s += __avail;
       this->setg(this->eback(), this->gptr() + __avail, this->egptr());
       __ret += __avail;
       __n -= __avail;
     }



   streamsize __len;
   for (;;)
     {
       __len = _M_file.xsgetn(reinterpret_cast<char*>(__s), __n);
       if (__len == -1)
  __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file"));

       if (__len == 0)
  break;

       __n -= __len;
       __ret += __len;
       if (__n == 0)
  break;

       __s += __len;
     }

   if (__n == 0)
     {

       _M_reading = true;
     }
   else if (__len == 0)
     {



       _M_set_buffer(-1);
       _M_reading = false;
     }
 }
      else
 __ret += __streambuf_type::xsgetn(__s, __n);

      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsputn(const _CharT* __s, streamsize __n)
    {
      streamsize __ret = 0;



      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__check_facet(_M_codecvt).always_noconv()
   && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && _M_buf_size > 1)
     __bufavail = _M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 {
   if (__s == 0 && __n == 0)
     _M_buf_size = 1;
   else if (__s && __n > 0)
     {
# 785 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/fstream.tcc" 3
       _M_buf = __s;
       _M_buf_size = __n;
     }
 }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {




   bool __no_movement = __way == ios_base::cur && __off == 0
     && (!_M_writing || _M_codecvt->always_noconv());


   if (!__no_movement)
     _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       __state = _M_state_last;
       __computed_off += _M_get_ext_pos(__state);
     }
   if (!__no_movement)
     __ret = _M_seek(__computed_off, __way, __state);
   else
     {
       if (_M_writing)
  __computed_off = this->pptr() - this->pbase();

       off_type __file_off = _M_file.seekoff(0, ios_base::cur);
       if (__file_off != off_type(-1))
  {
    __ret = __file_off + __computed_off;
    __ret.state(__state);
  }
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {
   off_type __file_off = _M_file.seekoff(__off, __way);
   if (__file_off != off_type(-1))
     {
       _M_reading = false;
       _M_writing = false;
       _M_ext_next = _M_ext_end = _M_ext_buf;
       _M_set_buffer(-1);
       _M_state_cur = __state;
       __ret = __file_off;
       __ret.state(_M_state_cur);
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    int basic_filebuf<_CharT, _Traits>::
    _M_get_ext_pos(__state_type& __state)
    {
      if (_M_codecvt->always_noconv())
        return this->gptr() - this->egptr();
      else
        {



          const int __gptr_off =
            _M_codecvt->length(__state, _M_ext_buf, _M_ext_next,
                               this->gptr() - this->eback());
          return _M_ext_buf + __gptr_off - _M_ext_end;
        }
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, _M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf,
          _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }




  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;




}
# 1170 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/fstream" 2 3
# 7 "firmware/nnet_utils/nnet_helpers.h" 2

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/map" 1 3
# 59 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/map" 3

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 1 3
# 62 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3







# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/aligned_buffer.h" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {





      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };
# 89 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/ext/aligned_buffer.h" 3
  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>
    {
      typename
 std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };


}
# 70 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 99 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };


  template<typename _Key_compare>
    struct _Rb_tree_key_compare
    {
      _Key_compare _M_key_compare;

      _Rb_tree_key_compare()
      noexcept(is_nothrow_default_constructible<_Key_compare>::value)

      : _M_key_compare()
      { }

      _Rb_tree_key_compare(const _Key_compare& __comp)
      : _M_key_compare(__comp)
      { }



      _Rb_tree_key_compare(const _Rb_tree_key_compare&) = default;

      _Rb_tree_key_compare(_Rb_tree_key_compare&& __x)
 noexcept(is_nothrow_copy_constructible<_Key_compare>::value)
      : _M_key_compare(__x._M_key_compare)
      { }

    };


  struct _Rb_tree_header
  {
    _Rb_tree_node_base _M_header;
    size_t _M_node_count;

    _Rb_tree_header() noexcept
    {
      _M_header._M_color = _S_red;
      _M_reset();
    }


    _Rb_tree_header(_Rb_tree_header&& __x) noexcept
    {
      if (__x._M_header._M_parent != nullptr)
 _M_move_data(__x);
      else
 {
   _M_header._M_color = _S_red;
   _M_reset();
 }
    }


    void
    _M_move_data(_Rb_tree_header& __from)
    {
      _M_header._M_color = __from._M_header._M_color;
      _M_header._M_parent = __from._M_header._M_parent;
      _M_header._M_left = __from._M_header._M_left;
      _M_header._M_right = __from._M_header._M_right;
      _M_header._M_parent->_M_parent = &_M_header;
      _M_node_count = __from._M_node_count;

      __from._M_reset();
    }

    void
    _M_reset()
    {
      _M_header._M_parent = 0;
      _M_header._M_left = &_M_header;
      _M_header._M_right = &_M_header;
      _M_node_count = 0;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
# 231 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
      __gnu_cxx::__aligned_membuf<_Val> _M_storage;

      _Val*
      _M_valptr()
      { return _M_storage._M_ptr(); }

      const _Val*
      _M_valptr() const
      { return _M_storage._M_ptr(); }

    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it) noexcept
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
        const _Rb_tree_const_iterator<_Val>& __y) noexcept
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
        const _Rb_tree_const_iterator<_Val>& __y) noexcept
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
    _Rb_tree_node_base* __x,
    _Rb_tree_node_base* __p,
    _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();
# 442 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Rb_tree_node<_Val> >::other _Node_allocator;

      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;


      static_assert(__is_invocable<_Compare&, const _Key&, const _Key&>{},
   "comparison object must be invocable with two arguments of key type");
# 462 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;

    private:


      struct _Reuse_or_alloc_node
      {
 _Reuse_or_alloc_node(_Rb_tree& __t)
   : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
 {
   if (_M_root)
     {
       _M_root->_M_parent = 0;

       if (_M_nodes->_M_left)
  _M_nodes = _M_nodes->_M_left;
     }
   else
     _M_nodes = 0;
 }


 _Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;


 ~_Reuse_or_alloc_node()
 { _M_t._M_erase(static_cast<_Link_type>(_M_root)); }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg)

   {
     _Link_type __node = static_cast<_Link_type>(_M_extract());
     if (__node)
       {
  _M_t._M_destroy_node(__node);
  _M_t._M_construct_node(__node, std::forward<_Arg>(__arg));
  return __node;
       }

     return _M_t._M_create_node(std::forward<_Arg>(__arg));
   }

      private:
 _Base_ptr
 _M_extract()
 {
   if (!_M_nodes)
     return _M_nodes;

   _Base_ptr __node = _M_nodes;
   _M_nodes = _M_nodes->_M_parent;
   if (_M_nodes)
     {
       if (_M_nodes->_M_right == __node)
  {
    _M_nodes->_M_right = 0;

    if (_M_nodes->_M_left)
      {
        _M_nodes = _M_nodes->_M_left;

        while (_M_nodes->_M_right)
   _M_nodes = _M_nodes->_M_right;

        if (_M_nodes->_M_left)
   _M_nodes = _M_nodes->_M_left;
      }
  }
       else
  _M_nodes->_M_left = 0;
     }
   else
     _M_root = 0;

   return __node;
 }

 _Base_ptr _M_root;
 _Base_ptr _M_nodes;
 _Rb_tree& _M_t;
      };



      struct _Alloc_node
      {
 _Alloc_node(_Rb_tree& __t)
   : _M_t(__t) { }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg) const

   { return _M_t._M_create_node(std::forward<_Arg>(__arg)); }

      private:
 _Rb_tree& _M_t;
      };

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator() noexcept
      { return this->_M_impl; }

      const _Node_allocator&
      _M_get_Node_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }

      void
      _M_put_node(_Link_type __p) noexcept
      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
# 630 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
      template<typename... _Args>
 void
 _M_construct_node(_Link_type __node, _Args&&... __args)
 {
   if (true)
     {
       ::new(__node) _Rb_tree_node<_Val>;
       _Alloc_traits::construct(_M_get_Node_allocator(),
           __node->_M_valptr(),
           std::forward<_Args>(__args)...);
     }
   if (false)
     {
       __node->~_Rb_tree_node<_Val>();
       _M_put_node(__node);
                              ;
     }
 }

      template<typename... _Args>
 _Link_type
 _M_create_node(_Args&&... __args)
 {
   _Link_type __tmp = _M_get_node();
   _M_construct_node(__tmp, std::forward<_Args>(__args)...);
   return __tmp;
 }

      void
      _M_destroy_node(_Link_type __p) noexcept
      {
 _Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
 __p->~_Rb_tree_node<_Val>();
      }


      void
      _M_drop_node(_Link_type __p) noexcept
      {
 _M_destroy_node(__p);
 _M_put_node(__p);
      }

      template<typename _NodeGen>
 _Link_type
 _M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)
 {
   _Link_type __tmp = __node_gen(*__x->_M_valptr());
   __tmp->_M_color = __x->_M_color;
   __tmp->_M_left = 0;
   __tmp->_M_right = 0;
   return __tmp;
 }

    protected:




      template<typename _Key_compare,
        bool = __is_pod(_Key_compare)>

 struct _Rb_tree_impl
 : public _Node_allocator
 , public _Rb_tree_key_compare<_Key_compare>
 , public _Rb_tree_header
 {
   typedef _Rb_tree_key_compare<_Key_compare> _Base_key_compare;

   _Rb_tree_impl()
     noexcept(is_nothrow_default_constructible<_Node_allocator>::value && is_nothrow_default_constructible<_Base_key_compare>::value)


   : _Node_allocator()
   { }

   _Rb_tree_impl(const _Rb_tree_impl& __x)
   : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))
   , _Base_key_compare(__x._M_key_compare)
   { }






   _Rb_tree_impl(_Rb_tree_impl&&) = default;

   _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
   : _Node_allocator(std::move(__a)), _Base_key_compare(__comp)
   { }

 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root() noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost() noexcept
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const noexcept
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost() noexcept
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const noexcept
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin() noexcept
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const noexcept
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Base_ptr
      _M_end() noexcept
      { return &this->_M_impl._M_header; }

      _Const_Base_ptr
      _M_end() const noexcept
      { return &this->_M_impl._M_header; }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return *__x->_M_valptr(); }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return *static_cast<_Const_Link_type>(__x)->_M_valptr(); }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
# 832 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_unique_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_equal_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_unique_pos(const_iterator __pos,
        const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_equal_pos(const_iterator __pos,
       const key_type& __k);

    private:

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);

      iterator
      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);

      template<typename _Arg>
 iterator
 _M_insert_lower(_Base_ptr __y, _Arg&& __v);

      template<typename _Arg>
 iterator
 _M_insert_equal_lower(_Arg&& __x);

      iterator
      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);

      iterator
      _M_insert_equal_lower_node(_Link_type __z);
# 883 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
      template<typename _NodeGen>
 _Link_type
 _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen&);

      template<typename _NodeGen>
 _Link_type
 _M_copy(const _Rb_tree& __x, _NodeGen& __gen)
 {
   _Link_type __root = _M_copy(__x._M_begin(), _M_end(), __gen);
   _M_leftmost() = _S_minimum(__root);
   _M_rightmost() = _S_maximum(__root);
   _M_impl._M_node_count = __x._M_impl._M_node_count;
   return __root;
 }

      _Link_type
      _M_copy(const _Rb_tree& __x)
      {
 _Alloc_node __an(*this);
 return _M_copy(__x, __an);
      }

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Base_ptr __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Base_ptr __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
       const _Key& __k) const;

    public:




      _Rb_tree() = default;


      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, _Node_allocator(__a)) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl)
      {
 if (__x._M_root() != 0)
   _M_root() = _M_copy(__x);
      }


      _Rb_tree(const allocator_type& __a)
      : _M_impl(_Compare(), _Node_allocator(__a))
      { }

      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
      {
 if (__x._M_root() != nullptr)
   _M_root() = _M_copy(__x);
      }

      _Rb_tree(_Rb_tree&&) = default;

      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
      : _Rb_tree(std::move(__x), _Node_allocator(__a))
      { }

      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);


      ~_Rb_tree() noexcept
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_header._M_left); }

      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_header._M_left); }

      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_header); }

      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_header); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      bool
      empty() const noexcept
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const noexcept
      { return _M_impl._M_node_count; }

      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }

      void
      swap(_Rb_tree& __t)
      noexcept(__is_nothrow_swappable<_Compare>::value);



      template<typename _Arg>
 pair<iterator, bool>
 _M_insert_unique(_Arg&& __x);

      template<typename _Arg>
 iterator
 _M_insert_equal(_Arg&& __x);

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename... _Args>
 pair<iterator, bool>
 _M_emplace_unique(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_equal(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
# 1103 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
      template<typename _InputIterator>
 void
 _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
 void
 _M_insert_equal(_InputIterator __first, _InputIterator __last);

    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:



      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      {
                                      ;
 const_iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result._M_const_cast();
      }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      {
                                      ;
 iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result;
      }
# 1159 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
      size_type
      erase(const key_type& __x);




      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      {
 _M_erase_aux(__first, __last);
 return __last._M_const_cast();
      }
# 1181 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear() noexcept
      {
 _M_erase(_M_begin());
 _M_impl._M_reset();
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;
# 1341 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
      bool
      __rb_verify() const;


      _Rb_tree&
      operator=(_Rb_tree&&)
      noexcept(_Alloc_traits::_S_nothrow_move()
        && is_nothrow_move_assignable<_Compare>::value);

      template<typename _Iterator>
 void
 _M_assign_unique(_Iterator, _Iterator);

      template<typename _Iterator>
 void
 _M_assign_equal(_Iterator, _Iterator);

    private:

      void
      _M_move_data(_Rb_tree& __x, std::true_type)
      { _M_impl._M_move_data(__x._M_impl); }



      void
      _M_move_data(_Rb_tree&, std::false_type);


      void
      _M_move_assign(_Rb_tree&, std::true_type);



      void
      _M_move_assign(_Rb_tree&, std::false_type);
# 1544 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
    : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
    {
      using __eq = typename _Alloc_traits::is_always_equal;
      if (__x._M_root() != nullptr)
 _M_move_data(__x, __eq());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_data(_Rb_tree& __x, std::false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
 _M_move_data(__x, std::true_type());
      else
 {
   _Alloc_node __an(*this);
   auto __lbd =
     [&__an](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __an(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x, __lbd);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_assign(_Rb_tree& __x, true_type)
    {
      clear();
      if (__x._M_root() != nullptr)
 _M_move_data(__x, std::true_type());
      std::__alloc_on_move(_M_get_Node_allocator(),
      __x._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_assign(_Rb_tree& __x, false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
 return _M_move_assign(__x, true_type{});



      _Reuse_or_alloc_node __roan(*this);
      _M_impl._M_reset();
      if (__x._M_root() != nullptr)
 {
   auto __lbd =
     [&__roan](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __roan(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x, __lbd);
   __x.clear();
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(_Rb_tree&& __x)
    noexcept(_Alloc_traits::_S_nothrow_move()
      && is_nothrow_move_assignable<_Compare>::value)
    {
      _M_impl._M_key_compare = std::move(__x._M_impl._M_key_compare);
      _M_move_assign(__x, __bool_constant<_Alloc_traits::_S_nothrow_move()>());
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_unique(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first, __roan);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_equal(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first, __roan);
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree& __x)
    {
      if (this != &__x)
 {


   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       auto& __this_alloc = this->_M_get_Node_allocator();
       auto& __that_alloc = __x._M_get_Node_allocator();
       if (!_Alloc_traits::_S_always_equal()
    && __this_alloc != __that_alloc)
  {


    clear();
    std::__alloc_on_copy(__this_alloc, __that_alloc);
  }
     }


   _Reuse_or_alloc_node __roan(*this);
   _M_impl._M_reset();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     _M_root() = _M_copy(__x, __roan);
 }

      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_(_Base_ptr __x, _Base_ptr __p,

   _Arg&& __v,



   _NodeGen& __node_gen)
      {
 bool __insert_left = (__x != 0 || __p == _M_end()
         || _M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key(__p)));

 _Link_type __z = __node_gen(std::forward<_Arg>(__v));

 _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
          this->_M_impl._M_header);
 ++_M_impl._M_node_count;
 return iterator(__z);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_lower(_Base_ptr __p, _Arg&& __v)



    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(std::forward<_Arg>(__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal_lower(_Arg&& __v)



    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
  _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__y, std::forward<_Arg>(__v));
    }

  template<typename _Key, typename _Val, typename _KoV,
    typename _Compare, typename _Alloc>
    template<typename _NodeGen>
      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
      _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)
      {

 _Link_type __top = _M_clone_node(__x, __node_gen);
 __top->_M_parent = __p;

 if (true)
   {
     if (__x->_M_right)
       __top->_M_right = _M_copy(_S_right(__x), __top, __node_gen);
     __p = __top;
     __x = _S_left(__x);

     while (__x != 0)
       {
  _Link_type __y = _M_clone_node(__x, __node_gen);
  __p->_M_left = __y;
  __y->_M_parent = __p;
  if (__x->_M_right)
    __y->_M_right = _M_copy(_S_right(__x), __y, __node_gen);
  __p = __y;
  __x = _S_left(__x);
       }
   }
 if (false)
   {
     _M_erase(__top);
                            ;
   }
 return __top;
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_drop_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Base_ptr __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Base_ptr __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x);
       _Base_ptr __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
     iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Base_ptr __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x);
       _Const_Base_ptr __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
     const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree& __t)
    noexcept(__is_nothrow_swappable<_Compare>::value)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     _M_impl._M_move_data(__t._M_impl);
 }
      else if (__t._M_root() == 0)
 __t._M_impl._M_move_data(_M_impl);
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
   std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
 }

      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);

      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
    __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_unique_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(__k, _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return _Res(__x, __y);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
 return _Res(__x, __y);
      return _Res(__j._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_equal_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
  _S_left(__x) : _S_right(__x);
 }
      return _Res(__x, __y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_unique(_Arg&& __v)



    {
      typedef pair<iterator, bool> _Res;
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_unique_pos(_KeyOfValue()(__v));

      if (__res.second)
 {
   _Alloc_node __an(*this);
   return _Res(_M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v), __an),
        true);
 }

      return _Res(iterator(__res.first), false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal(_Arg&& __v)



    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_equal_pos(_KeyOfValue()(__v));
      _Alloc_node __an(*this);
      return _M_insert_(__res.first, __res.second,
   std::forward<_Arg>(__v), __an);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_unique_pos(const_iterator __position,
      const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else

 return _Res(__pos._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_unique_(const_iterator __position,

   _Arg&& __v,



   _NodeGen& __node_gen)
    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v),
     __node_gen);
      return iterator(__res.first);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_equal_pos(__k);
 }
      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_equal_pos(__k);
 }
      else
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _Res(0, 0);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_equal_(const_iterator __position,

         _Arg&& __v,



         _NodeGen& __node_gen)
      {
 pair<_Base_ptr, _Base_ptr> __res
   = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));

 if (__res.second)
   return _M_insert_(__res.first, __res.second,
       std::forward<_Arg>(__v),
       __node_gen);

 return _M_insert_equal_lower(std::forward<_Arg>(__v));
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_S_key(__z),
            _S_key(__p)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _S_key(__z)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower_node(_Link_type __z)
    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
  _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower_node(__y, __z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator, bool>
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_unique(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 if (true)
   {
     typedef pair<iterator, bool> _Res;
     auto __res = _M_get_insert_unique_pos(_S_key(__z));
     if (__res.second)
       return _Res(_M_insert_node(__res.first, __res.second, __z), true);

     _M_drop_node(__z);
     return _Res(iterator(__res.first), false);
   }
 if (false)
   {
     _M_drop_node(__z);
                            ;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_equal(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 if (true)
   {
     auto __res = _M_get_insert_equal_pos(_S_key(__z));
     return _M_insert_node(__res.first, __res.second, __z);
   }
 if (false)
   {
     _M_drop_node(__z);
                            ;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 if (true)
   {
     auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     _M_drop_node(__z);
     return iterator(__res.first);
   }
 if (false)
   {
     _M_drop_node(__z);
                            ;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 if (true)
   {
     auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     return _M_insert_equal_lower_node(__z);
   }
 if (false)
   {
     _M_drop_node(__z);
                            ;
   }
      }


  template<typename _Key, typename _Val, typename _KoV,
    typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 _Alloc_node __an(*this);
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first, __an);
      }

  template<typename _Key, typename _Val, typename _KoV,
    typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 _Alloc_node __an(*this);
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first, __an);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_drop_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   _M_erase_aux(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      _M_erase_aux(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
         const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }
# 2628 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_tree.h" 3
}
# 61 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/map" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 1 3
# 63 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/tuple" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/tuple" 3






# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/array" 1 3
# 33 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/array" 3
# 43 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/array" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 93 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(_AT_Type::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


                           iterator
      begin() noexcept
      { return iterator(data()); }

                           const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

                           iterator
      end() noexcept
      { return iterator(data() + _Nm); }

                           const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

                           reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

                           const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

                           reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

                           const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

                           const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

                           const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

                           const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

                           const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


                           reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

                           reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)"),

     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)"),

        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

                           reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

                           reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

                           pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

                           const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };
# 250 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline






    void

    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }
# 305 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/array" 3
  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    struct tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    struct tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/tuple" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/uses_allocator.h" 1 3
# 35 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __erased_type { };

  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_same<_Tp, __erased_type>, is_convertible<_Alloc, _Tp>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

                    constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {
      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>,
   is_constructible<_Tp, _Args..., _Alloc>>::value, "construction with"
   " an allocator must be possible if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;







  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : conditional<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>>::type { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };







  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };
# 156 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/uses_allocator.h" 3
  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      __uses_allocator_construct_impl(__use_alloc<_Tp, _Alloc, _Args...>(__a),
          __ptr, std::forward<_Args>(__args)...);
    }


}
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/tuple" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/invoke.h" 1 3
# 34 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/invoke.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{
# 52 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }


}
# 42 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/tuple" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;

  template<std::size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 176 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value
               && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_assignable<_Head>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 return *this;
      }

      template<typename _UHead>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
   return *this;
 }

      template<typename _UHead>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };



  template<bool, typename... _Elements>
  struct _TC
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, const _UElements&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return __and_<is_convertible<const _UElements&, _Elements>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, _UElements&&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return __and_<is_convertible<_UElements&&, _Elements>...>::value;
    }

    template<typename _SrcTuple>
    static constexpr bool _NonNestedTuple()
    {
      return __and_<__not_<is_same<tuple<_Elements...>,
                                   typename remove_cv<
                                     typename remove_reference<_SrcTuple>::type
                                   >::type>>,
                     __not_<is_convertible<_SrcTuple, _Elements...>>,
                     __not_<is_constructible<_Elements..., _SrcTuple>>
              >::value;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return __not_<is_same<tuple<_Elements...>,
        typename remove_const<
          typename remove_reference<_UElements...>::type
          >::type>>::value;
    }
  };

  template<typename... _Elements>
  struct _TC<false, _Elements...>
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _NonNestedTuple()
    {
      return true;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return true;
    }
  };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;



      template<typename _Dummy>
      struct _TC2
      {
        static constexpr bool _DefaultConstructibleTuple()
        {
          return __and_<is_default_constructible<_Elements>...>::value;
        }
        static constexpr bool _ImplicitlyDefaultConstructibleTuple()
        {
          return __and_<__is_implicitly_default_constructible<_Elements>...>
            ::value;
        }
      };

    public:
      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = true>
      constexpr tuple()
      : _Inherited() { }

      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _DefaultConstructibleTuple()
                                  &&
                                  !_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = false>
      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value,
            _Elements...>;

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=true>
        constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=false>
      explicit constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }



      template<typename... _UElements> using _TMC =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && (_TC<(sizeof...(_UElements)==1), _Elements...>::
     template _NotSameTuple<_UElements...>()),
                      _Elements...>;



      template<typename... _UElements> using _TMCT =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && !is_same<tuple<_Elements...>,
      tuple<_UElements...>>::value,
                      _Elements...>;

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=true>
        constexpr tuple(_UElements&&... __elements)
        : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=false>
        explicit constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;



      template<typename _Dummy> using _TNTC =
        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
            _Elements...>;

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=true>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=false>
        explicit constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
        explicit constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements>
 typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements), tuple&>::type
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements>
 typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements), tuple&>::type
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };
# 889 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/tuple" 3
  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }


      tuple() = default;

      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&) { }
      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&, const tuple&) { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr tuple()
      : _Inherited() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<
                  __and_<
                    is_default_constructible<_U1>,
                    is_default_constructible<_U2>,
                    __not_<
                      __and_<__is_implicitly_default_constructible<_U1>,
                             __is_implicitly_default_constructible<_U2>>>>
                  ::value, bool>::type = false>

      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value, _T1, _T2>;

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && _TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = true>
        constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && !_TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = false>
        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }



      using _TMC = _TC<true, _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<typename decay<_U1>::type,
         allocator_arg_t>::value,
 bool>::type = true>
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<typename decay<_U1>::type,
         allocator_arg_t>::value,
 bool>::type = false>
        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=false>

 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };



  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
# 1278 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/tuple" 3
  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };




  template<size_t __i>
    struct tuple_element<__i, tuple<>>
    {
      static_assert(__i < tuple_size<tuple<>>::value,
   "tuple index is in range");
    };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<const __element_type&&>(std::get<__i>(__t));
    }
# 1382 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/tuple" 3
  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }



  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline





    void

    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 1632 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/tuple" 3
  struct _Swallow_assign
  {
    template<class _Tp>
                           const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };



                    constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }
# 1712 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/tuple" 3
}
# 64 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{



  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class multimap;
# 98 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:
# 122 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      static_assert(is_same<typename _Alloc::value_type, value_type>::value,
   "std::map must have the same value_type as its allocator");


    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
# 183 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      map() = default;







      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 205 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      map(const map&) = default;







      map(map&&) = default;
# 226 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      map(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      explicit
      map(const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }


      map(const map& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }


      map(map&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }


      map(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      template<typename _InputIterator>
 map(_InputIterator __first, _InputIterator __last,
     const allocator_type& __a)
 : _M_t(_Compare(), _Pair_alloc_type(__a))
 { _M_t._M_insert_unique(__first, __last); }
# 270 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      template<typename _InputIterator>
 map(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_unique(__first, __last); }
# 287 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      template<typename _InputIterator>
 map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
 { _M_t._M_insert_unique(__first, __last); }







      ~map() = default;
# 316 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      map&
      operator=(const map&) = default;


      map&
      operator=(map&&) = default;
# 334 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      map&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_unique(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }






      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 489 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))

   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
         std::tuple<const key_type&>(__k),
         std::tuple<>());



 return (*__i).second;
      }


      mapped_type&
      operator[](key_type&& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
     std::forward_as_tuple(std::move(__k)),
     std::tuple<>());
 return (*__i).second;
      }
# 534 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 572 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
# 602 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_unique(__pos,
          std::forward<_Args>(__args)...);
 }
# 800 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }




      std::pair<iterator, bool>
      insert(value_type&& __x)
      { return _M_t._M_insert_unique(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair>::value,
        pair<iterator, bool>>
 insert(_Pair&& __x)
 { return _M_t._M_emplace_unique(std::forward<_Pair>(__x)); }
# 827 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      void
      insert(std::initializer_list<value_type> __list)
      { insert(__list.begin(), __list.end()); }
# 856 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_unique_(__position, __x); }




      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_unique_(__position, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
 insert(const_iterator __position, _Pair&& __x)
 {
   return _M_t._M_emplace_hint_unique(__position,
          std::forward<_Pair>(__x));
 }
# 889 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_unique(__first, __last); }
# 1029 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
# 1066 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 1086 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 1120 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      void
      swap(map& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 1167 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 1192 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 1213 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 1237 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 1262 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 1282 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }
# 1302 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 1331 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 1360 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }
# 1377 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 1432 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 1449 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
       const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
       const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 1515 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_map.h" 3
}
# 62 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/map" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 1 3
# 64 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class map;
# 96 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:
# 121 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      static_assert(is_same<typename _Alloc::value_type, value_type>::value,
   "std::multimap must have the same value_type as its allocator");


    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
# 180 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      multimap() = default;







      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 202 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      multimap(const multimap&) = default;
# 211 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      multimap(multimap&&) = default;
# 223 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      multimap(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      explicit
      multimap(const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }


      multimap(const multimap& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }


      multimap(multimap&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }


      multimap(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      template<typename _InputIterator>
 multimap(_InputIterator __first, _InputIterator __last,
   const allocator_type& __a)
 : _M_t(_Compare(), _Pair_alloc_type(__a))
 { _M_t._M_insert_equal(__first, __last); }
# 266 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      template<typename _InputIterator>
 multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_equal(__first, __last); }
# 282 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      template<typename _InputIterator>
 multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
 { _M_t._M_insert_equal(__first, __last); }







      ~multimap() = default;
# 311 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap&) = default;


      multimap&
      operator=(multimap&&) = default;
# 329 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_equal(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }




      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 487 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
# 514 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_equal(__pos,
         std::forward<_Args>(__args)...);
 }
# 536 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }




      iterator
      insert(value_type&& __x)
      { return _M_t._M_insert_equal(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
 insert(_Pair&& __x)
 { return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }
# 575 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_equal_(__position, __x); }




      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_equal_(__position, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __position, _Pair&& __x)
 {
   return _M_t._M_emplace_hint_equal(__position,
         std::forward<_Pair>(__x));
 }
# 609 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_equal(__first, __last); }
# 622 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 699 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
# 736 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 757 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 794 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 840 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 864 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 882 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 906 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 931 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 951 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }
# 971 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 998 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 1025 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }
# 1042 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 1096 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 1113 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
  multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 1179 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_multimap.h" 3
}
# 63 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/map" 2 3
# 9 "firmware/nnet_utils/nnet_helpers.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 1 3
# 36 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3





# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 152 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 153 "/usr/include/math.h" 2 3 4
# 163 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 204 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 205 "/usr/include/math.h" 2 3 4
# 247 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 248 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 312 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbit (double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinf (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnan (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) noexcept (true);


extern int __issignaling (double __value) noexcept (true)
     __attribute__ ((__const__));
# 313 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern double acos (double __x) noexcept (true); extern double __acos (double __x) noexcept (true);

 extern double asin (double __x) noexcept (true); extern double __asin (double __x) noexcept (true);

 extern double atan (double __x) noexcept (true); extern double __atan (double __x) noexcept (true);

 extern double atan2 (double __y, double __x) noexcept (true); extern double __atan2 (double __y, double __x) noexcept (true);


 extern double cos (double __x) noexcept (true); extern double __cos (double __x) noexcept (true);

 extern double sin (double __x) noexcept (true); extern double __sin (double __x) noexcept (true);

 extern double tan (double __x) noexcept (true); extern double __tan (double __x) noexcept (true);




 extern double cosh (double __x) noexcept (true); extern double __cosh (double __x) noexcept (true);

 extern double sinh (double __x) noexcept (true); extern double __sinh (double __x) noexcept (true);

 extern double tanh (double __x) noexcept (true); extern double __tanh (double __x) noexcept (true);



 extern void sincos (double __x, double *__sinx, double *__cosx) noexcept (true); extern void __sincos (double __x, double *__sinx, double *__cosx) noexcept (true);





 extern double acosh (double __x) noexcept (true); extern double __acosh (double __x) noexcept (true);

 extern double asinh (double __x) noexcept (true); extern double __asinh (double __x) noexcept (true);

 extern double atanh (double __x) noexcept (true); extern double __atanh (double __x) noexcept (true);





 extern double exp (double __x) noexcept (true); extern double __exp (double __x) noexcept (true);


extern double frexp (double __x, int *__exponent) noexcept (true); extern double __frexp (double __x, int *__exponent) noexcept (true);


extern double ldexp (double __x, int __exponent) noexcept (true); extern double __ldexp (double __x, int __exponent) noexcept (true);


 extern double log (double __x) noexcept (true); extern double __log (double __x) noexcept (true);


 extern double log10 (double __x) noexcept (true); extern double __log10 (double __x) noexcept (true);


extern double modf (double __x, double *__iptr) noexcept (true); extern double __modf (double __x, double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern double exp10 (double __x) noexcept (true); extern double __exp10 (double __x) noexcept (true);




 extern double expm1 (double __x) noexcept (true); extern double __expm1 (double __x) noexcept (true);


 extern double log1p (double __x) noexcept (true); extern double __log1p (double __x) noexcept (true);


extern double logb (double __x) noexcept (true); extern double __logb (double __x) noexcept (true);




 extern double exp2 (double __x) noexcept (true); extern double __exp2 (double __x) noexcept (true);


 extern double log2 (double __x) noexcept (true); extern double __log2 (double __x) noexcept (true);






 extern double pow (double __x, double __y) noexcept (true); extern double __pow (double __x, double __y) noexcept (true);


extern double sqrt (double __x) noexcept (true); extern double __sqrt (double __x) noexcept (true);



 extern double hypot (double __x, double __y) noexcept (true); extern double __hypot (double __x, double __y) noexcept (true);




 extern double cbrt (double __x) noexcept (true); extern double __cbrt (double __x) noexcept (true);






extern double ceil (double __x) noexcept (true) __attribute__ ((__const__)); extern double __ceil (double __x) noexcept (true) __attribute__ ((__const__));


extern double fabs (double __x) noexcept (true) __attribute__ ((__const__)); extern double __fabs (double __x) noexcept (true) __attribute__ ((__const__));


extern double floor (double __x) noexcept (true) __attribute__ ((__const__)); extern double __floor (double __x) noexcept (true) __attribute__ ((__const__));


extern double fmod (double __x, double __y) noexcept (true); extern double __fmod (double __x, double __y) noexcept (true);
# 183 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern double drem (double __x, double __y) noexcept (true); extern double __drem (double __x, double __y) noexcept (true);



extern double significand (double __x) noexcept (true); extern double __significand (double __x) noexcept (true);






extern double copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double nan (const char *__tagb) noexcept (true); extern double __nan (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) noexcept (true); extern double __j0 (double) noexcept (true);
extern double j1 (double) noexcept (true); extern double __j1 (double) noexcept (true);
extern double jn (int, double) noexcept (true); extern double __jn (int, double) noexcept (true);
extern double y0 (double) noexcept (true); extern double __y0 (double) noexcept (true);
extern double y1 (double) noexcept (true); extern double __y1 (double) noexcept (true);
extern double yn (int, double) noexcept (true); extern double __yn (int, double) noexcept (true);





 extern double erf (double) noexcept (true); extern double __erf (double) noexcept (true);
 extern double erfc (double) noexcept (true); extern double __erfc (double) noexcept (true);
extern double lgamma (double) noexcept (true); extern double __lgamma (double) noexcept (true);




extern double tgamma (double) noexcept (true); extern double __tgamma (double) noexcept (true);





extern double gamma (double) noexcept (true); extern double __gamma (double) noexcept (true);







extern double lgamma_r (double, int *__signgamp) noexcept (true); extern double __lgamma_r (double, int *__signgamp) noexcept (true);






extern double rint (double __x) noexcept (true); extern double __rint (double __x) noexcept (true);


extern double nextafter (double __x, double __y) noexcept (true); extern double __nextafter (double __x, double __y) noexcept (true);

extern double nexttoward (double __x, long double __y) noexcept (true); extern double __nexttoward (double __x, long double __y) noexcept (true);




extern double nextdown (double __x) noexcept (true); extern double __nextdown (double __x) noexcept (true);

extern double nextup (double __x) noexcept (true); extern double __nextup (double __x) noexcept (true);



extern double remainder (double __x, double __y) noexcept (true); extern double __remainder (double __x, double __y) noexcept (true);



extern double scalbn (double __x, int __n) noexcept (true); extern double __scalbn (double __x, int __n) noexcept (true);



extern int ilogb (double __x) noexcept (true); extern int __ilogb (double __x) noexcept (true);




extern long int llogb (double __x) noexcept (true); extern long int __llogb (double __x) noexcept (true);




extern double scalbln (double __x, long int __n) noexcept (true); extern double __scalbln (double __x, long int __n) noexcept (true);



extern double nearbyint (double __x) noexcept (true); extern double __nearbyint (double __x) noexcept (true);



extern double round (double __x) noexcept (true) __attribute__ ((__const__)); extern double __round (double __x) noexcept (true) __attribute__ ((__const__));



extern double trunc (double __x) noexcept (true) __attribute__ ((__const__)); extern double __trunc (double __x) noexcept (true) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) noexcept (true); extern double __remquo (double __x, double __y, int *__quo) noexcept (true);






extern long int lrint (double __x) noexcept (true); extern long int __lrint (double __x) noexcept (true);
__extension__
extern long long int llrint (double __x) noexcept (true); extern long long int __llrint (double __x) noexcept (true);



extern long int lround (double __x) noexcept (true); extern long int __lround (double __x) noexcept (true);
__extension__
extern long long int llround (double __x) noexcept (true); extern long long int __llround (double __x) noexcept (true);



extern double fdim (double __x, double __y) noexcept (true); extern double __fdim (double __x, double __y) noexcept (true);



extern double fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) noexcept (true); extern double __fma (double __x, double __y, double __z) noexcept (true);




extern double roundeven (double __x) noexcept (true) __attribute__ ((__const__)); extern double __roundeven (double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalize (double *__cx, const double *__x) noexcept (true);






extern double fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorder (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) noexcept (true); extern double __getpayload (const double *__x) noexcept (true);


extern int setpayload (double *__x, double __payload) noexcept (true);


extern int setpayloadsig (double *__x, double __payload) noexcept (true);







extern double scalb (double __x, double __n) noexcept (true); extern double __scalb (double __x, double __n) noexcept (true);
# 314 "/usr/include/math.h" 2 3 4
# 329 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf (float __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) noexcept (true);


extern int __issignalingf (float __value) noexcept (true)
     __attribute__ ((__const__));
# 330 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern float acosf (float __x) noexcept (true); extern float __acosf (float __x) noexcept (true);

 extern float asinf (float __x) noexcept (true); extern float __asinf (float __x) noexcept (true);

 extern float atanf (float __x) noexcept (true); extern float __atanf (float __x) noexcept (true);

 extern float atan2f (float __y, float __x) noexcept (true); extern float __atan2f (float __y, float __x) noexcept (true);


 extern float cosf (float __x) noexcept (true); extern float __cosf (float __x) noexcept (true);

 extern float sinf (float __x) noexcept (true); extern float __sinf (float __x) noexcept (true);

 extern float tanf (float __x) noexcept (true); extern float __tanf (float __x) noexcept (true);




 extern float coshf (float __x) noexcept (true); extern float __coshf (float __x) noexcept (true);

 extern float sinhf (float __x) noexcept (true); extern float __sinhf (float __x) noexcept (true);

 extern float tanhf (float __x) noexcept (true); extern float __tanhf (float __x) noexcept (true);



 extern void sincosf (float __x, float *__sinx, float *__cosx) noexcept (true); extern void __sincosf (float __x, float *__sinx, float *__cosx) noexcept (true);





 extern float acoshf (float __x) noexcept (true); extern float __acoshf (float __x) noexcept (true);

 extern float asinhf (float __x) noexcept (true); extern float __asinhf (float __x) noexcept (true);

 extern float atanhf (float __x) noexcept (true); extern float __atanhf (float __x) noexcept (true);





 extern float expf (float __x) noexcept (true); extern float __expf (float __x) noexcept (true);


extern float frexpf (float __x, int *__exponent) noexcept (true); extern float __frexpf (float __x, int *__exponent) noexcept (true);


extern float ldexpf (float __x, int __exponent) noexcept (true); extern float __ldexpf (float __x, int __exponent) noexcept (true);


 extern float logf (float __x) noexcept (true); extern float __logf (float __x) noexcept (true);


 extern float log10f (float __x) noexcept (true); extern float __log10f (float __x) noexcept (true);


extern float modff (float __x, float *__iptr) noexcept (true); extern float __modff (float __x, float *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern float exp10f (float __x) noexcept (true); extern float __exp10f (float __x) noexcept (true);




 extern float expm1f (float __x) noexcept (true); extern float __expm1f (float __x) noexcept (true);


 extern float log1pf (float __x) noexcept (true); extern float __log1pf (float __x) noexcept (true);


extern float logbf (float __x) noexcept (true); extern float __logbf (float __x) noexcept (true);




 extern float exp2f (float __x) noexcept (true); extern float __exp2f (float __x) noexcept (true);


 extern float log2f (float __x) noexcept (true); extern float __log2f (float __x) noexcept (true);






 extern float powf (float __x, float __y) noexcept (true); extern float __powf (float __x, float __y) noexcept (true);


extern float sqrtf (float __x) noexcept (true); extern float __sqrtf (float __x) noexcept (true);



 extern float hypotf (float __x, float __y) noexcept (true); extern float __hypotf (float __x, float __y) noexcept (true);




 extern float cbrtf (float __x) noexcept (true); extern float __cbrtf (float __x) noexcept (true);






extern float ceilf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __ceilf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fabsf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __fabsf (float __x) noexcept (true) __attribute__ ((__const__));


extern float floorf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __floorf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) noexcept (true); extern float __fmodf (float __x, float __y) noexcept (true);
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) noexcept (true); extern float __dremf (float __x, float __y) noexcept (true);



extern float significandf (float __x) noexcept (true); extern float __significandf (float __x) noexcept (true);






extern float copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float nanf (const char *__tagb) noexcept (true); extern float __nanf (const char *__tagb) noexcept (true);
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));





extern float j0f (float) noexcept (true); extern float __j0f (float) noexcept (true);
extern float j1f (float) noexcept (true); extern float __j1f (float) noexcept (true);
extern float jnf (int, float) noexcept (true); extern float __jnf (int, float) noexcept (true);
extern float y0f (float) noexcept (true); extern float __y0f (float) noexcept (true);
extern float y1f (float) noexcept (true); extern float __y1f (float) noexcept (true);
extern float ynf (int, float) noexcept (true); extern float __ynf (int, float) noexcept (true);





 extern float erff (float) noexcept (true); extern float __erff (float) noexcept (true);
 extern float erfcf (float) noexcept (true); extern float __erfcf (float) noexcept (true);
extern float lgammaf (float) noexcept (true); extern float __lgammaf (float) noexcept (true);




extern float tgammaf (float) noexcept (true); extern float __tgammaf (float) noexcept (true);





extern float gammaf (float) noexcept (true); extern float __gammaf (float) noexcept (true);







extern float lgammaf_r (float, int *__signgamp) noexcept (true); extern float __lgammaf_r (float, int *__signgamp) noexcept (true);






extern float rintf (float __x) noexcept (true); extern float __rintf (float __x) noexcept (true);


extern float nextafterf (float __x, float __y) noexcept (true); extern float __nextafterf (float __x, float __y) noexcept (true);

extern float nexttowardf (float __x, long double __y) noexcept (true); extern float __nexttowardf (float __x, long double __y) noexcept (true);




extern float nextdownf (float __x) noexcept (true); extern float __nextdownf (float __x) noexcept (true);

extern float nextupf (float __x) noexcept (true); extern float __nextupf (float __x) noexcept (true);



extern float remainderf (float __x, float __y) noexcept (true); extern float __remainderf (float __x, float __y) noexcept (true);



extern float scalbnf (float __x, int __n) noexcept (true); extern float __scalbnf (float __x, int __n) noexcept (true);



extern int ilogbf (float __x) noexcept (true); extern int __ilogbf (float __x) noexcept (true);




extern long int llogbf (float __x) noexcept (true); extern long int __llogbf (float __x) noexcept (true);




extern float scalblnf (float __x, long int __n) noexcept (true); extern float __scalblnf (float __x, long int __n) noexcept (true);



extern float nearbyintf (float __x) noexcept (true); extern float __nearbyintf (float __x) noexcept (true);



extern float roundf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundf (float __x) noexcept (true) __attribute__ ((__const__));



extern float truncf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __truncf (float __x) noexcept (true) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) noexcept (true); extern float __remquof (float __x, float __y, int *__quo) noexcept (true);






extern long int lrintf (float __x) noexcept (true); extern long int __lrintf (float __x) noexcept (true);
__extension__
extern long long int llrintf (float __x) noexcept (true); extern long long int __llrintf (float __x) noexcept (true);



extern long int lroundf (float __x) noexcept (true); extern long int __lroundf (float __x) noexcept (true);
__extension__
extern long long int llroundf (float __x) noexcept (true); extern long long int __llroundf (float __x) noexcept (true);



extern float fdimf (float __x, float __y) noexcept (true); extern float __fdimf (float __x, float __y) noexcept (true);



extern float fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) noexcept (true); extern float __fmaf (float __x, float __y, float __z) noexcept (true);




extern float roundevenf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundevenf (float __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef (float *__cx, const float *__x) noexcept (true);






extern float fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) noexcept (true); extern float __getpayloadf (const float *__x) noexcept (true);


extern int setpayloadf (float *__x, float __payload) noexcept (true);


extern int setpayloadsigf (float *__x, float __payload) noexcept (true);







extern float scalbf (float __x, float __n) noexcept (true); extern float __scalbf (float __x, float __n) noexcept (true);
# 331 "/usr/include/math.h" 2 3 4
# 398 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitl (long double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) noexcept (true);


extern int __issignalingl (long double __value) noexcept (true)
     __attribute__ ((__const__));
# 399 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern long double acosl (long double __x) noexcept (true); extern long double __acosl (long double __x) noexcept (true);

 extern long double asinl (long double __x) noexcept (true); extern long double __asinl (long double __x) noexcept (true);

 extern long double atanl (long double __x) noexcept (true); extern long double __atanl (long double __x) noexcept (true);

 extern long double atan2l (long double __y, long double __x) noexcept (true); extern long double __atan2l (long double __y, long double __x) noexcept (true);


 extern long double cosl (long double __x) noexcept (true); extern long double __cosl (long double __x) noexcept (true);

 extern long double sinl (long double __x) noexcept (true); extern long double __sinl (long double __x) noexcept (true);

 extern long double tanl (long double __x) noexcept (true); extern long double __tanl (long double __x) noexcept (true);




 extern long double coshl (long double __x) noexcept (true); extern long double __coshl (long double __x) noexcept (true);

 extern long double sinhl (long double __x) noexcept (true); extern long double __sinhl (long double __x) noexcept (true);

 extern long double tanhl (long double __x) noexcept (true); extern long double __tanhl (long double __x) noexcept (true);



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true);





 extern long double acoshl (long double __x) noexcept (true); extern long double __acoshl (long double __x) noexcept (true);

 extern long double asinhl (long double __x) noexcept (true); extern long double __asinhl (long double __x) noexcept (true);

 extern long double atanhl (long double __x) noexcept (true); extern long double __atanhl (long double __x) noexcept (true);





 extern long double expl (long double __x) noexcept (true); extern long double __expl (long double __x) noexcept (true);


extern long double frexpl (long double __x, int *__exponent) noexcept (true); extern long double __frexpl (long double __x, int *__exponent) noexcept (true);


extern long double ldexpl (long double __x, int __exponent) noexcept (true); extern long double __ldexpl (long double __x, int __exponent) noexcept (true);


 extern long double logl (long double __x) noexcept (true); extern long double __logl (long double __x) noexcept (true);


 extern long double log10l (long double __x) noexcept (true); extern long double __log10l (long double __x) noexcept (true);


extern long double modfl (long double __x, long double *__iptr) noexcept (true); extern long double __modfl (long double __x, long double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern long double exp10l (long double __x) noexcept (true); extern long double __exp10l (long double __x) noexcept (true);




 extern long double expm1l (long double __x) noexcept (true); extern long double __expm1l (long double __x) noexcept (true);


 extern long double log1pl (long double __x) noexcept (true); extern long double __log1pl (long double __x) noexcept (true);


extern long double logbl (long double __x) noexcept (true); extern long double __logbl (long double __x) noexcept (true);




 extern long double exp2l (long double __x) noexcept (true); extern long double __exp2l (long double __x) noexcept (true);


 extern long double log2l (long double __x) noexcept (true); extern long double __log2l (long double __x) noexcept (true);






 extern long double powl (long double __x, long double __y) noexcept (true); extern long double __powl (long double __x, long double __y) noexcept (true);


extern long double sqrtl (long double __x) noexcept (true); extern long double __sqrtl (long double __x) noexcept (true);



 extern long double hypotl (long double __x, long double __y) noexcept (true); extern long double __hypotl (long double __x, long double __y) noexcept (true);




 extern long double cbrtl (long double __x) noexcept (true); extern long double __cbrtl (long double __x) noexcept (true);






extern long double ceill (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __ceill (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fabsl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __fabsl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double floorl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __floorl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) noexcept (true); extern long double __fmodl (long double __x, long double __y) noexcept (true);
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) noexcept (true); extern long double __dreml (long double __x, long double __y) noexcept (true);



extern long double significandl (long double __x) noexcept (true); extern long double __significandl (long double __x) noexcept (true);






extern long double copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) noexcept (true); extern long double __nanl (const char *__tagb) noexcept (true);
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));





extern long double j0l (long double) noexcept (true); extern long double __j0l (long double) noexcept (true);
extern long double j1l (long double) noexcept (true); extern long double __j1l (long double) noexcept (true);
extern long double jnl (int, long double) noexcept (true); extern long double __jnl (int, long double) noexcept (true);
extern long double y0l (long double) noexcept (true); extern long double __y0l (long double) noexcept (true);
extern long double y1l (long double) noexcept (true); extern long double __y1l (long double) noexcept (true);
extern long double ynl (int, long double) noexcept (true); extern long double __ynl (int, long double) noexcept (true);





 extern long double erfl (long double) noexcept (true); extern long double __erfl (long double) noexcept (true);
 extern long double erfcl (long double) noexcept (true); extern long double __erfcl (long double) noexcept (true);
extern long double lgammal (long double) noexcept (true); extern long double __lgammal (long double) noexcept (true);




extern long double tgammal (long double) noexcept (true); extern long double __tgammal (long double) noexcept (true);





extern long double gammal (long double) noexcept (true); extern long double __gammal (long double) noexcept (true);







extern long double lgammal_r (long double, int *__signgamp) noexcept (true); extern long double __lgammal_r (long double, int *__signgamp) noexcept (true);






extern long double rintl (long double __x) noexcept (true); extern long double __rintl (long double __x) noexcept (true);


extern long double nextafterl (long double __x, long double __y) noexcept (true); extern long double __nextafterl (long double __x, long double __y) noexcept (true);

extern long double nexttowardl (long double __x, long double __y) noexcept (true); extern long double __nexttowardl (long double __x, long double __y) noexcept (true);




extern long double nextdownl (long double __x) noexcept (true); extern long double __nextdownl (long double __x) noexcept (true);

extern long double nextupl (long double __x) noexcept (true); extern long double __nextupl (long double __x) noexcept (true);



extern long double remainderl (long double __x, long double __y) noexcept (true); extern long double __remainderl (long double __x, long double __y) noexcept (true);



extern long double scalbnl (long double __x, int __n) noexcept (true); extern long double __scalbnl (long double __x, int __n) noexcept (true);



extern int ilogbl (long double __x) noexcept (true); extern int __ilogbl (long double __x) noexcept (true);




extern long int llogbl (long double __x) noexcept (true); extern long int __llogbl (long double __x) noexcept (true);




extern long double scalblnl (long double __x, long int __n) noexcept (true); extern long double __scalblnl (long double __x, long int __n) noexcept (true);



extern long double nearbyintl (long double __x) noexcept (true); extern long double __nearbyintl (long double __x) noexcept (true);



extern long double roundl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundl (long double __x) noexcept (true) __attribute__ ((__const__));



extern long double truncl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __truncl (long double __x) noexcept (true) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) noexcept (true); extern long double __remquol (long double __x, long double __y, int *__quo) noexcept (true);






extern long int lrintl (long double __x) noexcept (true); extern long int __lrintl (long double __x) noexcept (true);
__extension__
extern long long int llrintl (long double __x) noexcept (true); extern long long int __llrintl (long double __x) noexcept (true);



extern long int lroundl (long double __x) noexcept (true); extern long int __lroundl (long double __x) noexcept (true);
__extension__
extern long long int llroundl (long double __x) noexcept (true); extern long long int __llroundl (long double __x) noexcept (true);



extern long double fdiml (long double __x, long double __y) noexcept (true); extern long double __fdiml (long double __x, long double __y) noexcept (true);



extern long double fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) noexcept (true); extern long double __fmal (long double __x, long double __y, long double __z) noexcept (true);




extern long double roundevenl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundevenl (long double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizel (long double *__cx, const long double *__x) noexcept (true);






extern long double fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) noexcept (true); extern long double __getpayloadl (const long double *__x) noexcept (true);


extern int setpayloadl (long double *__x, long double __payload) noexcept (true);


extern int setpayloadsigl (long double *__x, long double __payload) noexcept (true);







extern long double scalbl (long double __x, long double __n) noexcept (true); extern long double __scalbl (long double __x, long double __n) noexcept (true);
# 400 "/usr/include/math.h" 2 3 4
# 450 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32 acosf32 (_Float32 __x) noexcept (true); extern _Float32 __acosf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinf32 (_Float32 __x) noexcept (true); extern _Float32 __asinf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanf32 (_Float32 __x) noexcept (true); extern _Float32 __atanf32 (_Float32 __x) noexcept (true);

 extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) noexcept (true); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) noexcept (true);


 extern _Float32 cosf32 (_Float32 __x) noexcept (true); extern _Float32 __cosf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinf32 (_Float32 __x) noexcept (true); extern _Float32 __sinf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanf32 (_Float32 __x) noexcept (true); extern _Float32 __tanf32 (_Float32 __x) noexcept (true);




 extern _Float32 coshf32 (_Float32 __x) noexcept (true); extern _Float32 __coshf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinhf32 (_Float32 __x) noexcept (true); extern _Float32 __sinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanhf32 (_Float32 __x) noexcept (true); extern _Float32 __tanhf32 (_Float32 __x) noexcept (true);



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true);





 extern _Float32 acoshf32 (_Float32 __x) noexcept (true); extern _Float32 __acoshf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinhf32 (_Float32 __x) noexcept (true); extern _Float32 __asinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanhf32 (_Float32 __x) noexcept (true); extern _Float32 __atanhf32 (_Float32 __x) noexcept (true);





 extern _Float32 expf32 (_Float32 __x) noexcept (true); extern _Float32 __expf32 (_Float32 __x) noexcept (true);


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) noexcept (true); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) noexcept (true);


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) noexcept (true); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) noexcept (true);


 extern _Float32 logf32 (_Float32 __x) noexcept (true); extern _Float32 __logf32 (_Float32 __x) noexcept (true);


 extern _Float32 log10f32 (_Float32 __x) noexcept (true); extern _Float32 __log10f32 (_Float32 __x) noexcept (true);


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32 exp10f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10f32 (_Float32 __x) noexcept (true);




 extern _Float32 expm1f32 (_Float32 __x) noexcept (true); extern _Float32 __expm1f32 (_Float32 __x) noexcept (true);


 extern _Float32 log1pf32 (_Float32 __x) noexcept (true); extern _Float32 __log1pf32 (_Float32 __x) noexcept (true);


extern _Float32 logbf32 (_Float32 __x) noexcept (true); extern _Float32 __logbf32 (_Float32 __x) noexcept (true);




 extern _Float32 exp2f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2f32 (_Float32 __x) noexcept (true);


 extern _Float32 log2f32 (_Float32 __x) noexcept (true); extern _Float32 __log2f32 (_Float32 __x) noexcept (true);






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) noexcept (true);


extern _Float32 sqrtf32 (_Float32 __x) noexcept (true); extern _Float32 __sqrtf32 (_Float32 __x) noexcept (true);



 extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) noexcept (true);




 extern _Float32 cbrtf32 (_Float32 __x) noexcept (true); extern _Float32 __cbrtf32 (_Float32 __x) noexcept (true);






extern _Float32 ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) noexcept (true); extern _Float32 __nanf32 (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) noexcept (true); extern _Float32 __j0f32 (_Float32) noexcept (true);
extern _Float32 j1f32 (_Float32) noexcept (true); extern _Float32 __j1f32 (_Float32) noexcept (true);
extern _Float32 jnf32 (int, _Float32) noexcept (true); extern _Float32 __jnf32 (int, _Float32) noexcept (true);
extern _Float32 y0f32 (_Float32) noexcept (true); extern _Float32 __y0f32 (_Float32) noexcept (true);
extern _Float32 y1f32 (_Float32) noexcept (true); extern _Float32 __y1f32 (_Float32) noexcept (true);
extern _Float32 ynf32 (int, _Float32) noexcept (true); extern _Float32 __ynf32 (int, _Float32) noexcept (true);





 extern _Float32 erff32 (_Float32) noexcept (true); extern _Float32 __erff32 (_Float32) noexcept (true);
 extern _Float32 erfcf32 (_Float32) noexcept (true); extern _Float32 __erfcf32 (_Float32) noexcept (true);
extern _Float32 lgammaf32 (_Float32) noexcept (true); extern _Float32 __lgammaf32 (_Float32) noexcept (true);




extern _Float32 tgammaf32 (_Float32) noexcept (true); extern _Float32 __tgammaf32 (_Float32) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) noexcept (true); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) noexcept (true);






extern _Float32 rintf32 (_Float32 __x) noexcept (true); extern _Float32 __rintf32 (_Float32 __x) noexcept (true);


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true);






extern _Float32 nextdownf32 (_Float32 __x) noexcept (true); extern _Float32 __nextdownf32 (_Float32 __x) noexcept (true);

extern _Float32 nextupf32 (_Float32 __x) noexcept (true); extern _Float32 __nextupf32 (_Float32 __x) noexcept (true);



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 scalbnf32 (_Float32 __x, int __n) noexcept (true); extern _Float32 __scalbnf32 (_Float32 __x, int __n) noexcept (true);



extern int ilogbf32 (_Float32 __x) noexcept (true); extern int __ilogbf32 (_Float32 __x) noexcept (true);




extern long int llogbf32 (_Float32 __x) noexcept (true); extern long int __llogbf32 (_Float32 __x) noexcept (true);




extern _Float32 scalblnf32 (_Float32 __x, long int __n) noexcept (true); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) noexcept (true);



extern _Float32 nearbyintf32 (_Float32 __x) noexcept (true); extern _Float32 __nearbyintf32 (_Float32 __x) noexcept (true);



extern _Float32 roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true);






extern long int lrintf32 (_Float32 __x) noexcept (true); extern long int __lrintf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llrintf32 (_Float32 __x) noexcept (true); extern long long int __llrintf32 (_Float32 __x) noexcept (true);



extern long int lroundf32 (_Float32 __x) noexcept (true); extern long int __lroundf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llroundf32 (_Float32 __x) noexcept (true); extern long long int __llroundf32 (_Float32 __x) noexcept (true);



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));



extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true);




extern _Float32 roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) noexcept (true);






extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) noexcept (true); extern _Float32 __getpayloadf32 (const _Float32 *__x) noexcept (true);


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) noexcept (true);


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) noexcept (true);
# 451 "/usr/include/math.h" 2 3 4
# 467 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64 acosf64 (_Float64 __x) noexcept (true); extern _Float64 __acosf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinf64 (_Float64 __x) noexcept (true); extern _Float64 __asinf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanf64 (_Float64 __x) noexcept (true); extern _Float64 __atanf64 (_Float64 __x) noexcept (true);

 extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) noexcept (true); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) noexcept (true);


 extern _Float64 cosf64 (_Float64 __x) noexcept (true); extern _Float64 __cosf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinf64 (_Float64 __x) noexcept (true); extern _Float64 __sinf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanf64 (_Float64 __x) noexcept (true); extern _Float64 __tanf64 (_Float64 __x) noexcept (true);




 extern _Float64 coshf64 (_Float64 __x) noexcept (true); extern _Float64 __coshf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinhf64 (_Float64 __x) noexcept (true); extern _Float64 __sinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanhf64 (_Float64 __x) noexcept (true); extern _Float64 __tanhf64 (_Float64 __x) noexcept (true);



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true);





 extern _Float64 acoshf64 (_Float64 __x) noexcept (true); extern _Float64 __acoshf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinhf64 (_Float64 __x) noexcept (true); extern _Float64 __asinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanhf64 (_Float64 __x) noexcept (true); extern _Float64 __atanhf64 (_Float64 __x) noexcept (true);





 extern _Float64 expf64 (_Float64 __x) noexcept (true); extern _Float64 __expf64 (_Float64 __x) noexcept (true);


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) noexcept (true); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) noexcept (true);


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) noexcept (true); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) noexcept (true);


 extern _Float64 logf64 (_Float64 __x) noexcept (true); extern _Float64 __logf64 (_Float64 __x) noexcept (true);


 extern _Float64 log10f64 (_Float64 __x) noexcept (true); extern _Float64 __log10f64 (_Float64 __x) noexcept (true);


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64 exp10f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10f64 (_Float64 __x) noexcept (true);




 extern _Float64 expm1f64 (_Float64 __x) noexcept (true); extern _Float64 __expm1f64 (_Float64 __x) noexcept (true);


 extern _Float64 log1pf64 (_Float64 __x) noexcept (true); extern _Float64 __log1pf64 (_Float64 __x) noexcept (true);


extern _Float64 logbf64 (_Float64 __x) noexcept (true); extern _Float64 __logbf64 (_Float64 __x) noexcept (true);




 extern _Float64 exp2f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2f64 (_Float64 __x) noexcept (true);


 extern _Float64 log2f64 (_Float64 __x) noexcept (true); extern _Float64 __log2f64 (_Float64 __x) noexcept (true);






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float64 sqrtf64 (_Float64 __x) noexcept (true); extern _Float64 __sqrtf64 (_Float64 __x) noexcept (true);



 extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) noexcept (true);




 extern _Float64 cbrtf64 (_Float64 __x) noexcept (true); extern _Float64 __cbrtf64 (_Float64 __x) noexcept (true);






extern _Float64 ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) noexcept (true); extern _Float64 __nanf64 (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) noexcept (true); extern _Float64 __j0f64 (_Float64) noexcept (true);
extern _Float64 j1f64 (_Float64) noexcept (true); extern _Float64 __j1f64 (_Float64) noexcept (true);
extern _Float64 jnf64 (int, _Float64) noexcept (true); extern _Float64 __jnf64 (int, _Float64) noexcept (true);
extern _Float64 y0f64 (_Float64) noexcept (true); extern _Float64 __y0f64 (_Float64) noexcept (true);
extern _Float64 y1f64 (_Float64) noexcept (true); extern _Float64 __y1f64 (_Float64) noexcept (true);
extern _Float64 ynf64 (int, _Float64) noexcept (true); extern _Float64 __ynf64 (int, _Float64) noexcept (true);





 extern _Float64 erff64 (_Float64) noexcept (true); extern _Float64 __erff64 (_Float64) noexcept (true);
 extern _Float64 erfcf64 (_Float64) noexcept (true); extern _Float64 __erfcf64 (_Float64) noexcept (true);
extern _Float64 lgammaf64 (_Float64) noexcept (true); extern _Float64 __lgammaf64 (_Float64) noexcept (true);




extern _Float64 tgammaf64 (_Float64) noexcept (true); extern _Float64 __tgammaf64 (_Float64) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) noexcept (true); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) noexcept (true);






extern _Float64 rintf64 (_Float64 __x) noexcept (true); extern _Float64 __rintf64 (_Float64 __x) noexcept (true);


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true);






extern _Float64 nextdownf64 (_Float64 __x) noexcept (true); extern _Float64 __nextdownf64 (_Float64 __x) noexcept (true);

extern _Float64 nextupf64 (_Float64 __x) noexcept (true); extern _Float64 __nextupf64 (_Float64 __x) noexcept (true);



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 scalbnf64 (_Float64 __x, int __n) noexcept (true); extern _Float64 __scalbnf64 (_Float64 __x, int __n) noexcept (true);



extern int ilogbf64 (_Float64 __x) noexcept (true); extern int __ilogbf64 (_Float64 __x) noexcept (true);




extern long int llogbf64 (_Float64 __x) noexcept (true); extern long int __llogbf64 (_Float64 __x) noexcept (true);




extern _Float64 scalblnf64 (_Float64 __x, long int __n) noexcept (true); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) noexcept (true);



extern _Float64 nearbyintf64 (_Float64 __x) noexcept (true); extern _Float64 __nearbyintf64 (_Float64 __x) noexcept (true);



extern _Float64 roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true);






extern long int lrintf64 (_Float64 __x) noexcept (true); extern long int __lrintf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llrintf64 (_Float64 __x) noexcept (true); extern long long int __llrintf64 (_Float64 __x) noexcept (true);



extern long int lroundf64 (_Float64 __x) noexcept (true); extern long int __lroundf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llroundf64 (_Float64 __x) noexcept (true); extern long long int __llroundf64 (_Float64 __x) noexcept (true);



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));



extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);




extern _Float64 roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) noexcept (true);






extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) noexcept (true); extern _Float64 __getpayloadf64 (const _Float64 *__x) noexcept (true);


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) noexcept (true);


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) noexcept (true);
# 468 "/usr/include/math.h" 2 3 4
# 501 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32x acosf32x (_Float32x __x) noexcept (true); extern _Float32x __acosf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinf32x (_Float32x __x) noexcept (true); extern _Float32x __asinf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanf32x (_Float32x __x) noexcept (true); extern _Float32x __atanf32x (_Float32x __x) noexcept (true);

 extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) noexcept (true); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) noexcept (true);


 extern _Float32x cosf32x (_Float32x __x) noexcept (true); extern _Float32x __cosf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinf32x (_Float32x __x) noexcept (true); extern _Float32x __sinf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanf32x (_Float32x __x) noexcept (true); extern _Float32x __tanf32x (_Float32x __x) noexcept (true);




 extern _Float32x coshf32x (_Float32x __x) noexcept (true); extern _Float32x __coshf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinhf32x (_Float32x __x) noexcept (true); extern _Float32x __sinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanhf32x (_Float32x __x) noexcept (true); extern _Float32x __tanhf32x (_Float32x __x) noexcept (true);



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true);





 extern _Float32x acoshf32x (_Float32x __x) noexcept (true); extern _Float32x __acoshf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinhf32x (_Float32x __x) noexcept (true); extern _Float32x __asinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanhf32x (_Float32x __x) noexcept (true); extern _Float32x __atanhf32x (_Float32x __x) noexcept (true);





 extern _Float32x expf32x (_Float32x __x) noexcept (true); extern _Float32x __expf32x (_Float32x __x) noexcept (true);


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) noexcept (true); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) noexcept (true);


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) noexcept (true); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) noexcept (true);


 extern _Float32x logf32x (_Float32x __x) noexcept (true); extern _Float32x __logf32x (_Float32x __x) noexcept (true);


 extern _Float32x log10f32x (_Float32x __x) noexcept (true); extern _Float32x __log10f32x (_Float32x __x) noexcept (true);


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32x exp10f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10f32x (_Float32x __x) noexcept (true);




 extern _Float32x expm1f32x (_Float32x __x) noexcept (true); extern _Float32x __expm1f32x (_Float32x __x) noexcept (true);


 extern _Float32x log1pf32x (_Float32x __x) noexcept (true); extern _Float32x __log1pf32x (_Float32x __x) noexcept (true);


extern _Float32x logbf32x (_Float32x __x) noexcept (true); extern _Float32x __logbf32x (_Float32x __x) noexcept (true);




 extern _Float32x exp2f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2f32x (_Float32x __x) noexcept (true);


 extern _Float32x log2f32x (_Float32x __x) noexcept (true); extern _Float32x __log2f32x (_Float32x __x) noexcept (true);






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32x sqrtf32x (_Float32x __x) noexcept (true); extern _Float32x __sqrtf32x (_Float32x __x) noexcept (true);



 extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) noexcept (true);




 extern _Float32x cbrtf32x (_Float32x __x) noexcept (true); extern _Float32x __cbrtf32x (_Float32x __x) noexcept (true);






extern _Float32x ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) noexcept (true); extern _Float32x __nanf32x (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) noexcept (true); extern _Float32x __j0f32x (_Float32x) noexcept (true);
extern _Float32x j1f32x (_Float32x) noexcept (true); extern _Float32x __j1f32x (_Float32x) noexcept (true);
extern _Float32x jnf32x (int, _Float32x) noexcept (true); extern _Float32x __jnf32x (int, _Float32x) noexcept (true);
extern _Float32x y0f32x (_Float32x) noexcept (true); extern _Float32x __y0f32x (_Float32x) noexcept (true);
extern _Float32x y1f32x (_Float32x) noexcept (true); extern _Float32x __y1f32x (_Float32x) noexcept (true);
extern _Float32x ynf32x (int, _Float32x) noexcept (true); extern _Float32x __ynf32x (int, _Float32x) noexcept (true);





 extern _Float32x erff32x (_Float32x) noexcept (true); extern _Float32x __erff32x (_Float32x) noexcept (true);
 extern _Float32x erfcf32x (_Float32x) noexcept (true); extern _Float32x __erfcf32x (_Float32x) noexcept (true);
extern _Float32x lgammaf32x (_Float32x) noexcept (true); extern _Float32x __lgammaf32x (_Float32x) noexcept (true);




extern _Float32x tgammaf32x (_Float32x) noexcept (true); extern _Float32x __tgammaf32x (_Float32x) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true);






extern _Float32x rintf32x (_Float32x __x) noexcept (true); extern _Float32x __rintf32x (_Float32x __x) noexcept (true);


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true);






extern _Float32x nextdownf32x (_Float32x __x) noexcept (true); extern _Float32x __nextdownf32x (_Float32x __x) noexcept (true);

extern _Float32x nextupf32x (_Float32x __x) noexcept (true); extern _Float32x __nextupf32x (_Float32x __x) noexcept (true);



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x scalbnf32x (_Float32x __x, int __n) noexcept (true); extern _Float32x __scalbnf32x (_Float32x __x, int __n) noexcept (true);



extern int ilogbf32x (_Float32x __x) noexcept (true); extern int __ilogbf32x (_Float32x __x) noexcept (true);




extern long int llogbf32x (_Float32x __x) noexcept (true); extern long int __llogbf32x (_Float32x __x) noexcept (true);




extern _Float32x scalblnf32x (_Float32x __x, long int __n) noexcept (true); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) noexcept (true);



extern _Float32x nearbyintf32x (_Float32x __x) noexcept (true); extern _Float32x __nearbyintf32x (_Float32x __x) noexcept (true);



extern _Float32x roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true);






extern long int lrintf32x (_Float32x __x) noexcept (true); extern long int __lrintf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llrintf32x (_Float32x __x) noexcept (true); extern long long int __llrintf32x (_Float32x __x) noexcept (true);



extern long int lroundf32x (_Float32x __x) noexcept (true); extern long int __lroundf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llroundf32x (_Float32x __x) noexcept (true); extern long long int __llroundf32x (_Float32x __x) noexcept (true);



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));



extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);




extern _Float32x roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) noexcept (true);






extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) noexcept (true); extern _Float32x __getpayloadf32x (const _Float32x *__x) noexcept (true);


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) noexcept (true);


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) noexcept (true);
# 502 "/usr/include/math.h" 2 3 4
# 518 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64x acosf64x (_Float64x __x) noexcept (true); extern _Float64x __acosf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinf64x (_Float64x __x) noexcept (true); extern _Float64x __asinf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanf64x (_Float64x __x) noexcept (true); extern _Float64x __atanf64x (_Float64x __x) noexcept (true);

 extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) noexcept (true); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) noexcept (true);


 extern _Float64x cosf64x (_Float64x __x) noexcept (true); extern _Float64x __cosf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinf64x (_Float64x __x) noexcept (true); extern _Float64x __sinf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanf64x (_Float64x __x) noexcept (true); extern _Float64x __tanf64x (_Float64x __x) noexcept (true);




 extern _Float64x coshf64x (_Float64x __x) noexcept (true); extern _Float64x __coshf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinhf64x (_Float64x __x) noexcept (true); extern _Float64x __sinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanhf64x (_Float64x __x) noexcept (true); extern _Float64x __tanhf64x (_Float64x __x) noexcept (true);



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true);





 extern _Float64x acoshf64x (_Float64x __x) noexcept (true); extern _Float64x __acoshf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinhf64x (_Float64x __x) noexcept (true); extern _Float64x __asinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanhf64x (_Float64x __x) noexcept (true); extern _Float64x __atanhf64x (_Float64x __x) noexcept (true);





 extern _Float64x expf64x (_Float64x __x) noexcept (true); extern _Float64x __expf64x (_Float64x __x) noexcept (true);


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) noexcept (true); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) noexcept (true);


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) noexcept (true); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) noexcept (true);


 extern _Float64x logf64x (_Float64x __x) noexcept (true); extern _Float64x __logf64x (_Float64x __x) noexcept (true);


 extern _Float64x log10f64x (_Float64x __x) noexcept (true); extern _Float64x __log10f64x (_Float64x __x) noexcept (true);


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64x exp10f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10f64x (_Float64x __x) noexcept (true);




 extern _Float64x expm1f64x (_Float64x __x) noexcept (true); extern _Float64x __expm1f64x (_Float64x __x) noexcept (true);


 extern _Float64x log1pf64x (_Float64x __x) noexcept (true); extern _Float64x __log1pf64x (_Float64x __x) noexcept (true);


extern _Float64x logbf64x (_Float64x __x) noexcept (true); extern _Float64x __logbf64x (_Float64x __x) noexcept (true);




 extern _Float64x exp2f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2f64x (_Float64x __x) noexcept (true);


 extern _Float64x log2f64x (_Float64x __x) noexcept (true); extern _Float64x __log2f64x (_Float64x __x) noexcept (true);






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64x sqrtf64x (_Float64x __x) noexcept (true); extern _Float64x __sqrtf64x (_Float64x __x) noexcept (true);



 extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) noexcept (true);




 extern _Float64x cbrtf64x (_Float64x __x) noexcept (true); extern _Float64x __cbrtf64x (_Float64x __x) noexcept (true);






extern _Float64x ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) noexcept (true); extern _Float64x __nanf64x (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) noexcept (true); extern _Float64x __j0f64x (_Float64x) noexcept (true);
extern _Float64x j1f64x (_Float64x) noexcept (true); extern _Float64x __j1f64x (_Float64x) noexcept (true);
extern _Float64x jnf64x (int, _Float64x) noexcept (true); extern _Float64x __jnf64x (int, _Float64x) noexcept (true);
extern _Float64x y0f64x (_Float64x) noexcept (true); extern _Float64x __y0f64x (_Float64x) noexcept (true);
extern _Float64x y1f64x (_Float64x) noexcept (true); extern _Float64x __y1f64x (_Float64x) noexcept (true);
extern _Float64x ynf64x (int, _Float64x) noexcept (true); extern _Float64x __ynf64x (int, _Float64x) noexcept (true);





 extern _Float64x erff64x (_Float64x) noexcept (true); extern _Float64x __erff64x (_Float64x) noexcept (true);
 extern _Float64x erfcf64x (_Float64x) noexcept (true); extern _Float64x __erfcf64x (_Float64x) noexcept (true);
extern _Float64x lgammaf64x (_Float64x) noexcept (true); extern _Float64x __lgammaf64x (_Float64x) noexcept (true);




extern _Float64x tgammaf64x (_Float64x) noexcept (true); extern _Float64x __tgammaf64x (_Float64x) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true);






extern _Float64x rintf64x (_Float64x __x) noexcept (true); extern _Float64x __rintf64x (_Float64x __x) noexcept (true);


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true);






extern _Float64x nextdownf64x (_Float64x __x) noexcept (true); extern _Float64x __nextdownf64x (_Float64x __x) noexcept (true);

extern _Float64x nextupf64x (_Float64x __x) noexcept (true); extern _Float64x __nextupf64x (_Float64x __x) noexcept (true);



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x scalbnf64x (_Float64x __x, int __n) noexcept (true); extern _Float64x __scalbnf64x (_Float64x __x, int __n) noexcept (true);



extern int ilogbf64x (_Float64x __x) noexcept (true); extern int __ilogbf64x (_Float64x __x) noexcept (true);




extern long int llogbf64x (_Float64x __x) noexcept (true); extern long int __llogbf64x (_Float64x __x) noexcept (true);




extern _Float64x scalblnf64x (_Float64x __x, long int __n) noexcept (true); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) noexcept (true);



extern _Float64x nearbyintf64x (_Float64x __x) noexcept (true); extern _Float64x __nearbyintf64x (_Float64x __x) noexcept (true);



extern _Float64x roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true);






extern long int lrintf64x (_Float64x __x) noexcept (true); extern long int __lrintf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llrintf64x (_Float64x __x) noexcept (true); extern long long int __llrintf64x (_Float64x __x) noexcept (true);



extern long int lroundf64x (_Float64x __x) noexcept (true); extern long int __lroundf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llroundf64x (_Float64x __x) noexcept (true); extern long long int __llroundf64x (_Float64x __x) noexcept (true);



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));



extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);




extern _Float64x roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) noexcept (true);






extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) noexcept (true); extern _Float64x __getpayloadf64x (const _Float64x *__x) noexcept (true);


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) noexcept (true);


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) noexcept (true);
# 519 "/usr/include/math.h" 2 3 4
# 566 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) noexcept (true);


extern float fdiv (double __x, double __y) noexcept (true);


extern float ffma (double __x, double __y, double __z) noexcept (true);


extern float fmul (double __x, double __y) noexcept (true);


extern float fsqrt (double __x) noexcept (true);


extern float fsub (double __x, double __y) noexcept (true);
# 567 "/usr/include/math.h" 2 3 4
# 587 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) noexcept (true);


extern float fdivl (long double __x, long double __y) noexcept (true);


extern float ffmal (long double __x, long double __y, long double __z) noexcept (true);


extern float fmull (long double __x, long double __y) noexcept (true);


extern float fsqrtl (long double __x) noexcept (true);


extern float fsubl (long double __x, long double __y) noexcept (true);
# 588 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) noexcept (true);


extern double ddivl (long double __x, long double __y) noexcept (true);


extern double dfmal (long double __x, long double __y, long double __z) noexcept (true);


extern double dmull (long double __x, long double __y) noexcept (true);


extern double dsqrtl (long double __x) noexcept (true);


extern double dsubl (long double __x, long double __y) noexcept (true);
# 617 "/usr/include/math.h" 2 3 4
# 697 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32sqrtf32x (_Float32x __x) noexcept (true);


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 698 "/usr/include/math.h" 2 3 4
# 707 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32sqrtf64 (_Float64 __x) noexcept (true);


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 708 "/usr/include/math.h" 2 3 4
# 717 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32sqrtf64x (_Float64x __x) noexcept (true);


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 718 "/usr/include/math.h" 2 3 4
# 747 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xfmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xsqrtf64 (_Float64 __x) noexcept (true);


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 748 "/usr/include/math.h" 2 3 4
# 757 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xfmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xsqrtf64x (_Float64x __x) noexcept (true);


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 758 "/usr/include/math.h" 2 3 4
# 787 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64sqrtf64x (_Float64x __x) noexcept (true);


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 788 "/usr/include/math.h" 2 3 4
# 854 "/usr/include/math.h" 3 4
extern int signgam;
# 934 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1055 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     noexcept (true) __attribute__ ((__const__));
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }



}
# 1056 "/usr/include/math.h" 2 3 4
# 1067 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}





}
# 1098 "/usr/include/math.h" 3 4
extern "C++" {
# 1129 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1364 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};
# 1455 "/usr/include/math.h" 3 4
template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 2 3
# 77 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1889 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
}





}
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 10 "firmware/nnet_utils/nnet_helpers.h" 2

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/stdlib.h" 1 3
# 36 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/stdlib.h" 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 3
# 37 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 12 "firmware/nnet_utils/nnet_helpers.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/vector" 1 3
# 59 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/vector" 3




# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_uninitialized.h" 1 3
# 67 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   if (true)
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   if (false)
     {
       std::_Destroy(__result, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 113 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;




      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 179 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 242 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__result, __cur, __alloc);
                          ;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
                          ;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
                          ;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 378 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      if (true)
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
                          ;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      if (true)
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
                          ;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      if (true)
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
                          ;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      if (true)
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      if (false)
 {
   std::_Destroy(__first2, __mid2, __alloc);
                          ;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
                          ;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
                          ;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_1
    {
      template<typename _ForwardIterator>
 static void
 __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __cur != __last; ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
       return __cur;
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 { return std::next(__first, __n); }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default_novalue(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_novalue_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      return __uninitialized_default_novalue_n_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue_n(__first, __n);
    }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__result, __cur);
                          ;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return {__first, __cur};
 }
      if (false)
 {
   std::_Destroy(__result, __cur);
                          ;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline pair<_RandomAccessIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    {
      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
      auto __first_res = std::next(__first, __n);
      return {__first_res, __second_res};
    }
# 810 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }

  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
         _ForwardIterator __result)
    {
      return
 std::__uninitialized_copy_n_pair(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 883 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_uninitialized.h" 3
}
# 64 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/vector" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 1 3
# 74 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)),
   _M_start(), _M_finish(), _M_end_of_storage()
 { }


 void _M_swap_data(_Vector_impl& __x) noexcept
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
# 231 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base() noexcept
      {
 _M_deallocate(_M_impl._M_start,
        _M_impl._M_end_of_storage - _M_impl._M_start);
      }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 338 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
# 351 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
   "std::vector must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
   "std::vector must have the same value_type as its allocator");



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:






      vector()

      noexcept(is_nothrow_default_constructible<_Alloc>::value)

      : _Base() { }





      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 414 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }
# 427 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 458 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
 _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 476 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      noexcept(_Alloc_traits::_S_always_equal())
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
# 515 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 541 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 565 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      ~vector() noexcept
      {
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
                                      ;
      }
# 581 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 595 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 616 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
 return *this;
      }
# 635 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 652 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 680 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 823 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 843 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   _M_fill_insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 875 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 914 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 929 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      {
                                  ;
 return *(this->_M_impl._M_start + __n);
      }
# 947 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
                                  ;
 return *(this->_M_impl._M_start + __n);
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
      }

    public:
# 978 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 996 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
                              ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
                              ;
 return *begin();
      }





      reference
      back() noexcept
      {
                              ;
 return *(end() - 1);
      }





      const_reference
      back() const noexcept
      {
                              ;
 return *(end() - 1);
      }
# 1054 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      _Tp*
      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }

      const _Tp*
      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 1073 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
                                   ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
                                   ;
   }
 else
   _M_realloc_insert(end(), __x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>



 void

 emplace_back(_Args&&... __args);
# 1111 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
                              ;
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                                 ;
      }
# 1133 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args)
 { return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
# 1149 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1179 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_insert_rval(__position, std::move(__x)); }
# 1196 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      {
 auto __offset = __position - cbegin();
 _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
   std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1221 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1263 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1315 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1342 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1366 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {


                                                          ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
 pointer
 _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
 {
   pointer __result = this->_M_allocate(__n);
   if (true)
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   if (false)
     {
       _M_deallocate(__result, __n);
                              ;
     }
 }
# 1419 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
 {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   if (true) {
     for (; __first != __last; ++__first)

       emplace_back(*__first);



   } if (false) {
     clear();
                            ;
   }
 }


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1502 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }


      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);







      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
 { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
 {
   _M_range_insert(__pos, __first, __last,
     std::__iterator_category(__first));
 }


      template<typename _InputIterator>
 void
 _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();
# 1589 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
      struct _Temporary_value
      {
 template<typename... _Args>
   explicit
   _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
   {
     _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
         std::forward<_Args>(__args)...);
   }

 ~_Temporary_value()
 { _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }

 value_type&
 _M_val() { return *reinterpret_cast<_Tp*>(&__buf); }

      private:
 pointer
 _M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }

 vector* _M_this;
 typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
      };



      template<typename _Arg>
 void
 _M_insert_aux(iterator __position, _Arg&& __arg);

      template<typename... _Args>
 void
 _M_realloc_insert(iterator __position, _Args&&... __args);


      iterator
      _M_insert_rval(const_iterator __position, value_type&& __v);


      template<typename... _Args>
 iterator
 _M_emplace_aux(const_iterator __position, _Args&&... __args);


      iterator
      _M_emplace_aux(const_iterator __position, value_type&& __v)
      { return _M_insert_rval(__position, std::move(__v)); }



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 if (size_type __n = this->_M_impl._M_finish - __pos)
   {
     std::_Destroy(__pos, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     this->_M_impl._M_finish = __pos;
                                       ;
   }
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__tmp._M_impl);
 this->_M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }


      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const noexcept
 { return __ptr; }


      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__to_address(__ptr); }
# 1729 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
    };
# 1751 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1768 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



}
# 65 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/vector" 2 3
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_bvector.h" 1 3
# 64 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
     || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_type * __v,
   unsigned int __first, unsigned int __last, bool __x)
  {
    const _Bit_type __fmask = ~0ul << __first;
    const _Bit_type __lmask = ~0ul >> (_S_word_bit - __last);
    const _Bit_type __mask = __fmask & __lmask;

    if (__x)
      *__v |= __mask;
    else
      *__v &= ~__mask;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 _Bit_type* __first_p = __first._M_p;
 if (__first._M_offset != 0)
   __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);

 __builtin_memset(__first_p, __x ? ~0 : 0,
    (__last._M_p - __first_p) * sizeof(_Bit_type));

 if (__last._M_offset != 0)
   __fill_bvector(__last._M_p, 0, __last._M_offset, __x);
      }
    else if (__first._M_offset != __last._M_offset)
      __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl_data
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl_data(_Bvector_impl_data&& __x) noexcept
 : _M_start(__x._M_start), _M_finish(__x._M_finish)
 , _M_end_of_storage(__x._M_end_of_storage)
 { __x._M_reset(); }

 void
 _M_move_data(_Bvector_impl_data&& __x) noexcept
 {
   this->_M_start = __x._M_start;
   this->_M_finish = __x._M_finish;
   this->_M_end_of_storage = __x._M_end_of_storage;
   __x._M_reset();
 }


 void
 _M_reset() noexcept
 {
   _M_start = _M_finish = _Bit_iterator();
   _M_end_of_storage = _Bit_pointer();
 }
      };

      struct _Bvector_impl
 : public _Bit_alloc_type, public _Bvector_impl_data
 {
 public:
   _Bvector_impl() noexcept(is_nothrow_default_constructible<_Bit_alloc_type>::value)

   : _Bit_alloc_type()
   { }

   _Bvector_impl(const _Bit_alloc_type& __a) noexcept
   : _Bit_alloc_type(__a)
   { }


 _Bvector_impl(_Bvector_impl&&) = default;


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (this->_M_end_of_storage)
     return std::__addressof(this->_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return this->_M_impl; }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }


      _Bvector_base() = default;




      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&&) = default;


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
     _M_impl._M_reset();
   }
      }


      void
      _M_move_data(_Bvector_base&& __x) noexcept
      { _M_impl._M_move_data(std::move(__x._M_impl)); }


      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };



}




namespace std __attribute__ ((__visibility__ ("default")))
{
# 587 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_bvector.h" 3
  template<typename _Alloc>
    class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
    {
      typedef _Bvector_base<_Alloc> _Base;
      typedef typename _Base::_Bit_pointer _Bit_pointer;
      typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


      friend struct std::hash<vector>;


    public:
      typedef bool value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Bit_reference reference;
      typedef bool const_reference;
      typedef _Bit_reference* pointer;
      typedef const bool* const_pointer;
      typedef _Bit_iterator iterator;
      typedef _Bit_const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_S_nword;
      using _Base::_M_get_Bit_allocator;

    public:

      vector() = default;




      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }


      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : vector(__n, false, __a)
      { }

      vector(size_type __n, const bool& __value,
      const allocator_type& __a = allocator_type())





      : _Base(__a)
      {
 _M_initialize(__n);
 _M_initialize_value(__value);
      }

      vector(const vector& __x)
      : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }


      vector(vector&&) = default;

      vector(vector&& __x, const allocator_type& __a)
      noexcept(_Bit_alloc_traits::_S_always_equal())
      : _Base(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_move_data(std::move(__x));
 else
   {
     _M_initialize(__x.size());
     _M_copy_aligned(__x.begin(), __x.end(), begin());
     __x.clear();
   }
      }

      vector(const vector& __x, const allocator_type& __a)
      : _Base(__a)
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }

      vector(initializer_list<bool> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_initialize_range(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 710 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_bvector.h" 3
      ~vector() noexcept { }

      vector&
      operator=(const vector& __x)
      {
 if (&__x == this)
   return *this;

 if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
   {
     if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
       {
  this->_M_deallocate();
  std::__alloc_on_copy(_M_get_Bit_allocator(),
         __x._M_get_Bit_allocator());
  _M_initialize(__x.size());
       }
     else
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
   }

 if (__x.size() > capacity())
   {
     this->_M_deallocate();
     _M_initialize(__x.size());
   }
 this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
        begin());
 return *this;
      }


      vector&
      operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
      {
 if (_Bit_alloc_traits::_S_propagate_on_move_assign()
     || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
   {
     this->_M_deallocate();
     this->_M_move_data(std::move(__x));
     std::__alloc_on_move(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
   }
 else
   {
     if (__x.size() > capacity())
       {
  this->_M_deallocate();
  _M_initialize(__x.size());
       }
     this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
            begin());
     __x.clear();
   }
 return *this;
      }

      vector&
      operator=(initializer_list<bool> __l)
      {
 this->assign (__l.begin(), __l.end());
 return *this;
      }






      void
      assign(size_type __n, const bool& __x)
      { _M_fill_assign(__n, __x); }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
# 801 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_bvector.h" 3
      void
      assign(initializer_list<bool> __l)
      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }


      iterator
      begin() noexcept
      { return this->_M_impl._M_start; }

      const_iterator
      begin() const noexcept
      { return this->_M_impl._M_start; }

      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }

      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }


      const_iterator
      cbegin() const noexcept
      { return this->_M_impl._M_start; }

      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      size_type
      size() const noexcept
      { return size_type(end() - begin()); }

      size_type
      max_size() const noexcept
      {
 const size_type __isize =
   __gnu_cxx::__numeric_traits<difference_type>::__max
   - int(_S_word_bit) + 1;
 const size_type __asize
   = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
 return (__asize <= __isize / int(_S_word_bit)
  ? __asize * int(_S_word_bit) : __isize);
      }

      size_type
      capacity() const noexcept
      { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
    - begin()); }

      bool
      empty() const noexcept
      { return begin() == end(); }

      reference
      operator[](size_type __n)
      {
 return *iterator(this->_M_impl._M_start._M_p
    + __n / int(_S_word_bit), __n % int(_S_word_bit));
      }

      const_reference
      operator[](size_type __n) const
      {
 return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
      }

    protected:
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
      }

    public:
      reference
      at(size_type __n)
      { _M_range_check(__n); return (*this)[__n]; }

      const_reference
      at(size_type __n) const
      { _M_range_check(__n); return (*this)[__n]; }

      void
      reserve(size_type __n)
      {
 if (__n > max_size())
   __throw_length_error(("vector::reserve"));
 if (capacity() < __n)
   _M_reallocate(__n);
      }

      reference
      front()
      { return *begin(); }

      const_reference
      front() const
      { return *begin(); }

      reference
      back()
      { return *(end() - 1); }

      const_reference
      back() const
      { return *(end() - 1); }






      void
      data() noexcept { }

      void
      push_back(bool __x)
      {
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(end(), __x);
      }

      void
      swap(vector& __x) noexcept
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);
 _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
      }


      static void
      swap(reference __x, reference __y) noexcept
      {
 bool __tmp = __x;
 __x = __y;
 __y = __tmp;
      }

      iterator

      insert(const_iterator __position, const bool& __x = bool())



      {
 const difference_type __n = __position - begin();
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
     && __position == end())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(__position._M_const_cast(), __x);
 return begin() + __n;
      }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position,
        _InputIterator __first, _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(__position._M_const_cast(),
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1017 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_bvector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const bool& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }







      iterator
      insert(const_iterator __p, initializer_list<bool> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }


      void
      pop_back()
      { --this->_M_impl._M_finish; }

      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }

      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

      void
      resize(size_type __new_size, bool __x = bool())
      {
 if (__new_size < size())
   _M_erase_at_end(begin() + difference_type(__new_size));
 else
   insert(end(), __new_size - size(), __x);
      }


      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }


      void
      flip() noexcept
      {
 _Bit_type * const __end = this->_M_impl._M_end_addr();
 for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
   *__p = ~*__p;
      }

      void
      clear() noexcept
      { _M_erase_at_end(begin()); }


      template<typename... _Args>



 void

 emplace_back(_Args&&... __args)
 {
   push_back(bool(__args...));



 }

      template<typename... _Args>
 iterator
 emplace(const_iterator __pos, _Args&&... __args)
 { return insert(__pos, bool(__args...)); }


    protected:

      iterator
      _M_copy_aligned(const_iterator __first, const_iterator __last,
        iterator __result)
      {
 _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
 return std::copy(const_iterator(__last._M_p, 0), __last,
    iterator(__q, 0));
      }

      void
      _M_initialize(size_type __n)
      {
 if (__n)
   {
     _Bit_pointer __q = this->_M_allocate(__n);
     this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
     this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
   }
 else
   {
     this->_M_impl._M_end_of_storage = _Bit_pointer();
     this->_M_impl._M_start = iterator(0, 0);
   }
 this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);

      }

      void
      _M_initialize_value(bool __x)
      {
 if (_Bit_type* __p = this->_M_impl._M_start._M_p)
   __builtin_memset(__p, __x ? ~0 : 0,
      (this->_M_impl._M_end_addr() - __p)
      * sizeof(_Bit_type));
      }

      void
      _M_reallocate(size_type __n);


      bool
      _M_shrink_to_fit();






      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
 {
   _M_initialize(static_cast<size_type>(__n));
   _M_initialize_value(__x);
 }

      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 { _M_initialize_range(__first, __last,
         std::__iterator_category(__first)); }

      template<typename _InputIterator>
 void
 _M_initialize_range(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }

      template<typename _ForwardIterator>
 void
 _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   _M_initialize(__n);
   std::copy(__first, __last, this->_M_impl._M_start);
 }
# 1203 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/stl_bvector.h" 3
      void
      _M_fill_assign(size_t __n, bool __x)
      {
 if (__n > size())
   {
     _M_initialize_value(__x);
     insert(end(), __n - size(), __x);
   }
 else
   {
     _M_erase_at_end(begin() + __n);
     _M_initialize_value(__x);
   }
      }

      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag)
 {
   iterator __cur = begin();
   for (; __first != __last && __cur != end(); ++__cur, ++__first)
     *__cur = *__first;
   if (__first == __last)
     _M_erase_at_end(__cur);
   else
     insert(end(), __first, __last);
 }

      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
 {
   const size_type __len = std::distance(__first, __last);
   if (__len < size())
     _M_erase_at_end(std::copy(__first, __last, begin()));
   else
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
 }





      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
      __true_type)
 { _M_fill_insert(__pos, __n, __x); }

      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_insert_range(__pos, __first, __last,
     std::__iterator_category(__first)); }

      void
      _M_fill_insert(iterator __position, size_type __n, bool __x);

      template<typename _InputIterator>
 void
 _M_insert_range(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     {
       __pos = insert(__pos, *__first);
       ++__pos;
     }
 }

      template<typename _ForwardIterator>
 void
 _M_insert_range(iterator __position, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);

      void
      _M_insert_aux(iterator __position, bool __x);

      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }

      void
      _M_erase_at_end(iterator __pos)
      { this->_M_impl._M_finish = __pos; }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);
  };



}



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 66 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/vector" 2 3



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/vector.tcc" 1 3
# 59 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
                                ;
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>



      void

      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
                                   ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
                                   ;
   }
 else
   _M_realloc_insert(end(), std::forward<_Args>(__args)...);



      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == end())
   {
                                   ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
                                   ;
   }
 else
   {

     const auto __pos = begin() + (__position - cbegin());


     _Temporary_value __x_copy(this, __x);
     _M_insert_aux(__pos, std::move(__x_copy._M_val()));



   }
      else

 _M_realloc_insert(begin() + (__position - cbegin()), __x);




      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                                      ;
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
                                ;

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   const size_type __add = __n - size();
                                     ;
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __add, __val, _M_get_Tp_allocator());
                                     ;
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert(end(), __first, __last,
     std::__iterator_category(__first));
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
                                  ;
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     const size_type __attribute__((__unused__)) __n = __len - size();
                                     ;
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
                                     ;
   }
      }


  template<typename _Tp, typename _Alloc>
    auto
    vector<_Tp, _Alloc>::
    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
    {
      const auto __n = __position - cbegin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == cend())
   {
                                   ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::move(__v));
     ++this->_M_impl._M_finish;
                                   ;
   }
 else
   _M_insert_aux(begin() + __n, std::move(__v));
      else
 _M_realloc_insert(begin() + __n, std::move(__v));

      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      auto
      vector<_Tp, _Alloc>::
      _M_emplace_aux(const_iterator __position, _Args&&... __args)
      -> iterator
      {
 const auto __n = __position - cbegin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   if (__position == cend())
     {
                                     ;
       _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
           std::forward<_Args>(__args)...);
       ++this->_M_impl._M_finish;
                                     ;
     }
   else
     {



       _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
       _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
     }
 else
   _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);

 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _Arg>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Arg&& __arg)






    {
                                    ;
      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          std::move(*(this->_M_impl._M_finish - 1)));
      ++this->_M_impl._M_finish;
                                    ;



      std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);





      *__position = std::forward<_Arg>(__arg);

    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_realloc_insert(iterator __position, _Args&&... __args)






    {
      const size_type __len =
 _M_check_len(size_type(1), "vector::_M_realloc_insert");
      pointer __old_start = this->_M_impl._M_start;
      pointer __old_finish = this->_M_impl._M_finish;
      const size_type __elems_before = __position - begin();
      pointer __new_start(this->_M_allocate(__len));
      pointer __new_finish(__new_start);
      if (true)
 {





   _Alloc_traits::construct(this->_M_impl,
       __new_start + __elems_before,

       std::forward<_Args>(__args)...);



   __new_finish = pointer();

   __new_finish
     = std::__uninitialized_move_if_noexcept_a
     (__old_start, __position.base(),
      __new_start, _M_get_Tp_allocator());

   ++__new_finish;

   __new_finish
     = std::__uninitialized_move_if_noexcept_a
     (__position.base(), __old_finish,
      __new_finish, _M_get_Tp_allocator());
 }
      if (false)
 {
   if (!__new_finish)
     _Alloc_traits::destroy(this->_M_impl,
       __new_start + __elems_before);
   else
     std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
   _M_deallocate(__new_start, __len);
                          ;
 }
                                   ;
      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
      _M_deallocate(__old_start,
      this->_M_impl._M_end_of_storage - __old_start);
      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {



       _Temporary_value __tmp(this, __x);
       value_type& __x_copy = __tmp._M_val();

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
                                    ;
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
                                    ;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish);

    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
                                    ;
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
                                                    ;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
                                              ;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       if (true)
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       if (false)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
                           ;
  }
                                    ;
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   const size_type __size = size();
   size_type __navail = size_type(this->_M_impl._M_end_of_storage
      - this->_M_impl._M_finish);

   if (__size > max_size() || __navail > max_size() - __size)
     __builtin_unreachable();

   if (__navail >= __n)
     {
                                       ;
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
                                       ;
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       pointer __new_start(this->_M_allocate(__len));
       pointer __destroy_from = pointer();
       if (true)
  {
    std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
    __destroy_from = __new_start + __size;
    std::__uninitialized_move_if_noexcept_a(
        this->_M_impl._M_start, this->_M_impl._M_finish,
        __new_start, _M_get_Tp_allocator());
  }
       if (false)
  {
    if (__destroy_from)
      std::_Destroy(__destroy_from, __destroy_from + __n,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
                           ;
  }
                                    ;
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_start + __size + __n;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
                                   ;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 if (__pos == end())
   {
     for (; __first != __last; ++__first)
       insert(end(), *__first);
   }
 else if (__first != __last)
   {
     vector __tmp(__first, __last, _M_get_Tp_allocator());
     insert(__pos,
     std::make_move_iterator(__tmp.begin()),
     std::make_move_iterator(__tmp.end()));
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
                                      ;
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
                                      ;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish);

      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
                                      ;
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
                                                      ;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
                                                ;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  if (true)
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  if (false)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
                             ;
    }
                               ;
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      iterator __finish(_M_copy_aligned(begin(), end(), __start));
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   iterator __finish = std::copy(__position, end(),
     __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  iterator __finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
  this->_M_impl._M_finish = __finish;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   iterator __finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      if (true)
 {
   _M_reallocate(size());
   return true;
 }
      if (false)
 { return false; }
    }




}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 70 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/vector" 2 3
# 13 "firmware/nnet_utils/nnet_helpers.h" 2

namespace nnet {
# 252 "firmware/nnet_utils/nnet_helpers.h"
template <class src_T, class dst_T, size_t OFFSET, size_t SIZE> void copy_data(std::vector<src_T> src, dst_T dst[SIZE]) {
    typename std::vector<src_T>::const_iterator in_begin = src.cbegin() + OFFSET;
    typename std::vector<src_T>::const_iterator in_end = in_begin + SIZE;
    std::copy(in_begin, in_end, dst);
}

template <class src_T, class dst_T, size_t OFFSET, size_t SIZE>
void copy_data(std::vector<src_T> src, hls::stream<dst_T> &dst) {
    typename std::vector<src_T>::const_iterator in_begin = src.cbegin() + OFFSET;
    typename std::vector<src_T>::const_iterator in_end = in_begin + SIZE;

    size_t i_pack = 0;
    dst_T dst_pack;
    for (typename std::vector<src_T>::const_iterator i = in_begin; i != in_end; ++i) {
        dst_pack[i_pack++] = typename dst_T::value_type(*i);
        if (i_pack == dst_T::size) {
            i_pack = 0;
            dst.write(dst_pack);
        }
    }
}

template <class src_T, class dst_T, size_t OFFSET, size_t SIZE> void copy_data_axi(std::vector<src_T> src, dst_T dst[SIZE]) {
    for (auto i = 0; i < SIZE; i++)
        if (i == SIZE - 1) {
            dst[i].data = src[i];
            dst[i].last = 1;
        } else {
            dst[i].data = src[i];
            dst[i].last = 0;
        }
}

template <class res_T, size_t SIZE> void print_result(res_T result[SIZE], std::ostream &out, bool keep = false) {
    for (int i = 0; i < SIZE; i++) {
        out << result[i] << " ";
    }
    out << std::endl;
}

template <class res_T, size_t SIZE> void print_result(hls::stream<res_T> &result, std::ostream &out, bool keep = false) {
    for (int i = 0; i < SIZE / res_T::size; i++) {
        res_T res_pack = result.read();
        for (int j = 0; j < res_T::size; j++) {
            out << res_pack[j] << " ";
        }
        if (keep)
            result.write(res_pack);
    }
    out << std::endl;
}

template <class data_T, size_t SIZE> void fill_zero(data_T data[SIZE]) { std::fill_n(data, SIZE, 0.); }

template <class data_T, size_t SIZE> void fill_zero(hls::stream<data_T> &data) {
    for (int i = 0; i < SIZE / data_T::size; i++) {
        data_T data_pack;
        for (int j = 0; j < data_T::size; j++) {
            data_pack[j] = 0.;
        }
        data.write(data_pack);
    }
}

template <class dataType, unsigned int nrows> int read_file_1D(const char *filename, dataType data[nrows]) {
    FILE *fp;
    fp = fopen(filename, "r");
    if (fp == 0) {
        return -1;
    }

    float newval;
    for (int ii = 0; ii < nrows; ii++) {
        if (fscanf(fp, "%f\n", &newval) != 0) {
            data[ii] = newval;
        } else {
            return -2;
        }
    }
    fclose(fp);
    return 0;
}

template <class dataType, unsigned int nrows, unsigned int ncols>
int read_file_2D(const char *filename, dataType data[nrows][ncols]) {
    FILE *fp;
    fp = fopen(filename, "r");
    if (fp == 0) {
        return -1;
    }

    float newval;
    for (int ii = 0; ii < nrows; ii++) {
        for (int jj = 0; jj < ncols; jj++) {
            if (fscanf(fp, "%f\n", &newval) != 0) {
                data[ii][jj] = newval;
            } else {
                return -2;
            }
        }
    }
    fclose(fp);
    return 0;
}

template <class in_T, class out_T, int N_IN> void change_type(hls::stream<in_T> &in, hls::stream<out_T> &out) {
    in_T datareg;
    hls::stream<out_T> input_trunc;
    for (int ii = 0; ii < N_IN; ii++) {
        out << (out_T)in.read();
    }
}

template <class data_T, int N_IN> void hls_stream_debug(hls::stream<data_T> &data, hls::stream<data_T> &res) {
    data_T datareg;
    for (int ii = 0; ii < N_IN; ii++) {
        datareg = data.read();
        std::cout << "[" << ii << "]: " << datareg << std::endl;
        res << datareg;
    }
}

constexpr int ceillog2(int x) { return (x <= 2) ? 1 : 1 + ceillog2((x + 1) / 2); }

constexpr int floorlog2(int x) { return (x < 2) ? 0 : 1 + floorlog2(x / 2); }

constexpr int pow2(int x) { return x == 0 ? 1 : 2 * pow2(x - 1); }

}
# 5 "firmware/nnet_utils/nnet_code_gen.h" 2


namespace nnet {

template <class data_T, typename CONFIG_T> class FillConv1DBuffer {
  public:
    static void fill_buffer(data_T data[CONFIG_T::in_width * CONFIG_T::n_chan],
                            data_T buffer[CONFIG_T::n_pixels][CONFIG_T::filt_width * CONFIG_T::n_chan],
                            const unsigned partition) {

    }
};

template <class data_T, typename CONFIG_T> class FillConv2DBuffer {
  public:
    static void
    fill_buffer(data_T data[CONFIG_T::in_height * CONFIG_T::in_width * CONFIG_T::n_chan],
                data_T buffer[CONFIG_T::n_pixels][CONFIG_T::filt_height * CONFIG_T::filt_width * CONFIG_T::n_chan],
                const unsigned partition) {

    }
};


template<class data_T, typename CONFIG_T>
class fill_buffer_2 : public FillConv1DBuffer<data_T, CONFIG_T> {
    public:
    static void fill_buffer(
        data_T data[CONFIG_T::in_width * CONFIG_T::n_chan],
        data_T buffer[CONFIG_T::n_pixels][CONFIG_T::filt_width * CONFIG_T::n_chan],
        const unsigned partition
    ) {
        if (partition == 0) {
            buffer[0][0] = data[0]; buffer[0][1] = data[1]; buffer[0][2] = data[2];

        }
        if (partition == 1) {
            buffer[0][0] = data[1]; buffer[0][1] = data[2]; buffer[0][2] = data[3];

        }
        if (partition == 2) {
            buffer[0][0] = data[2]; buffer[0][1] = data[3]; buffer[0][2] = data[4];

        }
        if (partition == 3) {
            buffer[0][0] = data[3]; buffer[0][1] = data[4]; buffer[0][2] = data[5];

        }
        if (partition == 4) {
            buffer[0][0] = data[4]; buffer[0][1] = data[5]; buffer[0][2] = data[6];

        }
        if (partition == 5) {
            buffer[0][0] = data[5]; buffer[0][1] = data[6]; buffer[0][2] = data[7];

        }
        if (partition == 6) {
            buffer[0][0] = data[6]; buffer[0][1] = data[7]; buffer[0][2] = data[8];

        }
        if (partition == 7) {
            buffer[0][0] = data[7]; buffer[0][1] = data[8]; buffer[0][2] = data[9];

        }
        if (partition == 8) {
            buffer[0][0] = data[8]; buffer[0][1] = data[9]; buffer[0][2] = data[10];

        }
        if (partition == 9) {
            buffer[0][0] = data[9]; buffer[0][1] = data[10]; buffer[0][2] = data[11];

        }
        if (partition == 10) {
            buffer[0][0] = data[10]; buffer[0][1] = data[11]; buffer[0][2] = data[12];

        }
        if (partition == 11) {
            buffer[0][0] = data[11]; buffer[0][1] = data[12]; buffer[0][2] = data[13];

        }
        if (partition == 12) {
            buffer[0][0] = data[12]; buffer[0][1] = data[13]; buffer[0][2] = data[14];

        }
        if (partition == 13) {
            buffer[0][0] = data[13]; buffer[0][1] = data[14]; buffer[0][2] = data[15];

        }
        if (partition == 14) {
            buffer[0][0] = data[14]; buffer[0][1] = data[15]; buffer[0][2] = data[16];

        }
        if (partition == 15) {
            buffer[0][0] = data[15]; buffer[0][1] = data[16]; buffer[0][2] = data[17];

        }
        if (partition == 16) {
            buffer[0][0] = data[16]; buffer[0][1] = data[17]; buffer[0][2] = data[18];

        }
        if (partition == 17) {
            buffer[0][0] = data[17]; buffer[0][1] = data[18]; buffer[0][2] = data[19];

        }
        if (partition == 18) {
            buffer[0][0] = data[18]; buffer[0][1] = data[19]; buffer[0][2] = data[20];

        }
        if (partition == 19) {
            buffer[0][0] = data[19]; buffer[0][1] = data[20]; buffer[0][2] = data[21];

        }
        if (partition == 20) {
            buffer[0][0] = data[20]; buffer[0][1] = data[21]; buffer[0][2] = data[22];

        }
        if (partition == 21) {
            buffer[0][0] = data[21]; buffer[0][1] = data[22]; buffer[0][2] = data[23];

        }
        if (partition == 22) {
            buffer[0][0] = data[22]; buffer[0][1] = data[23]; buffer[0][2] = data[24];

        }
        if (partition == 23) {
            buffer[0][0] = data[23]; buffer[0][1] = data[24]; buffer[0][2] = data[25];

        }
        if (partition == 24) {
            buffer[0][0] = data[24]; buffer[0][1] = data[25]; buffer[0][2] = data[26];

        }
        if (partition == 25) {
            buffer[0][0] = data[25]; buffer[0][1] = data[26]; buffer[0][2] = data[27];

        }
        if (partition == 26) {
            buffer[0][0] = data[26]; buffer[0][1] = data[27]; buffer[0][2] = data[28];

        }
        if (partition == 27) {
            buffer[0][0] = data[27]; buffer[0][1] = data[28]; buffer[0][2] = data[29];

        }
        if (partition == 28) {
            buffer[0][0] = data[28]; buffer[0][1] = data[29]; buffer[0][2] = data[30];

        }
        if (partition == 29) {
            buffer[0][0] = data[29]; buffer[0][1] = data[30]; buffer[0][2] = data[31];

        }
        if (partition == 30) {
            buffer[0][0] = data[30]; buffer[0][1] = data[31]; buffer[0][2] = data[32];

        }
        if (partition == 31) {
            buffer[0][0] = data[31]; buffer[0][1] = data[32]; buffer[0][2] = data[33];

        }
        if (partition == 32) {
            buffer[0][0] = data[32]; buffer[0][1] = data[33]; buffer[0][2] = data[34];

        }
        if (partition == 33) {
            buffer[0][0] = data[33]; buffer[0][1] = data[34]; buffer[0][2] = data[35];

        }
        if (partition == 34) {
            buffer[0][0] = data[34]; buffer[0][1] = data[35]; buffer[0][2] = data[36];

        }
        if (partition == 35) {
            buffer[0][0] = data[35]; buffer[0][1] = data[36]; buffer[0][2] = data[37];

        }
        if (partition == 36) {
            buffer[0][0] = data[36]; buffer[0][1] = data[37]; buffer[0][2] = data[38];

        }
        if (partition == 37) {
            buffer[0][0] = data[37]; buffer[0][1] = data[38]; buffer[0][2] = data[39];

        }
        if (partition == 38) {
            buffer[0][0] = data[38]; buffer[0][1] = data[39]; buffer[0][2] = data[40];

        }
        if (partition == 39) {
            buffer[0][0] = data[39]; buffer[0][1] = data[40]; buffer[0][2] = data[41];

        }
        if (partition == 40) {
            buffer[0][0] = data[40]; buffer[0][1] = data[41]; buffer[0][2] = data[42];

        }
        if (partition == 41) {
            buffer[0][0] = data[41]; buffer[0][1] = data[42]; buffer[0][2] = data[43];

        }
        if (partition == 42) {
            buffer[0][0] = data[42]; buffer[0][1] = data[43]; buffer[0][2] = data[44];

        }
        if (partition == 43) {
            buffer[0][0] = data[43]; buffer[0][1] = data[44]; buffer[0][2] = data[45];

        }
        if (partition == 44) {
            buffer[0][0] = data[44]; buffer[0][1] = data[45]; buffer[0][2] = data[46];

        }
        if (partition == 45) {
            buffer[0][0] = data[45]; buffer[0][1] = data[46]; buffer[0][2] = data[47];

        }
        if (partition == 46) {
            buffer[0][0] = data[46]; buffer[0][1] = data[47]; buffer[0][2] = data[48];

        }
        if (partition == 47) {
            buffer[0][0] = data[47]; buffer[0][1] = data[48]; buffer[0][2] = data[49];

        }
        if (partition == 48) {
            buffer[0][0] = data[48]; buffer[0][1] = data[49]; buffer[0][2] = data[50];

        }
        if (partition == 49) {
            buffer[0][0] = data[49]; buffer[0][1] = data[50]; buffer[0][2] = data[51];

        }
        if (partition == 50) {
            buffer[0][0] = data[50]; buffer[0][1] = data[51]; buffer[0][2] = data[52];

        }
        if (partition == 51) {
            buffer[0][0] = data[51]; buffer[0][1] = data[52]; buffer[0][2] = data[53];

        }
        if (partition == 52) {
            buffer[0][0] = data[52]; buffer[0][1] = data[53]; buffer[0][2] = data[54];

        }
        if (partition == 53) {
            buffer[0][0] = data[53]; buffer[0][1] = data[54]; buffer[0][2] = data[55];

        }
        if (partition == 54) {
            buffer[0][0] = data[54]; buffer[0][1] = data[55]; buffer[0][2] = data[56];

        }
        if (partition == 55) {
            buffer[0][0] = data[55]; buffer[0][1] = data[56]; buffer[0][2] = data[57];

        }
        if (partition == 56) {
            buffer[0][0] = data[56]; buffer[0][1] = data[57]; buffer[0][2] = data[58];

        }
        if (partition == 57) {
            buffer[0][0] = data[57]; buffer[0][1] = data[58]; buffer[0][2] = data[59];

        }
        if (partition == 58) {
            buffer[0][0] = data[58]; buffer[0][1] = data[59]; buffer[0][2] = data[60];

        }
        if (partition == 59) {
            buffer[0][0] = data[59]; buffer[0][1] = data[60]; buffer[0][2] = data[61];

        }
        if (partition == 60) {
            buffer[0][0] = data[60]; buffer[0][1] = data[61]; buffer[0][2] = data[62];

        }
        if (partition == 61) {
            buffer[0][0] = data[61]; buffer[0][1] = data[62]; buffer[0][2] = data[63];

        }
        if (partition == 62) {
            buffer[0][0] = data[62]; buffer[0][1] = data[63]; buffer[0][2] = data[64];

        }
        if (partition == 63) {
            buffer[0][0] = data[63]; buffer[0][1] = data[64]; buffer[0][2] = data[65];

        }
        if (partition == 64) {
            buffer[0][0] = data[64]; buffer[0][1] = data[65]; buffer[0][2] = data[66];

        }
        if (partition == 65) {
            buffer[0][0] = data[65]; buffer[0][1] = data[66]; buffer[0][2] = data[67];

        }
        if (partition == 66) {
            buffer[0][0] = data[66]; buffer[0][1] = data[67]; buffer[0][2] = data[68];

        }
        if (partition == 67) {
            buffer[0][0] = data[67]; buffer[0][1] = data[68]; buffer[0][2] = data[69];

        }
        if (partition == 68) {
            buffer[0][0] = data[68]; buffer[0][1] = data[69]; buffer[0][2] = data[70];

        }
        if (partition == 69) {
            buffer[0][0] = data[69]; buffer[0][1] = data[70]; buffer[0][2] = data[71];

        }
        if (partition == 70) {
            buffer[0][0] = data[70]; buffer[0][1] = data[71]; buffer[0][2] = data[72];

        }
        if (partition == 71) {
            buffer[0][0] = data[71]; buffer[0][1] = data[72]; buffer[0][2] = data[73];

        }
        if (partition == 72) {
            buffer[0][0] = data[72]; buffer[0][1] = data[73]; buffer[0][2] = data[74];

        }
        if (partition == 73) {
            buffer[0][0] = data[73]; buffer[0][1] = data[74]; buffer[0][2] = data[75];

        }
        if (partition == 74) {
            buffer[0][0] = data[74]; buffer[0][1] = data[75]; buffer[0][2] = data[76];

        }
        if (partition == 75) {
            buffer[0][0] = data[75]; buffer[0][1] = data[76]; buffer[0][2] = data[77];

        }
        if (partition == 76) {
            buffer[0][0] = data[76]; buffer[0][1] = data[77]; buffer[0][2] = data[78];

        }
        if (partition == 77) {
            buffer[0][0] = data[77]; buffer[0][1] = data[78]; buffer[0][2] = data[79];

        }
        if (partition == 78) {
            buffer[0][0] = data[78]; buffer[0][1] = data[79]; buffer[0][2] = data[80];

        }
        if (partition == 79) {
            buffer[0][0] = data[79]; buffer[0][1] = data[80]; buffer[0][2] = data[81];

        }
        if (partition == 80) {
            buffer[0][0] = data[80]; buffer[0][1] = data[81]; buffer[0][2] = data[82];

        }
        if (partition == 81) {
            buffer[0][0] = data[81]; buffer[0][1] = data[82]; buffer[0][2] = data[83];

        }
        if (partition == 82) {
            buffer[0][0] = data[82]; buffer[0][1] = data[83]; buffer[0][2] = data[84];

        }
        if (partition == 83) {
            buffer[0][0] = data[83]; buffer[0][1] = data[84]; buffer[0][2] = data[85];

        }
        if (partition == 84) {
            buffer[0][0] = data[84]; buffer[0][1] = data[85]; buffer[0][2] = data[86];

        }
        if (partition == 85) {
            buffer[0][0] = data[85]; buffer[0][1] = data[86]; buffer[0][2] = data[87];

        }
        if (partition == 86) {
            buffer[0][0] = data[86]; buffer[0][1] = data[87]; buffer[0][2] = data[88];

        }
        if (partition == 87) {
            buffer[0][0] = data[87]; buffer[0][1] = data[88]; buffer[0][2] = data[89];

        }
        if (partition == 88) {
            buffer[0][0] = data[88]; buffer[0][1] = data[89]; buffer[0][2] = data[90];

        }
        if (partition == 89) {
            buffer[0][0] = data[89]; buffer[0][1] = data[90]; buffer[0][2] = data[91];

        }
        if (partition == 90) {
            buffer[0][0] = data[90]; buffer[0][1] = data[91]; buffer[0][2] = data[92];

        }
        if (partition == 91) {
            buffer[0][0] = data[91]; buffer[0][1] = data[92]; buffer[0][2] = data[93];

        }
        if (partition == 92) {
            buffer[0][0] = data[92]; buffer[0][1] = data[93]; buffer[0][2] = data[94];

        }
        if (partition == 93) {
            buffer[0][0] = data[93]; buffer[0][1] = data[94]; buffer[0][2] = data[95];

        }
        if (partition == 94) {
            buffer[0][0] = data[94]; buffer[0][1] = data[95]; buffer[0][2] = data[96];

        }
        if (partition == 95) {
            buffer[0][0] = data[95]; buffer[0][1] = data[96]; buffer[0][2] = data[97];

        }
        if (partition == 96) {
            buffer[0][0] = data[96]; buffer[0][1] = data[97]; buffer[0][2] = data[98];

        }
        if (partition == 97) {
            buffer[0][0] = data[97]; buffer[0][1] = data[98]; buffer[0][2] = data[99];

        }
        if (partition == 98) {
            buffer[0][0] = data[98]; buffer[0][1] = data[99]; buffer[0][2] = data[100];

        }
        if (partition == 99) {
            buffer[0][0] = data[99]; buffer[0][1] = data[100]; buffer[0][2] = data[101];

        }
        if (partition == 100) {
            buffer[0][0] = data[100]; buffer[0][1] = data[101]; buffer[0][2] = data[102];

        }
        if (partition == 101) {
            buffer[0][0] = data[101]; buffer[0][1] = data[102]; buffer[0][2] = data[103];

        }
        if (partition == 102) {
            buffer[0][0] = data[102]; buffer[0][1] = data[103]; buffer[0][2] = data[104];

        }
        if (partition == 103) {
            buffer[0][0] = data[103]; buffer[0][1] = data[104]; buffer[0][2] = data[105];

        }
        if (partition == 104) {
            buffer[0][0] = data[104]; buffer[0][1] = data[105]; buffer[0][2] = data[106];

        }
        if (partition == 105) {
            buffer[0][0] = data[105]; buffer[0][1] = data[106]; buffer[0][2] = data[107];

        }
        if (partition == 106) {
            buffer[0][0] = data[106]; buffer[0][1] = data[107]; buffer[0][2] = data[108];

        }
        if (partition == 107) {
            buffer[0][0] = data[107]; buffer[0][1] = data[108]; buffer[0][2] = data[109];

        }
        if (partition == 108) {
            buffer[0][0] = data[108]; buffer[0][1] = data[109]; buffer[0][2] = data[110];

        }
        if (partition == 109) {
            buffer[0][0] = data[109]; buffer[0][1] = data[110]; buffer[0][2] = data[111];

        }
        if (partition == 110) {
            buffer[0][0] = data[110]; buffer[0][1] = data[111]; buffer[0][2] = data[112];

        }
        if (partition == 111) {
            buffer[0][0] = data[111]; buffer[0][1] = data[112]; buffer[0][2] = data[113];

        }
        if (partition == 112) {
            buffer[0][0] = data[112]; buffer[0][1] = data[113]; buffer[0][2] = data[114];

        }
        if (partition == 113) {
            buffer[0][0] = data[113]; buffer[0][1] = data[114]; buffer[0][2] = data[115];

        }
        if (partition == 114) {
            buffer[0][0] = data[114]; buffer[0][1] = data[115]; buffer[0][2] = data[116];

        }
        if (partition == 115) {
            buffer[0][0] = data[115]; buffer[0][1] = data[116]; buffer[0][2] = data[117];

        }
        if (partition == 116) {
            buffer[0][0] = data[116]; buffer[0][1] = data[117]; buffer[0][2] = data[118];

        }
        if (partition == 117) {
            buffer[0][0] = data[117]; buffer[0][1] = data[118]; buffer[0][2] = data[119];

        }
    }
};
template<class data_T, typename CONFIG_T>
class fill_buffer_6 : public FillConv1DBuffer<data_T, CONFIG_T> {
    public:
    static void fill_buffer(
        data_T data[CONFIG_T::in_width * CONFIG_T::n_chan],
        data_T buffer[CONFIG_T::n_pixels][CONFIG_T::filt_width * CONFIG_T::n_chan],
        const unsigned partition
    ) {
        if (partition == 0) {
            buffer[0][0] = data[0]; buffer[0][1] = data[1]; buffer[0][2] = data[2]; buffer[0][3] = data[3]; buffer[0][4] = data[4]; buffer[0][5] = data[5]; buffer[0][6] = data[6]; buffer[0][7] = data[7]; buffer[0][8] = data[8]; buffer[0][9] = data[9]; buffer[0][10] = data[10]; buffer[0][11] = data[11]; buffer[0][12] = data[12]; buffer[0][13] = data[13]; buffer[0][14] = data[14]; buffer[0][15] = data[15]; buffer[0][16] = data[16]; buffer[0][17] = data[17]; buffer[0][18] = data[18]; buffer[0][19] = data[19]; buffer[0][20] = data[20]; buffer[0][21] = data[21]; buffer[0][22] = data[22]; buffer[0][23] = data[23]; buffer[0][24] = data[24]; buffer[0][25] = data[25]; buffer[0][26] = data[26]; buffer[0][27] = data[27]; buffer[0][28] = data[28]; buffer[0][29] = data[29]; buffer[0][30] = data[30]; buffer[0][31] = data[31]; buffer[0][32] = data[32]; buffer[0][33] = data[33]; buffer[0][34] = data[34]; buffer[0][35] = data[35]; buffer[0][36] = data[36]; buffer[0][37] = data[37]; buffer[0][38] = data[38]; buffer[0][39] = data[39]; buffer[0][40] = data[40]; buffer[0][41] = data[41]; buffer[0][42] = data[42]; buffer[0][43] = data[43]; buffer[0][44] = data[44]; buffer[0][45] = data[45]; buffer[0][46] = data[46]; buffer[0][47] = data[47];

        }
        if (partition == 1) {
            buffer[0][0] = data[16]; buffer[0][1] = data[17]; buffer[0][2] = data[18]; buffer[0][3] = data[19]; buffer[0][4] = data[20]; buffer[0][5] = data[21]; buffer[0][6] = data[22]; buffer[0][7] = data[23]; buffer[0][8] = data[24]; buffer[0][9] = data[25]; buffer[0][10] = data[26]; buffer[0][11] = data[27]; buffer[0][12] = data[28]; buffer[0][13] = data[29]; buffer[0][14] = data[30]; buffer[0][15] = data[31]; buffer[0][16] = data[32]; buffer[0][17] = data[33]; buffer[0][18] = data[34]; buffer[0][19] = data[35]; buffer[0][20] = data[36]; buffer[0][21] = data[37]; buffer[0][22] = data[38]; buffer[0][23] = data[39]; buffer[0][24] = data[40]; buffer[0][25] = data[41]; buffer[0][26] = data[42]; buffer[0][27] = data[43]; buffer[0][28] = data[44]; buffer[0][29] = data[45]; buffer[0][30] = data[46]; buffer[0][31] = data[47]; buffer[0][32] = data[48]; buffer[0][33] = data[49]; buffer[0][34] = data[50]; buffer[0][35] = data[51]; buffer[0][36] = data[52]; buffer[0][37] = data[53]; buffer[0][38] = data[54]; buffer[0][39] = data[55]; buffer[0][40] = data[56]; buffer[0][41] = data[57]; buffer[0][42] = data[58]; buffer[0][43] = data[59]; buffer[0][44] = data[60]; buffer[0][45] = data[61]; buffer[0][46] = data[62]; buffer[0][47] = data[63];

        }
        if (partition == 2) {
            buffer[0][0] = data[32]; buffer[0][1] = data[33]; buffer[0][2] = data[34]; buffer[0][3] = data[35]; buffer[0][4] = data[36]; buffer[0][5] = data[37]; buffer[0][6] = data[38]; buffer[0][7] = data[39]; buffer[0][8] = data[40]; buffer[0][9] = data[41]; buffer[0][10] = data[42]; buffer[0][11] = data[43]; buffer[0][12] = data[44]; buffer[0][13] = data[45]; buffer[0][14] = data[46]; buffer[0][15] = data[47]; buffer[0][16] = data[48]; buffer[0][17] = data[49]; buffer[0][18] = data[50]; buffer[0][19] = data[51]; buffer[0][20] = data[52]; buffer[0][21] = data[53]; buffer[0][22] = data[54]; buffer[0][23] = data[55]; buffer[0][24] = data[56]; buffer[0][25] = data[57]; buffer[0][26] = data[58]; buffer[0][27] = data[59]; buffer[0][28] = data[60]; buffer[0][29] = data[61]; buffer[0][30] = data[62]; buffer[0][31] = data[63]; buffer[0][32] = data[64]; buffer[0][33] = data[65]; buffer[0][34] = data[66]; buffer[0][35] = data[67]; buffer[0][36] = data[68]; buffer[0][37] = data[69]; buffer[0][38] = data[70]; buffer[0][39] = data[71]; buffer[0][40] = data[72]; buffer[0][41] = data[73]; buffer[0][42] = data[74]; buffer[0][43] = data[75]; buffer[0][44] = data[76]; buffer[0][45] = data[77]; buffer[0][46] = data[78]; buffer[0][47] = data[79];

        }
        if (partition == 3) {
            buffer[0][0] = data[48]; buffer[0][1] = data[49]; buffer[0][2] = data[50]; buffer[0][3] = data[51]; buffer[0][4] = data[52]; buffer[0][5] = data[53]; buffer[0][6] = data[54]; buffer[0][7] = data[55]; buffer[0][8] = data[56]; buffer[0][9] = data[57]; buffer[0][10] = data[58]; buffer[0][11] = data[59]; buffer[0][12] = data[60]; buffer[0][13] = data[61]; buffer[0][14] = data[62]; buffer[0][15] = data[63]; buffer[0][16] = data[64]; buffer[0][17] = data[65]; buffer[0][18] = data[66]; buffer[0][19] = data[67]; buffer[0][20] = data[68]; buffer[0][21] = data[69]; buffer[0][22] = data[70]; buffer[0][23] = data[71]; buffer[0][24] = data[72]; buffer[0][25] = data[73]; buffer[0][26] = data[74]; buffer[0][27] = data[75]; buffer[0][28] = data[76]; buffer[0][29] = data[77]; buffer[0][30] = data[78]; buffer[0][31] = data[79]; buffer[0][32] = data[80]; buffer[0][33] = data[81]; buffer[0][34] = data[82]; buffer[0][35] = data[83]; buffer[0][36] = data[84]; buffer[0][37] = data[85]; buffer[0][38] = data[86]; buffer[0][39] = data[87]; buffer[0][40] = data[88]; buffer[0][41] = data[89]; buffer[0][42] = data[90]; buffer[0][43] = data[91]; buffer[0][44] = data[92]; buffer[0][45] = data[93]; buffer[0][46] = data[94]; buffer[0][47] = data[95];

        }
        if (partition == 4) {
            buffer[0][0] = data[64]; buffer[0][1] = data[65]; buffer[0][2] = data[66]; buffer[0][3] = data[67]; buffer[0][4] = data[68]; buffer[0][5] = data[69]; buffer[0][6] = data[70]; buffer[0][7] = data[71]; buffer[0][8] = data[72]; buffer[0][9] = data[73]; buffer[0][10] = data[74]; buffer[0][11] = data[75]; buffer[0][12] = data[76]; buffer[0][13] = data[77]; buffer[0][14] = data[78]; buffer[0][15] = data[79]; buffer[0][16] = data[80]; buffer[0][17] = data[81]; buffer[0][18] = data[82]; buffer[0][19] = data[83]; buffer[0][20] = data[84]; buffer[0][21] = data[85]; buffer[0][22] = data[86]; buffer[0][23] = data[87]; buffer[0][24] = data[88]; buffer[0][25] = data[89]; buffer[0][26] = data[90]; buffer[0][27] = data[91]; buffer[0][28] = data[92]; buffer[0][29] = data[93]; buffer[0][30] = data[94]; buffer[0][31] = data[95]; buffer[0][32] = data[96]; buffer[0][33] = data[97]; buffer[0][34] = data[98]; buffer[0][35] = data[99]; buffer[0][36] = data[100]; buffer[0][37] = data[101]; buffer[0][38] = data[102]; buffer[0][39] = data[103]; buffer[0][40] = data[104]; buffer[0][41] = data[105]; buffer[0][42] = data[106]; buffer[0][43] = data[107]; buffer[0][44] = data[108]; buffer[0][45] = data[109]; buffer[0][46] = data[110]; buffer[0][47] = data[111];

        }
        if (partition == 5) {
            buffer[0][0] = data[80]; buffer[0][1] = data[81]; buffer[0][2] = data[82]; buffer[0][3] = data[83]; buffer[0][4] = data[84]; buffer[0][5] = data[85]; buffer[0][6] = data[86]; buffer[0][7] = data[87]; buffer[0][8] = data[88]; buffer[0][9] = data[89]; buffer[0][10] = data[90]; buffer[0][11] = data[91]; buffer[0][12] = data[92]; buffer[0][13] = data[93]; buffer[0][14] = data[94]; buffer[0][15] = data[95]; buffer[0][16] = data[96]; buffer[0][17] = data[97]; buffer[0][18] = data[98]; buffer[0][19] = data[99]; buffer[0][20] = data[100]; buffer[0][21] = data[101]; buffer[0][22] = data[102]; buffer[0][23] = data[103]; buffer[0][24] = data[104]; buffer[0][25] = data[105]; buffer[0][26] = data[106]; buffer[0][27] = data[107]; buffer[0][28] = data[108]; buffer[0][29] = data[109]; buffer[0][30] = data[110]; buffer[0][31] = data[111]; buffer[0][32] = data[112]; buffer[0][33] = data[113]; buffer[0][34] = data[114]; buffer[0][35] = data[115]; buffer[0][36] = data[116]; buffer[0][37] = data[117]; buffer[0][38] = data[118]; buffer[0][39] = data[119]; buffer[0][40] = data[120]; buffer[0][41] = data[121]; buffer[0][42] = data[122]; buffer[0][43] = data[123]; buffer[0][44] = data[124]; buffer[0][45] = data[125]; buffer[0][46] = data[126]; buffer[0][47] = data[127];

        }
        if (partition == 6) {
            buffer[0][0] = data[96]; buffer[0][1] = data[97]; buffer[0][2] = data[98]; buffer[0][3] = data[99]; buffer[0][4] = data[100]; buffer[0][5] = data[101]; buffer[0][6] = data[102]; buffer[0][7] = data[103]; buffer[0][8] = data[104]; buffer[0][9] = data[105]; buffer[0][10] = data[106]; buffer[0][11] = data[107]; buffer[0][12] = data[108]; buffer[0][13] = data[109]; buffer[0][14] = data[110]; buffer[0][15] = data[111]; buffer[0][16] = data[112]; buffer[0][17] = data[113]; buffer[0][18] = data[114]; buffer[0][19] = data[115]; buffer[0][20] = data[116]; buffer[0][21] = data[117]; buffer[0][22] = data[118]; buffer[0][23] = data[119]; buffer[0][24] = data[120]; buffer[0][25] = data[121]; buffer[0][26] = data[122]; buffer[0][27] = data[123]; buffer[0][28] = data[124]; buffer[0][29] = data[125]; buffer[0][30] = data[126]; buffer[0][31] = data[127]; buffer[0][32] = data[128]; buffer[0][33] = data[129]; buffer[0][34] = data[130]; buffer[0][35] = data[131]; buffer[0][36] = data[132]; buffer[0][37] = data[133]; buffer[0][38] = data[134]; buffer[0][39] = data[135]; buffer[0][40] = data[136]; buffer[0][41] = data[137]; buffer[0][42] = data[138]; buffer[0][43] = data[139]; buffer[0][44] = data[140]; buffer[0][45] = data[141]; buffer[0][46] = data[142]; buffer[0][47] = data[143];

        }
        if (partition == 7) {
            buffer[0][0] = data[112]; buffer[0][1] = data[113]; buffer[0][2] = data[114]; buffer[0][3] = data[115]; buffer[0][4] = data[116]; buffer[0][5] = data[117]; buffer[0][6] = data[118]; buffer[0][7] = data[119]; buffer[0][8] = data[120]; buffer[0][9] = data[121]; buffer[0][10] = data[122]; buffer[0][11] = data[123]; buffer[0][12] = data[124]; buffer[0][13] = data[125]; buffer[0][14] = data[126]; buffer[0][15] = data[127]; buffer[0][16] = data[128]; buffer[0][17] = data[129]; buffer[0][18] = data[130]; buffer[0][19] = data[131]; buffer[0][20] = data[132]; buffer[0][21] = data[133]; buffer[0][22] = data[134]; buffer[0][23] = data[135]; buffer[0][24] = data[136]; buffer[0][25] = data[137]; buffer[0][26] = data[138]; buffer[0][27] = data[139]; buffer[0][28] = data[140]; buffer[0][29] = data[141]; buffer[0][30] = data[142]; buffer[0][31] = data[143]; buffer[0][32] = data[144]; buffer[0][33] = data[145]; buffer[0][34] = data[146]; buffer[0][35] = data[147]; buffer[0][36] = data[148]; buffer[0][37] = data[149]; buffer[0][38] = data[150]; buffer[0][39] = data[151]; buffer[0][40] = data[152]; buffer[0][41] = data[153]; buffer[0][42] = data[154]; buffer[0][43] = data[155]; buffer[0][44] = data[156]; buffer[0][45] = data[157]; buffer[0][46] = data[158]; buffer[0][47] = data[159];

        }
        if (partition == 8) {
            buffer[0][0] = data[128]; buffer[0][1] = data[129]; buffer[0][2] = data[130]; buffer[0][3] = data[131]; buffer[0][4] = data[132]; buffer[0][5] = data[133]; buffer[0][6] = data[134]; buffer[0][7] = data[135]; buffer[0][8] = data[136]; buffer[0][9] = data[137]; buffer[0][10] = data[138]; buffer[0][11] = data[139]; buffer[0][12] = data[140]; buffer[0][13] = data[141]; buffer[0][14] = data[142]; buffer[0][15] = data[143]; buffer[0][16] = data[144]; buffer[0][17] = data[145]; buffer[0][18] = data[146]; buffer[0][19] = data[147]; buffer[0][20] = data[148]; buffer[0][21] = data[149]; buffer[0][22] = data[150]; buffer[0][23] = data[151]; buffer[0][24] = data[152]; buffer[0][25] = data[153]; buffer[0][26] = data[154]; buffer[0][27] = data[155]; buffer[0][28] = data[156]; buffer[0][29] = data[157]; buffer[0][30] = data[158]; buffer[0][31] = data[159]; buffer[0][32] = data[160]; buffer[0][33] = data[161]; buffer[0][34] = data[162]; buffer[0][35] = data[163]; buffer[0][36] = data[164]; buffer[0][37] = data[165]; buffer[0][38] = data[166]; buffer[0][39] = data[167]; buffer[0][40] = data[168]; buffer[0][41] = data[169]; buffer[0][42] = data[170]; buffer[0][43] = data[171]; buffer[0][44] = data[172]; buffer[0][45] = data[173]; buffer[0][46] = data[174]; buffer[0][47] = data[175];

        }
        if (partition == 9) {
            buffer[0][0] = data[144]; buffer[0][1] = data[145]; buffer[0][2] = data[146]; buffer[0][3] = data[147]; buffer[0][4] = data[148]; buffer[0][5] = data[149]; buffer[0][6] = data[150]; buffer[0][7] = data[151]; buffer[0][8] = data[152]; buffer[0][9] = data[153]; buffer[0][10] = data[154]; buffer[0][11] = data[155]; buffer[0][12] = data[156]; buffer[0][13] = data[157]; buffer[0][14] = data[158]; buffer[0][15] = data[159]; buffer[0][16] = data[160]; buffer[0][17] = data[161]; buffer[0][18] = data[162]; buffer[0][19] = data[163]; buffer[0][20] = data[164]; buffer[0][21] = data[165]; buffer[0][22] = data[166]; buffer[0][23] = data[167]; buffer[0][24] = data[168]; buffer[0][25] = data[169]; buffer[0][26] = data[170]; buffer[0][27] = data[171]; buffer[0][28] = data[172]; buffer[0][29] = data[173]; buffer[0][30] = data[174]; buffer[0][31] = data[175]; buffer[0][32] = data[176]; buffer[0][33] = data[177]; buffer[0][34] = data[178]; buffer[0][35] = data[179]; buffer[0][36] = data[180]; buffer[0][37] = data[181]; buffer[0][38] = data[182]; buffer[0][39] = data[183]; buffer[0][40] = data[184]; buffer[0][41] = data[185]; buffer[0][42] = data[186]; buffer[0][43] = data[187]; buffer[0][44] = data[188]; buffer[0][45] = data[189]; buffer[0][46] = data[190]; buffer[0][47] = data[191];

        }
        if (partition == 10) {
            buffer[0][0] = data[160]; buffer[0][1] = data[161]; buffer[0][2] = data[162]; buffer[0][3] = data[163]; buffer[0][4] = data[164]; buffer[0][5] = data[165]; buffer[0][6] = data[166]; buffer[0][7] = data[167]; buffer[0][8] = data[168]; buffer[0][9] = data[169]; buffer[0][10] = data[170]; buffer[0][11] = data[171]; buffer[0][12] = data[172]; buffer[0][13] = data[173]; buffer[0][14] = data[174]; buffer[0][15] = data[175]; buffer[0][16] = data[176]; buffer[0][17] = data[177]; buffer[0][18] = data[178]; buffer[0][19] = data[179]; buffer[0][20] = data[180]; buffer[0][21] = data[181]; buffer[0][22] = data[182]; buffer[0][23] = data[183]; buffer[0][24] = data[184]; buffer[0][25] = data[185]; buffer[0][26] = data[186]; buffer[0][27] = data[187]; buffer[0][28] = data[188]; buffer[0][29] = data[189]; buffer[0][30] = data[190]; buffer[0][31] = data[191]; buffer[0][32] = data[192]; buffer[0][33] = data[193]; buffer[0][34] = data[194]; buffer[0][35] = data[195]; buffer[0][36] = data[196]; buffer[0][37] = data[197]; buffer[0][38] = data[198]; buffer[0][39] = data[199]; buffer[0][40] = data[200]; buffer[0][41] = data[201]; buffer[0][42] = data[202]; buffer[0][43] = data[203]; buffer[0][44] = data[204]; buffer[0][45] = data[205]; buffer[0][46] = data[206]; buffer[0][47] = data[207];

        }
        if (partition == 11) {
            buffer[0][0] = data[176]; buffer[0][1] = data[177]; buffer[0][2] = data[178]; buffer[0][3] = data[179]; buffer[0][4] = data[180]; buffer[0][5] = data[181]; buffer[0][6] = data[182]; buffer[0][7] = data[183]; buffer[0][8] = data[184]; buffer[0][9] = data[185]; buffer[0][10] = data[186]; buffer[0][11] = data[187]; buffer[0][12] = data[188]; buffer[0][13] = data[189]; buffer[0][14] = data[190]; buffer[0][15] = data[191]; buffer[0][16] = data[192]; buffer[0][17] = data[193]; buffer[0][18] = data[194]; buffer[0][19] = data[195]; buffer[0][20] = data[196]; buffer[0][21] = data[197]; buffer[0][22] = data[198]; buffer[0][23] = data[199]; buffer[0][24] = data[200]; buffer[0][25] = data[201]; buffer[0][26] = data[202]; buffer[0][27] = data[203]; buffer[0][28] = data[204]; buffer[0][29] = data[205]; buffer[0][30] = data[206]; buffer[0][31] = data[207]; buffer[0][32] = data[208]; buffer[0][33] = data[209]; buffer[0][34] = data[210]; buffer[0][35] = data[211]; buffer[0][36] = data[212]; buffer[0][37] = data[213]; buffer[0][38] = data[214]; buffer[0][39] = data[215]; buffer[0][40] = data[216]; buffer[0][41] = data[217]; buffer[0][42] = data[218]; buffer[0][43] = data[219]; buffer[0][44] = data[220]; buffer[0][45] = data[221]; buffer[0][46] = data[222]; buffer[0][47] = data[223];

        }
        if (partition == 12) {
            buffer[0][0] = data[192]; buffer[0][1] = data[193]; buffer[0][2] = data[194]; buffer[0][3] = data[195]; buffer[0][4] = data[196]; buffer[0][5] = data[197]; buffer[0][6] = data[198]; buffer[0][7] = data[199]; buffer[0][8] = data[200]; buffer[0][9] = data[201]; buffer[0][10] = data[202]; buffer[0][11] = data[203]; buffer[0][12] = data[204]; buffer[0][13] = data[205]; buffer[0][14] = data[206]; buffer[0][15] = data[207]; buffer[0][16] = data[208]; buffer[0][17] = data[209]; buffer[0][18] = data[210]; buffer[0][19] = data[211]; buffer[0][20] = data[212]; buffer[0][21] = data[213]; buffer[0][22] = data[214]; buffer[0][23] = data[215]; buffer[0][24] = data[216]; buffer[0][25] = data[217]; buffer[0][26] = data[218]; buffer[0][27] = data[219]; buffer[0][28] = data[220]; buffer[0][29] = data[221]; buffer[0][30] = data[222]; buffer[0][31] = data[223]; buffer[0][32] = data[224]; buffer[0][33] = data[225]; buffer[0][34] = data[226]; buffer[0][35] = data[227]; buffer[0][36] = data[228]; buffer[0][37] = data[229]; buffer[0][38] = data[230]; buffer[0][39] = data[231]; buffer[0][40] = data[232]; buffer[0][41] = data[233]; buffer[0][42] = data[234]; buffer[0][43] = data[235]; buffer[0][44] = data[236]; buffer[0][45] = data[237]; buffer[0][46] = data[238]; buffer[0][47] = data[239];

        }
        if (partition == 13) {
            buffer[0][0] = data[208]; buffer[0][1] = data[209]; buffer[0][2] = data[210]; buffer[0][3] = data[211]; buffer[0][4] = data[212]; buffer[0][5] = data[213]; buffer[0][6] = data[214]; buffer[0][7] = data[215]; buffer[0][8] = data[216]; buffer[0][9] = data[217]; buffer[0][10] = data[218]; buffer[0][11] = data[219]; buffer[0][12] = data[220]; buffer[0][13] = data[221]; buffer[0][14] = data[222]; buffer[0][15] = data[223]; buffer[0][16] = data[224]; buffer[0][17] = data[225]; buffer[0][18] = data[226]; buffer[0][19] = data[227]; buffer[0][20] = data[228]; buffer[0][21] = data[229]; buffer[0][22] = data[230]; buffer[0][23] = data[231]; buffer[0][24] = data[232]; buffer[0][25] = data[233]; buffer[0][26] = data[234]; buffer[0][27] = data[235]; buffer[0][28] = data[236]; buffer[0][29] = data[237]; buffer[0][30] = data[238]; buffer[0][31] = data[239]; buffer[0][32] = data[240]; buffer[0][33] = data[241]; buffer[0][34] = data[242]; buffer[0][35] = data[243]; buffer[0][36] = data[244]; buffer[0][37] = data[245]; buffer[0][38] = data[246]; buffer[0][39] = data[247]; buffer[0][40] = data[248]; buffer[0][41] = data[249]; buffer[0][42] = data[250]; buffer[0][43] = data[251]; buffer[0][44] = data[252]; buffer[0][45] = data[253]; buffer[0][46] = data[254]; buffer[0][47] = data[255];

        }
        if (partition == 14) {
            buffer[0][0] = data[224]; buffer[0][1] = data[225]; buffer[0][2] = data[226]; buffer[0][3] = data[227]; buffer[0][4] = data[228]; buffer[0][5] = data[229]; buffer[0][6] = data[230]; buffer[0][7] = data[231]; buffer[0][8] = data[232]; buffer[0][9] = data[233]; buffer[0][10] = data[234]; buffer[0][11] = data[235]; buffer[0][12] = data[236]; buffer[0][13] = data[237]; buffer[0][14] = data[238]; buffer[0][15] = data[239]; buffer[0][16] = data[240]; buffer[0][17] = data[241]; buffer[0][18] = data[242]; buffer[0][19] = data[243]; buffer[0][20] = data[244]; buffer[0][21] = data[245]; buffer[0][22] = data[246]; buffer[0][23] = data[247]; buffer[0][24] = data[248]; buffer[0][25] = data[249]; buffer[0][26] = data[250]; buffer[0][27] = data[251]; buffer[0][28] = data[252]; buffer[0][29] = data[253]; buffer[0][30] = data[254]; buffer[0][31] = data[255]; buffer[0][32] = data[256]; buffer[0][33] = data[257]; buffer[0][34] = data[258]; buffer[0][35] = data[259]; buffer[0][36] = data[260]; buffer[0][37] = data[261]; buffer[0][38] = data[262]; buffer[0][39] = data[263]; buffer[0][40] = data[264]; buffer[0][41] = data[265]; buffer[0][42] = data[266]; buffer[0][43] = data[267]; buffer[0][44] = data[268]; buffer[0][45] = data[269]; buffer[0][46] = data[270]; buffer[0][47] = data[271];

        }
        if (partition == 15) {
            buffer[0][0] = data[240]; buffer[0][1] = data[241]; buffer[0][2] = data[242]; buffer[0][3] = data[243]; buffer[0][4] = data[244]; buffer[0][5] = data[245]; buffer[0][6] = data[246]; buffer[0][7] = data[247]; buffer[0][8] = data[248]; buffer[0][9] = data[249]; buffer[0][10] = data[250]; buffer[0][11] = data[251]; buffer[0][12] = data[252]; buffer[0][13] = data[253]; buffer[0][14] = data[254]; buffer[0][15] = data[255]; buffer[0][16] = data[256]; buffer[0][17] = data[257]; buffer[0][18] = data[258]; buffer[0][19] = data[259]; buffer[0][20] = data[260]; buffer[0][21] = data[261]; buffer[0][22] = data[262]; buffer[0][23] = data[263]; buffer[0][24] = data[264]; buffer[0][25] = data[265]; buffer[0][26] = data[266]; buffer[0][27] = data[267]; buffer[0][28] = data[268]; buffer[0][29] = data[269]; buffer[0][30] = data[270]; buffer[0][31] = data[271]; buffer[0][32] = data[272]; buffer[0][33] = data[273]; buffer[0][34] = data[274]; buffer[0][35] = data[275]; buffer[0][36] = data[276]; buffer[0][37] = data[277]; buffer[0][38] = data[278]; buffer[0][39] = data[279]; buffer[0][40] = data[280]; buffer[0][41] = data[281]; buffer[0][42] = data[282]; buffer[0][43] = data[283]; buffer[0][44] = data[284]; buffer[0][45] = data[285]; buffer[0][46] = data[286]; buffer[0][47] = data[287];

        }
        if (partition == 16) {
            buffer[0][0] = data[256]; buffer[0][1] = data[257]; buffer[0][2] = data[258]; buffer[0][3] = data[259]; buffer[0][4] = data[260]; buffer[0][5] = data[261]; buffer[0][6] = data[262]; buffer[0][7] = data[263]; buffer[0][8] = data[264]; buffer[0][9] = data[265]; buffer[0][10] = data[266]; buffer[0][11] = data[267]; buffer[0][12] = data[268]; buffer[0][13] = data[269]; buffer[0][14] = data[270]; buffer[0][15] = data[271]; buffer[0][16] = data[272]; buffer[0][17] = data[273]; buffer[0][18] = data[274]; buffer[0][19] = data[275]; buffer[0][20] = data[276]; buffer[0][21] = data[277]; buffer[0][22] = data[278]; buffer[0][23] = data[279]; buffer[0][24] = data[280]; buffer[0][25] = data[281]; buffer[0][26] = data[282]; buffer[0][27] = data[283]; buffer[0][28] = data[284]; buffer[0][29] = data[285]; buffer[0][30] = data[286]; buffer[0][31] = data[287]; buffer[0][32] = data[288]; buffer[0][33] = data[289]; buffer[0][34] = data[290]; buffer[0][35] = data[291]; buffer[0][36] = data[292]; buffer[0][37] = data[293]; buffer[0][38] = data[294]; buffer[0][39] = data[295]; buffer[0][40] = data[296]; buffer[0][41] = data[297]; buffer[0][42] = data[298]; buffer[0][43] = data[299]; buffer[0][44] = data[300]; buffer[0][45] = data[301]; buffer[0][46] = data[302]; buffer[0][47] = data[303];

        }
        if (partition == 17) {
            buffer[0][0] = data[272]; buffer[0][1] = data[273]; buffer[0][2] = data[274]; buffer[0][3] = data[275]; buffer[0][4] = data[276]; buffer[0][5] = data[277]; buffer[0][6] = data[278]; buffer[0][7] = data[279]; buffer[0][8] = data[280]; buffer[0][9] = data[281]; buffer[0][10] = data[282]; buffer[0][11] = data[283]; buffer[0][12] = data[284]; buffer[0][13] = data[285]; buffer[0][14] = data[286]; buffer[0][15] = data[287]; buffer[0][16] = data[288]; buffer[0][17] = data[289]; buffer[0][18] = data[290]; buffer[0][19] = data[291]; buffer[0][20] = data[292]; buffer[0][21] = data[293]; buffer[0][22] = data[294]; buffer[0][23] = data[295]; buffer[0][24] = data[296]; buffer[0][25] = data[297]; buffer[0][26] = data[298]; buffer[0][27] = data[299]; buffer[0][28] = data[300]; buffer[0][29] = data[301]; buffer[0][30] = data[302]; buffer[0][31] = data[303]; buffer[0][32] = data[304]; buffer[0][33] = data[305]; buffer[0][34] = data[306]; buffer[0][35] = data[307]; buffer[0][36] = data[308]; buffer[0][37] = data[309]; buffer[0][38] = data[310]; buffer[0][39] = data[311]; buffer[0][40] = data[312]; buffer[0][41] = data[313]; buffer[0][42] = data[314]; buffer[0][43] = data[315]; buffer[0][44] = data[316]; buffer[0][45] = data[317]; buffer[0][46] = data[318]; buffer[0][47] = data[319];

        }
        if (partition == 18) {
            buffer[0][0] = data[288]; buffer[0][1] = data[289]; buffer[0][2] = data[290]; buffer[0][3] = data[291]; buffer[0][4] = data[292]; buffer[0][5] = data[293]; buffer[0][6] = data[294]; buffer[0][7] = data[295]; buffer[0][8] = data[296]; buffer[0][9] = data[297]; buffer[0][10] = data[298]; buffer[0][11] = data[299]; buffer[0][12] = data[300]; buffer[0][13] = data[301]; buffer[0][14] = data[302]; buffer[0][15] = data[303]; buffer[0][16] = data[304]; buffer[0][17] = data[305]; buffer[0][18] = data[306]; buffer[0][19] = data[307]; buffer[0][20] = data[308]; buffer[0][21] = data[309]; buffer[0][22] = data[310]; buffer[0][23] = data[311]; buffer[0][24] = data[312]; buffer[0][25] = data[313]; buffer[0][26] = data[314]; buffer[0][27] = data[315]; buffer[0][28] = data[316]; buffer[0][29] = data[317]; buffer[0][30] = data[318]; buffer[0][31] = data[319]; buffer[0][32] = data[320]; buffer[0][33] = data[321]; buffer[0][34] = data[322]; buffer[0][35] = data[323]; buffer[0][36] = data[324]; buffer[0][37] = data[325]; buffer[0][38] = data[326]; buffer[0][39] = data[327]; buffer[0][40] = data[328]; buffer[0][41] = data[329]; buffer[0][42] = data[330]; buffer[0][43] = data[331]; buffer[0][44] = data[332]; buffer[0][45] = data[333]; buffer[0][46] = data[334]; buffer[0][47] = data[335];

        }
        if (partition == 19) {
            buffer[0][0] = data[304]; buffer[0][1] = data[305]; buffer[0][2] = data[306]; buffer[0][3] = data[307]; buffer[0][4] = data[308]; buffer[0][5] = data[309]; buffer[0][6] = data[310]; buffer[0][7] = data[311]; buffer[0][8] = data[312]; buffer[0][9] = data[313]; buffer[0][10] = data[314]; buffer[0][11] = data[315]; buffer[0][12] = data[316]; buffer[0][13] = data[317]; buffer[0][14] = data[318]; buffer[0][15] = data[319]; buffer[0][16] = data[320]; buffer[0][17] = data[321]; buffer[0][18] = data[322]; buffer[0][19] = data[323]; buffer[0][20] = data[324]; buffer[0][21] = data[325]; buffer[0][22] = data[326]; buffer[0][23] = data[327]; buffer[0][24] = data[328]; buffer[0][25] = data[329]; buffer[0][26] = data[330]; buffer[0][27] = data[331]; buffer[0][28] = data[332]; buffer[0][29] = data[333]; buffer[0][30] = data[334]; buffer[0][31] = data[335]; buffer[0][32] = data[336]; buffer[0][33] = data[337]; buffer[0][34] = data[338]; buffer[0][35] = data[339]; buffer[0][36] = data[340]; buffer[0][37] = data[341]; buffer[0][38] = data[342]; buffer[0][39] = data[343]; buffer[0][40] = data[344]; buffer[0][41] = data[345]; buffer[0][42] = data[346]; buffer[0][43] = data[347]; buffer[0][44] = data[348]; buffer[0][45] = data[349]; buffer[0][46] = data[350]; buffer[0][47] = data[351];

        }
        if (partition == 20) {
            buffer[0][0] = data[320]; buffer[0][1] = data[321]; buffer[0][2] = data[322]; buffer[0][3] = data[323]; buffer[0][4] = data[324]; buffer[0][5] = data[325]; buffer[0][6] = data[326]; buffer[0][7] = data[327]; buffer[0][8] = data[328]; buffer[0][9] = data[329]; buffer[0][10] = data[330]; buffer[0][11] = data[331]; buffer[0][12] = data[332]; buffer[0][13] = data[333]; buffer[0][14] = data[334]; buffer[0][15] = data[335]; buffer[0][16] = data[336]; buffer[0][17] = data[337]; buffer[0][18] = data[338]; buffer[0][19] = data[339]; buffer[0][20] = data[340]; buffer[0][21] = data[341]; buffer[0][22] = data[342]; buffer[0][23] = data[343]; buffer[0][24] = data[344]; buffer[0][25] = data[345]; buffer[0][26] = data[346]; buffer[0][27] = data[347]; buffer[0][28] = data[348]; buffer[0][29] = data[349]; buffer[0][30] = data[350]; buffer[0][31] = data[351]; buffer[0][32] = data[352]; buffer[0][33] = data[353]; buffer[0][34] = data[354]; buffer[0][35] = data[355]; buffer[0][36] = data[356]; buffer[0][37] = data[357]; buffer[0][38] = data[358]; buffer[0][39] = data[359]; buffer[0][40] = data[360]; buffer[0][41] = data[361]; buffer[0][42] = data[362]; buffer[0][43] = data[363]; buffer[0][44] = data[364]; buffer[0][45] = data[365]; buffer[0][46] = data[366]; buffer[0][47] = data[367];

        }
        if (partition == 21) {
            buffer[0][0] = data[336]; buffer[0][1] = data[337]; buffer[0][2] = data[338]; buffer[0][3] = data[339]; buffer[0][4] = data[340]; buffer[0][5] = data[341]; buffer[0][6] = data[342]; buffer[0][7] = data[343]; buffer[0][8] = data[344]; buffer[0][9] = data[345]; buffer[0][10] = data[346]; buffer[0][11] = data[347]; buffer[0][12] = data[348]; buffer[0][13] = data[349]; buffer[0][14] = data[350]; buffer[0][15] = data[351]; buffer[0][16] = data[352]; buffer[0][17] = data[353]; buffer[0][18] = data[354]; buffer[0][19] = data[355]; buffer[0][20] = data[356]; buffer[0][21] = data[357]; buffer[0][22] = data[358]; buffer[0][23] = data[359]; buffer[0][24] = data[360]; buffer[0][25] = data[361]; buffer[0][26] = data[362]; buffer[0][27] = data[363]; buffer[0][28] = data[364]; buffer[0][29] = data[365]; buffer[0][30] = data[366]; buffer[0][31] = data[367]; buffer[0][32] = data[368]; buffer[0][33] = data[369]; buffer[0][34] = data[370]; buffer[0][35] = data[371]; buffer[0][36] = data[372]; buffer[0][37] = data[373]; buffer[0][38] = data[374]; buffer[0][39] = data[375]; buffer[0][40] = data[376]; buffer[0][41] = data[377]; buffer[0][42] = data[378]; buffer[0][43] = data[379]; buffer[0][44] = data[380]; buffer[0][45] = data[381]; buffer[0][46] = data[382]; buffer[0][47] = data[383];

        }
        if (partition == 22) {
            buffer[0][0] = data[352]; buffer[0][1] = data[353]; buffer[0][2] = data[354]; buffer[0][3] = data[355]; buffer[0][4] = data[356]; buffer[0][5] = data[357]; buffer[0][6] = data[358]; buffer[0][7] = data[359]; buffer[0][8] = data[360]; buffer[0][9] = data[361]; buffer[0][10] = data[362]; buffer[0][11] = data[363]; buffer[0][12] = data[364]; buffer[0][13] = data[365]; buffer[0][14] = data[366]; buffer[0][15] = data[367]; buffer[0][16] = data[368]; buffer[0][17] = data[369]; buffer[0][18] = data[370]; buffer[0][19] = data[371]; buffer[0][20] = data[372]; buffer[0][21] = data[373]; buffer[0][22] = data[374]; buffer[0][23] = data[375]; buffer[0][24] = data[376]; buffer[0][25] = data[377]; buffer[0][26] = data[378]; buffer[0][27] = data[379]; buffer[0][28] = data[380]; buffer[0][29] = data[381]; buffer[0][30] = data[382]; buffer[0][31] = data[383]; buffer[0][32] = data[384]; buffer[0][33] = data[385]; buffer[0][34] = data[386]; buffer[0][35] = data[387]; buffer[0][36] = data[388]; buffer[0][37] = data[389]; buffer[0][38] = data[390]; buffer[0][39] = data[391]; buffer[0][40] = data[392]; buffer[0][41] = data[393]; buffer[0][42] = data[394]; buffer[0][43] = data[395]; buffer[0][44] = data[396]; buffer[0][45] = data[397]; buffer[0][46] = data[398]; buffer[0][47] = data[399];

        }
        if (partition == 23) {
            buffer[0][0] = data[368]; buffer[0][1] = data[369]; buffer[0][2] = data[370]; buffer[0][3] = data[371]; buffer[0][4] = data[372]; buffer[0][5] = data[373]; buffer[0][6] = data[374]; buffer[0][7] = data[375]; buffer[0][8] = data[376]; buffer[0][9] = data[377]; buffer[0][10] = data[378]; buffer[0][11] = data[379]; buffer[0][12] = data[380]; buffer[0][13] = data[381]; buffer[0][14] = data[382]; buffer[0][15] = data[383]; buffer[0][16] = data[384]; buffer[0][17] = data[385]; buffer[0][18] = data[386]; buffer[0][19] = data[387]; buffer[0][20] = data[388]; buffer[0][21] = data[389]; buffer[0][22] = data[390]; buffer[0][23] = data[391]; buffer[0][24] = data[392]; buffer[0][25] = data[393]; buffer[0][26] = data[394]; buffer[0][27] = data[395]; buffer[0][28] = data[396]; buffer[0][29] = data[397]; buffer[0][30] = data[398]; buffer[0][31] = data[399]; buffer[0][32] = data[400]; buffer[0][33] = data[401]; buffer[0][34] = data[402]; buffer[0][35] = data[403]; buffer[0][36] = data[404]; buffer[0][37] = data[405]; buffer[0][38] = data[406]; buffer[0][39] = data[407]; buffer[0][40] = data[408]; buffer[0][41] = data[409]; buffer[0][42] = data[410]; buffer[0][43] = data[411]; buffer[0][44] = data[412]; buffer[0][45] = data[413]; buffer[0][46] = data[414]; buffer[0][47] = data[415];

        }
        if (partition == 24) {
            buffer[0][0] = data[384]; buffer[0][1] = data[385]; buffer[0][2] = data[386]; buffer[0][3] = data[387]; buffer[0][4] = data[388]; buffer[0][5] = data[389]; buffer[0][6] = data[390]; buffer[0][7] = data[391]; buffer[0][8] = data[392]; buffer[0][9] = data[393]; buffer[0][10] = data[394]; buffer[0][11] = data[395]; buffer[0][12] = data[396]; buffer[0][13] = data[397]; buffer[0][14] = data[398]; buffer[0][15] = data[399]; buffer[0][16] = data[400]; buffer[0][17] = data[401]; buffer[0][18] = data[402]; buffer[0][19] = data[403]; buffer[0][20] = data[404]; buffer[0][21] = data[405]; buffer[0][22] = data[406]; buffer[0][23] = data[407]; buffer[0][24] = data[408]; buffer[0][25] = data[409]; buffer[0][26] = data[410]; buffer[0][27] = data[411]; buffer[0][28] = data[412]; buffer[0][29] = data[413]; buffer[0][30] = data[414]; buffer[0][31] = data[415]; buffer[0][32] = data[416]; buffer[0][33] = data[417]; buffer[0][34] = data[418]; buffer[0][35] = data[419]; buffer[0][36] = data[420]; buffer[0][37] = data[421]; buffer[0][38] = data[422]; buffer[0][39] = data[423]; buffer[0][40] = data[424]; buffer[0][41] = data[425]; buffer[0][42] = data[426]; buffer[0][43] = data[427]; buffer[0][44] = data[428]; buffer[0][45] = data[429]; buffer[0][46] = data[430]; buffer[0][47] = data[431];

        }
        if (partition == 25) {
            buffer[0][0] = data[400]; buffer[0][1] = data[401]; buffer[0][2] = data[402]; buffer[0][3] = data[403]; buffer[0][4] = data[404]; buffer[0][5] = data[405]; buffer[0][6] = data[406]; buffer[0][7] = data[407]; buffer[0][8] = data[408]; buffer[0][9] = data[409]; buffer[0][10] = data[410]; buffer[0][11] = data[411]; buffer[0][12] = data[412]; buffer[0][13] = data[413]; buffer[0][14] = data[414]; buffer[0][15] = data[415]; buffer[0][16] = data[416]; buffer[0][17] = data[417]; buffer[0][18] = data[418]; buffer[0][19] = data[419]; buffer[0][20] = data[420]; buffer[0][21] = data[421]; buffer[0][22] = data[422]; buffer[0][23] = data[423]; buffer[0][24] = data[424]; buffer[0][25] = data[425]; buffer[0][26] = data[426]; buffer[0][27] = data[427]; buffer[0][28] = data[428]; buffer[0][29] = data[429]; buffer[0][30] = data[430]; buffer[0][31] = data[431]; buffer[0][32] = data[432]; buffer[0][33] = data[433]; buffer[0][34] = data[434]; buffer[0][35] = data[435]; buffer[0][36] = data[436]; buffer[0][37] = data[437]; buffer[0][38] = data[438]; buffer[0][39] = data[439]; buffer[0][40] = data[440]; buffer[0][41] = data[441]; buffer[0][42] = data[442]; buffer[0][43] = data[443]; buffer[0][44] = data[444]; buffer[0][45] = data[445]; buffer[0][46] = data[446]; buffer[0][47] = data[447];

        }
        if (partition == 26) {
            buffer[0][0] = data[416]; buffer[0][1] = data[417]; buffer[0][2] = data[418]; buffer[0][3] = data[419]; buffer[0][4] = data[420]; buffer[0][5] = data[421]; buffer[0][6] = data[422]; buffer[0][7] = data[423]; buffer[0][8] = data[424]; buffer[0][9] = data[425]; buffer[0][10] = data[426]; buffer[0][11] = data[427]; buffer[0][12] = data[428]; buffer[0][13] = data[429]; buffer[0][14] = data[430]; buffer[0][15] = data[431]; buffer[0][16] = data[432]; buffer[0][17] = data[433]; buffer[0][18] = data[434]; buffer[0][19] = data[435]; buffer[0][20] = data[436]; buffer[0][21] = data[437]; buffer[0][22] = data[438]; buffer[0][23] = data[439]; buffer[0][24] = data[440]; buffer[0][25] = data[441]; buffer[0][26] = data[442]; buffer[0][27] = data[443]; buffer[0][28] = data[444]; buffer[0][29] = data[445]; buffer[0][30] = data[446]; buffer[0][31] = data[447]; buffer[0][32] = data[448]; buffer[0][33] = data[449]; buffer[0][34] = data[450]; buffer[0][35] = data[451]; buffer[0][36] = data[452]; buffer[0][37] = data[453]; buffer[0][38] = data[454]; buffer[0][39] = data[455]; buffer[0][40] = data[456]; buffer[0][41] = data[457]; buffer[0][42] = data[458]; buffer[0][43] = data[459]; buffer[0][44] = data[460]; buffer[0][45] = data[461]; buffer[0][46] = data[462]; buffer[0][47] = data[463];

        }
        if (partition == 27) {
            buffer[0][0] = data[432]; buffer[0][1] = data[433]; buffer[0][2] = data[434]; buffer[0][3] = data[435]; buffer[0][4] = data[436]; buffer[0][5] = data[437]; buffer[0][6] = data[438]; buffer[0][7] = data[439]; buffer[0][8] = data[440]; buffer[0][9] = data[441]; buffer[0][10] = data[442]; buffer[0][11] = data[443]; buffer[0][12] = data[444]; buffer[0][13] = data[445]; buffer[0][14] = data[446]; buffer[0][15] = data[447]; buffer[0][16] = data[448]; buffer[0][17] = data[449]; buffer[0][18] = data[450]; buffer[0][19] = data[451]; buffer[0][20] = data[452]; buffer[0][21] = data[453]; buffer[0][22] = data[454]; buffer[0][23] = data[455]; buffer[0][24] = data[456]; buffer[0][25] = data[457]; buffer[0][26] = data[458]; buffer[0][27] = data[459]; buffer[0][28] = data[460]; buffer[0][29] = data[461]; buffer[0][30] = data[462]; buffer[0][31] = data[463]; buffer[0][32] = data[464]; buffer[0][33] = data[465]; buffer[0][34] = data[466]; buffer[0][35] = data[467]; buffer[0][36] = data[468]; buffer[0][37] = data[469]; buffer[0][38] = data[470]; buffer[0][39] = data[471]; buffer[0][40] = data[472]; buffer[0][41] = data[473]; buffer[0][42] = data[474]; buffer[0][43] = data[475]; buffer[0][44] = data[476]; buffer[0][45] = data[477]; buffer[0][46] = data[478]; buffer[0][47] = data[479];

        }
        if (partition == 28) {
            buffer[0][0] = data[448]; buffer[0][1] = data[449]; buffer[0][2] = data[450]; buffer[0][3] = data[451]; buffer[0][4] = data[452]; buffer[0][5] = data[453]; buffer[0][6] = data[454]; buffer[0][7] = data[455]; buffer[0][8] = data[456]; buffer[0][9] = data[457]; buffer[0][10] = data[458]; buffer[0][11] = data[459]; buffer[0][12] = data[460]; buffer[0][13] = data[461]; buffer[0][14] = data[462]; buffer[0][15] = data[463]; buffer[0][16] = data[464]; buffer[0][17] = data[465]; buffer[0][18] = data[466]; buffer[0][19] = data[467]; buffer[0][20] = data[468]; buffer[0][21] = data[469]; buffer[0][22] = data[470]; buffer[0][23] = data[471]; buffer[0][24] = data[472]; buffer[0][25] = data[473]; buffer[0][26] = data[474]; buffer[0][27] = data[475]; buffer[0][28] = data[476]; buffer[0][29] = data[477]; buffer[0][30] = data[478]; buffer[0][31] = data[479]; buffer[0][32] = data[480]; buffer[0][33] = data[481]; buffer[0][34] = data[482]; buffer[0][35] = data[483]; buffer[0][36] = data[484]; buffer[0][37] = data[485]; buffer[0][38] = data[486]; buffer[0][39] = data[487]; buffer[0][40] = data[488]; buffer[0][41] = data[489]; buffer[0][42] = data[490]; buffer[0][43] = data[491]; buffer[0][44] = data[492]; buffer[0][45] = data[493]; buffer[0][46] = data[494]; buffer[0][47] = data[495];

        }
        if (partition == 29) {
            buffer[0][0] = data[464]; buffer[0][1] = data[465]; buffer[0][2] = data[466]; buffer[0][3] = data[467]; buffer[0][4] = data[468]; buffer[0][5] = data[469]; buffer[0][6] = data[470]; buffer[0][7] = data[471]; buffer[0][8] = data[472]; buffer[0][9] = data[473]; buffer[0][10] = data[474]; buffer[0][11] = data[475]; buffer[0][12] = data[476]; buffer[0][13] = data[477]; buffer[0][14] = data[478]; buffer[0][15] = data[479]; buffer[0][16] = data[480]; buffer[0][17] = data[481]; buffer[0][18] = data[482]; buffer[0][19] = data[483]; buffer[0][20] = data[484]; buffer[0][21] = data[485]; buffer[0][22] = data[486]; buffer[0][23] = data[487]; buffer[0][24] = data[488]; buffer[0][25] = data[489]; buffer[0][26] = data[490]; buffer[0][27] = data[491]; buffer[0][28] = data[492]; buffer[0][29] = data[493]; buffer[0][30] = data[494]; buffer[0][31] = data[495]; buffer[0][32] = data[496]; buffer[0][33] = data[497]; buffer[0][34] = data[498]; buffer[0][35] = data[499]; buffer[0][36] = data[500]; buffer[0][37] = data[501]; buffer[0][38] = data[502]; buffer[0][39] = data[503]; buffer[0][40] = data[504]; buffer[0][41] = data[505]; buffer[0][42] = data[506]; buffer[0][43] = data[507]; buffer[0][44] = data[508]; buffer[0][45] = data[509]; buffer[0][46] = data[510]; buffer[0][47] = data[511];

        }
        if (partition == 30) {
            buffer[0][0] = data[480]; buffer[0][1] = data[481]; buffer[0][2] = data[482]; buffer[0][3] = data[483]; buffer[0][4] = data[484]; buffer[0][5] = data[485]; buffer[0][6] = data[486]; buffer[0][7] = data[487]; buffer[0][8] = data[488]; buffer[0][9] = data[489]; buffer[0][10] = data[490]; buffer[0][11] = data[491]; buffer[0][12] = data[492]; buffer[0][13] = data[493]; buffer[0][14] = data[494]; buffer[0][15] = data[495]; buffer[0][16] = data[496]; buffer[0][17] = data[497]; buffer[0][18] = data[498]; buffer[0][19] = data[499]; buffer[0][20] = data[500]; buffer[0][21] = data[501]; buffer[0][22] = data[502]; buffer[0][23] = data[503]; buffer[0][24] = data[504]; buffer[0][25] = data[505]; buffer[0][26] = data[506]; buffer[0][27] = data[507]; buffer[0][28] = data[508]; buffer[0][29] = data[509]; buffer[0][30] = data[510]; buffer[0][31] = data[511]; buffer[0][32] = data[512]; buffer[0][33] = data[513]; buffer[0][34] = data[514]; buffer[0][35] = data[515]; buffer[0][36] = data[516]; buffer[0][37] = data[517]; buffer[0][38] = data[518]; buffer[0][39] = data[519]; buffer[0][40] = data[520]; buffer[0][41] = data[521]; buffer[0][42] = data[522]; buffer[0][43] = data[523]; buffer[0][44] = data[524]; buffer[0][45] = data[525]; buffer[0][46] = data[526]; buffer[0][47] = data[527];

        }
        if (partition == 31) {
            buffer[0][0] = data[496]; buffer[0][1] = data[497]; buffer[0][2] = data[498]; buffer[0][3] = data[499]; buffer[0][4] = data[500]; buffer[0][5] = data[501]; buffer[0][6] = data[502]; buffer[0][7] = data[503]; buffer[0][8] = data[504]; buffer[0][9] = data[505]; buffer[0][10] = data[506]; buffer[0][11] = data[507]; buffer[0][12] = data[508]; buffer[0][13] = data[509]; buffer[0][14] = data[510]; buffer[0][15] = data[511]; buffer[0][16] = data[512]; buffer[0][17] = data[513]; buffer[0][18] = data[514]; buffer[0][19] = data[515]; buffer[0][20] = data[516]; buffer[0][21] = data[517]; buffer[0][22] = data[518]; buffer[0][23] = data[519]; buffer[0][24] = data[520]; buffer[0][25] = data[521]; buffer[0][26] = data[522]; buffer[0][27] = data[523]; buffer[0][28] = data[524]; buffer[0][29] = data[525]; buffer[0][30] = data[526]; buffer[0][31] = data[527]; buffer[0][32] = data[528]; buffer[0][33] = data[529]; buffer[0][34] = data[530]; buffer[0][35] = data[531]; buffer[0][36] = data[532]; buffer[0][37] = data[533]; buffer[0][38] = data[534]; buffer[0][39] = data[535]; buffer[0][40] = data[536]; buffer[0][41] = data[537]; buffer[0][42] = data[538]; buffer[0][43] = data[539]; buffer[0][44] = data[540]; buffer[0][45] = data[541]; buffer[0][46] = data[542]; buffer[0][47] = data[543];

        }
        if (partition == 32) {
            buffer[0][0] = data[512]; buffer[0][1] = data[513]; buffer[0][2] = data[514]; buffer[0][3] = data[515]; buffer[0][4] = data[516]; buffer[0][5] = data[517]; buffer[0][6] = data[518]; buffer[0][7] = data[519]; buffer[0][8] = data[520]; buffer[0][9] = data[521]; buffer[0][10] = data[522]; buffer[0][11] = data[523]; buffer[0][12] = data[524]; buffer[0][13] = data[525]; buffer[0][14] = data[526]; buffer[0][15] = data[527]; buffer[0][16] = data[528]; buffer[0][17] = data[529]; buffer[0][18] = data[530]; buffer[0][19] = data[531]; buffer[0][20] = data[532]; buffer[0][21] = data[533]; buffer[0][22] = data[534]; buffer[0][23] = data[535]; buffer[0][24] = data[536]; buffer[0][25] = data[537]; buffer[0][26] = data[538]; buffer[0][27] = data[539]; buffer[0][28] = data[540]; buffer[0][29] = data[541]; buffer[0][30] = data[542]; buffer[0][31] = data[543]; buffer[0][32] = data[544]; buffer[0][33] = data[545]; buffer[0][34] = data[546]; buffer[0][35] = data[547]; buffer[0][36] = data[548]; buffer[0][37] = data[549]; buffer[0][38] = data[550]; buffer[0][39] = data[551]; buffer[0][40] = data[552]; buffer[0][41] = data[553]; buffer[0][42] = data[554]; buffer[0][43] = data[555]; buffer[0][44] = data[556]; buffer[0][45] = data[557]; buffer[0][46] = data[558]; buffer[0][47] = data[559];

        }
        if (partition == 33) {
            buffer[0][0] = data[528]; buffer[0][1] = data[529]; buffer[0][2] = data[530]; buffer[0][3] = data[531]; buffer[0][4] = data[532]; buffer[0][5] = data[533]; buffer[0][6] = data[534]; buffer[0][7] = data[535]; buffer[0][8] = data[536]; buffer[0][9] = data[537]; buffer[0][10] = data[538]; buffer[0][11] = data[539]; buffer[0][12] = data[540]; buffer[0][13] = data[541]; buffer[0][14] = data[542]; buffer[0][15] = data[543]; buffer[0][16] = data[544]; buffer[0][17] = data[545]; buffer[0][18] = data[546]; buffer[0][19] = data[547]; buffer[0][20] = data[548]; buffer[0][21] = data[549]; buffer[0][22] = data[550]; buffer[0][23] = data[551]; buffer[0][24] = data[552]; buffer[0][25] = data[553]; buffer[0][26] = data[554]; buffer[0][27] = data[555]; buffer[0][28] = data[556]; buffer[0][29] = data[557]; buffer[0][30] = data[558]; buffer[0][31] = data[559]; buffer[0][32] = data[560]; buffer[0][33] = data[561]; buffer[0][34] = data[562]; buffer[0][35] = data[563]; buffer[0][36] = data[564]; buffer[0][37] = data[565]; buffer[0][38] = data[566]; buffer[0][39] = data[567]; buffer[0][40] = data[568]; buffer[0][41] = data[569]; buffer[0][42] = data[570]; buffer[0][43] = data[571]; buffer[0][44] = data[572]; buffer[0][45] = data[573]; buffer[0][46] = data[574]; buffer[0][47] = data[575];

        }
        if (partition == 34) {
            buffer[0][0] = data[544]; buffer[0][1] = data[545]; buffer[0][2] = data[546]; buffer[0][3] = data[547]; buffer[0][4] = data[548]; buffer[0][5] = data[549]; buffer[0][6] = data[550]; buffer[0][7] = data[551]; buffer[0][8] = data[552]; buffer[0][9] = data[553]; buffer[0][10] = data[554]; buffer[0][11] = data[555]; buffer[0][12] = data[556]; buffer[0][13] = data[557]; buffer[0][14] = data[558]; buffer[0][15] = data[559]; buffer[0][16] = data[560]; buffer[0][17] = data[561]; buffer[0][18] = data[562]; buffer[0][19] = data[563]; buffer[0][20] = data[564]; buffer[0][21] = data[565]; buffer[0][22] = data[566]; buffer[0][23] = data[567]; buffer[0][24] = data[568]; buffer[0][25] = data[569]; buffer[0][26] = data[570]; buffer[0][27] = data[571]; buffer[0][28] = data[572]; buffer[0][29] = data[573]; buffer[0][30] = data[574]; buffer[0][31] = data[575]; buffer[0][32] = data[576]; buffer[0][33] = data[577]; buffer[0][34] = data[578]; buffer[0][35] = data[579]; buffer[0][36] = data[580]; buffer[0][37] = data[581]; buffer[0][38] = data[582]; buffer[0][39] = data[583]; buffer[0][40] = data[584]; buffer[0][41] = data[585]; buffer[0][42] = data[586]; buffer[0][43] = data[587]; buffer[0][44] = data[588]; buffer[0][45] = data[589]; buffer[0][46] = data[590]; buffer[0][47] = data[591];

        }
        if (partition == 35) {
            buffer[0][0] = data[560]; buffer[0][1] = data[561]; buffer[0][2] = data[562]; buffer[0][3] = data[563]; buffer[0][4] = data[564]; buffer[0][5] = data[565]; buffer[0][6] = data[566]; buffer[0][7] = data[567]; buffer[0][8] = data[568]; buffer[0][9] = data[569]; buffer[0][10] = data[570]; buffer[0][11] = data[571]; buffer[0][12] = data[572]; buffer[0][13] = data[573]; buffer[0][14] = data[574]; buffer[0][15] = data[575]; buffer[0][16] = data[576]; buffer[0][17] = data[577]; buffer[0][18] = data[578]; buffer[0][19] = data[579]; buffer[0][20] = data[580]; buffer[0][21] = data[581]; buffer[0][22] = data[582]; buffer[0][23] = data[583]; buffer[0][24] = data[584]; buffer[0][25] = data[585]; buffer[0][26] = data[586]; buffer[0][27] = data[587]; buffer[0][28] = data[588]; buffer[0][29] = data[589]; buffer[0][30] = data[590]; buffer[0][31] = data[591]; buffer[0][32] = data[592]; buffer[0][33] = data[593]; buffer[0][34] = data[594]; buffer[0][35] = data[595]; buffer[0][36] = data[596]; buffer[0][37] = data[597]; buffer[0][38] = data[598]; buffer[0][39] = data[599]; buffer[0][40] = data[600]; buffer[0][41] = data[601]; buffer[0][42] = data[602]; buffer[0][43] = data[603]; buffer[0][44] = data[604]; buffer[0][45] = data[605]; buffer[0][46] = data[606]; buffer[0][47] = data[607];

        }
        if (partition == 36) {
            buffer[0][0] = data[576]; buffer[0][1] = data[577]; buffer[0][2] = data[578]; buffer[0][3] = data[579]; buffer[0][4] = data[580]; buffer[0][5] = data[581]; buffer[0][6] = data[582]; buffer[0][7] = data[583]; buffer[0][8] = data[584]; buffer[0][9] = data[585]; buffer[0][10] = data[586]; buffer[0][11] = data[587]; buffer[0][12] = data[588]; buffer[0][13] = data[589]; buffer[0][14] = data[590]; buffer[0][15] = data[591]; buffer[0][16] = data[592]; buffer[0][17] = data[593]; buffer[0][18] = data[594]; buffer[0][19] = data[595]; buffer[0][20] = data[596]; buffer[0][21] = data[597]; buffer[0][22] = data[598]; buffer[0][23] = data[599]; buffer[0][24] = data[600]; buffer[0][25] = data[601]; buffer[0][26] = data[602]; buffer[0][27] = data[603]; buffer[0][28] = data[604]; buffer[0][29] = data[605]; buffer[0][30] = data[606]; buffer[0][31] = data[607]; buffer[0][32] = data[608]; buffer[0][33] = data[609]; buffer[0][34] = data[610]; buffer[0][35] = data[611]; buffer[0][36] = data[612]; buffer[0][37] = data[613]; buffer[0][38] = data[614]; buffer[0][39] = data[615]; buffer[0][40] = data[616]; buffer[0][41] = data[617]; buffer[0][42] = data[618]; buffer[0][43] = data[619]; buffer[0][44] = data[620]; buffer[0][45] = data[621]; buffer[0][46] = data[622]; buffer[0][47] = data[623];

        }
        if (partition == 37) {
            buffer[0][0] = data[592]; buffer[0][1] = data[593]; buffer[0][2] = data[594]; buffer[0][3] = data[595]; buffer[0][4] = data[596]; buffer[0][5] = data[597]; buffer[0][6] = data[598]; buffer[0][7] = data[599]; buffer[0][8] = data[600]; buffer[0][9] = data[601]; buffer[0][10] = data[602]; buffer[0][11] = data[603]; buffer[0][12] = data[604]; buffer[0][13] = data[605]; buffer[0][14] = data[606]; buffer[0][15] = data[607]; buffer[0][16] = data[608]; buffer[0][17] = data[609]; buffer[0][18] = data[610]; buffer[0][19] = data[611]; buffer[0][20] = data[612]; buffer[0][21] = data[613]; buffer[0][22] = data[614]; buffer[0][23] = data[615]; buffer[0][24] = data[616]; buffer[0][25] = data[617]; buffer[0][26] = data[618]; buffer[0][27] = data[619]; buffer[0][28] = data[620]; buffer[0][29] = data[621]; buffer[0][30] = data[622]; buffer[0][31] = data[623]; buffer[0][32] = data[624]; buffer[0][33] = data[625]; buffer[0][34] = data[626]; buffer[0][35] = data[627]; buffer[0][36] = data[628]; buffer[0][37] = data[629]; buffer[0][38] = data[630]; buffer[0][39] = data[631]; buffer[0][40] = data[632]; buffer[0][41] = data[633]; buffer[0][42] = data[634]; buffer[0][43] = data[635]; buffer[0][44] = data[636]; buffer[0][45] = data[637]; buffer[0][46] = data[638]; buffer[0][47] = data[639];

        }
        if (partition == 38) {
            buffer[0][0] = data[608]; buffer[0][1] = data[609]; buffer[0][2] = data[610]; buffer[0][3] = data[611]; buffer[0][4] = data[612]; buffer[0][5] = data[613]; buffer[0][6] = data[614]; buffer[0][7] = data[615]; buffer[0][8] = data[616]; buffer[0][9] = data[617]; buffer[0][10] = data[618]; buffer[0][11] = data[619]; buffer[0][12] = data[620]; buffer[0][13] = data[621]; buffer[0][14] = data[622]; buffer[0][15] = data[623]; buffer[0][16] = data[624]; buffer[0][17] = data[625]; buffer[0][18] = data[626]; buffer[0][19] = data[627]; buffer[0][20] = data[628]; buffer[0][21] = data[629]; buffer[0][22] = data[630]; buffer[0][23] = data[631]; buffer[0][24] = data[632]; buffer[0][25] = data[633]; buffer[0][26] = data[634]; buffer[0][27] = data[635]; buffer[0][28] = data[636]; buffer[0][29] = data[637]; buffer[0][30] = data[638]; buffer[0][31] = data[639]; buffer[0][32] = data[640]; buffer[0][33] = data[641]; buffer[0][34] = data[642]; buffer[0][35] = data[643]; buffer[0][36] = data[644]; buffer[0][37] = data[645]; buffer[0][38] = data[646]; buffer[0][39] = data[647]; buffer[0][40] = data[648]; buffer[0][41] = data[649]; buffer[0][42] = data[650]; buffer[0][43] = data[651]; buffer[0][44] = data[652]; buffer[0][45] = data[653]; buffer[0][46] = data[654]; buffer[0][47] = data[655];

        }
        if (partition == 39) {
            buffer[0][0] = data[624]; buffer[0][1] = data[625]; buffer[0][2] = data[626]; buffer[0][3] = data[627]; buffer[0][4] = data[628]; buffer[0][5] = data[629]; buffer[0][6] = data[630]; buffer[0][7] = data[631]; buffer[0][8] = data[632]; buffer[0][9] = data[633]; buffer[0][10] = data[634]; buffer[0][11] = data[635]; buffer[0][12] = data[636]; buffer[0][13] = data[637]; buffer[0][14] = data[638]; buffer[0][15] = data[639]; buffer[0][16] = data[640]; buffer[0][17] = data[641]; buffer[0][18] = data[642]; buffer[0][19] = data[643]; buffer[0][20] = data[644]; buffer[0][21] = data[645]; buffer[0][22] = data[646]; buffer[0][23] = data[647]; buffer[0][24] = data[648]; buffer[0][25] = data[649]; buffer[0][26] = data[650]; buffer[0][27] = data[651]; buffer[0][28] = data[652]; buffer[0][29] = data[653]; buffer[0][30] = data[654]; buffer[0][31] = data[655]; buffer[0][32] = data[656]; buffer[0][33] = data[657]; buffer[0][34] = data[658]; buffer[0][35] = data[659]; buffer[0][36] = data[660]; buffer[0][37] = data[661]; buffer[0][38] = data[662]; buffer[0][39] = data[663]; buffer[0][40] = data[664]; buffer[0][41] = data[665]; buffer[0][42] = data[666]; buffer[0][43] = data[667]; buffer[0][44] = data[668]; buffer[0][45] = data[669]; buffer[0][46] = data[670]; buffer[0][47] = data[671];

        }
        if (partition == 40) {
            buffer[0][0] = data[640]; buffer[0][1] = data[641]; buffer[0][2] = data[642]; buffer[0][3] = data[643]; buffer[0][4] = data[644]; buffer[0][5] = data[645]; buffer[0][6] = data[646]; buffer[0][7] = data[647]; buffer[0][8] = data[648]; buffer[0][9] = data[649]; buffer[0][10] = data[650]; buffer[0][11] = data[651]; buffer[0][12] = data[652]; buffer[0][13] = data[653]; buffer[0][14] = data[654]; buffer[0][15] = data[655]; buffer[0][16] = data[656]; buffer[0][17] = data[657]; buffer[0][18] = data[658]; buffer[0][19] = data[659]; buffer[0][20] = data[660]; buffer[0][21] = data[661]; buffer[0][22] = data[662]; buffer[0][23] = data[663]; buffer[0][24] = data[664]; buffer[0][25] = data[665]; buffer[0][26] = data[666]; buffer[0][27] = data[667]; buffer[0][28] = data[668]; buffer[0][29] = data[669]; buffer[0][30] = data[670]; buffer[0][31] = data[671]; buffer[0][32] = data[672]; buffer[0][33] = data[673]; buffer[0][34] = data[674]; buffer[0][35] = data[675]; buffer[0][36] = data[676]; buffer[0][37] = data[677]; buffer[0][38] = data[678]; buffer[0][39] = data[679]; buffer[0][40] = data[680]; buffer[0][41] = data[681]; buffer[0][42] = data[682]; buffer[0][43] = data[683]; buffer[0][44] = data[684]; buffer[0][45] = data[685]; buffer[0][46] = data[686]; buffer[0][47] = data[687];

        }
        if (partition == 41) {
            buffer[0][0] = data[656]; buffer[0][1] = data[657]; buffer[0][2] = data[658]; buffer[0][3] = data[659]; buffer[0][4] = data[660]; buffer[0][5] = data[661]; buffer[0][6] = data[662]; buffer[0][7] = data[663]; buffer[0][8] = data[664]; buffer[0][9] = data[665]; buffer[0][10] = data[666]; buffer[0][11] = data[667]; buffer[0][12] = data[668]; buffer[0][13] = data[669]; buffer[0][14] = data[670]; buffer[0][15] = data[671]; buffer[0][16] = data[672]; buffer[0][17] = data[673]; buffer[0][18] = data[674]; buffer[0][19] = data[675]; buffer[0][20] = data[676]; buffer[0][21] = data[677]; buffer[0][22] = data[678]; buffer[0][23] = data[679]; buffer[0][24] = data[680]; buffer[0][25] = data[681]; buffer[0][26] = data[682]; buffer[0][27] = data[683]; buffer[0][28] = data[684]; buffer[0][29] = data[685]; buffer[0][30] = data[686]; buffer[0][31] = data[687]; buffer[0][32] = data[688]; buffer[0][33] = data[689]; buffer[0][34] = data[690]; buffer[0][35] = data[691]; buffer[0][36] = data[692]; buffer[0][37] = data[693]; buffer[0][38] = data[694]; buffer[0][39] = data[695]; buffer[0][40] = data[696]; buffer[0][41] = data[697]; buffer[0][42] = data[698]; buffer[0][43] = data[699]; buffer[0][44] = data[700]; buffer[0][45] = data[701]; buffer[0][46] = data[702]; buffer[0][47] = data[703];

        }
        if (partition == 42) {
            buffer[0][0] = data[672]; buffer[0][1] = data[673]; buffer[0][2] = data[674]; buffer[0][3] = data[675]; buffer[0][4] = data[676]; buffer[0][5] = data[677]; buffer[0][6] = data[678]; buffer[0][7] = data[679]; buffer[0][8] = data[680]; buffer[0][9] = data[681]; buffer[0][10] = data[682]; buffer[0][11] = data[683]; buffer[0][12] = data[684]; buffer[0][13] = data[685]; buffer[0][14] = data[686]; buffer[0][15] = data[687]; buffer[0][16] = data[688]; buffer[0][17] = data[689]; buffer[0][18] = data[690]; buffer[0][19] = data[691]; buffer[0][20] = data[692]; buffer[0][21] = data[693]; buffer[0][22] = data[694]; buffer[0][23] = data[695]; buffer[0][24] = data[696]; buffer[0][25] = data[697]; buffer[0][26] = data[698]; buffer[0][27] = data[699]; buffer[0][28] = data[700]; buffer[0][29] = data[701]; buffer[0][30] = data[702]; buffer[0][31] = data[703]; buffer[0][32] = data[704]; buffer[0][33] = data[705]; buffer[0][34] = data[706]; buffer[0][35] = data[707]; buffer[0][36] = data[708]; buffer[0][37] = data[709]; buffer[0][38] = data[710]; buffer[0][39] = data[711]; buffer[0][40] = data[712]; buffer[0][41] = data[713]; buffer[0][42] = data[714]; buffer[0][43] = data[715]; buffer[0][44] = data[716]; buffer[0][45] = data[717]; buffer[0][46] = data[718]; buffer[0][47] = data[719];

        }
        if (partition == 43) {
            buffer[0][0] = data[688]; buffer[0][1] = data[689]; buffer[0][2] = data[690]; buffer[0][3] = data[691]; buffer[0][4] = data[692]; buffer[0][5] = data[693]; buffer[0][6] = data[694]; buffer[0][7] = data[695]; buffer[0][8] = data[696]; buffer[0][9] = data[697]; buffer[0][10] = data[698]; buffer[0][11] = data[699]; buffer[0][12] = data[700]; buffer[0][13] = data[701]; buffer[0][14] = data[702]; buffer[0][15] = data[703]; buffer[0][16] = data[704]; buffer[0][17] = data[705]; buffer[0][18] = data[706]; buffer[0][19] = data[707]; buffer[0][20] = data[708]; buffer[0][21] = data[709]; buffer[0][22] = data[710]; buffer[0][23] = data[711]; buffer[0][24] = data[712]; buffer[0][25] = data[713]; buffer[0][26] = data[714]; buffer[0][27] = data[715]; buffer[0][28] = data[716]; buffer[0][29] = data[717]; buffer[0][30] = data[718]; buffer[0][31] = data[719]; buffer[0][32] = data[720]; buffer[0][33] = data[721]; buffer[0][34] = data[722]; buffer[0][35] = data[723]; buffer[0][36] = data[724]; buffer[0][37] = data[725]; buffer[0][38] = data[726]; buffer[0][39] = data[727]; buffer[0][40] = data[728]; buffer[0][41] = data[729]; buffer[0][42] = data[730]; buffer[0][43] = data[731]; buffer[0][44] = data[732]; buffer[0][45] = data[733]; buffer[0][46] = data[734]; buffer[0][47] = data[735];

        }
        if (partition == 44) {
            buffer[0][0] = data[704]; buffer[0][1] = data[705]; buffer[0][2] = data[706]; buffer[0][3] = data[707]; buffer[0][4] = data[708]; buffer[0][5] = data[709]; buffer[0][6] = data[710]; buffer[0][7] = data[711]; buffer[0][8] = data[712]; buffer[0][9] = data[713]; buffer[0][10] = data[714]; buffer[0][11] = data[715]; buffer[0][12] = data[716]; buffer[0][13] = data[717]; buffer[0][14] = data[718]; buffer[0][15] = data[719]; buffer[0][16] = data[720]; buffer[0][17] = data[721]; buffer[0][18] = data[722]; buffer[0][19] = data[723]; buffer[0][20] = data[724]; buffer[0][21] = data[725]; buffer[0][22] = data[726]; buffer[0][23] = data[727]; buffer[0][24] = data[728]; buffer[0][25] = data[729]; buffer[0][26] = data[730]; buffer[0][27] = data[731]; buffer[0][28] = data[732]; buffer[0][29] = data[733]; buffer[0][30] = data[734]; buffer[0][31] = data[735]; buffer[0][32] = data[736]; buffer[0][33] = data[737]; buffer[0][34] = data[738]; buffer[0][35] = data[739]; buffer[0][36] = data[740]; buffer[0][37] = data[741]; buffer[0][38] = data[742]; buffer[0][39] = data[743]; buffer[0][40] = data[744]; buffer[0][41] = data[745]; buffer[0][42] = data[746]; buffer[0][43] = data[747]; buffer[0][44] = data[748]; buffer[0][45] = data[749]; buffer[0][46] = data[750]; buffer[0][47] = data[751];

        }
        if (partition == 45) {
            buffer[0][0] = data[720]; buffer[0][1] = data[721]; buffer[0][2] = data[722]; buffer[0][3] = data[723]; buffer[0][4] = data[724]; buffer[0][5] = data[725]; buffer[0][6] = data[726]; buffer[0][7] = data[727]; buffer[0][8] = data[728]; buffer[0][9] = data[729]; buffer[0][10] = data[730]; buffer[0][11] = data[731]; buffer[0][12] = data[732]; buffer[0][13] = data[733]; buffer[0][14] = data[734]; buffer[0][15] = data[735]; buffer[0][16] = data[736]; buffer[0][17] = data[737]; buffer[0][18] = data[738]; buffer[0][19] = data[739]; buffer[0][20] = data[740]; buffer[0][21] = data[741]; buffer[0][22] = data[742]; buffer[0][23] = data[743]; buffer[0][24] = data[744]; buffer[0][25] = data[745]; buffer[0][26] = data[746]; buffer[0][27] = data[747]; buffer[0][28] = data[748]; buffer[0][29] = data[749]; buffer[0][30] = data[750]; buffer[0][31] = data[751]; buffer[0][32] = data[752]; buffer[0][33] = data[753]; buffer[0][34] = data[754]; buffer[0][35] = data[755]; buffer[0][36] = data[756]; buffer[0][37] = data[757]; buffer[0][38] = data[758]; buffer[0][39] = data[759]; buffer[0][40] = data[760]; buffer[0][41] = data[761]; buffer[0][42] = data[762]; buffer[0][43] = data[763]; buffer[0][44] = data[764]; buffer[0][45] = data[765]; buffer[0][46] = data[766]; buffer[0][47] = data[767];

        }
        if (partition == 46) {
            buffer[0][0] = data[736]; buffer[0][1] = data[737]; buffer[0][2] = data[738]; buffer[0][3] = data[739]; buffer[0][4] = data[740]; buffer[0][5] = data[741]; buffer[0][6] = data[742]; buffer[0][7] = data[743]; buffer[0][8] = data[744]; buffer[0][9] = data[745]; buffer[0][10] = data[746]; buffer[0][11] = data[747]; buffer[0][12] = data[748]; buffer[0][13] = data[749]; buffer[0][14] = data[750]; buffer[0][15] = data[751]; buffer[0][16] = data[752]; buffer[0][17] = data[753]; buffer[0][18] = data[754]; buffer[0][19] = data[755]; buffer[0][20] = data[756]; buffer[0][21] = data[757]; buffer[0][22] = data[758]; buffer[0][23] = data[759]; buffer[0][24] = data[760]; buffer[0][25] = data[761]; buffer[0][26] = data[762]; buffer[0][27] = data[763]; buffer[0][28] = data[764]; buffer[0][29] = data[765]; buffer[0][30] = data[766]; buffer[0][31] = data[767]; buffer[0][32] = data[768]; buffer[0][33] = data[769]; buffer[0][34] = data[770]; buffer[0][35] = data[771]; buffer[0][36] = data[772]; buffer[0][37] = data[773]; buffer[0][38] = data[774]; buffer[0][39] = data[775]; buffer[0][40] = data[776]; buffer[0][41] = data[777]; buffer[0][42] = data[778]; buffer[0][43] = data[779]; buffer[0][44] = data[780]; buffer[0][45] = data[781]; buffer[0][46] = data[782]; buffer[0][47] = data[783];

        }
        if (partition == 47) {
            buffer[0][0] = data[752]; buffer[0][1] = data[753]; buffer[0][2] = data[754]; buffer[0][3] = data[755]; buffer[0][4] = data[756]; buffer[0][5] = data[757]; buffer[0][6] = data[758]; buffer[0][7] = data[759]; buffer[0][8] = data[760]; buffer[0][9] = data[761]; buffer[0][10] = data[762]; buffer[0][11] = data[763]; buffer[0][12] = data[764]; buffer[0][13] = data[765]; buffer[0][14] = data[766]; buffer[0][15] = data[767]; buffer[0][16] = data[768]; buffer[0][17] = data[769]; buffer[0][18] = data[770]; buffer[0][19] = data[771]; buffer[0][20] = data[772]; buffer[0][21] = data[773]; buffer[0][22] = data[774]; buffer[0][23] = data[775]; buffer[0][24] = data[776]; buffer[0][25] = data[777]; buffer[0][26] = data[778]; buffer[0][27] = data[779]; buffer[0][28] = data[780]; buffer[0][29] = data[781]; buffer[0][30] = data[782]; buffer[0][31] = data[783]; buffer[0][32] = data[784]; buffer[0][33] = data[785]; buffer[0][34] = data[786]; buffer[0][35] = data[787]; buffer[0][36] = data[788]; buffer[0][37] = data[789]; buffer[0][38] = data[790]; buffer[0][39] = data[791]; buffer[0][40] = data[792]; buffer[0][41] = data[793]; buffer[0][42] = data[794]; buffer[0][43] = data[795]; buffer[0][44] = data[796]; buffer[0][45] = data[797]; buffer[0][46] = data[798]; buffer[0][47] = data[799];

        }
        if (partition == 48) {
            buffer[0][0] = data[768]; buffer[0][1] = data[769]; buffer[0][2] = data[770]; buffer[0][3] = data[771]; buffer[0][4] = data[772]; buffer[0][5] = data[773]; buffer[0][6] = data[774]; buffer[0][7] = data[775]; buffer[0][8] = data[776]; buffer[0][9] = data[777]; buffer[0][10] = data[778]; buffer[0][11] = data[779]; buffer[0][12] = data[780]; buffer[0][13] = data[781]; buffer[0][14] = data[782]; buffer[0][15] = data[783]; buffer[0][16] = data[784]; buffer[0][17] = data[785]; buffer[0][18] = data[786]; buffer[0][19] = data[787]; buffer[0][20] = data[788]; buffer[0][21] = data[789]; buffer[0][22] = data[790]; buffer[0][23] = data[791]; buffer[0][24] = data[792]; buffer[0][25] = data[793]; buffer[0][26] = data[794]; buffer[0][27] = data[795]; buffer[0][28] = data[796]; buffer[0][29] = data[797]; buffer[0][30] = data[798]; buffer[0][31] = data[799]; buffer[0][32] = data[800]; buffer[0][33] = data[801]; buffer[0][34] = data[802]; buffer[0][35] = data[803]; buffer[0][36] = data[804]; buffer[0][37] = data[805]; buffer[0][38] = data[806]; buffer[0][39] = data[807]; buffer[0][40] = data[808]; buffer[0][41] = data[809]; buffer[0][42] = data[810]; buffer[0][43] = data[811]; buffer[0][44] = data[812]; buffer[0][45] = data[813]; buffer[0][46] = data[814]; buffer[0][47] = data[815];

        }
        if (partition == 49) {
            buffer[0][0] = data[784]; buffer[0][1] = data[785]; buffer[0][2] = data[786]; buffer[0][3] = data[787]; buffer[0][4] = data[788]; buffer[0][5] = data[789]; buffer[0][6] = data[790]; buffer[0][7] = data[791]; buffer[0][8] = data[792]; buffer[0][9] = data[793]; buffer[0][10] = data[794]; buffer[0][11] = data[795]; buffer[0][12] = data[796]; buffer[0][13] = data[797]; buffer[0][14] = data[798]; buffer[0][15] = data[799]; buffer[0][16] = data[800]; buffer[0][17] = data[801]; buffer[0][18] = data[802]; buffer[0][19] = data[803]; buffer[0][20] = data[804]; buffer[0][21] = data[805]; buffer[0][22] = data[806]; buffer[0][23] = data[807]; buffer[0][24] = data[808]; buffer[0][25] = data[809]; buffer[0][26] = data[810]; buffer[0][27] = data[811]; buffer[0][28] = data[812]; buffer[0][29] = data[813]; buffer[0][30] = data[814]; buffer[0][31] = data[815]; buffer[0][32] = data[816]; buffer[0][33] = data[817]; buffer[0][34] = data[818]; buffer[0][35] = data[819]; buffer[0][36] = data[820]; buffer[0][37] = data[821]; buffer[0][38] = data[822]; buffer[0][39] = data[823]; buffer[0][40] = data[824]; buffer[0][41] = data[825]; buffer[0][42] = data[826]; buffer[0][43] = data[827]; buffer[0][44] = data[828]; buffer[0][45] = data[829]; buffer[0][46] = data[830]; buffer[0][47] = data[831];

        }
        if (partition == 50) {
            buffer[0][0] = data[800]; buffer[0][1] = data[801]; buffer[0][2] = data[802]; buffer[0][3] = data[803]; buffer[0][4] = data[804]; buffer[0][5] = data[805]; buffer[0][6] = data[806]; buffer[0][7] = data[807]; buffer[0][8] = data[808]; buffer[0][9] = data[809]; buffer[0][10] = data[810]; buffer[0][11] = data[811]; buffer[0][12] = data[812]; buffer[0][13] = data[813]; buffer[0][14] = data[814]; buffer[0][15] = data[815]; buffer[0][16] = data[816]; buffer[0][17] = data[817]; buffer[0][18] = data[818]; buffer[0][19] = data[819]; buffer[0][20] = data[820]; buffer[0][21] = data[821]; buffer[0][22] = data[822]; buffer[0][23] = data[823]; buffer[0][24] = data[824]; buffer[0][25] = data[825]; buffer[0][26] = data[826]; buffer[0][27] = data[827]; buffer[0][28] = data[828]; buffer[0][29] = data[829]; buffer[0][30] = data[830]; buffer[0][31] = data[831]; buffer[0][32] = data[832]; buffer[0][33] = data[833]; buffer[0][34] = data[834]; buffer[0][35] = data[835]; buffer[0][36] = data[836]; buffer[0][37] = data[837]; buffer[0][38] = data[838]; buffer[0][39] = data[839]; buffer[0][40] = data[840]; buffer[0][41] = data[841]; buffer[0][42] = data[842]; buffer[0][43] = data[843]; buffer[0][44] = data[844]; buffer[0][45] = data[845]; buffer[0][46] = data[846]; buffer[0][47] = data[847];

        }
        if (partition == 51) {
            buffer[0][0] = data[816]; buffer[0][1] = data[817]; buffer[0][2] = data[818]; buffer[0][3] = data[819]; buffer[0][4] = data[820]; buffer[0][5] = data[821]; buffer[0][6] = data[822]; buffer[0][7] = data[823]; buffer[0][8] = data[824]; buffer[0][9] = data[825]; buffer[0][10] = data[826]; buffer[0][11] = data[827]; buffer[0][12] = data[828]; buffer[0][13] = data[829]; buffer[0][14] = data[830]; buffer[0][15] = data[831]; buffer[0][16] = data[832]; buffer[0][17] = data[833]; buffer[0][18] = data[834]; buffer[0][19] = data[835]; buffer[0][20] = data[836]; buffer[0][21] = data[837]; buffer[0][22] = data[838]; buffer[0][23] = data[839]; buffer[0][24] = data[840]; buffer[0][25] = data[841]; buffer[0][26] = data[842]; buffer[0][27] = data[843]; buffer[0][28] = data[844]; buffer[0][29] = data[845]; buffer[0][30] = data[846]; buffer[0][31] = data[847]; buffer[0][32] = data[848]; buffer[0][33] = data[849]; buffer[0][34] = data[850]; buffer[0][35] = data[851]; buffer[0][36] = data[852]; buffer[0][37] = data[853]; buffer[0][38] = data[854]; buffer[0][39] = data[855]; buffer[0][40] = data[856]; buffer[0][41] = data[857]; buffer[0][42] = data[858]; buffer[0][43] = data[859]; buffer[0][44] = data[860]; buffer[0][45] = data[861]; buffer[0][46] = data[862]; buffer[0][47] = data[863];

        }
        if (partition == 52) {
            buffer[0][0] = data[832]; buffer[0][1] = data[833]; buffer[0][2] = data[834]; buffer[0][3] = data[835]; buffer[0][4] = data[836]; buffer[0][5] = data[837]; buffer[0][6] = data[838]; buffer[0][7] = data[839]; buffer[0][8] = data[840]; buffer[0][9] = data[841]; buffer[0][10] = data[842]; buffer[0][11] = data[843]; buffer[0][12] = data[844]; buffer[0][13] = data[845]; buffer[0][14] = data[846]; buffer[0][15] = data[847]; buffer[0][16] = data[848]; buffer[0][17] = data[849]; buffer[0][18] = data[850]; buffer[0][19] = data[851]; buffer[0][20] = data[852]; buffer[0][21] = data[853]; buffer[0][22] = data[854]; buffer[0][23] = data[855]; buffer[0][24] = data[856]; buffer[0][25] = data[857]; buffer[0][26] = data[858]; buffer[0][27] = data[859]; buffer[0][28] = data[860]; buffer[0][29] = data[861]; buffer[0][30] = data[862]; buffer[0][31] = data[863]; buffer[0][32] = data[864]; buffer[0][33] = data[865]; buffer[0][34] = data[866]; buffer[0][35] = data[867]; buffer[0][36] = data[868]; buffer[0][37] = data[869]; buffer[0][38] = data[870]; buffer[0][39] = data[871]; buffer[0][40] = data[872]; buffer[0][41] = data[873]; buffer[0][42] = data[874]; buffer[0][43] = data[875]; buffer[0][44] = data[876]; buffer[0][45] = data[877]; buffer[0][46] = data[878]; buffer[0][47] = data[879];

        }
        if (partition == 53) {
            buffer[0][0] = data[848]; buffer[0][1] = data[849]; buffer[0][2] = data[850]; buffer[0][3] = data[851]; buffer[0][4] = data[852]; buffer[0][5] = data[853]; buffer[0][6] = data[854]; buffer[0][7] = data[855]; buffer[0][8] = data[856]; buffer[0][9] = data[857]; buffer[0][10] = data[858]; buffer[0][11] = data[859]; buffer[0][12] = data[860]; buffer[0][13] = data[861]; buffer[0][14] = data[862]; buffer[0][15] = data[863]; buffer[0][16] = data[864]; buffer[0][17] = data[865]; buffer[0][18] = data[866]; buffer[0][19] = data[867]; buffer[0][20] = data[868]; buffer[0][21] = data[869]; buffer[0][22] = data[870]; buffer[0][23] = data[871]; buffer[0][24] = data[872]; buffer[0][25] = data[873]; buffer[0][26] = data[874]; buffer[0][27] = data[875]; buffer[0][28] = data[876]; buffer[0][29] = data[877]; buffer[0][30] = data[878]; buffer[0][31] = data[879]; buffer[0][32] = data[880]; buffer[0][33] = data[881]; buffer[0][34] = data[882]; buffer[0][35] = data[883]; buffer[0][36] = data[884]; buffer[0][37] = data[885]; buffer[0][38] = data[886]; buffer[0][39] = data[887]; buffer[0][40] = data[888]; buffer[0][41] = data[889]; buffer[0][42] = data[890]; buffer[0][43] = data[891]; buffer[0][44] = data[892]; buffer[0][45] = data[893]; buffer[0][46] = data[894]; buffer[0][47] = data[895];

        }
        if (partition == 54) {
            buffer[0][0] = data[864]; buffer[0][1] = data[865]; buffer[0][2] = data[866]; buffer[0][3] = data[867]; buffer[0][4] = data[868]; buffer[0][5] = data[869]; buffer[0][6] = data[870]; buffer[0][7] = data[871]; buffer[0][8] = data[872]; buffer[0][9] = data[873]; buffer[0][10] = data[874]; buffer[0][11] = data[875]; buffer[0][12] = data[876]; buffer[0][13] = data[877]; buffer[0][14] = data[878]; buffer[0][15] = data[879]; buffer[0][16] = data[880]; buffer[0][17] = data[881]; buffer[0][18] = data[882]; buffer[0][19] = data[883]; buffer[0][20] = data[884]; buffer[0][21] = data[885]; buffer[0][22] = data[886]; buffer[0][23] = data[887]; buffer[0][24] = data[888]; buffer[0][25] = data[889]; buffer[0][26] = data[890]; buffer[0][27] = data[891]; buffer[0][28] = data[892]; buffer[0][29] = data[893]; buffer[0][30] = data[894]; buffer[0][31] = data[895]; buffer[0][32] = data[896]; buffer[0][33] = data[897]; buffer[0][34] = data[898]; buffer[0][35] = data[899]; buffer[0][36] = data[900]; buffer[0][37] = data[901]; buffer[0][38] = data[902]; buffer[0][39] = data[903]; buffer[0][40] = data[904]; buffer[0][41] = data[905]; buffer[0][42] = data[906]; buffer[0][43] = data[907]; buffer[0][44] = data[908]; buffer[0][45] = data[909]; buffer[0][46] = data[910]; buffer[0][47] = data[911];

        }
        if (partition == 55) {
            buffer[0][0] = data[880]; buffer[0][1] = data[881]; buffer[0][2] = data[882]; buffer[0][3] = data[883]; buffer[0][4] = data[884]; buffer[0][5] = data[885]; buffer[0][6] = data[886]; buffer[0][7] = data[887]; buffer[0][8] = data[888]; buffer[0][9] = data[889]; buffer[0][10] = data[890]; buffer[0][11] = data[891]; buffer[0][12] = data[892]; buffer[0][13] = data[893]; buffer[0][14] = data[894]; buffer[0][15] = data[895]; buffer[0][16] = data[896]; buffer[0][17] = data[897]; buffer[0][18] = data[898]; buffer[0][19] = data[899]; buffer[0][20] = data[900]; buffer[0][21] = data[901]; buffer[0][22] = data[902]; buffer[0][23] = data[903]; buffer[0][24] = data[904]; buffer[0][25] = data[905]; buffer[0][26] = data[906]; buffer[0][27] = data[907]; buffer[0][28] = data[908]; buffer[0][29] = data[909]; buffer[0][30] = data[910]; buffer[0][31] = data[911]; buffer[0][32] = data[912]; buffer[0][33] = data[913]; buffer[0][34] = data[914]; buffer[0][35] = data[915]; buffer[0][36] = data[916]; buffer[0][37] = data[917]; buffer[0][38] = data[918]; buffer[0][39] = data[919]; buffer[0][40] = data[920]; buffer[0][41] = data[921]; buffer[0][42] = data[922]; buffer[0][43] = data[923]; buffer[0][44] = data[924]; buffer[0][45] = data[925]; buffer[0][46] = data[926]; buffer[0][47] = data[927];

        }
        if (partition == 56) {
            buffer[0][0] = data[896]; buffer[0][1] = data[897]; buffer[0][2] = data[898]; buffer[0][3] = data[899]; buffer[0][4] = data[900]; buffer[0][5] = data[901]; buffer[0][6] = data[902]; buffer[0][7] = data[903]; buffer[0][8] = data[904]; buffer[0][9] = data[905]; buffer[0][10] = data[906]; buffer[0][11] = data[907]; buffer[0][12] = data[908]; buffer[0][13] = data[909]; buffer[0][14] = data[910]; buffer[0][15] = data[911]; buffer[0][16] = data[912]; buffer[0][17] = data[913]; buffer[0][18] = data[914]; buffer[0][19] = data[915]; buffer[0][20] = data[916]; buffer[0][21] = data[917]; buffer[0][22] = data[918]; buffer[0][23] = data[919]; buffer[0][24] = data[920]; buffer[0][25] = data[921]; buffer[0][26] = data[922]; buffer[0][27] = data[923]; buffer[0][28] = data[924]; buffer[0][29] = data[925]; buffer[0][30] = data[926]; buffer[0][31] = data[927]; buffer[0][32] = data[928]; buffer[0][33] = data[929]; buffer[0][34] = data[930]; buffer[0][35] = data[931]; buffer[0][36] = data[932]; buffer[0][37] = data[933]; buffer[0][38] = data[934]; buffer[0][39] = data[935]; buffer[0][40] = data[936]; buffer[0][41] = data[937]; buffer[0][42] = data[938]; buffer[0][43] = data[939]; buffer[0][44] = data[940]; buffer[0][45] = data[941]; buffer[0][46] = data[942]; buffer[0][47] = data[943];

        }
    }
};

}
# 8 "firmware/parameters.h" 2


# 1 "firmware/nnet_utils/nnet_activation.h" 1




# 1 "firmware/nnet_utils/nnet_common.h" 1
# 22 "firmware/nnet_utils/nnet_common.h"
namespace nnet {


enum io_type { io_parallel = 0, io_stream };
enum strategy { latency, resource };
# 36 "firmware/nnet_utils/nnet_common.h"
template <class T, int N, class Op> T reduce(const T *x, Op op) {
    static constexpr int leftN = pow2(floorlog2(N - 1)) > 0 ? pow2(floorlog2(N - 1)) : 0;
    static constexpr int rightN = N - leftN > 0 ? N - leftN : 0;
    if (N == 1) {
        return x[0];
    }
    if (N == 2) {
        return op(x[0], x[1]);
    }
    return op(reduce<T, leftN, Op>(x, op), reduce<T, rightN, Op>(x + leftN, op));
}

template <class T> class Op_add {
  public:
    T operator()(T a, T b) { return a + b; }
};

template <class T> class Op_and {
  public:
    T operator()(T a, T b) { return a && b; }
};

template <class T> class Op_or {
  public:
    T operator()(T a, T b) { return a || b; }
};

template <class T> class Op_max {
  public:
    T operator()(T a, T b) { return a >= b ? a : b; }
};

template <class T> class Op_min {
  public:
    T operator()(T a, T b) { return a <= b ? a : b; }
};

}
# 6 "firmware/nnet_utils/nnet_activation.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
# 7 "firmware/nnet_utils/nnet_activation.h" 2

namespace nnet {

struct activ_config {

    static const unsigned n_in = 10;


    static const unsigned table_size = 1024;


    static const unsigned io_type = io_parallel;
    static const unsigned reuse_factor = 1;


    typedef ap_fixed<18, 8> table_t;
};




template <class data_T, class res_T, typename CONFIG_T> void linear(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        res[ii] = data[ii];
    }
}




template <class data_T, class res_T, typename CONFIG_T> void relu(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg > 0)
            res[ii] = datareg;
        else
            res[ii] = 0;
    }
}

template <class data_T, class res_T, int MAX_INT, typename CONFIG_T>
void relu_max(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg < 0)
            res[ii] = 0;
        else if (datareg > MAX_INT)
            res[ii] = MAX_INT;
        else
            res[ii] = datareg;
    }
}

template <class data_T, class res_T, typename CONFIG_T> void relu6(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
    relu_max<data_T, res_T, 6, CONFIG_T>(data, res);
}

template <class data_T, class res_T, typename CONFIG_T> void relu1(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
    relu_max<data_T, res_T, 1, CONFIG_T>(data, res);
}




inline float sigmoid_fcn_float(float input) { return 1.0 / (1 + std::exp(-input)); }

template <typename CONFIG_T, int N_TABLE> void init_sigmoid_table(typename CONFIG_T::table_t table_out[N_TABLE]) {


    for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = 2 * 8.0 * (ii - float(N_TABLE) / 2.0) / float(N_TABLE);

        typename CONFIG_T::table_t real_val = sigmoid_fcn_float(in_val);

        table_out[ii] = real_val;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void sigmoid(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t sigmoid_table[CONFIG_T::table_size];




    if (!initialized) {
        init_sigmoid_table<CONFIG_T, CONFIG_T::table_size>(sigmoid_table);
        initialized = true;
    }

#pragma HLS PIPELINE


 int data_round;
    int index;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        data_round = data[ii] * CONFIG_T::table_size / 16;
        index = data_round + 8 * CONFIG_T::table_size / 16;
        if (index < 0)
            index = 0;
        if (index > CONFIG_T::table_size - 1)
            index = CONFIG_T::table_size - 1;
        res[ii] = (res_T)sigmoid_table[index];
    }
}





enum class softmax_implementation { latency = 0, legacy = 1, stable = 2, argmax = 3 };

inline float exp_fcn_float(float input) { return std::exp(input); }

template <class data_T, typename CONFIG_T> inline float softmax_real_val_from_idx(unsigned i) {

    static constexpr int N = ceillog2(CONFIG_T::table_size);
    data_T x(0);
    x(x.width - 1, x.width - N) = i;
    return (float)x;
}

template <class data_T, typename CONFIG_T> inline unsigned softmax_idx_from_real_val(data_T x) {

    static constexpr int N = ceillog2(CONFIG_T::table_size);
    ap_uint<N> y = x(x.width - 1, x.width - N);
    return (unsigned)y(N - 1, 0);
}

template <class data_T, typename CONFIG_T>
void init_exp_table(typename CONFIG_T::exp_table_t table_out[CONFIG_T::table_size]) {

    for (unsigned i = 0; i < CONFIG_T::table_size; i++) {

        float x = softmax_real_val_from_idx<data_T, CONFIG_T>(i);
        typename CONFIG_T::exp_table_t exp_x = exp_fcn_float(x);
        table_out[i] = exp_x;
    }
}

template <class data_T, typename CONFIG_T>
void init_invert_table(typename CONFIG_T::inv_table_t table_out[CONFIG_T::table_size]) {

    for (unsigned i = 0; i < CONFIG_T::table_size; i++) {
        float x = softmax_real_val_from_idx<data_T, CONFIG_T>(i);
        typename CONFIG_T::inv_table_t inv_x = 1 / x;
        table_out[i] = inv_x;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_latency(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS pipeline


 bool initialized = false;
    typename CONFIG_T::exp_table_t exp_table[CONFIG_T::table_size];
    typename CONFIG_T::inv_table_t invert_table[CONFIG_T::table_size];






    if (!initialized) {

        init_exp_table<data_T, CONFIG_T>(exp_table);

        init_invert_table<typename CONFIG_T::exp_table_t, CONFIG_T>(invert_table);
        initialized = true;
    }


    typename CONFIG_T::exp_table_t exp_res[CONFIG_T::n_in];
#pragma HLS array_partition variable=exp_res complete
 typename CONFIG_T::exp_table_t exp_sum(0);
    for (unsigned i = 0; i < CONFIG_T::n_in; i++) {
#pragma HLS unroll
 unsigned x = softmax_idx_from_real_val<data_T, CONFIG_T>(data[i]);
        exp_res[i] = exp_table[x];
    }



    Op_add<typename CONFIG_T::exp_table_t> op_add;
    exp_sum =
        reduce<typename CONFIG_T::exp_table_t, CONFIG_T::n_in, Op_add<typename CONFIG_T::exp_table_t>>(exp_res, op_add);

    typename CONFIG_T::inv_table_t inv_exp_sum =
        invert_table[softmax_idx_from_real_val<typename CONFIG_T::exp_table_t, CONFIG_T>(exp_sum)];
    for (unsigned i = 0; i < CONFIG_T::n_in; i++) {
#pragma HLS unroll
 res[i] = exp_res[i] * inv_exp_sum;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_stable(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS pipeline


 bool initialized = false;
    typename CONFIG_T::exp_table_t exp_table[CONFIG_T::table_size];
    typename CONFIG_T::inv_table_t invert_table[CONFIG_T::table_size];






    if (!initialized) {

        init_exp_table<data_T, CONFIG_T>(exp_table);

        init_invert_table<typename CONFIG_T::exp_table_t, CONFIG_T>(invert_table);
        initialized = true;
    }


    Op_max<data_T> op_max;
    data_T x_max = reduce<data_T, CONFIG_T::n_in, Op_max<data_T>>(data, op_max);


    ap_fixed<data_T::width, data_T::iwidth, AP_RND, AP_SAT> d_xi_xmax[CONFIG_T::n_in];
    for (unsigned i = 0; i < CONFIG_T::n_in; i++) {
#pragma HLS unroll
 d_xi_xmax[i] = data[i] - x_max;
    }


    typename CONFIG_T::exp_table_t exp_res[CONFIG_T::n_in];
#pragma HLS array_partition variable=exp_res complete
 typename CONFIG_T::exp_table_t exp_sum(0);
    for (unsigned i = 0; i < CONFIG_T::n_in; i++) {
#pragma HLS unroll
 unsigned x = softmax_idx_from_real_val<data_T, CONFIG_T>(d_xi_xmax[i]);
        exp_res[i] = exp_table[x];
    }



    Op_add<typename CONFIG_T::exp_table_t> op_add;
    exp_sum =
        reduce<typename CONFIG_T::exp_table_t, CONFIG_T::n_in, Op_add<typename CONFIG_T::exp_table_t>>(exp_res, op_add);

    typename CONFIG_T::inv_table_t inv_exp_sum =
        invert_table[softmax_idx_from_real_val<typename CONFIG_T::exp_table_t, CONFIG_T>(exp_sum)];
    for (unsigned i = 0; i < CONFIG_T::n_in; i++) {
#pragma HLS unroll
 res[i] = exp_res[i] * inv_exp_sum;
    }
}

template <typename CONFIG_T, int N_TABLE> void init_exp_table_legacy(typename CONFIG_T::table_t table_out[N_TABLE]) {
    for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = 2 * 8.0 * (ii - float(N_TABLE) / 2.0) / float(N_TABLE);

        typename CONFIG_T::table_t real_val = exp_fcn_float(in_val);

        table_out[ii] = real_val;
    }
}

template <typename CONFIG_T, int N_TABLE> void init_invert_table_legacy(typename CONFIG_T::table_t table_out[N_TABLE]) {


    for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = 64.0 * ii / float(N_TABLE);

        if (in_val > 0.0)
            table_out[ii] = 1.0 / in_val;
        else
            table_out[ii] = 0.0;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_legacy(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t exp_table[CONFIG_T::table_size];
    typename CONFIG_T::table_t invert_table[CONFIG_T::table_size];





    if (!initialized) {
        init_exp_table_legacy<CONFIG_T, CONFIG_T::table_size>(exp_table);
        init_invert_table_legacy<CONFIG_T, CONFIG_T::table_size>(invert_table);
        initialized = true;
    }

#pragma HLS PIPELINE


 typename CONFIG_T::table_t exp_res[CONFIG_T::n_in];
    typename CONFIG_T::table_t exp_diff_res;
    data_T data_cache[CONFIG_T::n_in];
    int data_round;
    int index;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        data_cache[ii] = data[ii];
        exp_res[ii] = 0;
    }

    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        for (int jj = 0; jj < CONFIG_T::n_in; jj++) {
            if (ii == jj)
                exp_diff_res = 1;
            else {
                data_round = (data_cache[jj] - data_cache[ii]) * CONFIG_T::table_size / 16;
                index = data_round + 8 * CONFIG_T::table_size / 16;
                if (index < 0)
                    index = 0;
                if (index > CONFIG_T::table_size - 1)
                    index = CONFIG_T::table_size - 1;
                exp_diff_res = exp_table[index];
            }
            exp_res[ii] += exp_diff_res;
        }
    }


    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        int exp_res_index = exp_res[ii] * CONFIG_T::table_size / 64;
        if (exp_res_index < 0)
            exp_res_index = 0;
        if (exp_res_index > CONFIG_T::table_size - 1)
            exp_res_index = CONFIG_T::table_size - 1;

        res[ii] = (res_T)invert_table[exp_res_index];
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_argmax(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
    for (int i = 0; i < CONFIG_T::n_in; i++) {
#pragma HLS UNROLL
 res[i] = (res_T)0;
    }

    data_T maximum = data[0];
    int idx = 0;

    for (int i = 1; i < CONFIG_T::n_in; i++) {
#pragma HLS PIPELINE
 if (data[i] > maximum) {
            maximum = data[i];
            idx = i;
        }
    }

    res[idx] = (res_T)1;
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS inline
 switch (CONFIG_T::implementation) {
    case softmax_implementation::latency:
        softmax_latency<data_T, res_T, CONFIG_T>(data, res);
        break;
    case softmax_implementation::stable:
        softmax_stable<data_T, res_T, CONFIG_T>(data, res);
        break;
    case softmax_implementation::legacy:
        softmax_legacy<data_T, res_T, CONFIG_T>(data, res);
        break;
    case softmax_implementation::argmax:
        softmax_argmax<data_T, res_T, CONFIG_T>(data, res);
        break;
    }
}




template <typename CONFIG_T, int N_TABLE> void init_tanh_table(typename CONFIG_T::table_t table_out[N_TABLE]) {

    for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = 2 * 4.0 * (ii - float(N_TABLE) / 2.0) / float(N_TABLE);

        typename CONFIG_T::table_t real_val = tanh(in_val);


        table_out[ii] = real_val;
    }
}

template <class data_T, class res_T, typename CONFIG_T> void tanh(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t tanh_table[CONFIG_T::table_size];




    if (!initialized) {
        init_tanh_table<CONFIG_T, CONFIG_T::table_size>(tanh_table);
        initialized = true;
    }

#pragma HLS PIPELINE


 int data_round;
    int index;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        data_round = data[ii] * CONFIG_T::table_size / 8;
        index = data_round + 4 * CONFIG_T::table_size / 8;

        if (index < 0)
            index = 0;
        if (index > CONFIG_T::table_size - 1)
            index = CONFIG_T::table_size - 1;
        res[ii] = (res_T)tanh_table[index];
    }
}




template <int table_size, class data_T> inline unsigned get_index_unary_lut(data_T x) {

    static constexpr int N = ceillog2(table_size);
    return (unsigned)(x(x.width - 1, 0));
}

template <class data_T, class res_T, typename CONFIG_T>
void unary_lut(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in],
               typename CONFIG_T::table_t table[CONFIG_T::table_size]) {
#pragma HLS function_instantiate variable=table
#pragma HLS ARRAY_PARTITION variable=table

 for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
#pragma HLS UNROLL
 unsigned index = get_index_unary_lut<CONFIG_T::table_size>(data[ii]);
        res[ii] = (res_T)table[index];
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void hard_sigmoid(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        auto datareg = CONFIG_T::slope * data[ii] + CONFIG_T::shift;
        if (datareg > 1)
            datareg = 1;
        else if (datareg < 0)
            datareg = 0;
        res[ii] = datareg;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void hard_tanh(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
    if (CONFIG_T::io_type == io_parallel) {
#pragma HLS PIPELINE
 }

    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        auto sigmoid = CONFIG_T::slope * data[ii] + CONFIG_T::shift;
        if (sigmoid > 1)
            sigmoid = 1;
        else if (sigmoid < 0)
            sigmoid = 0;
        res[ii] = 2 * sigmoid - 1;
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void leaky_relu(data_T data[CONFIG_T::n_in], data_T alpha, res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg > 0)
            res[ii] = datareg;
        else
            res[ii] = alpha * datareg;
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void thresholded_relu(data_T data[CONFIG_T::n_in], data_T theta, res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg > theta)
            res[ii] = datareg;
        else
            res[ii] = 0;
    }
}




inline float softplus_fcn_float(float input) { return std::log(std::exp(input) + 1.); }

template <typename CONFIG_T, int N_TABLE> void init_softplus_table(typename CONFIG_T::table_t table_out[N_TABLE]) {


    for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = 2 * 8.0 * (ii - float(N_TABLE) / 2.0) / float(N_TABLE);

        typename CONFIG_T::table_t real_val = softplus_fcn_float(in_val);

        table_out[ii] = real_val;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softplus(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t softplus_table[CONFIG_T::table_size];




    if (!initialized) {
        init_softplus_table<CONFIG_T, CONFIG_T::table_size>(softplus_table);
        initialized = true;
    }

#pragma HLS PIPELINE


 int data_round;
    int index;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        data_round = data[ii] * CONFIG_T::table_size / 16;
        index = data_round + 8 * CONFIG_T::table_size / 16;
        if (index < 0)
            index = 0;
        if (index > CONFIG_T::table_size - 1)
            index = CONFIG_T::table_size - 1;
        res[ii] = (res_T)softplus_table[index];
    }
}




inline float softsign_fcn_float(float input) { return input / (std::abs(input) + 1.); }

template <typename CONFIG_T, int N_TABLE> void init_softsign_table(typename CONFIG_T::table_t table_out[N_TABLE]) {


    for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = 2 * 8.0 * (ii - float(N_TABLE) / 2.0) / float(N_TABLE);

        typename CONFIG_T::table_t real_val = softsign_fcn_float(in_val);

        table_out[ii] = real_val;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softsign(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t softsign_table[CONFIG_T::table_size];




    if (!initialized) {
        init_softsign_table<CONFIG_T, CONFIG_T::table_size>(softsign_table);
        initialized = true;
    }

#pragma HLS PIPELINE


 int data_round;
    int index;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        data_round = data[ii] * CONFIG_T::table_size / 16;
        index = data_round + 8 * CONFIG_T::table_size / 16;
        if (index < 0)
            index = 0;
        if (index > CONFIG_T::table_size - 1)
            index = CONFIG_T::table_size - 1;
        res[ii] = (res_T)softsign_table[index];
    }
}




inline float elu_fcn_float(float input) { return std::exp(input) - 1.; }

template <typename CONFIG_T, int N_TABLE> void init_elu_table(typename CONFIG_T::table_t table_out[N_TABLE]) {


    for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = -8.0 * ii / float(N_TABLE);

        typename CONFIG_T::table_t real_val = elu_fcn_float(in_val);

        table_out[ii] = real_val;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void elu(data_T data[CONFIG_T::n_in], const res_T alpha, res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t elu_table[CONFIG_T::table_size];




    if (!initialized) {
        init_elu_table<CONFIG_T, CONFIG_T::table_size>(elu_table);
        initialized = true;
    }

#pragma HLS PIPELINE

 data_T datareg;

    int index;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg >= 0) {
            res[ii] = datareg;
        } else {
            index = datareg * CONFIG_T::table_size / -8;
            if (index > CONFIG_T::table_size - 1)
                index = CONFIG_T::table_size - 1;
            res[ii] = alpha * elu_table[index];
        }
    }
}

template <class data_T, class res_T, typename CONFIG_T> void elu(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
    elu<data_T, res_T, CONFIG_T>(data, 1.0, res);
}




inline float selu_fcn_float(float input) {
    return 1.0507009873554804934193349852946 * (1.6732632423543772848170429916717 * (std::exp(input) - 1.));
}

template <typename CONFIG_T, int N_TABLE> void init_selu_table(typename CONFIG_T::table_t table_out[N_TABLE]) {


    for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = -8.0 * ii / float(N_TABLE);

        typename CONFIG_T::table_t real_val = selu_fcn_float(in_val);

        table_out[ii] = real_val;
    }
}

template <class data_T, class res_T, typename CONFIG_T> void selu(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t selu_table[CONFIG_T::table_size];




    if (!initialized) {
        init_selu_table<CONFIG_T, CONFIG_T::table_size>(selu_table);
        initialized = true;
    }

#pragma HLS PIPELINE

 data_T datareg;

    int index;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg >= 0) {
            res[ii] = res_T(1.0507009873554804934193349852946) * datareg;
        } else {
            index = datareg * CONFIG_T::table_size / -8;
            if (index > CONFIG_T::table_size - 1)
                index = CONFIG_T::table_size - 1;
            res[ii] = selu_table[index];
        }
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void prelu(data_T data[CONFIG_T::n_in], data_T alpha[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg > 0)
            res[ii] = datareg;
        else
            res[ii] = alpha[ii] * datareg;
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void binary_tanh(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    res_T cache;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg > 0)
            cache = 1;
        else
            cache = -1;

        res[ii] = (res_T)cache;
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void ternary_tanh(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    res_T cache;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = 2 * data[ii];
        if (datareg > 1)
            cache = 1;
        else if (datareg > -1 && datareg <= 1)
            cache = 0;
        else
            cache = -1;

        res[ii] = (res_T)cache;
    }
}

}
# 11 "firmware/parameters.h" 2
# 1 "firmware/nnet_utils/nnet_activation_stream.h" 1







# 1 "firmware/nnet_utils/nnet_stream.h" 1







namespace nnet {

struct broadcast_config {
    static const unsigned in_height = 1;
    static const unsigned in_width = 1;
    static const unsigned in_chan = 3;
    static const unsigned out_height = 2;
    static const unsigned out_width = 2;
    static const unsigned out_chan = 3;
};

template <class data_T, class res_T, int N>
void clone_stream(hls::stream<data_T> &data, hls::stream<res_T> &res1, hls::stream<res_T> &res2) {
CloneLoop:
    for (int i = 0; i < N / data_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data1;
        res_T out_data2;



    ClonePack:
        for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 out_data1[j] = in_data[j];
            out_data2[j] = in_data[j];
        }

        res1.write(out_data1);
        res2.write(out_data2);
    }
}

template <class data_T, class res_T, int N>
void clone_stream(hls::stream<data_T> &data, hls::stream<res_T> &res1, hls::stream<res_T> &res2, hls::stream<res_T> &res3) {
CloneLoop:
    for (int i = 0; i < N / data_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data1;
        res_T out_data2;
        res_T out_data3;




    ClonePack:
        for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 out_data1[j] = in_data[j];
            out_data2[j] = in_data[j];
            out_data3[j] = in_data[j];
        }

        res1.write(out_data1);
        res2.write(out_data2);
        res3.write(out_data3);
    }
}

template <class data_T, class res_T, int N> void repack_stream(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    if (data_T::size == res_T::size) {
        for (int i = 0; i < N / data_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
            res_T out_data;


            for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 out_data[j] = in_data[j];
            }

            res.write(out_data);
        }
    } else if (data_T::size > res_T::size) {
        constexpr unsigned pack_diff = data_T::size / res_T::size;
        for (int i = 0; i < N / data_T::size; i++) {
            if (N / data_T::size > 1) {
#pragma HLS PIPELINE
 }

            data_T in_data = data.read();
            res_T out_data;


            for (int j = 0; j < pack_diff; j++) {
#pragma HLS PIPELINE

 res_T out_data;
                for (int k = 0; k < res_T::size; k++) {
#pragma HLS UNROLL
 out_data[k] = in_data[j * res_T::size + k];
                }
                res.write(out_data);
            }
        }
    } else {
        res_T out_data;
        constexpr unsigned pack_diff = res_T::size / data_T::size;
        unsigned pack_cnt = 0;
        for (int i = 0; i < N / data_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
            for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 out_data[pack_cnt * data_T::size + j] = in_data[j];
            }

            if (pack_cnt == pack_diff - 1) {
                res.write(out_data);
                pack_cnt = 0;
            } else {
                pack_cnt++;
            }
        }
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void broadcast_stream_1x1xC(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    ({ bool _AssertPred = CONFIG_T::in_height == 1 && CONFIG_T::in_width == 1 && CONFIG_T::in_chan == CONFIG_T::out_chan; __builtin_assume(_AssertPred); });
    int n_dupl = (CONFIG_T::out_height * CONFIG_T::out_width * CONFIG_T::out_chan) /
                 (CONFIG_T::in_height * CONFIG_T::in_width * CONFIG_T::in_chan);
BroadcastLoop:
    for (int i = 0; i < CONFIG_T::in_height * CONFIG_T::in_width * CONFIG_T::in_chan / data_T::size; i++) {
#pragma HLS PIPELINE
 data_T in_data = data.read();
        for (int j = 0; j < n_dupl; j++) {
#pragma HLS PIPELINE
 res_T out_data;

            for (int k = 0; k < res_T::size; k++) {
#pragma HLS UNROLL
 out_data[k] = in_data[k];
            }
            res.write(out_data);
        }
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void broadcast_stream_HxWx1(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    ({ bool _AssertPred = CONFIG_T::in_chan == 1 && CONFIG_T::in_height == CONFIG_T::out_height && CONFIG_T::in_width == CONFIG_T::out_width; __builtin_assume(_AssertPred); });

BroadcastLoop:
    for (int i = 0; i < CONFIG_T::in_height * CONFIG_T::in_width * CONFIG_T::in_chan / data_T::size; i++) {
#pragma HLS PIPELINE
 data_T in_data = data.read();
        res_T out_data;

        for (int k = 0; k < res_T::size; k++) {
#pragma HLS UNROLL
 out_data[k] = in_data[0];
        }
        res.write(out_data);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void broadcast_stream(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    if (CONFIG_T::in_height == 1 && CONFIG_T::in_width == 1 && CONFIG_T::in_chan == CONFIG_T::out_chan) {
        broadcast_stream_1x1xC<data_T, res_T, CONFIG_T>(data, res);
    } else if (CONFIG_T::in_chan == 1 && CONFIG_T::in_height == CONFIG_T::out_height &&
               CONFIG_T::in_width == CONFIG_T::out_width) {
        broadcast_stream_HxWx1<data_T, res_T, CONFIG_T>(data, res);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void transpose_2d(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    typename data_T::value_type data_array[CONFIG_T::height * CONFIG_T::width];
#pragma HLS ARRAY_PARTITION variable=data_array complete

 for (int i = 0; i < CONFIG_T::height * CONFIG_T::width / data_T::size; i++) {
#pragma HLS PIPELINE
 data_T in_data = data.read();
        for (int j = 0; j < data_T::size; j++) {
            data_array[i * data_T::size + j] = typename data_T::value_type(in_data[j]);
        }
    }

    for (int i = 0; i < CONFIG_T::height * CONFIG_T::width / res_T::size; i++) {
#pragma HLS PIPELINE
 res_T out_data;

        for (int j = 0; j < res_T::size; j++) {
            out_data[j] = typename res_T::value_type(data_array[j * data_T::size + i]);
        }
        res.write(out_data);
    }
}
}
# 9 "firmware/nnet_utils/nnet_activation_stream.h" 2

# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cmath" 3
# 11 "firmware/nnet_utils/nnet_activation_stream.h" 2

namespace nnet {




template <class data_T, class res_T, typename CONFIG_T> void linear(hls::stream<data_T> &data, hls::stream<res_T> &res) {
LinearActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    LinearPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 out_data[j] = in_data[j];
        }

        res.write(out_data);
    }
}




template <class data_T, class res_T, typename CONFIG_T> void relu(hls::stream<data_T> &data, hls::stream<res_T> &res) {
ReLUActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    ReLUPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 if (in_data[j] > 0)
                out_data[j] = in_data[j];
            else
                out_data[j] = 0;
        }

        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T> void sigmoid(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t sigmoid_table[CONFIG_T::table_size];




    if (!initialized) {
        init_sigmoid_table<CONFIG_T, CONFIG_T::table_size>(sigmoid_table);
        initialized = true;
    }

SigmoidActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    SigmoidPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 int data_round = in_data[j] * CONFIG_T::table_size / 16;
            int index = data_round + 8 * CONFIG_T::table_size / 16;
            if (index < 0)
                index = 0;
            else if (index > CONFIG_T::table_size - 1)
                index = CONFIG_T::table_size - 1;
            out_data[j] = sigmoid_table[index];
        }

        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T>
void softmax_latency(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::exp_table_t exp_table[CONFIG_T::table_size];
    typename CONFIG_T::inv_table_t invert_table[CONFIG_T::table_size];






    if (!initialized) {

        init_exp_table<typename data_T::value_type, CONFIG_T>(exp_table);

        init_invert_table<typename CONFIG_T::exp_table_t, CONFIG_T>(invert_table);
        initialized = true;
    }

    constexpr unsigned multiplier_limit = ((data_T::size + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);
    constexpr unsigned ii = data_T::size / multiplier_limit;


    typename CONFIG_T::exp_table_t exp_res[data_T::size];
#pragma HLS array_partition variable=exp_res complete
 typename CONFIG_T::exp_table_t exp_sum(0);
SoftmaxExpLoop:
    for (unsigned i = 0; i < CONFIG_T::n_in / data_T::size; i++) {
#pragma HLS PIPELINE II=ii

 data_T in_pack = data.read();
    SoftmaxExpPackLoop:
        for (unsigned j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 unsigned x = softmax_idx_from_real_val<typename data_T::value_type, CONFIG_T>(in_pack[j]);
            exp_res[j] = exp_table[x];
        }



        Op_add<typename CONFIG_T::exp_table_t> op_add;
        exp_sum =
            reduce<typename CONFIG_T::exp_table_t, data_T::size, Op_add<typename CONFIG_T::exp_table_t>>(exp_res, op_add);

        typename CONFIG_T::inv_table_t inv_exp_sum =
            invert_table[softmax_idx_from_real_val<typename CONFIG_T::exp_table_t, CONFIG_T>(exp_sum)];

        res_T out_pack;


    SoftmaxInvPackLoop:
        for (unsigned j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
#pragma HLS ALLOCATION operation instances=mul limit=multiplier_limit
 out_pack[j] = exp_res[j] * inv_exp_sum;
        }
        res.write(out_pack);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_stable(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::exp_table_t exp_table[CONFIG_T::table_size];
    typename CONFIG_T::inv_table_t invert_table[CONFIG_T::table_size];






    if (!initialized) {

        init_exp_table<typename data_T::value_type, CONFIG_T>(exp_table);

        init_invert_table<typename CONFIG_T::exp_table_t, CONFIG_T>(invert_table);
        initialized = true;
    }

    constexpr unsigned multiplier_limit = ((data_T::size + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);
    constexpr unsigned ii = data_T::size / multiplier_limit;

    typename data_T::value_type data_array[data_T::size];
#pragma HLS ARRAY_PARTITION variable=data_array complete
SoftmaxArrayLoop:
    for (unsigned i = 0; i < CONFIG_T::n_in / data_T::size; i++) {
#pragma HLS PIPELINE II=ii

 data_T in_pack = data.read();
    SoftmaxArrayPackLoop:
        for (unsigned j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 data_array[j] = in_pack[j];
        }


        Op_max<typename data_T::value_type> op_max;
        typename data_T::value_type x_max =
            reduce<typename data_T::value_type, data_T::size, Op_max<typename data_T::value_type>>(data_array, op_max);


        ap_fixed<data_T::value_type::width, data_T::value_type::iwidth, AP_RND, AP_SAT> d_xi_xmax[data_T::size];
        for (unsigned j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 d_xi_xmax[j] = data_array[j] - x_max;
        }


        typename CONFIG_T::exp_table_t exp_res[data_T::size];
#pragma HLS ARRAY_PARTITION variable=exp_res complete
 typename CONFIG_T::exp_table_t exp_sum(0);
        for (unsigned j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 unsigned x = softmax_idx_from_real_val<typename data_T::value_type, CONFIG_T>(d_xi_xmax[j]);
            exp_res[j] = exp_table[x];
        }



        Op_add<typename CONFIG_T::exp_table_t> op_add;
        exp_sum =
            reduce<typename CONFIG_T::exp_table_t, data_T::size, Op_add<typename CONFIG_T::exp_table_t>>(exp_res, op_add);

        typename CONFIG_T::inv_table_t inv_exp_sum =
            invert_table[softmax_idx_from_real_val<typename CONFIG_T::exp_table_t, CONFIG_T>(exp_sum)];

        res_T out_pack;


    SoftmaxInvPackLoop:
        for (unsigned j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
#pragma HLS ALLOCATION operation instances=mul limit=multiplier_limit
 out_pack[j] = exp_res[j] * inv_exp_sum;
        }
        res.write(out_pack);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_legacy(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t exp_table[CONFIG_T::table_size];
    typename CONFIG_T::table_t invert_table[CONFIG_T::table_size];





    if (!initialized) {
        init_exp_table_legacy<CONFIG_T, CONFIG_T::table_size>(exp_table);
        init_invert_table_legacy<CONFIG_T, CONFIG_T::table_size>(invert_table);
        initialized = true;
    }


    typename CONFIG_T::table_t exp_res[data_T::size];
    typename CONFIG_T::table_t exp_diff_res;
    typename data_T::value_type data_cache[data_T::size];

SoftmaxInitLoop:
    for (unsigned s = 0; s < CONFIG_T::n_in / data_T::size; s++) {
#pragma HLS PIPELINE
 data_T in_pack = data.read();
    SoftmaxInitPackLoop:
        for (unsigned j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 data_cache[j] = in_pack[j];
            exp_res[j] = 0;
        }

    SoftmaxExpLoop:
        for (int i = 0; i < data_T::size; i++) {
#pragma HLS UNROLL
 SoftmaxExpInner:
            for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL

 if (i == j) {
                    exp_diff_res = 1;
                } else {
                    int data_round = (data_cache[j] - data_cache[i]) * CONFIG_T::table_size / 16;
                    int index = data_round + 8 * CONFIG_T::table_size / 16;
                    if (index < 0)
                        index = 0;
                    if (index > CONFIG_T::table_size - 1)
                        index = CONFIG_T::table_size - 1;
                    exp_diff_res = exp_table[index];
                }

                exp_res[i] += exp_diff_res;
            }
        }

        res_T out_pack;


    SoftmaxInvPackLoop:
        for (unsigned j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL

 int exp_res_index = exp_res[j] * CONFIG_T::table_size / 64;
            if (exp_res_index < 0)
                exp_res_index = 0;
            if (exp_res_index > CONFIG_T::table_size - 1)
                exp_res_index = CONFIG_T::table_size - 1;

            out_pack[j] = (typename res_T::value_type)invert_table[exp_res_index];
        }
        res.write(out_pack);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_argmax(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE
 data_T in_data = data.read();
        res_T out_data;

        for (int i = 0; i < res_T::size; i++) {
#pragma HLS UNROLL
 out_data[i] = (typename res_T::value_type)0;
        }

        typename data_T::value_type maximum = in_data[0];
        int idx = 0;

        for (int i = 1; i < res_T::size; i++) {
#pragma HLS PIPELINE
 if (in_data[i] > maximum) {
                maximum = in_data[i];
                idx = i;
            }
        }

        out_data[idx] = (typename res_T::value_type)1;
        res.write(out_data);
    }
}

template <class data_T, class res_T, typename CONFIG_T> void softmax(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    ({ bool _AssertPred = CONFIG_T::axis == -1; __builtin_assume(_AssertPred); });

    switch (CONFIG_T::implementation) {
    case softmax_implementation::latency:
        softmax_latency<data_T, res_T, CONFIG_T>(data, res);
        break;
    case softmax_implementation::stable:
        softmax_stable<data_T, res_T, CONFIG_T>(data, res);
        break;
    case softmax_implementation::legacy:
        softmax_legacy<data_T, res_T, CONFIG_T>(data, res);
        break;
    case softmax_implementation::argmax:
        softmax_argmax<data_T, res_T, CONFIG_T>(data, res);
        break;
    }
}





template <class data_T, class res_T, typename CONFIG_T> void tanh(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t tanh_table[CONFIG_T::table_size];




    if (!initialized) {
        init_tanh_table<CONFIG_T, CONFIG_T::table_size>(tanh_table);
        initialized = true;
    }

TanHActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    TanHPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 int data_round = in_data[j] * CONFIG_T::table_size / 8;
            int index = data_round + 4 * CONFIG_T::table_size / 8;
            if (index < 0)
                index = 0;
            else if (index > CONFIG_T::table_size - 1)
                index = CONFIG_T::table_size - 1;
            out_data[j] = tanh_table[index];
        }

        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T>
void unary_lut(hls::stream<data_T> &data, hls::stream<res_T> &res, typename CONFIG_T::table_t table[CONFIG_T::table_size]) {
#pragma HLS function_instantiate variable=table
#pragma HLS ARRAY_PARTITION variable=table complete

UnaryLUTActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE II=CONFIG_T::reuse_factor rewind

 data_T in_data = data.read();
        res_T out_data;


    UnaryLUTPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 unsigned index = get_index_unary_lut<CONFIG_T::table_size>(in_data[j].V);
            out_data[j] = table[index];
        }

        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T>
void hard_sigmoid(hls::stream<data_T> &data, hls::stream<res_T> &res) {

HardSigmoidActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    HardSigmoidPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 auto datareg = CONFIG_T::slope * in_data[j] + CONFIG_T::shift;
            if (datareg > 1)
                datareg = 1;
            else if (datareg < 0)
                datareg = 0;
            out_data[j] = datareg;
        }

        res.write(out_data);
    }
}

template <class data_T, class res_T, typename CONFIG_T> void hard_tanh(hls::stream<data_T> &data, hls::stream<res_T> &res) {

HardSigmoidActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    HardSigmoidPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 auto sigmoid = CONFIG_T::slope * in_data[j] + CONFIG_T::shift;
            if (sigmoid > 1)
                sigmoid = 1;
            else if (sigmoid < 0)
                sigmoid = 0;
            out_data[j] = 2 * sigmoid - 1;
        }

        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T>
void leaky_relu(hls::stream<data_T> &data, typename data_T::value_type alpha, hls::stream<res_T> &res) {
LeakyReLUActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    LeakyReLUPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 if (in_data[j] > 0)
                out_data[j] = in_data[j];
            else
                out_data[j] = alpha * in_data[j];
        }
        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T>
void thresholded_relu(hls::stream<data_T> &data, typename data_T::value_type theta, hls::stream<res_T> &res) {
ThresholdedReLUActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    ThresholdedReLUPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 if (in_data[j] > theta)
                out_data[j] = in_data[j];
            else
                out_data[j] = 0;
        }

        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T> void softplus(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t softplus_table[CONFIG_T::table_size];




    if (!initialized) {
        init_softplus_table<CONFIG_T, CONFIG_T::table_size>(softplus_table);
        initialized = true;
    }

SoftplusActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    SoftplusPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 int data_round = in_data[j] * CONFIG_T::table_size / 16;
            int index = data_round + 8 * CONFIG_T::table_size / 16;
            if (index < 0)
                index = 0;
            else if (index > CONFIG_T::table_size - 1)
                index = CONFIG_T::table_size - 1;
            out_data[j] = softplus_table[index];
        }
        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T> void softsign(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t softsign_table[CONFIG_T::table_size];




    if (!initialized) {
        init_softsign_table<CONFIG_T, CONFIG_T::table_size>(softsign_table);
        initialized = true;
    }

SoftsignActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    SoftsignPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 int data_round = in_data[j] * CONFIG_T::table_size / 16;
            int index = data_round + 8 * CONFIG_T::table_size / 16;
            if (index < 0)
                index = 0;
            else if (index > CONFIG_T::table_size - 1)
                index = CONFIG_T::table_size - 1;
            out_data[j] = softsign_table[index];
        }
        res.write(out_data);
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void elu(hls::stream<data_T> &data, typename data_T::value_type alpha, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t elu_table[CONFIG_T::table_size];




    if (!initialized) {
        init_elu_table<CONFIG_T, CONFIG_T::table_size>(elu_table);
        initialized = true;
    }

EluActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    EluPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL

 typename data_T::value_type datareg = in_data[j];
            if (datareg >= 0) {
                out_data[j] = datareg;
            } else {
                int index = datareg * CONFIG_T::table_size / -8;
                if (index > CONFIG_T::table_size - 1)
                    index = CONFIG_T::table_size - 1;
                out_data[j] = alpha * elu_table[index];
            }
        }
        res.write(out_data);
    }
}

template <class data_T, class res_T, typename CONFIG_T> void elu(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    elu<data_T, res_T, CONFIG_T>(data, 1.0, res);
}





template <class data_T, class res_T, typename CONFIG_T> void selu(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t selu_table[CONFIG_T::table_size];




    if (!initialized) {
        init_selu_table<CONFIG_T, CONFIG_T::table_size>(selu_table);
        initialized = true;
    }

SeluActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    SeluPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL

 typename data_T::value_type datareg = in_data[j];
            if (datareg >= 0) {
                out_data[j] = (typename data_T::value_type)1.0507009873554804934193349852946 * datareg;
            } else {
                int index = datareg * CONFIG_T::table_size / -8;
                if (index > CONFIG_T::table_size - 1)
                    index = CONFIG_T::table_size - 1;
                out_data[j] = selu_table[index];
            }
        }
        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T>
void prelu(hls::stream<data_T> &data, typename data_T::value_type alpha[CONFIG_T::n_in], hls::stream<res_T> &res) {
PReLUActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    PReLUPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 if (in_data[j] > 0)
                out_data[j] = in_data[j];
            else
                out_data[j] = alpha[i * res_T::size + j] * in_data[j];
        }
        res.write(out_data);
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void binary_tanh(hls::stream<data_T> &data, hls::stream<res_T> &res) {
PReLUActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    PReLUPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 if (in_data[j] > 0)
                out_data[j] = (typename res_T::value_type)1;
            else
                out_data[j] = (typename res_T::value_type) - 1;
        }
        res.write(out_data);
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void ternary_tanh(hls::stream<data_T> &data, hls::stream<res_T> &res) {
PReLUActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    PReLUPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 if (in_data[j] > 1)
                out_data[j] = (typename res_T::value_type)1;
            else if (in_data[j] <= -1)
                out_data[j] = (typename res_T::value_type) - 1;
            else
                out_data[j] = (typename res_T::value_type)0;
        }
        res.write(out_data);
    }
}

}
# 12 "firmware/parameters.h" 2
# 1 "firmware/nnet_utils/nnet_batchnorm.h" 1





# 1 "firmware/nnet_utils/nnet_dense.h" 1





# 1 "firmware/nnet_utils/nnet_dense_latency.h" 1






# 1 "firmware/nnet_utils/nnet_mult.h" 1







# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 1 3
# 9 "firmware/nnet_utils/nnet_mult.h" 2

namespace nnet {

namespace product {






class Product {};

template <class x_T, class w_T> class both_binary : public Product {
  public:
    static x_T product(x_T a, w_T w) {

#pragma HLS INLINE
 return a == w;
    }
};

template <class x_T, class w_T> class weight_binary : public Product {
  public:
    static auto product(x_T a, w_T w) -> decltype(-a) {

#pragma HLS INLINE
 if (w == 0)
            return -a;
        else
            return a;
    }
};

template <class x_T, class w_T> class data_binary : public Product {
  public:
    static auto product(x_T a, w_T w) -> decltype(-w) {

#pragma HLS INLINE
 if (a == 0)
            return -w;
        else
            return w;
    }
};

template <class x_T, class w_T> class weight_ternary : public Product {
  public:
    static auto product(x_T a, w_T w) -> decltype(-a) {

#pragma HLS INLINE
 if (w == 0)
            return 0;
        else if (w == -1)
            return -a;
        else
            return a;
    }
};

template <class x_T, class w_T> class mult : public Product {
  public:
    static auto product(x_T a, w_T w) -> decltype(a * w) {

#pragma HLS INLINE
 return a * w;
    }
};

template <class x_T, class w_T> class weight_exponential : public Product {
  public:
    using r_T = ap_fixed<2 * (decltype(w_T::weight)::width + x_T::width), (decltype(w_T::weight)::width + x_T::width)>;
    static r_T product(x_T a, w_T w) {

#pragma HLS INLINE


 r_T y = static_cast<r_T>(a) << w.weight;


        return w.sign == 1 ? y : static_cast<r_T>(-y);
    }
};

}

template <class data_T, class res_T, typename CONFIG_T>
inline typename std::enable_if<std::is_same<data_T, ap_uint<1>>::value &&
                                   std::is_same<typename CONFIG_T::weight_t, ap_uint<1>>::value,
                               ap_int<nnet::ceillog2(CONFIG_T::n_in) + 2>>::type
cast(typename CONFIG_T::accum_t x) {
    return (ap_int<nnet::ceillog2(CONFIG_T::n_in) + 2>)(x - CONFIG_T::n_in / 2) * 2;
}

template <class data_T, class res_T, typename CONFIG_T>
inline typename std::enable_if<
    std::is_same<data_T, ap_uint<1>>::value && !std::is_same<typename CONFIG_T::weight_t, ap_uint<1>>::value, res_T>::type
cast(typename CONFIG_T::accum_t x) {
    return (res_T)x;
}

template <class data_T, class res_T, typename CONFIG_T>
inline typename std::enable_if<(!std::is_same<data_T, ap_uint<1>>::value), res_T>::type cast(typename CONFIG_T::accum_t x) {
    return (res_T)x;
}

}
# 8 "firmware/nnet_utils/nnet_dense_latency.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 1 3
# 9 "firmware/nnet_utils/nnet_dense_latency.h" 2

namespace nnet {

template <class data_T, class res_T, typename CONFIG_T>
void dense_latency(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                   typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                   typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
    data_T cache;
    typename CONFIG_T::accum_t mult[CONFIG_T::n_in * CONFIG_T::n_out];
    typename CONFIG_T::accum_t acc[CONFIG_T::n_out];


#pragma HLS function_instantiate variable=weights,biases




#pragma HLS PIPELINE II=CONFIG_T::reuse_factor


#pragma HLS ARRAY_PARTITION variable=biases complete
#pragma HLS ARRAY_PARTITION variable=mult complete
#pragma HLS ARRAY_PARTITION variable=acc complete

#pragma HLS ALLOCATION operation instances=mul limit=CONFIG_T::multiplier_limit


Product1:
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        cache = data[ii];
    Product2:
        for (int jj = 0; jj < CONFIG_T::n_out; jj++) {
            int index = ii * CONFIG_T::n_out + jj;
            mult[index] = CONFIG_T::template product<data_T, typename CONFIG_T::weight_t>::product(cache, weights[index]);
        }
    }


ResetAccum:
    for (int iacc = 0; iacc < CONFIG_T::n_out; iacc++) {
        acc[iacc] = (typename CONFIG_T::accum_t)biases[iacc];
    }


Accum1:
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
    Accum2:
        for (int jj = 0; jj < CONFIG_T::n_out; jj++) {
            int index = ii * CONFIG_T::n_out + jj;
            acc[jj] += mult[index];
        }
    }


Result:
    for (int ires = 0; ires < CONFIG_T::n_out; ires++) {

        res[ires] = cast<data_T, res_T, CONFIG_T>(acc[ires]);
    }
}

}
# 7 "firmware/nnet_utils/nnet_dense.h" 2
# 1 "firmware/nnet_utils/nnet_dense_resource.h" 1






# 1 "/usr/include/assert.h" 1 3 4
# 8 "firmware/nnet_utils/nnet_dense_resource.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 1 3
# 9 "firmware/nnet_utils/nnet_dense_resource.h" 2

namespace nnet {

template <class data_T, class res_T, typename CONFIG_T>
void dense_resource_rf_leq_nin(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                               typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                               typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {

    const int rufactor = CONFIG_T::reuse_factor;
    const int multfactor = (CONFIG_T::n_in > CONFIG_T::reuse_factor ? CONFIG_T::reuse_factor : CONFIG_T::n_in);
    const int multiplier_limit = ((CONFIG_T::n_in * CONFIG_T::n_out + multfactor - 1) / multfactor);
    const int block_factor = ((CONFIG_T::n_in * CONFIG_T::n_out + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);
    const int multscale = multiplier_limit / CONFIG_T::n_out;
    const int nin = CONFIG_T::n_in;
    const int nout = CONFIG_T::n_out;

    ({ bool _AssertPred = (multiplier_limit % nout == 0 || rufactor >= nin) && "The current Reuse Factor is not allowed"; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = (multiplier_limit == block_factor) && "This function is correct only for RF <= N_IN"; __builtin_assume(_AssertPred); });

#pragma HLS function_instantiate variable=weights,biases

#pragma HLS ARRAY_RESHAPE variable=weights block factor=block_factor
#pragma HLS ARRAY_PARTITION variable=biases complete

 typename CONFIG_T::accum_t acc[CONFIG_T::n_out];
#pragma HLS ARRAY_PARTITION variable=acc complete

InitAccum:
    for (int iacc = 0; iacc < nout; iacc++) {
#pragma HLS UNROLL
 acc[iacc] = (typename CONFIG_T::accum_t)biases[iacc];
    }

ReuseLoop:
    for (int ir = 0; ir < rufactor; ir++) {
#pragma HLS PIPELINE II=1 rewind

 int w_index = ir;
        int in_index = ir;
        int out_index = 0;
        int acc_step = 0;

    MultLoop:
        for (int im = 0; im < block_factor; im++) {
#pragma HLS UNROLL

 acc[out_index] += static_cast<typename CONFIG_T::accum_t>(
                CONFIG_T::template product<data_T, typename CONFIG_T::weight_t>::product(data[in_index], weights[w_index]));


            w_index += rufactor;

            in_index += rufactor;
            if (in_index >= nin) {
                in_index = ir;
            }

            if (acc_step + 1 >= multscale) {
                acc_step = 0;
                out_index++;
            } else {
                acc_step++;
            }
        }
    }


Result:
    for (int ires = 0; ires < CONFIG_T::n_out; ires++) {
#pragma HLS UNROLL
 res[ires] = cast<data_T, res_T, CONFIG_T>(acc[ires]);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void dense_resource_rf_gt_nin_rem0(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                                   typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                                   typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {

    const int rufactor = (CONFIG_T::reuse_factor > CONFIG_T::n_in * CONFIG_T::n_out ? CONFIG_T::n_in * CONFIG_T::n_out : CONFIG_T::reuse_factor);
    const int multfactor = (CONFIG_T::n_in > CONFIG_T::reuse_factor ? CONFIG_T::reuse_factor : CONFIG_T::n_in);
    const int multiplier_limit = ((CONFIG_T::n_in * CONFIG_T::n_out + multfactor - 1) / multfactor);
    const int block_factor = ((CONFIG_T::n_in * CONFIG_T::n_out + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);
    const int multscale = multiplier_limit / CONFIG_T::n_out;
    const int nin = CONFIG_T::n_in;
    const int nout = CONFIG_T::n_out;

    ({ bool _AssertPred = (multiplier_limit % nout == 0 || rufactor >= nin) && "The current Reuse Factor is not allowed"; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = (rufactor > nin && rufactor % nin == 0) && "This function is correct only for RF > N_IN && RF % N_IN == 0"; __builtin_assume(_AssertPred); });

#pragma HLS function_instantiate variable=weights,biases

#pragma HLS ARRAY_RESHAPE variable=weights block factor=block_factor
#pragma HLS ARRAY_PARTITION variable=biases complete

 typename CONFIG_T::accum_t acc[CONFIG_T::n_out];
#pragma HLS ARRAY_PARTITION variable=acc complete

InitAccum:
    for (int iacc = 0; iacc < nout; iacc++) {
#pragma HLS UNROLL
 acc[iacc] = (typename CONFIG_T::accum_t)biases[iacc];
    }

    int w_index;
    int in_index = 0;
    int out_index;
    int outstep = 0;
    const int outscale = rufactor / nin;

    int outidx[rufactor];
IndexLoop:
    for (int ir = 0; ir < rufactor; ir++) {
        outidx[ir] = outstep;
        if ((ir + 1) % nin == 0) {
            outstep++;
        }
    }

ReuseLoop:
    for (int ir = 0; ir < rufactor; ir++) {
#pragma HLS PIPELINE II=1 rewind

 w_index = ir;
        out_index = outidx[ir] ;

    MultLoop:
        for (int im = 0; im < block_factor; im++) {
#pragma HLS UNROLL
 acc[out_index] += static_cast<typename CONFIG_T::accum_t>(
                CONFIG_T::template product<data_T, typename CONFIG_T::weight_t>::product(data[in_index], weights[w_index]));

            w_index += rufactor;
            if (w_index >= CONFIG_T::n_in * CONFIG_T::n_out)
                break;
            out_index += outscale;
        }

        in_index++;
        if (in_index >= nin) {
            in_index = 0;

        }
    }


Result:
    for (int ires = 0; ires < CONFIG_T::n_out; ires++) {
#pragma HLS UNROLL
 res[ires] = cast<data_T, res_T, CONFIG_T>(acc[ires]);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void dense_resource_rf_gt_nin(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                              typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                              typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {

    const int rufactor = CONFIG_T::reuse_factor;
    const int multfactor = (CONFIG_T::n_in > CONFIG_T::reuse_factor ? CONFIG_T::reuse_factor : CONFIG_T::n_in);
    const int multiplier_limit = ((CONFIG_T::n_in * CONFIG_T::n_out + multfactor - 1) / multfactor);
    const int block_factor = ((CONFIG_T::n_in * CONFIG_T::n_out + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);
    const int multscale = multiplier_limit / CONFIG_T::n_out;
    const int nin = CONFIG_T::n_in;
    const int nout = CONFIG_T::n_out;

    ({ bool _AssertPred = (multiplier_limit % nout == 0 || rufactor >= nin) && "The current Reuse Factor is not allowed"; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = (rufactor > nin) && "This function is correct only for RF > N_IN"; __builtin_assume(_AssertPred); });

#pragma HLS function_instantiate variable=weights,biases

#pragma HLS ARRAY_RESHAPE variable=weights block factor=block_factor
#pragma HLS ARRAY_PARTITION variable=biases complete

 typename CONFIG_T::accum_t acc[CONFIG_T::n_out];
#pragma HLS ARRAY_PARTITION variable=acc complete

InitAccum:
    for (int iacc = 0; iacc < nout; iacc++) {
#pragma HLS UNROLL
 acc[iacc] = (typename CONFIG_T::accum_t)biases[iacc];
    }

ReuseLoop:
    for (int ir = 0; ir < rufactor; ir++) {
#pragma HLS PIPELINE II=1 rewind
 typename CONFIG_T::accum_t tmpmult[block_factor];
#pragma HLS ARRAY_PARTITION variable=tmpmult complete

 MultLoop:
        for (int im = 0; im < block_factor; im++) {
#pragma HLS UNROLL
 int w_index = ir + rufactor * im;
            int in_index = w_index % nin;
            if (w_index >= CONFIG_T::n_in * CONFIG_T::n_out)
                continue;
            tmpmult[im] =
                CONFIG_T::template product<data_T, typename CONFIG_T::weight_t>::product(data[in_index], weights[w_index]);
        }

        typename CONFIG_T::accum_t mult[multiplier_limit];
#pragma HLS ARRAY_PARTITION variable=mult complete

 ResetMult:
        for (int imult = 0; imult < multiplier_limit; imult++) {
#pragma HLS UNROLL
 mult[imult] = 0;
        }

    AccumLoop1:
        for (int im = 0; im < block_factor; im++) {
#pragma HLS UNROLL
 int w_index = ir + rufactor * im;
            int out_index = w_index / multfactor;
            if (out_index >= multiplier_limit)
                continue;
            mult[out_index] += tmpmult[im];
        }

    AccumLoop2:
        for (int im = 0; im < multiplier_limit; im++) {
#pragma HLS UNROLL


 acc[im] += mult[im];
        }
    }


Result:
    for (int ires = 0; ires < CONFIG_T::n_out; ires++) {
#pragma HLS UNROLL
 res[ires] = cast<data_T, res_T, CONFIG_T>(acc[ires]);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void dense_resource(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                    typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                    typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {

#pragma HLS INLINE recursive

 if (CONFIG_T::reuse_factor <= CONFIG_T::n_in) {
        dense_resource_rf_leq_nin<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    } else if (CONFIG_T::reuse_factor % CONFIG_T::n_in == 0) {
        dense_resource_rf_gt_nin_rem0<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    } else {
        dense_resource_rf_gt_nin<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    }
}

}
# 8 "firmware/nnet_utils/nnet_dense.h" 2


# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 1 3
# 11 "firmware/nnet_utils/nnet_dense.h" 2

namespace nnet {

struct dense_config {

    typedef float bias_t;
    typedef float weight_t;
    typedef float accum_t;


    static const unsigned n_in = 10;
    static const unsigned n_out = 10;


    static const unsigned io_type = io_parallel;
    static const unsigned strategy = latency;
    static const unsigned reuse_factor = 1;
    static const bool store_weights_in_bram = false;
    static const unsigned n_zeros = 0;


    template <class x_T, class y_T> using product = nnet::product::mult<x_T, y_T>;
};

template <class data_T, class res_T, typename CONFIG_T>
void dense(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
           typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
           typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
#pragma HLS inline
 if (CONFIG_T::strategy == nnet::latency) {
        dense_latency<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    } else {
        dense_resource<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    }
}

}
# 7 "firmware/nnet_utils/nnet_batchnorm.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 1 3
# 8 "firmware/nnet_utils/nnet_batchnorm.h" 2

namespace nnet {

struct batchnorm_config {

    typedef float bias_t;
    typedef float scale_t;


    static const unsigned n_in = 10;
    static const unsigned n_filt = -1;
    static const unsigned n_scale_bias = 10;


    static const unsigned io_type = io_parallel;
    static const unsigned reuse_factor = 1;
    static const bool store_weights_in_bram = false;
    static const unsigned n_zeros = 0;

    template <class x_T, class y_T> using product = nnet::product::mult<x_T, y_T>;
};

template <class data_T, class res_T, typename CONFIG_T>
void normalize(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in],
               typename CONFIG_T::scale_t scale[CONFIG_T::n_scale_bias],
               typename CONFIG_T::bias_t bias[CONFIG_T::n_scale_bias]) {
    data_T cache;


#pragma HLS function_instantiate variable=scale,bias




#pragma HLS PIPELINE II=CONFIG_T::reuse_factor


#pragma HLS ARRAY_PARTITION variable=scale complete
#pragma HLS ARRAY_PARTITION variable=bias complete

#pragma HLS ALLOCATION operation instances=mul limit=CONFIG_T::multiplier_limit


Result:
    for (int ires = 0; ires < CONFIG_T::n_in; ires++) {
        if (CONFIG_T::n_filt == -1) {
            res[ires] = CONFIG_T::template product<data_T, typename CONFIG_T::scale_t>::product(data[ires], scale[ires]) +
                        bias[ires];
        } else {
            int norm_index = ires % CONFIG_T::n_filt;
            res[ires] =
                CONFIG_T::template product<data_T, typename CONFIG_T::scale_t>::product(data[ires], scale[norm_index]) +
                bias[norm_index];
        }
    }
}




struct batchnorm_quantized_tanh_config {

    static const unsigned n_in = 10;
    static const unsigned n_filt = -1;
    static const unsigned n_scale_bias = 10;


    static const unsigned io_type = io_parallel;
    static const unsigned reuse_factor = 1;
    static const unsigned n_zeros = 0;
};

template <class data_T, typename CONFIG_T>
void normalize_binary_tanh(data_T data[CONFIG_T::n_in], ap_uint<1> res[CONFIG_T::n_in],
                           data_T threshold[CONFIG_T::n_scale_bias]) {
#pragma HLS PIPELINE
#pragma HLS ARRAY_PARTITION variable=res complete

 data_T datareg;
    ap_uint<1> cache;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        int norm_index = CONFIG_T::n_filt == -1 ? ii : ii % CONFIG_T::n_filt;
        if (datareg >= threshold[norm_index])
            cache = 1;
        else
            cache = 0;

        res[ii] = cache;
    }
}

template <class data_T, typename CONFIG_T>
void normalize_ternary_tanh(data_T data[CONFIG_T::n_in], ap_int<2> res[CONFIG_T::n_in],
                            data_T threshold_hi[CONFIG_T::n_scale_bias], data_T threshold_lo[CONFIG_T::n_scale_bias]) {
#pragma HLS PIPELINE
#pragma HLS ARRAY_PARTITION variable=res complete

 data_T datareg;
    ap_int<2> cache;
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        int norm_index = CONFIG_T::n_filt == -1 ? ii : ii % CONFIG_T::n_filt;
        if (datareg > threshold_hi[norm_index])
            cache = 1;
        else if (datareg <= threshold_lo[norm_index])
            cache = -1;
        else
            cache = 0;

        res[ii] = cache;
    }
}

}
# 13 "firmware/parameters.h" 2
# 1 "firmware/nnet_utils/nnet_batchnorm_stream.h" 1








namespace nnet {





template <class data_T, class res_T, typename CONFIG_T>
void normalize(hls::stream<data_T> &data, hls::stream<res_T> &res, typename CONFIG_T::scale_t scale[CONFIG_T::n_scale_bias],
               typename CONFIG_T::bias_t bias[CONFIG_T::n_scale_bias]) {
#pragma HLS ARRAY_PARTITION variable=scale complete
#pragma HLS ARRAY_PARTITION variable=bias complete

 constexpr unsigned ii = CONFIG_T::n_in / CONFIG_T::multiplier_limit;
#pragma HLS ALLOCATION operation instances=mul limit=CONFIG_T::multiplier_limit

BatchNormLoop:
    for (int i = 0; i < CONFIG_T::n_in / data_T::size; i++) {
#pragma HLS PIPELINE II=ii

 data_T in_data = data.read();
        res_T out_data;


    BatchNormpack:
        for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 int norm_index;
            if (CONFIG_T::n_filt == -1) {
                norm_index = i * data_T::size + j;
            } else {
                norm_index = j % CONFIG_T::n_filt;
            }
            out_data[j] = CONFIG_T::template product<typename data_T::value_type, typename CONFIG_T::scale_t>::product(
                              in_data[j], scale[norm_index]) +
                          bias[norm_index];
        }

        res.write(out_data);
    }
}




template <class data_T, typename CONFIG_T>
void normalize_binary_tanh(hls::stream<data_T> &data, hls::stream<nnet::array<ap_uint<1>, CONFIG_T::n_scale_bias>> &res,
                           typename data_T::value_type threshold[CONFIG_T::n_scale_bias]) {
#pragma HLS ARRAY_PARTITION variable=threshold complete

BinaryNormLoop:
    for (int i = 0; i < CONFIG_T::n_in / data_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        nnet::array<ap_uint<1>, CONFIG_T::n_scale_bias> out_data;


    BatchNormPack:
        for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 int norm_index;
            if (CONFIG_T::n_filt == -1) {
                norm_index = i * data_T::size + j;
            } else {
                norm_index = j % CONFIG_T::n_filt;
            }
            out_data[j] = (in_data[j] >= threshold[norm_index]) ? 1 : 0;
        }

        res.write(out_data);
    }
}

template <class data_T, typename CONFIG_T>
void normalize_ternary_tanh(hls::stream<data_T> &data, hls::stream<nnet::array<ap_int<2>, CONFIG_T::n_scale_bias>> &res,
                            typename data_T::value_type threshold_hi[CONFIG_T::n_scale_bias],
                            typename data_T::value_type threshold_lo[CONFIG_T::n_scale_bias]) {
#pragma HLS ARRAY_PARTITION variable=threshold_hi complete
#pragma HLS ARRAY_PARTITION variable=threshold_lo complete

TernaryNormLoop:
    for (int i = 0; i < CONFIG_T::n_in / data_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        nnet::array<ap_int<2>, CONFIG_T::n_scale_bias> out_data;


    BatchNormPack:
        for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL

 int norm_index;
            if (CONFIG_T::n_filt == -1) {
                norm_index = i * data_T::size + j;
            } else {
                norm_index = j % CONFIG_T::n_filt;
            }

            if (in_data[j] > threshold_hi[norm_index]) {
                out_data[j] = 1;
            } else if (in_data[j] <= threshold_lo[norm_index]) {
                out_data[j] = -1;
            } else {
                out_data[j] = 0;
            }
        }

        res.write(out_data);
    }
}

}
# 14 "firmware/parameters.h" 2
# 1 "firmware/nnet_utils/nnet_conv1d.h" 1




# 1 "firmware/nnet_utils/nnet_conv1d_latency.h" 1





# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 3
# 7 "firmware/nnet_utils/nnet_conv1d_latency.h" 2

namespace nnet {

template <class data_T, class res_T, typename CONFIG_T>
void conv_1d_latency_cl(data_T data[CONFIG_T::in_width * CONFIG_T::n_chan],
                        res_T res[CONFIG_T::out_width * CONFIG_T::n_filt],
                        typename CONFIG_T::weight_t weights[CONFIG_T::filt_width * CONFIG_T::n_chan * CONFIG_T::n_filt],
                        typename CONFIG_T::bias_t biases[CONFIG_T::n_filt]) {
    constexpr unsigned mult_n_in = CONFIG_T::filt_width * CONFIG_T::n_chan;
    constexpr unsigned mult_n_out = CONFIG_T::n_filt;

    data_T data_buf[CONFIG_T::n_pixels][mult_n_in];
#pragma HLS ARRAY_PARTITION variable=data_buf complete dim=0

 typename CONFIG_T::accum_t mult[mult_n_in * mult_n_out];
#pragma HLS ARRAY_PARTITION variable=mult complete

 typename CONFIG_T::accum_t acc[mult_n_out];
#pragma HLS ARRAY_PARTITION variable=acc complete

#pragma HLS ARRAY_PARTITION variable=weights complete
#pragma HLS ARRAY_PARTITION variable=biases complete


#pragma HLS ALLOCATION operation instances=mul limit=CONFIG_T::mult_config::multiplier_limit

PartitionLoop:
    for (int i_part = 0; i_part < CONFIG_T::n_partitions; i_part++) {
#pragma HLS PIPELINE II=CONFIG_T::reuse_factor rewind

 CONFIG_T::template fill_buffer<data_T, CONFIG_T>::fill_buffer(data, data_buf, i_part);

    PixelLoop:
        for (unsigned i_pxl = 0; i_pxl < CONFIG_T::n_pixels; i_pxl++) {
#pragma HLS UNROLL

 data_T cache;


        Product1:
            for (int i_in = 0; i_in < mult_n_in; i_in++) {
#pragma HLS UNROLL
 cache = data_buf[i_pxl][i_in];
            Product2:
                for (int i_out = 0; i_out < mult_n_out; i_out++) {
#pragma HLS UNROLL
 mult[i_in * mult_n_out + i_out] =
                        CONFIG_T::mult_config::template product<data_T, typename CONFIG_T::mult_config::weight_t>::product(
                            cache, weights[i_in * mult_n_out + i_out]);
                }
            }


        ResetAccum:
            for (int i_acc = 0; i_acc < mult_n_out; i_acc++) {
#pragma HLS UNROLL
 acc[i_acc] = (typename CONFIG_T::accum_t)biases[i_acc];
            }


        Accum1:
            for (int i_in = 0; i_in < mult_n_in; i_in++) {
#pragma HLS UNROLL
 Accum2:
                for (int i_out = 0; i_out < mult_n_out; i_out++) {
#pragma HLS UNROLL
 acc[i_out] += mult[i_in * mult_n_out + i_out];
                }
            }


        Result:
            for (int i_res = 0; i_res < mult_n_out; i_res++) {
#pragma HLS UNROLL
 res[i_part * CONFIG_T::n_pixels * mult_n_out + i_pxl * mult_n_out + i_res] =
                    cast<data_T, res_T, typename CONFIG_T::mult_config>(acc[i_res]);
            }
        }
    }
}

}
# 6 "firmware/nnet_utils/nnet_conv1d.h" 2
# 1 "firmware/nnet_utils/nnet_conv1d_resource.h" 1






namespace nnet {

template <class data_T, class res_T, typename CONFIG_T>
void conv_1d_resource_cl(data_T data[CONFIG_T::in_width * CONFIG_T::n_chan],
                         res_T res[CONFIG_T::out_width * CONFIG_T::n_filt],
                         typename CONFIG_T::weight_t weights[CONFIG_T::filt_width * CONFIG_T::n_chan * CONFIG_T::n_filt],
                         typename CONFIG_T::bias_t biases[CONFIG_T::n_filt]) {
    constexpr unsigned mult_n_in = CONFIG_T::filt_width * CONFIG_T::n_chan;
    constexpr unsigned mult_n_out = CONFIG_T::n_filt;
    constexpr unsigned block_factor = ((mult_n_in * mult_n_out + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);
    constexpr unsigned multscale = block_factor / mult_n_out;

    ({ bool _AssertPred = (block_factor % mult_n_out == 0 || CONFIG_T::reuse_factor >= mult_n_in) && "The current Reuse Factor is not allowed"; __builtin_assume(_AssertPred); });

    ({ bool _AssertPred = (CONFIG_T::reuse_factor <= CONFIG_T::filt_width * CONFIG_T::n_chan) && "This function is correct only for RF <= FILT_WIDTH * N_CHAN"; __builtin_assume(_AssertPred); });




    typename CONFIG_T::weight_t(*weights_2d)[CONFIG_T::reuse_factor] =
        (typename CONFIG_T::weight_t(*)[CONFIG_T::reuse_factor])weights;

    data_T data_buf[CONFIG_T::n_pixels][mult_n_in];
#pragma HLS ARRAY_PARTITION variable=data_buf complete dim=0

#pragma HLS ARRAY_PARTITION variable=biases complete

 typename CONFIG_T::accum_t acc[CONFIG_T::n_pixels][mult_n_out];
#pragma HLS ARRAY_PARTITION variable=acc complete dim=0

PartitionLoop:
    for (unsigned i_part = 0; i_part < CONFIG_T::n_partitions; i_part++) {


        CONFIG_T::template fill_buffer<data_T, CONFIG_T>::fill_buffer(data, data_buf, i_part);

    PixelInitAccumLoop:
        for (unsigned i_pxl = 0; i_pxl < CONFIG_T::n_pixels; i_pxl++) {
#pragma HLS UNROLL

 InitAccumLoop:
            for (unsigned i_acc = 0; i_acc < mult_n_out; i_acc++) {
#pragma HLS UNROLL
 acc[i_pxl][i_acc] = (typename CONFIG_T::accum_t)biases[i_acc];
            }
        }

    ReuseLoop:
        for (unsigned i_rf = 0; i_rf < CONFIG_T::reuse_factor; i_rf++) {
#pragma HLS PIPELINE II=1 rewind

 unsigned i_in = i_rf;
            unsigned i_out = 0;
            unsigned i_acc = 0;

        MultLoop:
            for (unsigned i_blk = 0; i_blk < block_factor; i_blk++) {
#pragma HLS UNROLL

 PixelMultLoop:
                for (unsigned i_pxl = 0; i_pxl < CONFIG_T::n_pixels; i_pxl++) {
#pragma HLS UNROLL

 acc[i_pxl][i_out] += static_cast<typename CONFIG_T::accum_t>(
                        CONFIG_T::mult_config::template product<data_T, typename CONFIG_T::mult_config::weight_t>::product(
                            data_buf[i_pxl][i_in], weights_2d[i_blk][i_rf]));
                }


                i_in += CONFIG_T::reuse_factor;
                if (i_in >= mult_n_in) {
                    i_in = i_rf;
                }

                if (i_acc + 1 >= multscale) {
                    i_acc = 0;
                    i_out++;
                } else {
                    i_acc++;
                }
            }
        }

    PixelResultLoop:
        for (unsigned i_pxl = 0; i_pxl < CONFIG_T::n_pixels; i_pxl++) {
#pragma HLS UNROLL

 ResultLoop:
            for (unsigned i_res = 0; i_res < mult_n_out; i_res++) {
#pragma HLS UNROLL
 *(res++) = cast<data_T, res_T, typename CONFIG_T::mult_config>(acc[i_pxl][i_res]);
            }
        }
    }
}

}
# 7 "firmware/nnet_utils/nnet_conv1d.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 1 3
# 40 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/cstdlib" 3
# 8 "firmware/nnet_utils/nnet_conv1d.h" 2

namespace nnet {

struct conv1d_config {

    typedef float bias_t;
    typedef float weight_t;
    typedef float accum_t;


    static const unsigned pad_left = 0;
    static const unsigned pad_right = 0;
    static const unsigned in_width = 10;
    static const unsigned n_chan = 0;
    static const unsigned filt_width = 1;
    static const unsigned kernel_size = filt_width;
    static const unsigned n_filt = 1;
    static const unsigned stride_width = 1;
    static const unsigned dilation = 1;
    static const unsigned out_width = 10;

    static const unsigned reuse_factor = 1;
    static const bool store_weights_in_bram = false;
    static const unsigned n_zeros = 0;
};

template <class data_T, class res_T, typename CONFIG_T>
void conv_1d_cl(data_T data[CONFIG_T::in_width * CONFIG_T::n_chan], res_T res[CONFIG_T::out_width * CONFIG_T::n_filt],
                typename CONFIG_T::weight_t weights[CONFIG_T::filt_width * CONFIG_T::n_chan * CONFIG_T::n_filt],
                typename CONFIG_T::bias_t biases[CONFIG_T::n_filt]) {



    if (CONFIG_T::strategy == nnet::latency) {
        conv_1d_latency_cl<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    } else {
        conv_1d_resource_cl<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void pointwise_conv_1d_cl(data_T data[CONFIG_T::in_width * CONFIG_T::n_chan],
                          res_T res[CONFIG_T::out_width * CONFIG_T::n_filt],
                          typename CONFIG_T::weight_t weights[CONFIG_T::n_chan * CONFIG_T::n_filt],
                          typename CONFIG_T::bias_t biases[CONFIG_T::n_filt]) {
    ({ bool _AssertPred = CONFIG_T::filt_width == 1; __builtin_assume(_AssertPred); });





    if (CONFIG_T::strategy == nnet::latency) {
        conv_1d_latency_cl<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    } else {
        conv_1d_resource_cl<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    }
}

}
# 15 "firmware/parameters.h" 2
# 1 "firmware/nnet_utils/nnet_conv1d_stream.h" 1





# 1 "firmware/nnet_utils/nnet_conv_stream.h" 1



# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_shift_reg.h" 1
# 41 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/ap_shift_reg.h"
template<typename __SHIFT_T__, unsigned int __SHIFT_DEPTH__ = 32>
class ap_shift_reg
{
  public:

    inline __attribute__((always_inline)) __attribute__((nodebug)) ap_shift_reg(){
#pragma HLS inline
 if (std::is_class<__SHIFT_T__>::value) {
#pragma HLS aggregate variable = Array bit
 }
    }
    inline __attribute__((always_inline)) __attribute__((nodebug)) ap_shift_reg(const char* name) {
      (void)name;
#pragma HLS inline
 if (std::is_class<__SHIFT_T__>::value) {
#pragma HLS aggregate variable = Array bit
 }
    }

  private:

    ap_shift_reg(const ap_shift_reg< __SHIFT_T__, __SHIFT_DEPTH__ >& shreg)
    {
        for (unsigned i = 0; i < __SHIFT_DEPTH__; ++i)
            Array[i] = shreg.Array[i];
    }

    ap_shift_reg& operator = (const ap_shift_reg< __SHIFT_T__,
        __SHIFT_DEPTH__ >& shreg)
    {
        for (unsigned i = 0; i < __SHIFT_DEPTH__; ++i)
            Array[i] = shreg.Array[i];
        return *this;
    }

  public:

    inline __attribute__((always_inline)) __attribute__((nodebug)) __SHIFT_T__ shift(__SHIFT_T__ DataIn,
        unsigned int Addr = __SHIFT_DEPTH__ - 1, bool Enable = true)
    {





        __SHIFT_T__ DataOut = __fpga_shift_register_peek((__SHIFT_T__*)Array, Addr);
        __fpga_shift_register_shift(DataIn, (__SHIFT_T__*)Array, Enable);
        return DataOut;

    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) __SHIFT_T__ read(unsigned int Addr = __SHIFT_DEPTH__ - 1) const
    {






        return __fpga_shift_register_peek((__SHIFT_T__*)Array, Addr);

    }

  protected:
    __SHIFT_T__ Array[__SHIFT_DEPTH__] __attribute__((no_ctor));
};
# 5 "firmware/nnet_utils/nnet_conv_stream.h" 2




namespace nnet {

enum class conv_implementation { linebuffer = 0, encoded = 1 };




template <unsigned K, unsigned S, unsigned W> unsigned scale_index_K_gte_S(const unsigned idx) {
#pragma HLS INLINE

 if (idx < K - S) {
        return idx;
    }

    constexpr unsigned nW = ((W - K) / S) * S + K;
    constexpr unsigned sW = (((K + S - 1) / S) - 1) * S + K;
    if (idx >= nW) {
        return sW;
    }

    const unsigned r = nW - idx;
    if (r <= K - S) {
        return sW - r;
    }

    return K - S + (idx - (K - S)) % S;
}

template <unsigned K, unsigned S, unsigned W> unsigned scale_index_K_lt_S(const unsigned idx) {
#pragma HLS INLINE

 if (idx < S - K) {
        return idx;
    }

    constexpr unsigned nW = ((W - K) / S) * S + K;
    constexpr unsigned sW = (((S + K - 1) / K) - 1) * S + K;
    if (idx >= nW) {
        return sW;
    }

    const unsigned r = nW - idx;
    if (r <= S - K) {
        return sW - r;
    }

    return S - K + (idx - (S - K)) % S;
}

template <unsigned K, unsigned S, unsigned W> class scale_index_regular {
  public:
    static unsigned scale_index(const unsigned idx) {
#pragma HLS INLINE

 if (K >= S) {
            return scale_index_K_gte_S<K, S, W>(idx);
        } else {
            return scale_index_K_lt_S<K, S, W>(idx);
        }
    }
};

template <unsigned K, unsigned S, unsigned W> class scale_index_unscaled {
  public:
    static unsigned scale_index(const unsigned idx) {
#pragma HLS INLINE
 return idx;
    }
};

template <class data_T, class res_T, typename CONFIG_T>
void mult_buffer(hls::stream<typename data_T::value_type> data_window[CONFIG_T::kernel_size * CONFIG_T::n_chan],
                 res_T &res_pack, hls::stream<res_T> &res_stream, unsigned &outputs_ready,
                 typename CONFIG_T::weight_t weights[CONFIG_T::kernel_size * CONFIG_T::n_chan * CONFIG_T::n_filt],
                 typename CONFIG_T::bias_t biases[CONFIG_T::n_filt]) {
#pragma HLS INLINE

 typename data_T::value_type data[CONFIG_T::kernel_size * CONFIG_T::n_chan];
#pragma HLS ARRAY_PARTITION variable = data complete
 typename res_T::value_type res[CONFIG_T::n_filt];
#pragma HLS ARRAY_PARTITION variable = res complete

InitData:
    for (int id = 0; id < CONFIG_T::kernel_size * CONFIG_T::n_chan; id++) {
#pragma HLS UNROLL
 data[id] = data_window[id].read();
    }

#pragma HLS INLINE recursive
 if (CONFIG_T::strategy == nnet::latency) {
        dense_latency<typename data_T::value_type, typename res_T::value_type, typename CONFIG_T::mult_config>(
            data, res, weights, biases);
    } else {
        dense_resource<typename data_T::value_type, typename res_T::value_type, typename CONFIG_T::mult_config>(
            data, res, weights, biases);
    }

CastLoop:
    for (unsigned jj = 0; jj < CONFIG_T::n_filt; jj++) {
#pragma HLS UNROLL
 if (res_T::size / CONFIG_T::n_filt == 1) {
            res_pack[jj] = res[jj];
        } else {
            res_pack[outputs_ready * CONFIG_T::n_filt + jj] = res[jj];
        }
    }

    if (res_T::size / CONFIG_T::n_filt == 1) {
        res_stream.write(res_pack);
    } else {
        if (outputs_ready == (res_T::size / CONFIG_T::n_filt) - 1) {
            res_stream.write(res_pack);
            outputs_ready = 0;
        } else {
            outputs_ready++;
        }
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void compute_output_encoded(const data_T &in_elem,
                            hls::stream<typename data_T::value_type> data_window[CONFIG_T::kernel_size * CONFIG_T::n_chan],
                            hls::stream<res_T> &res, res_T &res_pack, unsigned &outputs_ready,
                            typename CONFIG_T::weight_t weights[CONFIG_T::kernel_size * CONFIG_T::n_chan * CONFIG_T::n_filt],
                            typename CONFIG_T::bias_t biases[CONFIG_T::n_filt], ap_uint<CONFIG_T::kernel_size> *pixel_idx) {
#pragma HLS INLINE

MultLoop:
    for (unsigned p = 0; p < data_T::size / CONFIG_T::n_chan; p++) {
#pragma HLS PIPELINE II = CONFIG_T::reuse_factor
 CopyDataFilt:
        for (unsigned f = 0; f < CONFIG_T::kernel_size; f++) {
#pragma HLS UNROLL
 CopyDataChan:
            for (unsigned c = 0; c < CONFIG_T::n_chan; c++) {
#pragma HLS UNROLL
 if (pixel_idx[p][f])
                    data_window[f * CONFIG_T::n_chan + c].write(in_elem[p * CONFIG_T::n_chan + c]);
            }
        }
        if (pixel_idx[p][CONFIG_T::kernel_size - 1]) {
            mult_buffer<data_T, res_T, CONFIG_T>(data_window, res_pack, res, outputs_ready, weights, biases);
        }
    }
}




template <class data_T, typename CONFIG_T>
void kernel_shift_1d(const data_T &in_elem,
                     typename data_T::value_type kernel_window[CONFIG_T::filt_width * CONFIG_T::n_chan]) {
#pragma HLS inline


 static const int filt_width = CONFIG_T::filt_width - 1;
KernelShiftWidth:
    for (int i_iw = 0; i_iw < filt_width; i_iw++) {
#pragma HLS PIPELINE II = 1
 KernelShiftChannel:
        for (unsigned i_ic = 0; i_ic < CONFIG_T::n_chan; i_ic++) {
#pragma HLS UNROLL

 kernel_window[i_iw * CONFIG_T::n_chan + i_ic] = kernel_window[(i_iw + 1) * CONFIG_T::n_chan + i_ic];
        }
    }


    static const int lastheight = (CONFIG_T::filt_width - 1) * CONFIG_T::n_chan;
KernelPushChannel:
    for (int i_ic = 0; i_ic < CONFIG_T::n_chan; i_ic++) {
#pragma HLS UNROLL
 kernel_window[lastheight + i_ic] = in_elem[i_ic];
    }
}

template <class data_T, typename CONFIG_T>
void kernel_shift_2d(
    typename data_T::value_type shift_buffer[CONFIG_T::filt_height][CONFIG_T::n_chan],
    typename data_T::value_type kernel_window[CONFIG_T::filt_width * CONFIG_T::filt_height * CONFIG_T::n_chan]) {
#pragma HLS inline


 static const int filt_width = CONFIG_T::filt_width - 1;
KernelShiftWidth:
    for (int i_iw = 0; i_iw < filt_width; i_iw++) {
#pragma HLS PIPELINE II = 1
 KernelShiftHeight:
        for (unsigned i_ih = 0; i_ih < CONFIG_T::filt_height; i_ih++) {
        KernelShiftChannel:
            for (unsigned i_ic = 0; i_ic < CONFIG_T::n_chan; i_ic++) {

                kernel_window[i_ih * CONFIG_T::filt_width * CONFIG_T::n_chan + i_iw * CONFIG_T::n_chan + i_ic] =
                    kernel_window[i_ih * CONFIG_T::filt_width * CONFIG_T::n_chan + (i_iw + 1) * CONFIG_T::n_chan + i_ic];
            }
        }
    }


    static const int lastheight = (CONFIG_T::filt_width - 1) * CONFIG_T::n_chan;
KernelPushHeight:
    for (int i_ih = 0; i_ih < CONFIG_T::filt_height; i_ih++) {
#pragma HLS UNROLL
 KernelPushChannel:
        for (int i_ic = 0; i_ic < CONFIG_T::n_chan; i_ic++) {
            kernel_window[lastheight + i_ih * CONFIG_T::filt_width * CONFIG_T::n_chan + i_ic] = shift_buffer[i_ih][i_ic];
        }
    }
}

template <class data_T, typename CONFIG_T>
void shift_line_buffer(
    const data_T &in_elem,
    ap_shift_reg<typename data_T::value_type, CONFIG_T::in_width> line_buffer[(CONFIG_T::filt_height - 1 > 1 ? CONFIG_T::filt_height - 1 : 1)]
                                                                             [CONFIG_T::n_chan],
    typename data_T::value_type kernel_window[CONFIG_T::filt_height * CONFIG_T::filt_width * CONFIG_T::n_chan]) {

#pragma HLS PIPELINE


 typename data_T::value_type shift_buffer[CONFIG_T::filt_height][CONFIG_T::n_chan];
#pragma HLS ARRAY_PARTITION variable = shift_buffer complete dim = 0

UpdateBuffer:
    for (int i_ic = 0; i_ic < CONFIG_T::n_chan; i_ic++) {
#pragma HLS UNROLL


 shift_buffer[CONFIG_T::filt_height - 1][i_ic] = in_elem[i_ic];
    }

LineBufferDataIn:
    for (int i_ic = 0; i_ic < CONFIG_T::n_chan; i_ic++) {

    LineBufferShift:
        for (unsigned i_ih = 1; i_ih < CONFIG_T::filt_height; i_ih++) {
#pragma HLS UNROLL
 typename data_T::value_type pop_elem = line_buffer[i_ih - 1][i_ic].shift(
                shift_buffer[CONFIG_T::filt_height - i_ih][i_ic]);
            shift_buffer[CONFIG_T::filt_height - i_ih - 1][i_ic] =
                pop_elem;
        }
    }
    kernel_shift_2d<data_T, CONFIG_T>(shift_buffer, kernel_window);
}

template <class data_T, class res_T, typename CONFIG_T>
void compute_output_buffer_2d(
    const data_T &in_elem,
    ap_shift_reg<typename data_T::value_type, CONFIG_T::in_width> line_buffer[(CONFIG_T::filt_height - 1 > 1 ? CONFIG_T::filt_height - 1 : 1)]
                                                                             [CONFIG_T::n_chan],
    hls::stream<res_T> &res_stream,
    typename CONFIG_T::weight_t weights[CONFIG_T::kernel_size * CONFIG_T::n_chan * CONFIG_T::n_filt],
    typename CONFIG_T::bias_t biases[CONFIG_T::n_filt]) {
#pragma HLS INLINE OFF


 const static int lShiftX = CONFIG_T::filt_width - 1;
    const static int lShiftY = CONFIG_T::filt_height - 1;


    static int pX = 0;
    static int pY = 0;

    static int sX = 0;
    static int sY = 0;

    static typename data_T::value_type kernel_data[CONFIG_T::filt_height * CONFIG_T::filt_width * CONFIG_T::n_chan];
#pragma HLS ARRAY_PARTITION variable = kernel_data complete

 typename res_T::value_type res_out[CONFIG_T::n_filt];
#pragma HLS ARRAY_PARTITION variable = res_out complete dim = 0

 res_T res_pack;



    nnet::shift_line_buffer<data_T, CONFIG_T>(in_elem, line_buffer, kernel_data);


    if ((sX - lShiftX) == 0 && (sY - lShiftY) == 0 && pY > lShiftY - 1 && pX > lShiftX - 1) {



        if (CONFIG_T::strategy == nnet::latency) {
            dense_latency<typename data_T::value_type, typename res_T::value_type, typename CONFIG_T::mult_config>(
                kernel_data, res_out, weights, biases);
        } else {
            dense_resource<typename data_T::value_type, typename res_T::value_type, typename CONFIG_T::mult_config>(
                kernel_data, res_out, weights, biases);
        }


    CastLoop:
        for (unsigned i_ic = 0; i_ic < CONFIG_T::n_filt; i_ic++) {
#pragma HLS UNROLL
 res_pack[i_ic] = res_out[i_ic];
        }


        res_stream.write(res_pack);
    }


    if (pX + 1 == CONFIG_T::in_width)
    {
        pX = 0;
        sX = 0;
        if (pY + 1 == CONFIG_T::in_height) {
            pY = 0;
            sY = 0;
        } else {
            pY = pY + 1;

            sY = ((sY - lShiftY) == 0) ? sY - CONFIG_T::stride_height + 1 : sY + 1;
        }
    } else {
        pX = pX + 1;

        sX = ((sX - lShiftX) == 0) ? sX - CONFIG_T::stride_width + 1 : sX + 1;
    }
}


template <class data_T, class res_T, typename CONFIG_T>
void compute_output_buffer_1d(
    const data_T &in_elem, hls::stream<res_T> &res_stream,
    typename CONFIG_T::weight_t weights[CONFIG_T::kernel_size * CONFIG_T::n_chan * CONFIG_T::n_filt],
    typename CONFIG_T::bias_t biases[CONFIG_T::n_filt]) {
#pragma HLS INLINE


 const static int lShiftX = CONFIG_T::filt_width - 1;


    static int pX = 0;
    static int sX = 0;

    static typename data_T::value_type kernel_data[CONFIG_T::filt_width * CONFIG_T::n_chan];
#pragma HLS ARRAY_PARTITION variable = kernel_data complete

 typename res_T::value_type res_out[CONFIG_T::n_filt];
#pragma HLS ARRAY_PARTITION variable = res_out complete dim = 0

 res_T res_pack;



    nnet::kernel_shift_1d<data_T, CONFIG_T>(in_elem, kernel_data);


    if ((sX - lShiftX) == 0 && pX > lShiftX - 1) {


#pragma HLS INLINE recursive
 if (CONFIG_T::strategy == nnet::latency) {
            dense_latency<typename data_T::value_type, typename res_T::value_type, typename CONFIG_T::mult_config>(
                kernel_data, res_out, weights, biases);
        } else {
            dense_resource<typename data_T::value_type, typename res_T::value_type, typename CONFIG_T::mult_config>(
                kernel_data, res_out, weights, biases);
        }


    CastLoop:
        for (unsigned i_ic = 0; i_ic < CONFIG_T::n_filt; i_ic++) {
#pragma HLS UNROLL
 res_pack[i_ic] = res_out[i_ic];
        }


        res_stream.write(res_pack);
    }


    if (pX + 1 == CONFIG_T::in_width)
    {
        pX = 0;
        sX = 0;
    } else {
        pX = pX + 1;

        sX = ((sX - lShiftX) == 0) ? sX - CONFIG_T::stride_width + 1 : sX + 1;
    }
}

}
# 7 "firmware/nnet_utils/nnet_conv1d_stream.h" 2

namespace nnet {

template <class data_T, class res_T, typename CONFIG_T>
void conv_1d_cl(hls::stream<data_T> &data, hls::stream<res_T> &res,
                typename CONFIG_T::weight_t weights[CONFIG_T::filt_width * CONFIG_T::n_chan * CONFIG_T::n_filt],
                typename CONFIG_T::bias_t biases[CONFIG_T::n_filt]) {
    ({ bool _AssertPred = CONFIG_T::implementation == conv_implementation::linebuffer && "Only \"linebuffer\" implementation is supported in Vitis HLS."; __builtin_assume(_AssertPred); });


    ({ bool _AssertPred = CONFIG_T::pad_left == 0 && CONFIG_T::pad_right == 0; __builtin_assume(_AssertPred); });

    if (CONFIG_T::strategy == nnet::latency) {
    ReadInputWidth:
        for (unsigned i_iw = 0; i_iw < CONFIG_T::in_width; i_iw++) {
#pragma HLS PIPELINE II=CONFIG_T::reuse_factor
 compute_output_buffer_1d<data_T, res_T, CONFIG_T>(data.read(), res, weights, biases);
        }
    } else {
    ReadInputWidthSerial:
        for (unsigned i_iw = 0; i_iw < CONFIG_T::in_width; i_iw++) {
            compute_output_buffer_1d<data_T, res_T, CONFIG_T>(data.read(), res, weights, biases);
        }
    }
}

}
# 16 "firmware/parameters.h" 2

# 1 "firmware/nnet_utils/nnet_dense_compressed.h" 1






# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 1 3
# 8 "firmware/nnet_utils/nnet_dense_compressed.h" 2

namespace nnet {

template <typename CONFIG_T>
void fill_mult(typename CONFIG_T::index_t index, typename CONFIG_T::accum_t mult[CONFIG_T::n_out],
               typename CONFIG_T::accum_t weight) {
    for (unsigned k = 0; k < CONFIG_T::n_out; k++) {
#pragma HLS UNROLL
 if (k == index)
            mult[k] += weight;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void dense_compressed(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                      typename CONFIG_T::weight_t weights[CONFIG_T::n_nonzeros],
                      typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {

    const int multiplier_limit = ((CONFIG_T::n_nonzeros + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);

    typename CONFIG_T::accum_t acc[CONFIG_T::n_out];
#pragma HLS ARRAY_PARTITION variable=acc complete
#pragma HLS ARRAY_PARTITION variable=biases complete
#pragma HLS ARRAY_RESHAPE variable=weights block factor=multiplier_limit


#pragma HLS AGGREGATE variable=weights




InitAccum:
    for (unsigned i = 0; i < CONFIG_T::n_out; i++) {
#pragma HLS UNROLL
 acc[i] = (typename CONFIG_T::accum_t)(biases[i]);
    }


    const int rufactor = CONFIG_T::reuse_factor;
ReuseLoop:
    for (unsigned ir = 0; ir < rufactor; ir++) {
#pragma HLS PIPELINE II=1 rewind

 typename CONFIG_T::accum_t mult[CONFIG_T::n_out];
#pragma HLS ARRAY_PARTITION variable=mult complete

 ResetMult:
        for (int imult = 0; imult < CONFIG_T::n_out; imult++) {
#pragma HLS UNROLL
 mult[imult] = 0;
        }

    CompressedMultLoop:
        for (unsigned im = 0; im < multiplier_limit; im++) {
#pragma HLS UNROLL
 unsigned w = im * rufactor + ir;
            auto row = weights[w].row_index;
            auto col = weights[w].col_index;
            auto weight_cache = weights[w].weight;
            data_T data_cache = data[row];

            typename CONFIG_T::accum_t prod =
                CONFIG_T::template product<data_T, typename CONFIG_T::weight_t>::product(data_cache, weight_cache);
            fill_mult<CONFIG_T>(col, mult, prod);
        }

        for (int im = 0; im < CONFIG_T::n_out; im++) {
            acc[im] += mult[im];
        }
    }


ResultLoop:
    for (unsigned i = 0; i < CONFIG_T::n_out; i++) {
#pragma HLS UNROLL

 res[i] = cast<data_T, res_T, CONFIG_T>(acc[i]);
    }
}

}
# 18 "firmware/parameters.h" 2
# 1 "firmware/nnet_utils/nnet_dense_stream.h" 1






# 1 "/usr/include/assert.h" 1 3 4
# 8 "firmware/nnet_utils/nnet_dense_stream.h" 2
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/tps/lnx64/gcc-8.3.0/lib/gcc/x86_64-pc-linux-gnu/8.3.0/../../../../include/c++/8.3.0/math.h" 1 3
# 9 "firmware/nnet_utils/nnet_dense_stream.h" 2

namespace nnet {

template <class data_T, class res_T, typename CONFIG_T>
void dense_latency_wrapper(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                           typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                           typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
#pragma HLS PIPELINE II=CONFIG_T::reuse_factor
 dense_latency<data_T, res_T, CONFIG_T>(data, res, weights, biases);
}

template <class data_T, class res_T, typename CONFIG_T>
void dense_resource_wrapper(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                            typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                            typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
    dense_resource<data_T, res_T, CONFIG_T>(data, res, weights, biases);
}

template <class data_T, typename CONFIG_T>
void data_prepare(hls::stream<data_T> &data_stream, typename data_T::value_type data[CONFIG_T::n_in]) {
#pragma HLS INLINE

 if (CONFIG_T::n_in / data_T::size > 1) {
    DataPrepare:
        for (int i_in = 0; i_in < CONFIG_T::n_in / data_T::size; i_in++) {
#pragma HLS PIPELINE
 data_T data_pack = data_stream.read();
        DataPackPipeline:
            for (int i_pack = 0; i_pack < data_T::size; i_pack++) {
#pragma HLS UNROLL
 data[i_in * data_T::size + i_pack] = data_pack[i_pack];
            }
        }
    } else {
        data_T data_pack = data_stream.read();
    DataPackSingle:
        for (int i_pack = 0; i_pack < data_T::size; i_pack++) {
#pragma HLS UNROLL
 data[i_pack] = data_pack[i_pack];
        }
    }
}

template <class res_T, typename CONFIG_T>
void res_write(typename res_T::value_type res[CONFIG_T::n_out], hls::stream<res_T> &res_stream) {
#pragma HLS INLINE

 if (CONFIG_T::n_out / res_T::size > 1) {
    ResWrite:
        for (unsigned i_out = 0; i_out < CONFIG_T::n_out / res_T::size; i_out++) {
#pragma HLS PIPELINE
 res_T res_pack;

        ResPackPipeline:
            for (int i_pack = 0; i_pack < res_T::size; i_pack++) {
#pragma HLS UNROLL
 res_pack[i_pack] = res[i_out * res_T::size + i_pack];
            }
            res_stream.write(res_pack);
        }
    } else {
        res_T res_pack;

    ResPackSingle:
        for (int i_pack = 0; i_pack < res_T::size; i_pack++) {
#pragma HLS UNROLL
 res_pack[i_pack] = res[i_pack];
        }
        res_stream.write(res_pack);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void dense(hls::stream<data_T> &data_stream, hls::stream<res_T> &res_stream,
           typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
           typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
#pragma HLS INLINE recursive

 typename data_T::value_type data[CONFIG_T::n_in];
#pragma HLS ARRAY_PARTITION variable=data complete

 typename res_T::value_type res[CONFIG_T::n_out];
#pragma HLS ARRAY_PARTITION variable=res complete

 data_prepare<data_T, CONFIG_T>(data_stream, data);
    if (CONFIG_T::strategy == nnet::latency) {
        dense_latency_wrapper<typename data_T::value_type, typename res_T::value_type, CONFIG_T>(data, res, weights, biases);
    } else {
        dense_resource_wrapper<typename data_T::value_type, typename res_T::value_type, CONFIG_T>(data, res, weights,
                                                                                                  biases);
    }
    res_write<res_T, CONFIG_T>(res, res_stream);
}

}
# 19 "firmware/parameters.h" 2
# 1 "firmware/nnet_utils/nnet_pooling.h" 1







namespace nnet {


template <typename T, int N, typename accum_t> accum_t max(T x[N]) {
    T y = x[0];
    for (int i = 1; i < N; i++) {
        y = x[i] > y ? x[i] : y;
    }
    return y;
}


template <typename T, int N, typename accum_t> accum_t avg(T (&x)[N], unsigned length) {
    accum_t y = 0;
    for (int i = 0; i < N; i++) {
        y += x[i];
    }
    y /= length;
    return y;
}


enum Pool_Op { Max, Average };
template <typename T, int N, Pool_Op op, typename accum_t> accum_t pool_op(T (&x)[N], unsigned length) {
    switch (op) {
    case Max:
        return max<T, N, accum_t>(x);
    case Average:
        return avg<T, N, accum_t>(x, length);

    }
}

template <typename T, int N, Pool_Op op, typename accum_t> accum_t pool_op(T (&x)[N]) {
    return pool_op<T, N, op, accum_t>(x, N);
}

template <typename T, Pool_Op op> T pad_val() {







    switch (op) {
    case Max: {
        T x = 0;
        x[x.width - 1] = 1;
        return x;
        break;
    }
    case Average:
        return 0;
    }
}

struct pooling1d_config {

    static const unsigned n_in = 10;
    static const unsigned pool_width = 2;
    static const unsigned stride_width = 2;
    static const unsigned n_out = (n_in - pool_width) / stride_width + 1;
    static const unsigned pad_left = 0;
    static const unsigned pad_right = 0;

    static const Pool_Op pool_op = Max;
};

template <typename CONFIG_T> constexpr int pool_op_limit_1d() {
    return CONFIG_T::n_in * CONFIG_T::n_filt / CONFIG_T::reuse_factor;
}

template <class data_T, class res_T, typename CONFIG_T>
void pooling1d_cl(data_T data[CONFIG_T::n_in * CONFIG_T::n_filt], res_T res[CONFIG_T::n_out * CONFIG_T::n_filt]) {
#pragma HLS PIPELINE II=CONFIG_T::reuse_factor


 const int limit = pool_op_limit_1d<CONFIG_T>();
#pragma HLS ALLOCATION function instances=pool_op<data_T, CONFIG_T::pool_width, CONFIG_T::pool_op, typename CONFIG_T::accum_t> limit=limit



 unsigned padded_width = CONFIG_T::n_in + CONFIG_T::pad_left + CONFIG_T::pad_right;
    if (CONFIG_T::pad_left == 0 && CONFIG_T::pad_right == 0) {
        padded_width -= padded_width - (padded_width / CONFIG_T::stride_width * CONFIG_T::stride_width);
    }

    for (int ff = 0; ff < CONFIG_T::n_filt; ff++) {

        for (int ii = 0; ii < padded_width; ii += CONFIG_T::stride_width) {
            unsigned overlap_pixel = 0;
            data_T pool[CONFIG_T::pool_width];
#pragma HLS ARRAY_PARTITION variable=pool complete dim=0

 for (int jj = 0; jj < CONFIG_T::pool_width; jj++) {
                if (ii + jj >= CONFIG_T::pad_left && ii + jj < CONFIG_T::n_in + CONFIG_T::pad_left) {
                    pool[jj] = data[(ii + jj - CONFIG_T::pad_left) * CONFIG_T::n_filt + ff];
                    overlap_pixel++;
                } else
                    pool[jj] = pad_val<data_T, CONFIG_T::pool_op>();
            }

            int patch_size = CONFIG_T::count_pad ? CONFIG_T::stride_width : overlap_pixel;

            res[(ii / CONFIG_T::stride_width) * CONFIG_T::n_filt + ff] =
                pool_op<data_T, CONFIG_T::pool_width, CONFIG_T::pool_op, typename CONFIG_T::accum_t>(pool, patch_size);
        }
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void global_pooling1d_cl(data_T data[CONFIG_T::n_in * CONFIG_T::n_filt], res_T res[CONFIG_T::n_filt]) {
#pragma HLS PIPELINE II=CONFIG_T::reuse_factor

 ({ bool _AssertPred = CONFIG_T::pad_left == 0 && CONFIG_T::pad_right == 0; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = CONFIG_T::pool_width == CONFIG_T::stride_width; __builtin_assume(_AssertPred); });


    const int limit = pool_op_limit_1d<CONFIG_T>();
#pragma HLS ALLOCATION function instances=pool_op<data_T, CONFIG_T::pool_width, CONFIG_T::pool_op, typename CONFIG_T::accum_t> limit=limit


 for (int ff = 0; ff < CONFIG_T::n_filt; ff++) {
        data_T pool[CONFIG_T::n_in];
        for (int jj = 0; jj < CONFIG_T::n_in; jj++) {
            pool[jj] = data[jj * CONFIG_T::n_filt + ff];
        }

        res[ff] = pool_op<data_T, CONFIG_T::n_in, CONFIG_T::pool_op, typename CONFIG_T::accum_t>(pool);
    }
}

struct pooling2d_config {

    static const unsigned in_height = 10;
    static const unsigned in_width = 10;
    static const unsigned n_filt = 4;
    static const unsigned stride_height = 2;
    static const unsigned stride_width = 2;
    static const unsigned pool_height = 2;
    static const unsigned pool_width = 2;
    static const unsigned out_height = (in_height - pool_height) / stride_height + 1;
    static const unsigned out_width = (in_width - pool_width) / stride_width + 1;

    static const unsigned pad_top = 0;
    static const unsigned pad_bottom = 0;
    static const unsigned pad_left = 0;
    static const unsigned pad_right = 0;

    static const Pool_Op pool_op = Max;

    static const unsigned reuse_factor = 1;


    typedef float accum_t;
};

template <typename CONFIG_T> constexpr int pool_op_limit() {
    return (((CONFIG_T::out_height * CONFIG_T::out_width) * CONFIG_T::n_filt + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);
}

template <class data_T, class res_T, typename CONFIG_T>
void pooling2d_cl(data_T data[CONFIG_T::in_height * CONFIG_T::in_width * CONFIG_T::n_filt],
                  res_T res[CONFIG_T::out_height * CONFIG_T::out_width * CONFIG_T::n_filt]) {
#pragma HLS PIPELINE II=CONFIG_T::reuse_factor


 const int limit = pool_op_limit<CONFIG_T>();
#pragma HLS ALLOCATION function instances=pool_op<data_T, CONFIG_T::pool_height*CONFIG_T::pool_width, CONFIG_T::pool_op, typename CONFIG_T::accum_t> limit=limit

 unsigned padded_height = CONFIG_T::in_height + CONFIG_T::pad_top + CONFIG_T::pad_bottom;
    unsigned padded_width = CONFIG_T::in_width + CONFIG_T::pad_left + CONFIG_T::pad_right;
    if (CONFIG_T::pad_top == 0 && CONFIG_T::pad_bottom == 0 && CONFIG_T::pad_left == 0 && CONFIG_T::pad_right == 0) {
        padded_height -= padded_height - (padded_height / CONFIG_T::stride_height * CONFIG_T::stride_height);
        padded_width -= padded_width - (padded_width / CONFIG_T::stride_width * CONFIG_T::stride_width);
    }

    for (int ff = 0; ff < CONFIG_T::n_filt; ff++) {

        for (int ii = 0; ii < padded_height; ii += CONFIG_T::stride_height) {

            for (int jj = 0; jj < padded_width; jj += CONFIG_T::stride_width) {
                data_T pool[CONFIG_T::pool_height * CONFIG_T::pool_width];
#pragma HLS ARRAY_PARTITION variable=pool complete dim=0

 unsigned overlap_pixel = 0;


                for (int kk = 0; kk < CONFIG_T::stride_height; kk++) {

                    for (int ll = 0; ll < CONFIG_T::stride_width; ll++) {
                        bool cond1 = ii + kk >= CONFIG_T::pad_top && ii + kk < CONFIG_T::in_height + CONFIG_T::pad_top;
                        bool cond2 = jj + ll >= CONFIG_T::pad_left && jj + ll < CONFIG_T::in_width + CONFIG_T::pad_left;
                        if (cond1 && cond2) {
                            unsigned data_idx =
                                ((ii + kk - CONFIG_T::pad_top) * CONFIG_T::in_width + (jj + ll - CONFIG_T::pad_left)) *
                                    CONFIG_T::n_filt +
                                ff;
                            pool[kk * CONFIG_T::stride_width + ll] = data[data_idx];
                            overlap_pixel++;
                        } else
                            pool[kk * CONFIG_T::stride_width + ll] = pad_val<data_T, CONFIG_T::pool_op>();
                    }
                }

                int patch_size = CONFIG_T::count_pad ? CONFIG_T::stride_width * CONFIG_T::stride_height : overlap_pixel;

                res[(ii / CONFIG_T::stride_height) * CONFIG_T::out_width * CONFIG_T::n_filt +
                    (jj / CONFIG_T::stride_width) * CONFIG_T::n_filt + ff] =
                    pool_op<data_T, CONFIG_T::pool_height * CONFIG_T::pool_width, CONFIG_T::pool_op,
                            typename CONFIG_T::accum_t>(pool, patch_size);
            }
        }
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void pooling2d_cf(data_T data[CONFIG_T::in_height * CONFIG_T::in_width * CONFIG_T::n_filt],
                  res_T res[CONFIG_T::out_height * CONFIG_T::out_width * CONFIG_T::n_filt]) {
#pragma HLS PIPELINE II=CONFIG_T::reuse_factor


 const int limit = pool_op_limit<CONFIG_T>();
#pragma HLS ALLOCATION function instances=pool_op<data_T, CONFIG_T::pool_height*CONFIG_T::pool_width, CONFIG_T::pool_op, typename CONFIG_T::accum_t> limit=limit


 unsigned padded_height = CONFIG_T::in_height + CONFIG_T::pad_top + CONFIG_T::pad_bottom;
    unsigned padded_width = CONFIG_T::in_width + CONFIG_T::pad_left + CONFIG_T::pad_right;
    if (CONFIG_T::pad_top == 0 && CONFIG_T::pad_bottom == 0 && CONFIG_T::pad_left == 0 && CONFIG_T::pad_right == 0) {
        padded_height -= padded_height - (padded_height / CONFIG_T::stride_height * CONFIG_T::stride_height);
        padded_width -= padded_width - (padded_width / CONFIG_T::stride_width * CONFIG_T::stride_width);
    }

    for (int ff = 0; ff < CONFIG_T::n_filt; ff++) {

        for (int ii = 0; ii < padded_height; ii += CONFIG_T::stride_height) {

            for (int jj = 0; jj < padded_width; jj += CONFIG_T::stride_width) {
                data_T pool[CONFIG_T::pool_height * CONFIG_T::pool_width];

                unsigned img_overlap = 0;

                for (int kk = 0; kk < CONFIG_T::stride_height; kk++) {

                    for (int ll = 0; ll < CONFIG_T::stride_width; ll++) {
                        if (ii + kk < CONFIG_T::pad_top || ii + kk >= (padded_height - CONFIG_T::pad_bottom) ||
                            jj + ll < CONFIG_T::pad_left || jj + ll >= (padded_width - CONFIG_T::pad_right)) {

                            pool[kk * CONFIG_T::stride_width + ll] = pad_val<data_T, CONFIG_T::pool_op>();
                        } else {
                            pool[kk * CONFIG_T::stride_width + ll] =
                                data[(ii + kk) * CONFIG_T::in_width + ff * CONFIG_T::in_width * CONFIG_T::in_height + ll +
                                     jj];
                            img_overlap++;
                        }
                    }
                }



                res[(ii / CONFIG_T::stride_height) * CONFIG_T::out_width + (jj / CONFIG_T::stride_width) +
                    ff * CONFIG_T::out_height * CONFIG_T::out_width] =
                    pool_op<data_T, CONFIG_T::pool_height * CONFIG_T::pool_width, CONFIG_T::pool_op,
                            typename CONFIG_T::accum_t>(pool);

                if (CONFIG_T::pool_op == Average) {
                    data_T rescale =
                        static_cast<data_T>(CONFIG_T::pool_height) * static_cast<data_T>(CONFIG_T::pool_width) / img_overlap;
                    res[(ii / CONFIG_T::stride_height) * CONFIG_T::out_width + (jj / CONFIG_T::stride_width) +
                        ff * CONFIG_T::out_height * CONFIG_T::out_width] *= rescale;
                }
            }
        }
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void global_pooling2d_cl(data_T data[CONFIG_T::in_height * CONFIG_T::in_width * CONFIG_T::n_filt],
                         res_T res[CONFIG_T::n_filt]) {
    ({ bool _AssertPred = CONFIG_T::pad_left == 0 && CONFIG_T::pad_right == 0; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = CONFIG_T::pad_top == 0 && CONFIG_T::pad_bottom == 0; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = CONFIG_T::pool_width == CONFIG_T::stride_width; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = CONFIG_T::pool_height == CONFIG_T::stride_height; __builtin_assume(_AssertPred); });

#pragma HLS PIPELINE II=CONFIG_T::reuse_factor

 const int limit = pool_op_limit<CONFIG_T>();
#pragma HLS ALLOCATION function instances=pool_op<data_T, CONFIG_T::pool_width * CONFIG_T::pool_height, CONFIG_T::pool_op, typename CONFIG_T::accum_t> limit=limit


FiltLoop:
    for (int filt = 0; filt < CONFIG_T::n_filt; filt++) {
        data_T pool[CONFIG_T::in_height * CONFIG_T::in_width];

    InputLoop:
        for (int i = 0; i < CONFIG_T::in_height * CONFIG_T::in_width; i++) {
            pool[i] = data[i * CONFIG_T::n_filt + filt];
        }

        res[filt] = static_cast<res_T>(
            pool_op<data_T, CONFIG_T::in_height * CONFIG_T::in_width, CONFIG_T::pool_op, typename CONFIG_T::accum_t>(pool));
    }
}

}
# 20 "firmware/parameters.h" 2
# 1 "firmware/nnet_utils/nnet_pooling_stream.h" 1








# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h" 1
# 11 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
# 1 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/hls_half.h" 1
# 12 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h" 2
# 43 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
namespace hls {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hls::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };
}


namespace hlstmp {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hlstmp::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hlstmp::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hlstmp::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };
}


static inline
const
uint32_t pow2(uint32_t e)
{
    switch(e) {
        case 0: return 1; break;
        case 1: return 2; break;
        case 2: return 4; break;
        case 3: return 8; break;
        case 4: return 16; break;
        case 5: return 32; break;
        case 6: return 64; break;
        case 7: return 128; break;
        case 8: return 256; break;
        case 9: return 512; break;
        case 10: return 1024; break;
        case 11: return 2048; break;
        default: return 0;
    }
}

template<typename T>


__attribute__((hls_preserve))


T reg(T d)
{
#pragma HLS PIPELINE II=1
#pragma HLS LATENCY min=1 max=1
#pragma HLS INLINE off
 return d;
}
# 245 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
static inline
float to_float(float v)
{
    return v;
}

template<int _W, int _I>
float to_float(ap_fixed<_W, _I> v)
{
    return v.to_float();
}
# 264 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
template <typename T>
class fp_struct
{
};

union single_cast {
    float f;
    uint32_t i;
};

template <>
class fp_struct<float>
{
public:
    const static int EXP_INFNAN = 255;
    const static int EXP_BIAS = 127;
    const static int EXP_BITS = 8;
    const static int SIG_BITS = 23;
    const static int BITS = 32;

    fp_struct() {
    }
    fp_struct(float f) {


        union single_cast dc;
        dc.f = f;
        ap_uint<32> data = dc.i;





        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(ap_uint<32> data) {
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(uint32_t i) {
        ap_uint<32> data = i;
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    inline ap_uint<32> data() const {
        ap_uint<32> t;
        t[31] = sign[0];
        t(30,23) = exp(7,0);
        t(22,0) = sig(22,0);
        return t;
    }
    inline int expv() const {
        return exp-127;
    }
    inline int32_t to_int() const {
        return data().to_int();
    }
    inline float to_float() const {


        union single_cast ret;
        ret.i = data().to_uint();
        return ret.f;







    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline float to_ieee() const {
        return to_float();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static float infinity() {
        fp_struct<float> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static float minus_infinity() {
        fp_struct<float> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint32_t inttype;
    typedef ap_uint<32> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 394 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
static inline
void
castSingle(
    float din,
    fp_struct<float> &dout)
{
    fp_struct<float> t(din);
    dout = t;
}

static inline
float
castSingle(
    fp_struct<float> din)
{
    return din.to_float();
}

static inline
void
dumpSingle(
    float da,
    fp_struct<float> ds)
{
# 431 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
   (void)(da);
   (void)(ds);

}







union double_cast {
    double d;
    uint64_t i;
};

template <>
class fp_struct<double>
{
public:
    const static int EXP_INFNAN = 2047;
    const static int EXP_BIAS = 1023;
    const static int EXP_BITS = 11;
    const static int SIG_BITS = 52;
    const static int BITS = 64;

    fp_struct() {
    }
    fp_struct(double f) {
        union double_cast dc;
        dc.d = f;
        ap_uint<64> data = dc.i;
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(ap_uint<64> data) {
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(uint64_t i) {
        ap_uint<64> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<64> data() const {
        ap_uint<64> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int64_t to_int() const {
        return data().to_int64();
    }
    inline int expv() const {
        return exp-1023;
    }
    inline ap_uint<20> sig_msb() const {
        return sig(51,32);
    }
    inline ap_uint<32> sig_lsb() const {
        return sig(31,0);
    }
    inline double to_double() const {
        union double_cast ret;
        ret.i = data().to_uint64();
        return ret.d;
    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline double to_ieee() const {
        return to_double();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static double infinity() {
        fp_struct<double> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static double minus_infinity() {
        fp_struct<double> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint64_t inttype;
    typedef ap_uint<64> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 555 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
static inline
void
castDouble(
    double din,
    fp_struct<double> &dout)
{
    fp_struct<double> t(din);
    dout = t;
}

static inline
double
castDouble(
    fp_struct<double> din)
{
    return din.to_double();
}

static inline
void
dumpDouble(
    double da,
    fp_struct<double> ds)
{
# 592 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
   (void)(da);
   (void)(ds);

}
# 605 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
union half_cast {
    half d;
    uint16_t i;
};


template <>
class fp_struct<half>
{
public:
    const static int EXP_INFNAN = 31;
    const static int EXP_BIAS = 15;
    const static int EXP_BITS = 5;
    const static int SIG_BITS = 10;
    const static int BITS = 16;

    fp_struct() {
    }
    fp_struct(half f) {

        union half_cast dc;
        dc.d = f;
        ap_uint<16> data = dc.i;



        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(ap_uint<16> data) {
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(uint16_t i) {
        ap_uint<16> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<16> data() const {
        ap_uint<16> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int expv() const {
        return exp-EXP_BIAS;
    }
    inline int16_t to_int() const {
        return uint16_t(data().to_int());
    }
    inline half to_half() const {

        union half_cast ret;
        ret.i = data().to_uint64();
        return ret.d;





    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline half to_ieee() const {
        return to_half();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static half infinity() {
        fp_struct<half> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static half minus_infinity() {
        fp_struct<half> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint16_t inttype;
    typedef ap_uint<16> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 723 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
static inline
void
castHalf(
    half din,
    fp_struct<half> &dout)
{
    fp_struct<half> t(din);
    dout = t;
}

static inline
half
castHalf(
    fp_struct<half> din)
{
    return din.to_half();
}

static inline
void
dumpHalf(
    half da,
    fp_struct<half> ds)
{
# 760 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
   (void)(da);
   (void)(ds);

}
# 778 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
template < unsigned int _Base, unsigned int _Num >
class Power
{
public:
    static const unsigned int Value = _Base * Power< _Base, _Num - 1 >::Value;
};

template < unsigned int _Base >
class Power< _Base, 0 >
{
public:
    static const unsigned int Value = 1;
};
# 800 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class BitWidth
{
public:
    static const unsigned int Value = 1 + BitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class BitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 2;
};
# 822 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class UnsignedBitWidth
{
public:
    static const unsigned int Value = 1 + UnsignedBitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class UnsignedBitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 1;
};
# 843 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
template < typename T >
class Type_BitWidth
{
public:
    static const unsigned int Value = 8*sizeof(T);
};

template <int W >
class Type_BitWidth< ap_uint<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W >
class Type_BitWidth< ap_int<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_ufixed<W, I> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_fixed<W, I> >
{
public:
    static const unsigned int Value = W;
};
# 891 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
template <typename _T, int _Num, int _I=_Num-1>
class Table : public Table<_T, _Num, _I-1>
{
public:
    typedef typename _T::TableType TableType;
    static const typename _T::TableType dummy;
    static const int size = _Num;

};

template <typename _T, int _Num>
class Table<_T, _Num, 0>
{
public:
    static const typename _T::TableType dummy;
    static typename _T::TableType array[_Num];
};
# 918 "/tools/Xilinx/Vitis_HLS/2024.1/common/technology/autopilot/utils/x_hls_utils.h"
template <typename _T, int _Num, int _I>
const typename _T::TableType Table<_T, _Num, _I>::dummy
    = Table<_T, _Num, 0>::array[_I] = _T::apply(_I,_Num) + 0*Table<_T, _Num, _I-1>::dummy;

template <typename _T, int _Num>
const typename _T::TableType Table<_T, _Num, 0>::dummy
    = Table<_T, _Num, 0>::array[0] = _T::apply(0,_Num);




template <typename _T, int _Num>
typename _T::TableType Table<_T, _Num, 0>::array[_Num];



template <class T>
struct is_fptype { static const bool value = false; };
template <> struct is_fptype<float> { static const bool value = true; };
template <> struct is_fptype<double> { static const bool value = true; };
template <> struct is_fptype<half> { static const bool value = true; };

template <class T>
struct is_integraltype { static const bool value = false; };
template <> struct is_integraltype<int> { static const bool value = true; };
template <> struct is_integraltype<unsigned int> { static const bool value = true; };
template <> struct is_integraltype<char> { static const bool value = true; };
template <> struct is_integraltype<signed char> { static const bool value = true; };
template <> struct is_integraltype<unsigned char> { static const bool value = true; };
template <> struct is_integraltype<short> { static const bool value = true; };
template <> struct is_integraltype<unsigned short> { static const bool value = true; };
template <> struct is_integraltype<long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long> { static const bool value = true; };
template <> struct is_integraltype<long long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long long> { static const bool value = true; };
template <int W> struct is_integraltype<ap_int<W> > { static const bool value = true; };
template <int W> struct is_integraltype<ap_uint<W> > { static const bool value = true; };

template <class T>
struct is_fixedtype { static const bool value = false; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_fixed<W,I,Q,O> > { static const bool value = true; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_ufixed<W,I,Q,O> > { static const bool value = true; };

namespace hls {
    template<bool B, class T = void>
    struct enable_if {};

    template<class T>
    struct enable_if<true, T> { typedef T type; };
    template<typename T, T _v>
    struct integral_constant
    {
        static const T value = _v;
        typedef T value_type;
        typedef integral_constant<T,_v> type;
        operator value_type() { return value; }
    };

    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;

    template<typename T1, typename T2>
    struct is_same;

    template<typename T1, typename T2>
    struct is_same : public false_type { };

    template<typename T1>
    struct is_same<T1,T1> : public true_type { };

    template<typename T>
    struct is_arithmetic : public integral_constant<bool, (is_integraltype<T>::value || is_fptype<T>::value)> { };
}

template<typename T1, typename T2>
struct enable_or { static const bool value = T1::value || T2::value; };

template<typename T1, typename T2>
struct enable_and { static const bool value = T1::value && T2::value; };



template<typename T, bool = is_integraltype<T>::value>
struct __promote { typedef double type; };

template<typename T>
struct __promote<T, false> { };

template<>
struct __promote<double> { typedef double type; };

template<>
struct __promote<float> { typedef float type; };

template<>
struct __promote<half> { typedef half type; };
# 10 "firmware/nnet_utils/nnet_pooling_stream.h" 2

namespace nnet {





template <class T, int N, class CONFIG_T> T reduce_pool(T x[N]) {
#pragma HLS INLINE
 if (CONFIG_T::pool_op == Max) {
        Op_max<T> op_max;
        return reduce<T, N, Op_max<T>>(x, op_max);
    } else {
        Op_add<T> op_add;
        T sum = reduce<T, N, Op_add<T>>(x, op_add);
        return sum / N;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void compute_pool_buffer_2d(const data_T &in_elem,
                            ap_shift_reg<typename data_T::value_type, CONFIG_T::in_width>
                                line_buffer[(CONFIG_T::pool_height - 1 > 1 ? CONFIG_T::pool_height - 1 : 1)][CONFIG_T::n_filt],
                            hls::stream<res_T> &res) {
#pragma HLS INLINE
 const static int lShiftX = CONFIG_T::pool_width - 1;
    const static int lShiftY = CONFIG_T::pool_height - 1;
    static int pX = 0;
    static int pY = 0;
    static int sX = 0;
    static int sY = 0;

    typename CONFIG_T::accum_t pool_window[CONFIG_T::pool_height * CONFIG_T::pool_width];
#pragma HLS ARRAY_PARTITION variable=pool_window complete

 static typename data_T::value_type kernel_data[CONFIG_T::pool_height * CONFIG_T::pool_width * CONFIG_T::n_filt];
#pragma HLS ARRAY_PARTITION variable = kernel_data complete dim = 0

 res_T res_pack;



    nnet::shift_line_buffer<data_T, CONFIG_T>(in_elem, line_buffer, kernel_data);


    if ((sX - lShiftX) == 0 && (sY - lShiftY) == 0 && pY > lShiftY - 1 && pX > lShiftX - 1) {
    FiltLoop:
        for (unsigned i_ic = 0; i_ic < CONFIG_T::n_filt; i_ic++) {
#pragma HLS PIPELINE


 PoolLoop:
            for (unsigned i_ihw = 0; i_ihw < CONFIG_T::pool_height * CONFIG_T::pool_width; i_ihw++) {
                pool_window[i_ihw] = kernel_data[i_ihw * CONFIG_T::n_filt + i_ic];
            }


            res_pack[i_ic] =
                reduce_pool<typename CONFIG_T::accum_t, CONFIG_T::pool_height * CONFIG_T::pool_width, CONFIG_T>(pool_window);
        }


        res.write(res_pack);
    }


    if (pX + 1 == CONFIG_T::in_width)
    {
        pX = 0;
        sX = 0;
        if (pY + 1 == CONFIG_T::in_height) {
            pY = 0;
            sY = 0;
        } else {
            pY = pY + 1;

            sY = ((sY - lShiftY) == 0) ? sY - CONFIG_T::stride_height + 1 : sY + 1;
        }
    } else {
        pX = pX + 1;

        sX = ((sX - lShiftX) == 0) ? sX - CONFIG_T::stride_width + 1 : sX + 1;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void pooling2d_cl(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    ({ bool _AssertPred = CONFIG_T::implementation == conv_implementation::linebuffer && "Only \"linebuffer\" implementation is supported in Vitis HLS."; __builtin_assume(_AssertPred); });


#pragma HLS INLINE recursive
 ({ bool _AssertPred = CONFIG_T::pad_top == 0 && CONFIG_T::pad_bottom == 0 && CONFIG_T::pad_left == 0 && CONFIG_T::pad_right == 0; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = CONFIG_T::pool_height == CONFIG_T::stride_height && CONFIG_T::pool_width == CONFIG_T::stride_width; __builtin_assume(_AssertPred); });

    static ap_shift_reg<typename data_T::value_type, CONFIG_T::in_width> line_buffer[(CONFIG_T::pool_height - 1 > 1 ? CONFIG_T::pool_height - 1 : 1)]
                                                                                    [CONFIG_T::n_filt];
#pragma HLS ARRAY_PARTITION variable = line_buffer complete dim = 2

ReadInputHeight:
    for (unsigned i_ih = 0; i_ih < CONFIG_T::in_height; i_ih++) {
    ReadInputWidth:
        for (unsigned i_iw = 0; i_iw < CONFIG_T::in_width; i_iw++) {
#pragma HLS LOOP_FLATTEN
#pragma HLS PIPELINE

 compute_pool_buffer_2d<data_T, res_T, CONFIG_T>(data.read(), line_buffer, res);
        }
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void compute_pool_buffer_1d(const data_T &in_elem, hls::stream<res_T> &res) {
#pragma HLS INLINE
 const static int lShiftX = CONFIG_T::pool_width - 1;

    static int pX = 0;
    static int sX = 0;

    typename CONFIG_T::accum_t pool_window[CONFIG_T::pool_width];
#pragma HLS ARRAY_PARTITION variable=pool_window complete

 static typename data_T::value_type kernel_data[CONFIG_T::pool_width * CONFIG_T::n_filt];
#pragma HLS ARRAY_PARTITION variable = kernel_data complete dim = 0

 res_T res_pack;




    nnet::kernel_shift_1d<data_T, CONFIG_T>(in_elem, kernel_data);


    if ((sX - lShiftX) == 0 && pX > lShiftX - 1) {
    FiltLoop:
        for (unsigned i_ic = 0; i_ic < CONFIG_T::n_filt; i_ic++) {
#pragma HLS PIPELINE


 PoolLoop:
            for (unsigned i_iw = 0; i_iw < CONFIG_T::pool_width; i_iw++) {
                pool_window[i_iw] = kernel_data[i_iw * CONFIG_T::n_filt + i_ic];
            }


            res_pack[i_ic] = reduce_pool<typename CONFIG_T::accum_t, CONFIG_T::pool_width, CONFIG_T>(pool_window);
        }


        res.write(res_pack);
    }


    if (pX + 1 == CONFIG_T::n_in)
    {
        pX = 0;
        sX = 0;
    } else {
        pX = pX + 1;

        sX = ((sX - lShiftX) == 0) ? sX - CONFIG_T::stride_width + 1 : sX + 1;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void pooling1d_cl(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    ({ bool _AssertPred = CONFIG_T::implementation == conv_implementation::linebuffer && "Only \"linebuffer\" implementation is supported in Vitis HLS."; __builtin_assume(_AssertPred); });

    ({ bool _AssertPred = CONFIG_T::pad_left == 0 && CONFIG_T::pad_right == 0; __builtin_assume(_AssertPred); });

#pragma HLS inline recursive

ReadInputWidth:
    for (unsigned i_iw = 0; i_iw < CONFIG_T::n_in; i_iw++) {
#pragma HLS PIPELINE
 compute_pool_buffer_1d<data_T, res_T, CONFIG_T>(data.read(), res);
    }
}





template <class T, int N, class CONFIG_T> T reduce_global_pool(T x, T y[N]) {
#pragma HLS INLINE
 if (CONFIG_T::pool_op == Max) {
        Op_max<T> op_max;
        T y_max = reduce<T, N, Op_max<T>>(y, op_max);
        return (x > y_max) ? x : y_max;
    } else {
        Op_add<T> op_add;
        T y_sum = reduce<T, N, Op_add<T>>(y, op_add);
        return x + y_sum;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void compute_global_pool(const data_T &in_elem, typename CONFIG_T::accum_t data_window[CONFIG_T::n_filt]) {
PoolFilt:
    for (unsigned c = 0; c < CONFIG_T::n_filt; c++) {
#pragma HLS UNROLL

 typename CONFIG_T::accum_t data_pack[data_T::size / CONFIG_T::n_filt];
#pragma HLS ARRAY_PARTITION variable=data_pack complete dim=0

 PixelLoop:
        for (unsigned p = 0; p < data_T::size / CONFIG_T::n_filt; p++) {
#pragma HLS UNROLL
 data_pack[p] = in_elem[p * CONFIG_T::n_filt + c];
        }
        data_window[c] = reduce_global_pool<typename CONFIG_T::accum_t, data_T::size / CONFIG_T::n_filt, CONFIG_T>(
            data_window[c], data_pack);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void global_pooling2d_cl(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    ({ bool _AssertPred = CONFIG_T::pad_top == 0 && CONFIG_T::pad_bottom == 0 && CONFIG_T::pad_left == 0 && CONFIG_T::pad_right == 0; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = CONFIG_T::pool_height == CONFIG_T::stride_height && CONFIG_T::pool_width == CONFIG_T::stride_width; __builtin_assume(_AssertPred); });

    typename CONFIG_T::accum_t data_window[CONFIG_T::n_filt];
#pragma HLS ARRAY_PARTITION variable=data_window complete

 typename CONFIG_T::accum_t init = 0;
    if (CONFIG_T::pool_op == Max) {
        init = hls::numeric_limits<typename CONFIG_T::accum_t>::min();
    }

PoolInitLoop:
    for (unsigned i_init = 0; i_init < CONFIG_T::n_filt; i_init++) {
#pragma HLS UNROLL
 data_window[i_init] = init;
    }

ReadInputHeight:
    for (unsigned i_ih = 0; i_ih < CONFIG_T::in_height; i_ih++) {
    ReadInputWidth:
        for (unsigned i_iw = 0; i_iw < CONFIG_T::in_width / (data_T::size / CONFIG_T::n_filt); i_iw++) {
#pragma HLS LOOP_FLATTEN
 compute_global_pool<data_T, res_T, CONFIG_T>(data.read(), data_window);
        }
    }

    if (CONFIG_T::pool_op == Max) {
    MaxPoolRes:
        for (unsigned i_res = 0; i_res < CONFIG_T::n_filt / res_T::size; i_res++) {
#pragma HLS PIPELINE

 res_T res_pack;

        MaxPoolPack:
            for (unsigned i_pack = 0; i_pack < res_T::size; i_pack++) {
#pragma HLS UNROLL
 res_pack[i_pack] = data_window[i_pack];
            }
            res.write(res_pack);
        }
    } else {
    AvgPoolRes:
        for (unsigned i_res = 0; i_res < CONFIG_T::n_filt / res_T::size; i_res++) {
#pragma HLS PIPELINE

 res_T res_pack;

        AvgPoolPack:
            for (unsigned i_pack = 0; i_pack < res_T::size; i_pack++) {
#pragma HLS UNROLL
 res_pack[i_pack] = data_window[i_pack] / (CONFIG_T::in_height * CONFIG_T::in_width);
            }
            res.write(res_pack);
        }
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void global_pooling1d_cl(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    ({ bool _AssertPred = CONFIG_T::pad_left == 0 && CONFIG_T::pad_right == 0; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = CONFIG_T::pool_width == CONFIG_T::stride_width; __builtin_assume(_AssertPred); });

    typename CONFIG_T::accum_t data_window[CONFIG_T::n_filt];
#pragma HLS ARRAY_PARTITION variable=data_window complete

 typename CONFIG_T::accum_t init = 0;
    if (CONFIG_T::pool_op == Max) {
        init = hls::numeric_limits<typename CONFIG_T::accum_t>::min();
    }

PoolInitLoop:
    for (unsigned i_init = 0; i_init < CONFIG_T::n_filt; i_init++) {
#pragma HLS UNROLL
 data_window[i_init] = init;
    }

ReadInput:
    for (unsigned i_iw = 0; i_iw < CONFIG_T::n_in / (data_T::size / CONFIG_T::n_filt); i_iw++) {
#pragma HLS LOOP_FLATTEN
 compute_global_pool<data_T, res_T, CONFIG_T>(data.read(), data_window);
    }

    if (CONFIG_T::pool_op == Max) {
    MaxPoolRes:
        for (unsigned i_res = 0; i_res < CONFIG_T::n_filt / res_T::size; i_res++) {
#pragma HLS PIPELINE

 res_T res_pack;

        MaxPoolPack:
            for (unsigned i_pack = 0; i_pack < res_T::size; i_pack++) {
#pragma HLS UNROLL
 res_pack[i_pack] = data_window[i_pack];
            }
            res.write(res_pack);
        }
    } else {
    AvgPoolRes:
        for (unsigned i_res = 0; i_res < CONFIG_T::n_filt / res_T::size; i_res++) {
#pragma HLS PIPELINE

 res_T res_pack;

        AvgPoolPack:
            for (unsigned i_pack = 0; i_pack < res_T::size; i_pack++) {
#pragma HLS UNROLL
 res_pack[i_pack] = data_window[i_pack] / CONFIG_T::n_in;
            }
            res.write(res_pack);
        }
    }
}

}
# 21 "firmware/parameters.h" 2


# 1 "firmware/weights/w2.h" 1
# 12 "firmware/weights/w2.h"
conv1d_weight_t w2[48] = {-0.0024408193, 0.2187929899, 0.1374217421, 0.1862317026, 0.3711631000, -0.0992003828, 0.3359334469, 0.2277399153, 0.3036508858, 0.3537633121, 0.0582163595, -0.1909132153, 0.0177664235, 0.2035520375, 0.1778117865, 0.1454776973, -0.0105626490, 0.2571586370, -0.1460919976, -0.2995744646, -0.0051867743, -0.1813419312, 0.0839705989, -0.1077638045, -0.3934272528, -0.0906438455, -0.3361620903, -0.2444883436, 0.4366544783, -0.1509790421, 0.1792265624, -0.0141729582, -0.2212706208, 0.2395963967, -0.3111768067, 0.2234267443, 0.0838309526, -0.1557389647, -0.1584090889, -0.1265395433, 0.0946027264, -0.1705556065, -0.0938328430, 0.1118340939, 0.1405650377, -0.0312101413, 0.0212961789, 0.1139338389};
# 24 "firmware/parameters.h" 2
# 1 "firmware/weights/b2.h" 1
# 12 "firmware/weights/b2.h"
conv1d_bias_t b2[16] = {0.0190177858, 0.0365232304, -0.0346412472, -0.0038121995, 0.0218919218, -0.0209602434, 0.0209805053, 0.0080043720, 0.0073677571, 0.0402834788, 0.0245032422, 0.0166370198, -0.0067150989, 0.0056976625, -0.0390143283, -0.0146689611};
# 25 "firmware/parameters.h" 2
# 1 "firmware/weights/s4.h" 1
# 12 "firmware/weights/s4.h"
batch_normalization_scale_t s4[16] = {23.6290588379, 14.5449724197, 24.2028388977, 25.7783031464, 18.1565799713, 21.6451625824, 19.4633979797, 23.6190586090, 25.2378196716, 19.8845481873, 18.1463947296, 20.5363712311, 18.7524948120, 26.4032726288, 28.0369014740, 29.1411571503};
# 26 "firmware/parameters.h" 2
# 1 "firmware/weights/b4.h" 1
# 12 "firmware/weights/b4.h"
batch_normalization_bias_t b4[16] = {-0.8297862411, -0.3060290217, -0.2353388518, -0.0609733835, -0.4086852372, -0.3064215183, -0.4401482642, -0.4373376071, -0.2325901389, -0.6638315916, -1.0143065453, -0.7341303229, -0.2831906378, -0.0227049291, -0.0741063356, -0.0227775276};
# 27 "firmware/parameters.h" 2
# 1 "firmware/weights/w6.h" 1
# 12 "firmware/weights/w6.h"
conv1d_1_weight_t w6[1536] = {-0.0650198162, -0.2522404492, 0.1744018942, 0.0060170009, 0.0502407253, -0.1969431639, -0.0526672192, 0.0032325448, 0.1755423248, -0.1304173917, -0.1454956979, -0.0552993529, 0.1790550202, -0.0446608067, -0.1362024695, 0.1100404188, -0.1019234285, 0.1639093459, 0.1922880411, 0.2027466744, 0.0530352220, -0.1774669141, 0.1028608456, -0.1051255092, 0.0030169059, 0.0824025646, 0.0666832626, -0.1559090018, 0.1555003971, -0.1781500429, -0.0700665191, -0.1457983404, -0.0497098863, 0.1443982869, -0.2650966346, 0.0667269975, -0.2352714092, -0.1225519925, -0.1481417120, 0.0579673424, 0.0504209697, -0.1314903945, 0.1658238918, -0.1289649457, -0.0621540844, -0.0865476057, -0.0532219112, 0.1251179725, -0.0853350759, 0.1653593630, -0.0815588012, -0.1106611118, 0.0088034337, -0.0256979614, -0.0171801336, 0.0154748289, -0.2136074603, -0.1237010881, 0.1503125280, -0.0700913817, -0.2662934065, -0.1618404388, 0.0816330016, 0.1781428456, 0.1050530821, -0.1023718640, -0.2427432537, -0.1353420019, 0.0281823482, -0.1203084290, 0.1409703940, 0.2405444533, -0.1224913374, -0.2146433890, -0.0499788411, 0.1611026973, 0.1105693728, -0.1980872601, -0.1605496407, 0.0477186255, 0.1271556318, 0.0048713731, 0.1398201585, -0.0835882872, -0.0335177667, 0.0106775602, -0.1838308871, -0.0623223111, -0.1664216667, -0.1667146683, -0.0856225491, -0.1237399578, -0.0653237179, -0.1257405728, -0.2299987227, 0.1326314956, -0.0837020576, -0.0881217271, 0.1191962287, 0.0416630097, 0.0381622575, -0.0675376356, -0.0737808049, 0.0424990989, 0.0773595497, -0.1168393269, 0.1146322042, 0.0755562186, -0.0756025463, 0.2170225531, -0.2495435029, 0.1198263541, -0.1597741693, -0.1721415371, -0.1695719957, 0.0334462672, -0.0020886392, -0.0423349328, -0.0311698876, 0.0957441330, -0.0157386530, -0.1283175796, -0.1689593196, -0.1150683314, -0.0135172624, -0.0105533209, 0.1653951555, 0.1803891808, 0.1234816909, 0.1191294193, -0.1614057571, 0.0739178807, -0.2940626442, 0.2480119169, -0.0514272489, -0.0808824822, -0.1104151681, 0.1429369450, -0.0468754061, -0.0999899283, 0.0147202602, 0.0898764208, 0.0873764083, -0.1569849402, 0.2051903754, 0.1567696482, 0.0913789868, -0.0854420066, -0.1003953964, 0.0511514470, -0.0118440110, 0.0375355482, -0.1796950251, -0.1662626714, -0.2289309502, -0.1744997501, 0.0047670547, 0.0000583382, -0.2259930670, -0.2099749148, 0.0615774207, -0.0034718195, -0.1070270091, -0.0839336962, 0.0538834557, 0.1167353094, -0.1999110281, 0.1801835299, 0.0307549499, -0.0516370311, 0.0383076929, -0.0650146827, -0.1476324797, -0.2546499372, -0.1796873063, 0.1329642534, 0.0504862033, -0.1912905723, 0.1379458904, 0.1130442768, 0.0437013879, 0.1188514009, 0.1660381854, -0.2136205137, -0.1898590624, -0.1252626032, 0.1592779309, -0.0468507148, -0.2991143465, -0.0431258604, -0.1133150458, -0.0500107370, 0.0244964939, 0.0818495452, 0.1384783387, -0.0019017317, -0.0833255425, -0.1357970238, -0.0322981961, -0.0015570647, 0.0379678123, -0.1005402282, 0.0168713499, -0.0844889954, -0.0571876913, -0.1315765679, 0.0443183184, -0.1302720457, 0.0635607541, -0.0676649287, -0.1188124195, 0.1638914347, 0.1161308363, 0.1556015611, -0.0893624425, 0.1681179851, 0.0450004824, -0.1998750567, -0.0473322161, -0.0972025692, 0.1572145671, -0.0760354921, -0.0312887207, 0.1686696112, 0.0812887624, 0.0784377381, 0.1169615760, 0.0945892483, 0.1327044368, -0.1585777849, 0.1659373045, -0.0555495583, -0.0843271390, 0.0177749507, 0.0670649037, -0.0244337916, -0.0962845460, -0.3297541142, -0.0876312852, 0.1636897475, 0.1065503061, -0.1950976849, -0.1464163065, 0.0289338138, 0.1982779503, 0.0660151765, 0.0200638920, -0.1687542200, 0.1515275985, -0.4125482142, 0.1526827663, -0.2767710686, 0.2671810389, -0.0118279941, 0.1284165531, -0.0295273513, -0.2848752737, 0.0619735196, 0.0801302567, 0.2060993761, -0.0024739555, -0.1591975689, 0.0534312688, -0.2707934976, -0.1311120391, -0.0130990110, 0.0724520013, -0.0790737867, -0.1417843252, -0.2899036407, 0.1253101975, -0.0321091488, -0.2548084855, 0.1677651554, -0.3131839633, 0.0220066123, 0.0309019927, 0.0471529663, 0.0363711528, -0.0189651623, 0.0275699813, -0.4531242251, 0.0398269519, -0.1039205641, -0.0989955515, -0.0629996136, 0.1534106284, -0.0488167033, -0.0914921314, -0.0617243461, 0.1371425986, -0.1649913937, -0.1948155016, -0.2236013263, 0.0300803389, -0.0393735357, -0.1899392605, 0.1944995224, -0.1261117607, -0.1228692681, -0.2516259849, -0.3076549768, 0.0057933838, 0.0282906052, -0.1350016594, 0.1028095782, -0.2761187851, -0.1864671707, -0.1580300629, 0.0910239741, 0.0391740091, -0.0660204887, -0.0469926149, -0.3722279072, -0.0067570731, -0.0841088519, -0.1223664284, 0.1934383810, -0.1331895739, -0.1640022546, -0.0306031108, -0.0333753265, -0.0109273009, -0.1075102538, 0.0385574475, 0.1260607243, 0.1328491271, 0.0423408225, 0.0699400827, -0.2219587862, -0.1812649071, -0.0707130730, 0.0706661195, -0.0337989144, -0.1611252874, 0.0814945623, 0.0339695029, -0.1660516411, 0.0252289008, -0.2286844403, 0.0217317436, -0.0722635761, 0.1089798734, 0.1238766387, 0.0462004803, -0.1563287526, -0.2428649366, -0.0320351236, -0.1639242172, -0.0826527104, 0.1077727899, 0.0039354423, -0.2933805287, 0.1165868416, -0.0685873181, -0.2636159062, 0.0559352003, -0.0653995201, -0.1815578490, 0.0765857697, -0.1492590606, -0.0922882929, -0.0160337295, 0.0643980131, 0.0731640011, 0.0557485074, -0.2893441021, -0.0711132810, -0.1179080456, -0.0215482879, -0.0495351143, -0.2198461592, 0.2612965405, -0.2378900349, 0.1454546750, -0.0353534557, 0.2519562840, 0.0128289079, 0.0664233938, 0.0695155859, -0.2089898586, 0.0259288065, 0.0617119819, 0.2314956337, 0.0704986751, 0.1107996926, -0.2044255435, -0.0620520040, 0.0860261172, 0.0480267517, 0.0677398294, 0.0956410021, 0.1152033731, 0.0636281669, -0.0745904669, -0.2733311355, 0.0216344707, -0.1786698252, -0.3024656177, -0.0279143341, -0.1566915959, 0.0815523043, 0.0348126814, 0.1224566773, 0.0575232431, 0.0029061604, 0.0690821186, 0.0381283090, 0.0743606389, 0.0830390900, -0.2416660190, 0.0042120987, -0.2102882266, -0.0460533313, -0.0190239493, -0.1983045340, 0.1345538646, -0.2405702621, -0.1960644126, -0.0017301623, -0.1973474920, 0.0043610386, 0.0018948776, 0.0138142258, -0.2209448665, 0.0475213267, 0.0652180463, 0.0165324565, -0.3005264997, -0.2206030339, 0.0169083104, 0.0964963809, -0.1668989211, -0.1011499241, -0.3285631537, 0.0009649186, -0.1270866096, 0.0244676955, 0.1099070013, -0.1068701968, 0.1114047840, -0.0509430543, -0.1942842603, -0.3122383356, 0.0264081657, 0.0886442214, 0.1423498392, 0.1927587837, 0.1105177328, -0.0413583666, -0.2042021751, -0.2701616883, -0.1183063835, 0.1613125354, 0.1566824019, 0.0427512452, -0.0087026572, 0.0890680999, 0.1129291877, 0.0100595504, 0.1213038787, -0.2542596459, 0.0359551162, 0.0478592552, 0.1493079364, 0.0630246997, -0.0642911196, -0.2123153359, 0.2157619447, -0.1660362184, 0.2586030662, -0.1061549559, -0.1412920207, 0.0899694189, -0.2722139955, 0.1194317490, -0.1309087425, -0.1861609370, 0.1108198166, -0.0863506123, 0.0063926266, -0.1544771343, -0.0301050786, -0.1978408247, -0.1582449824, 0.1466023028, -0.0062880269, 0.1066966876, -0.0950613841, 0.0540572964, 0.1707693636, -0.0317916200, -0.0763096437, 0.0167320278, -0.0999312773, 0.1991776079, 0.0260791965, 0.0617305934, -0.2272868305, 0.0912494510, 0.2073280662, 0.0123771355, 0.1172774881, -0.0249495097, -0.1663174927, -0.1890548766, 0.0472506881, -0.1355156451, -0.0344052128, 0.0465127937, 0.0890693739, 0.1463717818, -0.0698979571, -0.0243192986, 0.2008643746, 0.0293889567, 0.1765147150, -0.1299736053, 0.1833096147, 0.0662123561, 0.0943072289, 0.0287847817, -0.0569349714, 0.0359931365, -0.1915407181, -0.1201202869, 0.1421402097, 0.1535130590, -0.1609755903, -0.0961102843, -0.0022894873, -0.1554606408, 0.0868252292, 0.0428874306, -0.1883164197, -0.0732826814, -0.1496713758, -0.2397783846, -0.0388586633, -0.1233545765, -0.0036923157, -0.1836518347, 0.1545921266, -0.1125727445, 0.0236601923, 0.0498953275, -0.2053938508, -0.0120219477, 0.0770376697, -0.0561515354, -0.1793675870, 0.1090970114, -0.1308180243, -0.1684958488, 0.0470226146, 0.1129162833, -0.0183062255, 0.1492964476, -0.0825586841, -0.0717655867, -0.2551046908, -0.1323328018, -0.1629887819, 0.1783701479, 0.0519379526, -0.1469961554, -0.0379799977, -0.1707789749, 0.2338106930, 0.1335573643, -0.2535687387, 0.0301175788, -0.0041920715, -0.0921754465, -0.0981314778, 0.0888419300, 0.2157297432, -0.1780847609, -0.1824762374, 0.1320379078, -0.0400724150, 0.1065150872, 0.0647875443, 0.0579674728, 0.1254421324, -0.3504517078, -0.2617258728, -0.0275358204, -0.1192275211, 0.0770886838, -0.0565101951, -0.0833834335, -0.0557611585, -0.1317180842, -0.1742314100, -0.3110387027, -0.0010844476, 0.1470281184, -0.1913982779, 0.2453028262, -0.0228252299, 0.0583409108, -0.1370793581, -0.0133858714, -0.1488485634, -0.1665127575, 0.1447472423, -0.0139179165, -0.0792518854, -0.0847501755, -0.0565596707, -0.1211018339, -0.0299605932, -0.1313259155, -0.0791867077, 0.1264641434, -0.1356031895, -0.1171191260, -0.0872325301, 0.1123915315, -0.1239736900, -0.0134861702, -0.1649996191, -0.1538388133, -0.0071061989, 0.0335723609, 0.0478298366, 0.1618023217, 0.0701704174, -0.1189949512, -0.2025656104, 0.0850603282, -0.1745268553, -0.0656516328, 0.2150390446, 0.2140131891, -0.1204949543, 0.1042836085, 0.0953046530, -0.0818420276, -0.0801940709, 0.0019796283, 0.0861352831, -0.1267827153, 0.1529223472, 0.1320310831, -0.1728097051, 0.1981154829, 0.1560064107, 0.0297371335, -0.0791840926, -0.1278192997, 0.0902780220, 0.0311353505, -0.1748788208, -0.0685075521, -0.0598449670, 0.0901192948, -0.0966129526, 0.1245600134, -0.2000993192, 0.1114486977, -0.0071306303, -0.0333323292, -0.0887199193, 0.0554894432, -0.1103631929, 0.1705021709, -0.1369006783, 0.0922760963, -0.1510488540, 0.0813916102, 0.1093578488, 0.0420021601, -0.1962797344, -0.1323007941, -0.1633128822, 0.0305628683, 0.0370060243, 0.0591997541, -0.0960129946, -0.0856874138, 0.0486628786, -0.1808283478, -0.1653329581, 0.0795892254, 0.1138545126, -0.1113945469, -0.1122956723, -0.0653101206, 0.1562587619, 0.0860105902, 0.0799722075, -0.0628049746, 0.1537643969, -0.0145300282, -0.1831182390, -0.1238597557, -0.1239192933, -0.1473887712, -0.0476679243, -0.2377004921, -0.1864670664, 0.0788717344, 0.0881829485, 0.0238222405, 0.1004882380, -0.1216107309, -0.0765840411, -0.2039519250, 0.2079183459, -0.0230225418, 0.0463152677, -0.1584288627, -0.1782411039, 0.0259667709, -0.0103369514, -0.0462804064, 0.1922666579, 0.1584271640, 0.1074629277, -0.1816232204, 0.1234364733, 0.0249697417, 0.0641733482, -0.1688732356, 0.0344711356, 0.0923436433, 0.1939350665, -0.0258994419, -0.1787727177, 0.2544876933, -0.0166763589, -0.0926168337, 0.0057638604, -0.2710751295, -0.1248960122, -0.1163001135, 0.1439538598, 0.1394253075, 0.1535859406, 0.0824121982, -0.0447666496, 0.0036692370, 0.0811646804, -0.0952297300, -0.1708163619, 0.0976654738, -0.0458920188, -0.1145774648, 0.1406498104, 0.1190354005, -0.0696601346, -0.1795537323, -0.1679896265, -0.1393045634, -0.0901215523, -0.1016512662, -0.0737465471, 0.1021522731, 0.0189158861, -0.1178103909, 0.0587664358, 0.1073497683, 0.1989133209, 0.0793274716, 0.1096253246, -0.0370547734, -0.1954588890, -0.1860473603, -0.0035444074, 0.2199580371, 0.0000057076, 0.0242434926, -0.0353468060, -0.1923201382, -0.0451069288, -0.1287833452, -0.2938737571, 0.2056113183, 0.0655129924, -0.0638060793, 0.0703912750, -0.2290654331, -0.2090697587, 0.2154993117, -0.3320703208, -0.0159741677, -0.0107640894, -0.2676445246, 0.1919424236, -0.0023946760, -0.1093963161, -0.2590992153, -0.0170312170, 0.0664811358, 0.1125370786, 0.1039629951, 0.0460826233, -0.1889379174, 0.0021884758, 0.1123594269, 0.0089849466, -0.2084629238, -0.0230347291, -0.1033200622, -0.0801066533, -0.1069641262, 0.1200262904, 0.0842535868, -0.1124695614, -0.1063259915, 0.0267058406, 0.2256572694, -0.1720774621, -0.1233518943, 0.0154973846, 0.0625055134, 0.0152705600, 0.0485597663, 0.1957766414, -0.2079217732, -0.1629794389, 0.1012386605, 0.1262014210, 0.0968182534, -0.0200366154, -0.0888696834, 0.0326164290, 0.1116623655, -0.0936724022, -0.1107757986, 0.1670717746, -0.0970908850, 0.0054068314, -0.1197026893, 0.2061340809, -0.1600222439, 0.0892472491, 0.2354239821, -0.1085976139, 0.0191224515, -0.2116222084, 0.1421873569, 0.1089921519, 0.0995843858, -0.1310457587, 0.0941479504, 0.0505584776, 0.1736461371, -0.1099979803, 0.0794760957, 0.0605698414, -0.0255609471, -0.1879186183, 0.1799329072, -0.1667456478, 0.0939603150, -0.1177166700, 0.0909244344, -0.0128412442, 0.1318046451, -0.1091219112, 0.0302566886, -0.1480117887, -0.0836076885, 0.1546095610, 0.0676077902, 0.0743096173, -0.2132749110, -0.0558328591, 0.0224922299, 0.1151973307, -0.0725059062, -0.0383814611, -0.0059868218, -0.1201753840, 0.1590049118, 0.1014448851, -0.0916807130, -0.2518750131, -0.1585852504, -0.1610430628, -0.1129871607, 0.1450012624, -0.0490697101, -0.1185395196, 0.1024148092, 0.1864644587, -0.3308733106, 0.0180238690, -0.0508418307, -0.1397462934, -0.1410897225, -0.1680799574, -0.1689663827, 0.1407127678, 0.0919841751, -0.0822785795, -0.0645080209, 0.0733321235, -0.1209452972, 0.1489093602, 0.1164956316, 0.1853909194, -0.1702360660, 0.1404570043, -0.2128908187, 0.2024213672, 0.0096777640, 0.0225870796, -0.0284779500, -0.1592521667, 0.1185325384, -0.0362116545, 0.0979000852, -0.1926894188, -0.1608148515, -0.0715589896, 0.0964916870, -0.0192383025, 0.1561625153, -0.2944812775, -0.1298622489, 0.1247515529, -0.0260946080, -0.2728525400, -0.2104359269, -0.0193794537, -0.1330995113, 0.1164088175, 0.1186830550, -0.0617804453, -0.1000970900, -0.0904964283, -0.1710877419, -0.0902560204, -0.0575731471, -0.1433336735, 0.0482239984, -0.0024635647, 0.0431410819, 0.0999680609, -0.0535846353, -0.0237893034, -0.0958314985, 0.0007265469, -0.0380849950, -0.1319444627, -0.2302468121, 0.0136922291, -0.0817712694, 0.1706653386, 0.0836893320, -0.1062094271, -0.0117704272, 0.2114890516, 0.0627105385, -0.0633420050, -0.2850182950, -0.0839998722, -0.1477089971, -0.1063114256, 0.1002421230, 0.0514932089, -0.0705809593, 0.0061724586, -0.2144057453, 0.1725460440, -0.0786925405, -0.0606750399, -0.1403086632, 0.1706875414, -0.1853225380, -0.1688907146, 0.1176164597, -0.1400216967, -0.0339810476, 0.1599718779, -0.1898295879, -0.0072199460, 0.1019659266, -0.1046380624, -0.1089246422, 0.0231985543, -0.2254387736, -0.0481714457, -0.1612966806, 0.0959677398, 0.1528911889, -0.0324292891, -0.2755250335, 0.2024655342, 0.1641097963, -0.2780258656, 0.1632089466, 0.0936086327, -0.0304830186, 0.0944983736, -0.0430188999, -0.1939142793, -0.1534919888, 0.0555419140, -0.0730666742, -0.0762973726, -0.1649172008, -0.0129653281, 0.0880703032, -0.1781429499, -0.0911879539, -0.0429402106, -0.0959511772, 0.0108263800, 0.1718945354, 0.0614017211, -0.1592353880, 0.0127496133, -0.2210449725, -0.2076249421, -0.1144545153, 0.0373404324, -0.0615464449, 0.1052594483, -0.0025141605, 0.0543208793, 0.0625903383, -0.0224892311, 0.0903243497, 0.0117288530, 0.1073693484, -0.0218647812, -0.0278188791, -0.0115443394, 0.1702801883, 0.0567492656, -0.1694246680, 0.1822796464, -0.1058011949, 0.1106442362, -0.0753968731, -0.0026317448, -0.0568199195, -0.0666044354, -0.1478957385, -0.1250164211, 0.1352232248, -0.0109970840, 0.1610362083, 0.0751886889, 0.0558126941, 0.1625138372, -0.0340895616, 0.0403024554, -0.0812274516, 0.0840384960, -0.0555723272, -0.1083737314, 0.0444789790, 0.1473144144, -0.0219075847, -0.0054952903, -0.1665671617, -0.0506474786, 0.0585935749, -0.2946965098, 0.1834526807, -0.0727853104, -0.0947154760, 0.1803104877, -0.1526172012, -0.1207256466, -0.2262174040, -0.2082600445, -0.0236033797, 0.0143242618, -0.0537002385, -0.1967664659, 0.1491962969, -0.0478260480, 0.0363053419, -0.1718103737, 0.0507556982, 0.0901896432, -0.0551998876, 0.0242739562, -0.1376210451, 0.0874109417, -0.0302932914, 0.2033517659, -0.1531352997, 0.0127150174, -0.0238847826, 0.1315694004, -0.1048989072, -0.0375378095, -0.0361323282, -0.1280280650, 0.0446800701, -0.0988148078, -0.1886772215, -0.0700692758, 0.0678340942, -0.1031032726, 0.0047773616, 0.0876697674, -0.0659148470, -0.2310116589, -0.1252363026, -0.0180160720, -0.1429492533, 0.0520564541, -0.1264715195, -0.0590828769, 0.1097017080, 0.0259491820, 0.0889596269, 0.0152053721, -0.2090220749, -0.2042839527, -0.0481309295, -0.0026014883, 0.1223260909, -0.0980564207, -0.2670674324, -0.0444378257, 0.0581054948, -0.1940791905, -0.1718568951, -0.2361610532, 0.0903143436, 0.0770202950, -0.0317225456, 0.0430412404, -0.0764735937, 0.0191496182, -0.1770829111, 0.0336109698, 0.2005459964, 0.0238286648, 0.1357648522, 0.0250252541, 0.0379676819, 0.1890092641, 0.1487365216, -0.1306932122, -0.1090300754, 0.1244861707, -0.0094206100, -0.1052915007, 0.0454617478, 0.1981971264, -0.0244556628, -0.1045821980, -0.0890290663, 0.0910701901, -0.1797862351, 0.0605932847, -0.1410125643, 0.0913965479, 0.0697196722, 0.1521034688, 0.0999520347, -0.0663025081, 0.0110806003, -0.0066080708, 0.1337867230, -0.0884884149, 0.1111808270, 0.1461907029, -0.1659443527, 0.1056330949, -0.1966436356, -0.1255876422, -0.0036635499, -0.2221321017, 0.2505478561, 0.1378177255, -0.1168219894, -0.1573272943, 0.1591436267, 0.1472887546, -0.0732932389, -0.1848332137, -0.0718716234, -0.0942625105, 0.0244193077, -0.1254554838, -0.1194464713, 0.0893390551, 0.0801520571, -0.1329533309, -0.1552175879, 0.1645953506, -0.0680176094, 0.1583736539, -0.1132100075, 0.0709140226, 0.0878797472, -0.0622070618, -0.0353884771, 0.1754596680, -0.0186035298, 0.0533557124, -0.0227112770, -0.1224281266, -0.0606428571, -0.0957796648, -0.2363072187, -0.1408392191, -0.0545605719, 0.1181140020, -0.1553549916, 0.0071317614, -0.0728772208, 0.1264190227, 0.1427157968, 0.1088817120, -0.0004993540, 0.0180685259, 0.1145778373, 0.1168424711, 0.0986691117, -0.1946779937, 0.0866577029, 0.0156947765, -0.1169867814, 0.1096251830, 0.1203787774, 0.0593902133, -0.0279432908, -0.0154632377, 0.1769909263, -0.0542631745, 0.1097517163, 0.0808604658, -0.1580521464, 0.0849206448, 0.1414444298, 0.0040542437, 0.0186736006, -0.0575756133, -0.1038571745, -0.2793105841, 0.0552514866, 0.1617449820, -0.0465671681, 0.0145239336, -0.2321525663, -0.1228495315, -0.0436776616, 0.0439829268, 0.0961691737, -0.0595693439, 0.0047331611, 0.0490548909, -0.2044233382, 0.0182284899, -0.1043788642, -0.2297467738, -0.2510839403, 0.0080915606, -0.0305271652, -0.0705153868, 0.0690695941, -0.1370246559, 0.0999460444, -0.0580346324, -0.1260896772, 0.0411396325, 0.2118180841, 0.0913298354, -0.0198743232, 0.0049918136, -0.0099189514, 0.0035135113, -0.2024422288, -0.0505392030, -0.1012135223, 0.0410605818, -0.0131694004, -0.2354527563, -0.0025650181, 0.0734061226, -0.0392922200, -0.0377397388, 0.1393389702, 0.1462840885, 0.1049350500, 0.0439876169, -0.0975562260, -0.2610293627, -0.0034927921, 0.1149802804, 0.0841551945, -0.1147303060, 0.0229724646, -0.1227408722, -0.0746958181, -0.0238221027, 0.2350446731, 0.1362491548, 0.0843360350, 0.0805064812, 0.0504836477, -0.0918389112, 0.0609723777, -0.0119175119, 0.1470602155, -0.0256564282, -0.0019431504, 0.0218457114, 0.0895968080, -0.1417698264, -0.0552344024, 0.2342927605, 0.1370357424, -0.1055175290, -0.1573610902, -0.0026330769, -0.0159880407, 0.1035544798, 0.0645475835, 0.0560923666, -0.0207756534, -0.1294961721, -0.1279974878, 0.1588827819, 0.1376399249, 0.0542495847, 0.1124054939, -0.0465477332, 0.0567845702, -0.1406413019, 0.0076320767, -0.1403024793, -0.1037139222, -0.1045478284, 0.0000409842, -0.1383074969, 0.1343944967, -0.2179694623, -0.2629576027, -0.1205334142, -0.0853649974, 0.1265929639, -0.1640218347, 0.0976958275, 0.1870376915, 0.0849982798, 0.0429702029, 0.1346687227, -0.0140553191, -0.0288331434, -0.1262899786, -0.0542005263, -0.2588893771, 0.2132224888, -0.0610763803, 0.1271808743, -0.0091285249, 0.1600797325, -0.1292044073, -0.1919646263, -0.1829597354, -0.0190979112, 0.0979942009, -0.1982996315, 0.1156791598, 0.1685217768, 0.1590223163, 0.1617234051, 0.0682007745, 0.1257641613, -0.1676634252, -0.1196349338, -0.0670721009, 0.0191001240, -0.1889916360, -0.1453682184, 0.0349315554, -0.0345548131, 0.0879492909, 0.0424099825, 0.0729926676, -0.1036531329, 0.0156189920, 0.2319159955, -0.1504139751, -0.0721623003, 0.1099410877, 0.0310258213, 0.0885595232, -0.0088192821, -0.0198810827, -0.0365774222, 0.0478468016, -0.2383951843, -0.0197756812, -0.2334297895, -0.1461634338, -0.1410831064, 0.1499889940, 0.0322157443, 0.1041882560, -0.0313946567, 0.0625073239, 0.1414663643, -0.1168090627, 0.1437119097, 0.0240851529, 0.0289794784, 0.1265167892, 0.1758886725, 0.0621899441, -0.1345836222, -0.0653495565, -0.2277256101, -0.0648241118, 0.1767058820, -0.2700552940, 0.1667184234, 0.1576182991, 0.1647281647, -0.0411693789, 0.1032451168, -0.1252846867, 0.0100830048, -0.1717447788, -0.1279021353, 0.0602716468, 0.1338284463, 0.0381553434, -0.0147816148, -0.0262767691, 0.1003946066, -0.1033327281, 0.0955773667, -0.1624253243, 0.1889223605, -0.0741035342, -0.1189595535, -0.2913530469, 0.1082032919, 0.1927705407, -0.1160456166, 0.1410083622, 0.0477658771, 0.0432076715, -0.1884308904, -0.2430071533, -0.2453777790, 0.1074008197, -0.0215152930, 0.0212454200, 0.1065534130, 0.1826478541, -0.0271065198, 0.0328811742, 0.1138897017, 0.0206637606, 0.1551489085, -0.1112749279, 0.1760539263, 0.0435354114, -0.0316250809, 0.1013265550, -0.0492544509, -0.1046664640, -0.0245191138, -0.2292704731, 0.1806834340, -0.1773693860, 0.2058064044, -0.2221787423, -0.0933832601, -0.0475118496, -0.0976339802, -0.1191957146, 0.1301373839, -0.1682026535, -0.0606836528, 0.0289469976, 0.1147932708, -0.2379756421, -0.0891947374, 0.1235395372, -0.1299109012, 0.1500098407, 0.0329815745, -0.1471752971, -0.0487495326, 0.0011411726, 0.0428476557, 0.1864837408, -0.1274401695, -0.1695632637, 0.1296023279, 0.1193590239, 0.1056204066, -0.1233870536, 0.2016844302, 0.1425217539, 0.1893966496, -0.0591788590, -0.0242992882, 0.0658836663, 0.1003232896, -0.0350276381, 0.0055547440, -0.0570269860, -0.1334020942, -0.0185398515, -0.0497371703, 0.1278946549, 0.0463468879, -0.0342604555, 0.1250559986, 0.0499954969, -0.1576976925, -0.1140116304, -0.0010623868, -0.0527883656, 0.0708417296, 0.0542514846, 0.0282201655, 0.0888254568, -0.1592977345, -0.0739687160, 0.1238856390, 0.0289631430, -0.2139420062, -0.1154544950, 0.0174847357, -0.0651009008, -0.0148629211, 0.1254672408};
# 28 "firmware/parameters.h" 2
# 1 "firmware/weights/b6.h" 1
# 12 "firmware/weights/b6.h"
conv1d_1_bias_t b6[32] = {-0.0409479700, -0.2019008696, 0.0975745693, -0.0857121795, -0.2394983619, -0.0109388512, -0.1570589840, -0.1468092054, -0.1456208378, -0.0700124279, 0.0668064430, -0.0674176812, -0.2395161092, -0.0508656688, -0.0636076853, -0.2321671993, -0.0926442072, -0.1168615296, -0.0349320993, -0.0350608192, -0.0438934639, -0.0258043278, 0.1380115151, -0.1198514625, 0.0207327027, -0.0547070950, -0.1211789548, -0.0631595999, -0.0800762549, -0.0623176098, 0.0787107795, -0.0270104315};
# 29 "firmware/parameters.h" 2
# 1 "firmware/weights/s8.h" 1
# 12 "firmware/weights/s8.h"
batch_normalization_1_scale_t s8[32] = {4.7118372917, 4.4743404388, 3.3558518887, 3.2667446136, 3.8985519409, 5.5366239548, 3.0572834015, 3.1371979713, 3.7791938782, 6.7556552887, 3.5208690166, 4.6558184624, 2.4582488537, 4.0226073265, 5.4962439537, 2.6632268429, 12.5864734650, 3.0317184925, 5.5840301514, 6.9353361130, 2.4449744225, 2.9398777485, 2.8551800251, 3.4248094559, 3.9257936478, 4.3330268860, 5.7744679451, 3.2384796143, 5.5022845268, 5.0416269302, 2.5698387623, 7.5495691299};
# 30 "firmware/parameters.h" 2
# 1 "firmware/weights/b8.h" 1
# 12 "firmware/weights/b8.h"
batch_normalization_1_bias_t b8[32] = {-0.1409239620, -0.2073184401, -0.8757270575, -0.3653976917, -0.2537840605, -0.6110646129, -0.1435627043, -0.2125632912, -0.1201706454, -1.0679035187, -0.7557854056, -1.2652183771, -0.1432944983, -0.4579546452, -0.9688373804, -0.2255509645, -0.1278969347, -0.3323936760, -0.8007902503, -1.0168554783, -0.4397598505, -0.2596091032, -0.9958612323, -0.1658701599, -0.7722814679, -1.0155236721, -1.2305825949, -0.3476019800, -0.4102536738, -1.1961244345, -0.8362533450, -1.3451081514};
# 31 "firmware/parameters.h" 2
# 1 "firmware/weights/w11.h" 1
# 12 "firmware/weights/w11.h"
dense_weight_t w11[57344] = {-0.0358964801, 0.0420472957, -0.0098644430, -0.0000372657, 0.0397613235, 0.0043036947, 0.0241681896, -0.0251823422, -0.0221680906, -0.0049021021, 0.0451246351, 0.0286796596, -0.0012662126, -0.0201436896, 0.0139867170, 0.0301755574, 0.0143854897, -0.0268920809, -0.0023766097, 0.0233212318, -0.0000012501, -0.0057659647, -0.0257195774, 0.0089011388, 0.0046314695, -0.0114718666, -0.0278158896, 0.0173385814, -0.0214564875, 0.0246732272, -0.0017163862, -0.0606721863, 0.0269069243, -0.0266679563, -0.0272468086, -0.0124123869, -0.0019890361, 0.0150647089, -0.0065945545, 0.0054901647, -0.0072346241, -0.0561032109, -0.0011046068, 0.0467022769, 0.0165700447, -0.0234782584, 0.0099436333, -0.0268913005, 0.0022286526, -0.0161636379, 0.0069935778, 0.0318846181, 0.0297763553, 0.0014203888, 0.0196603015, 0.0089104334, 0.0014825789, 0.0211965144, 0.0157360639, -0.0436479300, 0.0192102883, 0.0308066178, -0.0155636212, -0.0069464725, -0.0067360774, -0.0206832979, -0.0159674082, 0.0001976024, -0.0136151742, 0.0125055360, 0.0053781681, 0.0098485574, 0.0021825507, 0.0037023956, 0.0316214301, 0.0203565247, -0.0006066280, -0.0031335109, 0.0422012582, 0.0077029057, 0.0412752777, -0.0002108767, -0.0075188372, -0.0348256752, -0.0001023706, 0.0142155886, -0.0109920995, 0.0067912815, -0.0168879014, -0.0295608286, -0.0274772737, -0.0016378264, -0.0023911563, -0.0020421455, -0.0394086242, -0.0073995572, 0.0248193648, 0.0086956564, -0.0407624133, -0.0138406102, 0.0081689591, 0.0004774997, -0.0050827535, 0.0087614041, -0.0389714651, -0.0431169458, -0.0005133308, 0.0219859052, 0.0101389997, 0.0317142494, -0.0056418050, 0.0027533737, 0.0017588177, -0.0036195244, -0.0075368043, 0.0105010252, 0.0192371290, -0.0042849360, 0.0288236104, 0.0044569094, 0.0028660165, -0.0187868178, 0.0159517433, 0.0079553481, 0.0002460338, 0.0156784840, -0.0086822025, 0.0087425411, 0.0459804274, 0.0162591599, 0.0115965055, -0.0003038193, 0.0118568642, -0.0338838771, 0.0275962073, 0.0041041556, 0.0164393503, 0.0005879899, -0.0083383108, -0.0584118143, 0.0006015745, -0.0120322555, -0.0310222264, -0.0423816442, -0.0282812063, 0.0192632563, 0.0041101286, -0.0332973488, 0.0000000262, 0.0120985527, -0.0001672719, 0.0066302726, -0.0005500351, -0.0175307039, 0.0625386462, 0.0072656246, 0.0032638209, -0.0167092513, 0.0188210197, -0.0055134087, 0.0100523764, 0.0032399937, 0.0828076452, 0.0335875861, -0.0141006811, -0.0141433151, -0.0205700602, 0.0087760119, -0.0187154505, 0.0572962798, -0.0000453472, -0.0783141777, -0.0469071455, -0.0645183325, 0.0397204980, 0.0014435031, -0.0148044992, -0.0107831899, 0.0517895035, -0.0635287613, -0.0051372945, -0.0043873978, 0.0130691063, 0.0646720901, 0.0954047740, -0.0191695541, 0.0212027151, 0.0047058654, -0.0523330458, 0.0071494761, -0.0143130226, -0.0107887285, -0.0005449013, 0.0115576312, 0.0225049760, -0.0000082196, -0.0085358964, -0.0039197025, -0.0593564920, -0.0165580940, -0.0377622806, -0.0072848331, 0.0205424018, -0.0113681974, -0.0002683223, 0.0527218916, 0.0088351639, -0.0612951852, -0.0376674980, 0.0229371618, 0.0031296508, 0.0107391402, -0.0000001333, 0.0070361253, -0.0174032319, -0.0183767173, -0.0037112648, 0.0058709779, 0.0032486944, -0.0035514210, 0.0368172042, -0.0081043337, -0.0217412729, -0.0517588966, 0.0612807274, -0.0018295823, 0.0404340737, 0.0153937610, 0.0111773796, 0.0221083239, 0.0342296213, 0.0032313094, -0.0259367861, -0.0350392945, -0.0000740051, 0.0053595714, 0.0651784688, -0.0106937531, 0.0177067649, -0.0002731609, -0.0022943867, -0.0154093578, 0.0021391250, 0.0472126603, 0.0229082275, 0.0036575759, -0.0135801909, -0.0011219897, 0.0197023228, -0.0241258275, 0.0301605966, -0.0125139132, -0.0168970805, -0.0619805828, -0.0303958356, 0.0148843452, 0.0348789245, -0.0099951895, -0.0325785503, -0.0006445564, 0.0461889692, 0.0044417838, 0.0497390591, 0.0079410803, 0.0022788825, 0.0412454233, -0.0328453481, -0.0017421676, 0.0014070249, -0.0584964827, 0.0055682929, 0.0006585428, 0.0352428332, 0.0055322535, -0.0181740224, -0.0415322669, -0.0000007483, -0.0291524772, 0.0447258428, 0.0052754944, -0.0002489660, -0.0294155031, 0.0350028425, 0.0143923694, 0.0095888972, -0.0217898116, 0.0245561916, 0.0344086662, -0.0711953342, -0.0786363706, -0.0347186103, -0.0453065112, -0.0438149162, -0.0817577690, 0.0210937448, 0.0332472324, 0.0049164556, 0.0548834912, -0.0002148824, -0.0352873094, -0.0752119869, -0.0057800319, 0.0209514424, -0.0016591004, 0.0396735631, -0.0042366213, -0.0219783559, -0.1176613420, -0.0041180872, -0.0042339368, 0.0491092019, 0.0374103375, 0.0229643490, -0.0208599716, -0.0395646431, 0.0143014481, -0.0157118775, 0.1077314839, 0.0096036429, 0.0317523815, -0.0018945206, -0.0534576625, 0.0138436928, -0.0002714738, 0.0203507002, 0.0294961501, -0.0306518078, -0.0038959021, -0.0312929489, -0.0157983415, 0.0092810681, 0.0084308116, -0.0012286366, -0.0070846048, -0.0114660077, 0.0197622441, -0.0266859271, 0.0103313122, 0.0016515411, -0.0313154496, -0.0000039156, -0.0012384781, 0.0086745117, 0.0160720777, -0.0024474273, 0.0062537631, -0.0118772658, -0.0301052667, 0.0016090288, 0.0021955995, -0.0167776141, 0.0219475105, 0.0489108711, -0.0073298630, 0.0397926383, -0.0368628763, 0.0524993688, 0.0284454469, -0.0200161058, 0.0124442130, -0.0564097539, 0.0459936820, -0.0000854613, 0.0194133669, 0.0062935464, -0.0200229101, -0.0215029735, -0.0022763547, -0.0223261807, 0.0116024138, -0.0120339105, 0.0191625748, -0.0251847468, -0.0100645414, 0.0184031967, -0.0010705977, -0.0624459200, 0.0662584230, 0.0204914436, 0.0028233132, 0.0137779033, -0.0292754695, 0.0151058575, 0.0560828559, -0.0306246206, 0.0443993099, -0.0023286096, -0.0000085742, 0.0003985748, -0.0239398796, -0.0026697884, -0.0109647866, -0.0037394778, 0.0011987215, 0.0206322297, 0.0088675255, -0.0000001380, 0.0109635154, -0.0107807685, 0.0147203701, -0.0121824713, -0.0182024129, -0.0057913191, 0.0284816604, 0.0000000341, -0.0013472952, -0.0192520563, 0.0050034551, 0.0000517808, 0.0146505898, -0.0095926141, 0.0088786939, -0.0032391846, -0.0159838852, -0.0173277725, -0.0215363633, 0.0018864892, 0.0064422460, 0.0109557072, 0.0152448267, -0.0230764989, -0.0015911539, 0.0173602849, -0.0082277488, 0.0140347211, -0.0081636254, -0.0000638828, 0.0118475147, -0.0014491606, 0.0128226727, 0.0245232210, -0.0012639369, -0.0014604860, -0.0151443919, 0.0081772655, 0.0168069061, 0.0197070558, 0.0009450520, 0.0043014144, 0.0231894646, 0.0306358337, 0.0218684822, 0.0028145085, -0.0492694490, 0.0455867499, 0.0053752074, -0.0007835689, 0.0020897475, 0.0043744328, 0.0517527908, -0.0023711431, 0.0002610949, 0.0324229971, -0.0062791994, 0.0407915339, -0.0408208482, -0.0047553019, 0.0395919904, -0.0081018498, 0.0442372002, -0.0000028452, -0.0245007500, -0.0003826256, -0.0245577469, 0.0418053642, -0.0341605768, -0.0112491995, 0.0244284198, -0.0000001952, -0.0002746292, 0.0433611386, 0.0411628745, 0.0000039407, -0.0000336711, -0.0702139288, -0.0199623089, 0.0243665464, -0.0010779379, 0.0201817248, 0.0542081632, -0.0318928920, -0.0089507168, -0.0664260015, -0.0252857469, 0.0075958320, -0.0101709254, -0.0145541551, 0.0035847635, -0.0073116869, 0.0276009161, -0.0002086825, -0.0095378291, 0.0018227885, 0.0060690562, -0.0086474046, 0.0002950460, 0.0324838273, 0.0005202750, -0.0474459827, -0.0014352056, 0.0219882652, -0.0042088367, 0.0388760306, -0.0107754124, 0.0407992676, -0.0311948098, 0.0059920531, -0.0208645854, 0.0006007659, 0.0951927006, -0.0276198369, 0.0070334547, -0.0305844080, -0.0150029706, -0.0011059066, -0.0000674097, 0.0004614159, -0.0002722259, -0.0217067637, -0.0402179100, 0.0132054631, -0.0090928786, 0.0523002110, 0.0121999308, -0.0052106609, 0.0023705207, -0.0198320299, 0.0166527554, 0.0198463723, 0.0144460732, -0.0082084769, 0.0105281994, -0.0000042695, -0.0166514236, -0.0172477476, -0.0362497270, -0.0036300705, 0.0099851815, 0.0153973224, -0.0073067630, -0.0263526440, 0.0210724920, 0.0326765738, -0.0406346582, -0.0298874099, 0.0242399741, -0.0061172931, 0.0505340733, -0.0154636167, -0.0130708329, 0.0121314321, 0.0311031826, 0.0261157490, -0.0366794877, -0.0003566999, 0.0679515526, -0.0126806954, 0.0297314115, -0.0008414102, -0.0043988903, -0.0123976907, -0.0183731131, -0.0125349192, 0.0010413683, 0.0176314041, 0.0054929256, 0.0056307390, -0.0378869846, 0.0001193104, 0.0414712206, -0.0098355273, 0.0332154334, 0.0651964992, -0.0267504621, -0.0357902907, -0.0245925393, -0.0018845118, -0.0043210112, 0.0113112805, 0.0000039561, -0.0387756601, -0.0115566701, -0.0851056650, -0.0107860332, 0.0047868961, 0.0058847643, 0.0205350127, -0.0221808441, 0.0000282450, 0.0007223351, 0.0199377816, 0.0255996082, 0.0458607823, 0.0108270524, 0.0030052236, 0.0001540085, 0.0000004382, -0.0032258835, 0.0093765594, -0.0165207069, -0.0004041950, 0.0274659190, 0.0087682158, -0.0077363080, -0.0145930545, -0.0067995563, 0.0067642936, -0.0040717633, 0.0022447065, 0.0076520848, 0.0017544971, 0.0028645811, 0.0057683652, 0.0133290570, 0.0047221440, 0.0033748280, -0.0008475063, -0.0225618761, 0.0000037345, -0.0010121542, -0.0134335840, -0.0163594820, -0.0114173600, 0.0027019773, 0.0070416983, -0.0075215520, 0.0061204806, 0.0172192175, 0.0141329672, 0.0003088877, 0.0137284212, -0.0012893183, 0.0072680330, 0.0016453059, 0.0127188098, -0.0488750376, 0.0116031226, -0.0316769332, 0.0018609042, 0.0078286612, -0.0062888414, -0.0203540120, 0.0128536578, -0.0000849546, -0.0084521202, 0.0395882316, -0.0285408851, -0.0409932844, 0.0019947328, -0.0157808401, 0.0184794329, 0.0191828590, -0.0010255328, 0.0012706009, -0.0235472713, -0.0209527314, -0.0068435417, -0.0147239640, -0.0064379675, -0.0091212299, 0.0001149055, 0.0073828562, -0.0149939368, 0.0220003761, 0.0046779448, -0.0173904244, -0.0013590785, 0.0082638757, -0.0185527075, 0.0052329837, -0.0324139558, -0.0413053185, 0.0412720405, 0.0051772860, -0.0403025076, 0.0274749696, 0.0107755791, 0.0132940328, -0.0084762303, -0.0104276948, 0.0090568950, -0.0446637273, 0.0000251712, 0.0427976064, 0.0126699535, 0.0020070400, -0.0229242239, -0.0266673528, 0.0078587821, -0.0159886796, 0.0160911605, -0.0018238841, 0.0025872015, -0.0010254981, -0.0008768048, 0.0025169258, -0.0016767825, -0.0032047315, -0.0021504415, 0.0310994647, -0.0108698001, -0.0354562402, 0.0079021389, 0.0033203827, 0.0003546574, 0.0098707136, -0.0332893804, -0.0000031922, -0.0239723735, -0.0043213246, -0.0176921338, -0.0037369004, -0.0051510558, -0.0030595977, -0.0018940530, -0.0090753073, 0.0000652884, 0.0029814809, -0.0007211390, 0.0414055921, 0.0083939368, -0.0035545668, 0.0062912703, 0.0013832054, 0.0000002075, 0.0030137291, -0.0169614702, -0.0194837321, 0.0006393182, 0.0129488036, -0.0043090358, 0.0033073635, 0.0155685060, 0.0063890317, 0.0166052245, -0.0058484692, -0.0082240580, 0.0010493465, 0.0250147972, -0.0229915492, 0.0075770728, 0.0004728759, -0.0054712091, -0.0092426185, 0.0247998312, -0.0155671993, 0.0000021192, 0.0073296595, 0.0204347055, -0.0166875161, 0.0021311943, 0.0040820614, -0.0115009928, 0.0002557754, -0.0068829753, -0.0032240406, -0.0187414903, -0.0001725426, 0.0164156742, -0.0054430538, -0.0187111869, 0.0032300306, -0.0180557650, 0.0021934742, 0.0179986451, -0.0146108977, 0.0071330369, 0.0000678234, -0.0155235445, 0.0165593289, -0.0198595244, 0.0013747878, 0.0131830983, -0.0173605494, 0.0108314073, 0.0216070637, 0.0160685256, 0.0195496045, 0.0023747000, 0.0160869025, -0.0050794338, 0.0137998136, 0.0033155873, 0.0348489583, 0.0426868759, 0.0041820048, -0.0131194871, -0.0010359883, -0.0001083421, -0.0288777929, 0.0018296741, -0.0137428744, -0.0154390000, -0.0179374386, 0.0107903387, 0.0306229834, -0.0366441309, -0.0174362119, -0.0161846634, -0.0283796377, -0.0146167567, -0.0168503374, -0.0351914018, -0.0070532612, -0.0398698449, -0.0133202849, 0.0105079934, 0.0298483856, 0.0088652745, -0.0098714232, -0.0002026901, 0.0284339599, -0.0530726276, 0.0460014157, 0.0264971778, -0.0034985410, 0.0161090754, -0.0243041702, 0.0036787686, -0.0277099051, 0.0205294751, -0.0032432636, 0.0186623354, -0.0146392845, -0.0060701622, -0.0133860102, -0.0192463547, 0.0071416637, 0.0365056694, 0.0410208218, 0.0069312095, 0.0144137116, -0.0133113898, 0.0139492182, 0.0002621010, -0.0002260994, 0.0374588631, 0.0103240749, -0.0262554456, 0.0310910139, -0.0129047511, -0.0033032133, -0.0560874119, -0.0116036981, 0.0004954610, -0.0013079485, -0.0098815002, 0.0270818248, -0.0386536643, -0.0128516993, -0.0014732324, 0.0117779355, 0.0000000205, -0.0173135903, 0.0222121216, 0.0093469415, -0.0042595617, -0.0376369618, 0.0533340946, 0.0124861477, -0.0119623151, -0.0063494500, 0.0228643492, 0.0273423009, -0.0135177858, -0.0345307402, 0.0215499923, 0.0031537237, -0.0069572525, -0.0516759381, 0.0239072517, 0.0254967716, 0.0644189045, 0.0364397913, -0.0001679638, 0.0605575442, 0.0131945387, 0.0049460032, 0.0639750510, -0.0063609672, -0.0049653826, -0.0181659609, 0.0366862193, -0.0817645565, -0.0095927855, -0.0012999070, 0.0307545755, -0.0519720167, -0.0015566670, 0.0168438181, 0.0128760608, -0.0136583094, -0.0060105128, -0.0196369272, 0.0261793304, 0.0554689690, -0.0253258236, -0.0207160041, -0.0103990044, 0.0000160758, -0.0306124408, -0.0095915059, -0.0217124224, -0.0091381809, -0.0096188337, -0.0026439836, 0.0016753046, -0.0284377728, 0.0000010260, 0.0085975220, 0.0210216846, -0.0035622912, -0.0274039935, 0.0123116216, 0.0089629646, -0.0210226607, 0.0000004393, 0.0035865051, -0.0380567461, 0.0052651307, 0.0024970088, 0.0118991649, -0.0018304220, 0.0083362041, 0.0063926922, -0.0022495990, -0.0094423555, -0.0367921814, 0.0072095930, 0.0057153259, 0.0137666985, -0.0079068141, -0.0190228317, 0.0201161150, -0.0092546428, -0.0017761193, -0.0021743816, -0.0045783282, 0.0001613626, 0.0013134765, -0.0013550672, 0.0053529814, 0.0421108827, 0.0027297484, -0.0158102587, 0.0025283326, 0.0283304546, 0.0104510924, 0.0037474055, 0.0012170236, -0.0007517694, 0.0189574361, 0.0518357828, -0.0303775072, 0.0000863152, 0.0099318409, 0.0304062068, -0.0396827981, -0.0108406357, 0.0228512678, -0.0185675230, 0.0122413915, -0.0158872530, -0.0000084805, 0.0047823070, -0.0183807872, -0.0488078743, -0.0079072211, 0.0006222753, -0.0252353456, 0.0253315456, -0.0089948205, -0.0002090050, 0.0047603780, -0.0239000116, -0.0043589226, 0.0080903908, -0.0050184214, 0.0068868184, 0.0149883693, -0.0000006418, -0.0229905136, -0.0085994909, -0.0278088227, -0.0030526202, 0.0215862524, 0.0006352530, 0.0129064536, -0.0269210730, 0.0357702635, 0.0047168368, -0.0262350440, 0.0298689920, -0.0107511571, 0.0303066391, 0.0225469247, -0.0150209144, -0.0220733006, -0.0263878368, -0.0116376393, 0.0103792483, -0.0275362283, -0.0000184267, 0.0078354487, 0.0418957174, -0.0027912098, -0.0063234181, -0.0017355925, -0.0062282942, -0.0153798759, 0.0045879497, 0.0350768976, 0.0239616632, 0.0066364352, -0.0096824514, 0.0220814571, -0.0377461836, 0.0414165072, 0.0087773679, 0.0077578719, 0.0120119946, -0.0371264480, -0.0217328537, 0.0081526441, -0.0125388857, -0.0180806033, 0.0004311291, -0.0000497526, 0.0157391522, -0.0010651166, 0.0119330911, -0.0162452217, -0.0070250710, -0.0048663737, -0.0142693790, 0.0010206515, 0.0000402989, -0.0086482828, 0.0043656207, -0.0129777109, -0.0261946749, -0.0187767372, 0.0091330716, -0.0469941422, 0.0000000127, -0.0039370274, -0.0009215191, -0.0242368318, 0.0000985274, 0.0032957334, -0.0023055936, 0.0278236251, 0.0239265971, -0.0086855534, 0.0029584866, 0.0085962787, 0.0098871402, -0.0101643959, -0.0152104022, -0.0215094294, -0.0016900646, -0.0042515607, -0.0218372103, -0.0176558550, 0.0065416037, 0.0504944474, -0.0001787125, -0.0111922277, -0.0106258383, -0.0106718009, 0.0011441556, 0.0005888611, 0.0023818649, 0.0126385409, 0.0466589853, -0.0063406648, -0.0144240502, -0.0070384671, -0.0048840954, 0.0291930754, 0.0255876109, -0.0170067269, 0.0017618232, -0.0094067873, -0.0322624743, -0.0047608158, -0.0141703151, 0.0177176967, -0.0337696932, 0.0190039910, -0.0222480856, -0.0000023043, -0.0010573030, -0.0355081297, -0.0061231945, -0.0047334665, 0.0157791041, -0.0046533234, 0.0227751918, 0.0393971242, -0.0004496293, 0.0643098056, -0.0110536460, 0.0136703243, 0.0493790470, 0.0152706206, -0.0092744399, -0.0030956990, -0.0000021155, -0.0052959872, -0.0258932449, -0.0158963259, -0.0110477293, 0.0121950665, -0.0069491141, 0.0436901227, -0.0158614498, 0.0108492970, -0.0260480084, -0.0191872828, 0.0382741615, 0.0350750051, -0.0368934833, -0.0030782404, -0.0124961780, 0.0394765325, -0.0243747886, 0.0111579122, -0.0422700085, -0.0582245998, -0.0001364394, 0.0592690781, 0.0062317490, 0.0651022345, -0.0257689636, -0.0161526632, -0.0024263922, -0.0164576620, -0.0118681630, 0.0366977416, 0.0477768965, -0.0018030099, 0.0076241829, -0.0285247862, -0.0531018376, 0.0171719790, -0.0116524640, -0.0041352669, 0.0471690036, -0.0048391707, -0.0016727058, -0.0084586786, -0.0362391509, 0.0455742814, 0.0297114849, 0.0000242269, 0.0614096187, 0.0150892781, 0.0454228409, 0.0392831191, -0.0016807693, 0.0592419542, -0.0573032871, 0.0180988666, 0.0002708662, -0.0292347018, 0.0843262374, 0.0198510699, 0.0418050773, 0.0125042703, -0.0184476394, 0.0356179364, -0.0000069828, -0.0144061251, 0.0193385184, -0.0044510029, 0.0000212989, -0.0154023813, -0.0324059390, 0.0372503027, -0.0085374610, -0.0330971181, 0.0415479504, 0.0028028339, -0.0855309889, -0.0489075966, -0.0631942526, -0.0386241749, 0.0252426751, -0.0498289876, 0.0065430822, 0.0500285402, 0.0058100461, 0.0244092885, 0.0001824105, 0.0113096535, -0.0220218115, 0.0737969577, 0.0291236229, 0.0013307782, 0.0704676285, -0.0098547153, -0.0712966323, -0.0506006405, 0.0035671711, 0.0003285461, 0.0239160638, -0.0344743766, -0.0162758715, -0.0401163921, 0.0005662784, -0.0821016058, 0.0349126793, 0.1139949560, 0.0139235118, 0.0166214034, 0.0462121740, 0.0548849702, -0.0036504054, 0.0000021806, -0.0725413114, -0.0635715574, -0.0359532237, 0.0430537201, 0.0393190272, -0.0005043437, -0.0498369597, -0.0257248618, 0.0000374824, 0.0173651613, 0.0286171082, -0.0434861891, 0.0259996932, 0.0315362215, 0.0049975505, 0.0279201865, 0.0000000087, 0.0150949601, 0.0107899401, -0.0374023430, -0.0003079028, 0.0190732386, -0.0086748637, 0.0401037522, 0.0014212998, -0.0129376650, -0.0255014971, 0.0161348917, 0.0397315919, 0.0405962318, -0.0240320489, -0.0286582056, 0.0058639301, 0.0392684005, 0.0069818101, 0.0093314918, -0.0176284164, -0.0353980623, 0.0000012608, -0.0251447186, -0.0135768065, -0.0027371743, -0.0287972372, 0.0130631262, -0.0229160190, 0.0064846650, 0.0006634075, 0.0413448326, 0.0112769688, -0.0067646764, -0.0010989243, 0.0041407016, -0.0139469123, -0.0251881499, -0.0005558690, 0.0051128273, 0.0234034974, -0.0028718445, 0.0297189914, -0.0356213190, -0.0214057583, 0.0293908548, -0.0416982993, -0.0001476156, 0.0268138293, -0.0416420400, -0.0039204140, -0.0410356075, 0.0148435608, 0.0054766010, 0.0004078261, 0.0401152335, -0.0000250747, 0.0156505108, -0.0432365090, 0.0039817477, 0.0600819103, -0.0567766428, -0.0090081301, 0.0286786407, -0.0000005012, -0.0069818739, 0.0254516844, 0.0257612746, 0.0000135780, 0.0037963358, -0.0542411841, -0.0066190343, -0.0104922680, 0.0236373264, 0.0084900334, 0.0444731377, -0.0325082354, 0.0063325209, -0.0298319235, 0.0039813640, 0.0057790973, 0.0054871934, -0.0079613067, -0.0010380652, 0.0435304008, -0.0197596010, -0.0000529676, 0.0167207271, 0.0033618561, 0.0278413724, -0.0114918994, -0.0015641747, 0.0009760302, -0.0089660119, -0.0296341330, -0.0085254107, 0.0072209937, -0.0010182894, 0.0241218302, -0.0340745784, -0.0020789667, 0.0305417478, -0.0161241405, -0.0300243180, 0.0390375555, 0.0391777828, -0.0119482577, 0.0418062173, 0.0138065256, 0.0103182970, 0.0029516544, -0.0005767886, -0.0351378955, 0.0242834315, -0.0331994630, 0.0021170264, -0.0010559245, -0.0124254832, 0.0162395537, -0.0126625039, 0.0003134914, -0.0121595738, 0.0080995150, -0.0120690968, 0.0121969385, -0.0142996833, -0.0086721973, 0.0271347072, -0.0002700827, 0.0006842940, -0.0234232657, 0.0187641326, -0.0101462286, -0.0077562896, -0.0152055155, -0.0447478406, -0.0343618058, -0.0019473674, -0.0158441868, -0.0380110331, 0.0369294323, 0.0533970557, 0.0013397069, 0.0193248205, 0.0030168395, 0.0303404387, 0.0004682853, -0.0134096220, 0.0334836021, -0.0272803400, -0.0000946946, 0.0315741599, 0.0098004192, 0.0171853341, -0.0057711098, -0.0066811969, 0.0162910335, -0.0070655602, 0.0321740508, 0.0311209131, 0.0102025168, -0.0005037163, -0.0390125513, -0.0138649363, 0.0006231457, -0.0096288128, 0.0318874493, 0.0208883081, 0.0001223256, -0.0109249251, -0.0008428637, -0.0035535041, 0.0476766154, 0.0439845063, -0.0294785742, -0.0000652735, -0.0171027351, -0.0058921315, -0.0241232701, 0.0166265424, 0.0030704422, 0.0070275837, -0.0199030917, 0.0185007695, -0.0001039959, -0.0342120901, 0.0114305671, 0.0352759659, 0.0658681989, -0.0029664696, 0.0000228151, 0.0272306092, 0.0000000781, -0.0066478793, 0.0017022470, 0.0304053761, -0.0031523772, -0.0121447351, -0.0317208245, -0.0176551621, 0.0058837002, -0.0153318746, 0.0201083217, 0.0408789143, -0.0152822277, 0.0204083398, -0.0226954408, -0.0203947071, -0.0110506192, -0.0049248310, 0.0012409175, 0.0157231856, 0.0304795261, -0.0070335199, -0.0000201650, -0.0418161564, -0.0186250433, 0.0278667286, 0.0193170365, -0.0031159637, 0.0017163819, -0.0125490827, -0.0384689569, -0.0185727533, 0.0038144400, -0.0024919745, 0.0122607565, -0.0265517309, -0.0006108861, -0.0268295165, -0.0181532521, -0.0128384139, 0.0184563808, 0.0484002419, 0.0119586689, 0.0176853389, -0.0433715731, 0.0546671376, -0.0026622240, 0.0000089631, 0.0559656061, -0.0560669936, -0.0201491602, -0.0036585932, 0.0284212735, -0.0215261467, -0.0105510196, 0.0077266614, -0.0000065169, 0.0418384895, -0.0815771818, 0.0234898236, 0.0080027049, -0.0352735780, 0.0036413996, 0.0256282277, 0.0000001231, -0.0065383608, -0.0231770109, -0.0252264030, -0.0029902912, 0.0118711768, -0.0016648296, 0.0442101285, -0.0099565377, -0.0174024664, -0.0221901760, -0.0069931573, 0.0393177494, 0.0058966726, 0.0390456170, 0.0154256765, -0.0058006337, 0.0166627821, -0.0526038110, -0.0227220301, 0.0131090898, -0.0021908758, -0.0001196232, 0.0460119471, 0.0208842941, -0.0503173172, -0.0223603602, -0.0070765796, -0.0185329374, -0.0244695656, 0.0577542409, 0.0380046293, 0.0053022583, 0.0054735253, 0.0309908167, 0.0063803038, -0.0129211321, 0.0759100989, 0.0281796549, -0.0649487004, 0.0268879849, -0.0261921752, -0.0171247292, 0.0325320251, 0.0235667638, 0.0046034604, -0.0110317776, 0.0003067811, 0.0242727306, 0.0123603921, 0.0376918614, -0.0057700649, 0.0050106118, -0.0028697990, -0.0201071929, -0.0038611612, 0.0015970090, -0.0595552810, -0.0377426744, 0.0144912982, 0.0493661612, 0.0193607416, 0.0003886881, -0.0390955582, 0.0000000493, -0.0150700873, -0.0085511720, -0.0435360856, 0.0003499268, -0.0096907541, 0.0468720980, 0.0368922539, 0.0191370379, -0.0401069298, 0.0443515889, 0.0057951235, -0.0151678221, -0.0632488802, -0.0063845855, -0.0337342806, -0.0707830563, -0.0945834965, 0.0237094536, 0.0155055560, 0.0054754619, 0.0760439411, -0.0000997694, -0.0592378899, -0.0549932644, 0.0156767815, 0.0177900158, -0.0032263170, 0.0020610634, -0.0075998576, -0.0084116627, -0.1028811932, 0.0255437754, -0.0009681892, 0.0509369262, 0.0459322184, 0.0320762880, -0.0216791648, -0.0190951917, -0.0210711993, -0.0142672248, 0.1064106822, -0.0116702095, -0.0206105299, -0.0178073458, -0.0053407671, -0.0143286707, -0.0000213258, 0.0201519281, 0.0337329954, -0.0663321167, -0.0213281959, -0.0168230701, -0.0164571777, -0.0186950639, -0.0314332470, -0.0041415459, -0.0106176389, 0.0126865692, 0.0637629852, 0.0002785341, -0.0118091870, 0.0082058236, 0.0120590292, -0.0000026392, -0.0256677736, -0.0151938265, 0.0282594226, 0.0016778632, -0.0251942649, 0.0138984993, 0.0133166090, -0.0061141495, 0.0073474441, 0.0363858305, 0.0306260996, -0.0239860024, -0.0184809566, 0.0178952366, -0.0108865183, 0.0149512989, -0.0271031316, 0.0154726068, 0.0020830443, 0.0532381982, 0.0110058393, -0.0004143156, 0.0237745829, 0.0041602417, -0.0032813963, 0.0345606282, -0.0053495434, -0.0098202284, -0.0023939849, 0.0269945133, -0.0586013533, -0.0369670019, 0.0016442356, -0.0187518895, -0.0350834727, -0.0054667499, 0.0099636521, 0.0018694766, -0.0141108232, 0.0168493502, -0.0217773262, -0.0179766696, 0.0382615216, 0.0242394302, -0.0442813560, -0.0327552706, 0.0000818891, 0.0189358424, -0.0076709883, 0.0825033411, 0.0287986752, -0.0091871759, 0.0288148485, -0.0335721895, 0.0234366581, -0.0000414624, -0.0396169610, -0.0272587892, -0.0121568339, -0.0480672643, -0.0365351290, -0.0067735408, -0.0097858272, -0.0000007526, -0.0315685868, 0.0553543381, 0.0465455838, 0.0002250104, -0.0071379337, -0.0076912669, -0.0072832955, -0.0105953868, 0.0153190093, -0.0015537892, 0.0467629842, -0.0454925373, -0.0229227468, -0.0348308273, -0.0262051951, 0.0030886005, -0.0082235625, -0.0315612070, -0.0147120859, 0.0347785354, 0.0077437893, -0.0000010715, -0.0186744742, -0.0332045406, 0.0077731293, -0.0113080153, -0.0033490187, 0.0073007043, 0.0168647133, 0.0132348360, -0.0314479731, -0.0375172123, -0.0123608215, -0.0465428419, -0.0186045356, 0.0011942377, 0.0175008010, -0.0364080556, 0.0272587594, -0.0401459485, 0.0384859778, 0.0434851274, 0.0194111932, -0.0021170715, 0.0598737895, -0.0172356609, -0.0000334235, 0.0280613303, -0.0223655086, -0.0170486737, -0.0234508049, 0.0113184471, -0.0134676360, -0.0182947498, 0.0120193437, 0.0030075531, 0.0195046067, -0.0348292850, 0.0485170744, 0.0617095158, 0.0057450901, -0.0036856197, 0.0335325599, 0.0000003596, -0.0086071221, -0.0154246306, -0.0060023507, -0.0061355024, 0.0035401734, 0.0341229960, 0.0059722909, -0.0168789495, -0.0162349455, 0.0275042057, -0.0026516749, -0.0354330838, 0.0216913167, 0.0132881030, 0.0220445786, -0.0043100379, -0.0382199474, -0.0029172320, 0.0088254269, 0.0529499687, 0.0022051656, -0.0000267034, 0.0182372015, -0.0216460507, -0.0026398662, 0.0221873485, -0.0010236797, -0.0149436360, -0.0131065827, -0.0132543668, -0.0193061791, -0.0188486204, -0.0010621280, 0.0298523810, -0.0116804931, -0.0118434923, 0.0205946825, -0.0034591532, -0.0245784875, 0.0601085201, 0.0648698732, -0.0324733071, -0.0414773151, -0.0561923012, -0.0072036884, 0.0195227433, -0.0020280376, -0.0580431782, -0.0612886548, -0.0405988880, 0.0175323933, 0.0103546083, -0.0012653770, 0.0147848492, -0.0133576607, 0.0003754363, 0.0415588133, -0.0081056021, -0.0108541008, -0.0023596836, 0.0157382246, -0.0063816002, 0.0200530309, 0.0000053560, -0.0201955847, 0.0043818261, -0.0191722065, -0.0091949776, -0.0098266480, 0.0120950015, 0.0241781175, -0.0223592483, -0.0285996012, -0.0400084481, -0.0538012795, 0.0322316736, 0.0026742253, 0.0088976845, 0.0178917404, -0.0178962592, -0.0296425484, -0.0116815390, 0.0109740794, 0.0207367819, -0.0510298572, -0.0003583945, 0.0296273101, 0.0145951947, -0.0307631455, 0.0364533402, -0.0102762142, 0.0247083772, -0.0120293843, 0.0788777024, 0.0105555160, 0.0251628011, 0.0055537284, 0.0081728958, 0.0020560278, 0.0414774604, -0.0310932249, -0.0161043294, -0.0206183754, 0.0246706717, -0.0571012534, 0.0270692147, 0.0270532910, -0.0138733750, 0.0073930109, -0.0116274999, 0.0000010754, -0.0206167884, -0.0364183486, -0.0191486627, 0.0056928317, 0.0150659233, -0.0013281434, -0.0148238419, -0.0122443130, 0.0000516557, 0.0127923721, -0.0057290667, -0.0245962311, -0.0024387066, -0.0037660089, 0.0067486144, -0.0006945623, 0.0000000330, 0.0057038264, -0.0074646189, -0.0130251022, 0.0002968527, 0.0152720576, 0.0089722592, 0.0059054024, 0.0186173879, -0.0005447494, 0.0104434015, -0.0132054752, 0.0148815019, 0.0339518860, 0.0061066193, 0.0178877078, -0.0155379856, -0.0033619364, -0.0002489625, 0.0006743674, 0.0059565427, 0.0164553840, 0.0000033821, -0.0087116929, 0.0096509717, 0.0182709619, 0.0003512832, 0.0046462016, -0.0069715814, -0.0055874516, 0.0048097465, -0.0172124337, 0.0143455686, 0.0005417813, -0.0183959287, -0.0105441082, 0.0039172526, -0.0167240575, 0.0001910956, -0.0004950855, -0.0090832869, -0.0093010440, 0.0041773962, -0.0104624145, 0.0249106456, 0.0135328341, -0.0279072374, -0.0001523449, -0.0350065082, -0.0602394752, -0.0134318238, -0.0117630605, 0.0042739720, -0.0012994087, -0.0108148707, -0.0024719732, -0.0005932389, -0.0068720151, -0.0401377380, -0.0103906225, 0.0034900974, 0.0049800538, 0.0007527543, -0.0140955634, -0.0000058833, 0.0035337701, 0.0040894579, 0.0166401900, -0.0013900122, 0.0044219298, 0.0247053616, 0.0119019896, -0.0141285686, -0.0292284247, -0.0369476154, -0.0199803337, 0.0122136073, 0.0118937548, 0.0131904026, -0.0148200346, -0.0400281437, -0.0168931521, 0.0220964551, 0.0111505250, -0.0210004747, 0.0111934189, -0.0001159043, -0.0069190995, -0.0192330182, 0.0041113053, 0.0162354708, 0.0003278569, -0.0142379981, -0.0209298879, 0.0271508340, -0.0336061120, 0.0137527110, -0.0034697356, 0.0421372727, 0.0332100578, 0.0411384143, 0.0272535942, -0.0195001923, -0.0066995700, 0.0237774234, -0.0114934864, 0.0104179708, 0.0432940908, 0.0059455261, 0.0141643407, -0.0236448273, -0.0000008442, 0.0064628362, -0.0071943011, 0.0309958011, -0.0086163618, -0.0196673889, 0.0285819974, -0.0195818935, 0.0157028269, 0.0000058985, -0.0209600609, -0.0014390837, -0.0022371768, 0.0107019236, -0.0063499752, -0.0038564370, 0.0402245782, -0.0000000659, -0.0073817968, 0.0249618385, 0.0230102986, 0.0008233726, 0.0056381160, -0.0372099318, -0.0125695942, 0.0091903349, -0.0122041618, -0.0019450738, 0.0236569904, -0.0331008025, -0.0121221971, -0.0197149087, -0.0374118164, 0.0090808934, -0.0063061593, -0.0129017010, 0.0049404963, 0.0081615392, -0.0582594648, 0.0000013987, -0.0053208033, 0.0161025934, 0.0129138008, -0.0101536550, 0.0033646424, 0.0279244818, 0.0056410008, -0.0551184081, -0.0202839617, 0.0011187186, -0.0001499790, 0.0153721105, -0.0192210339, 0.0114362249, 0.0005363054, -0.0376130901, -0.0222891606, 0.0115791121, 0.0236533843, 0.0149941389, 0.0423246995, 0.0034010296, -0.0009506505, 0.0235475078, -0.0008326158, -0.0119159641, 0.0623793192, -0.0364315100, 0.0158945173, -0.0088211047, -0.0137966005, 0.0385018028, 0.0154594211, -0.0029552784, -0.0339006893, 0.0216193087, 0.0120038893, -0.0349224955, -0.0090605700, -0.0063794744, -0.0085458867, -0.0000217619, 0.0086337179, -0.0075931102, -0.0002652734, -0.0027161762, -0.0294243526, 0.0114702377, 0.0093510626, 0.0000404197, -0.0118133798, -0.0097435545, -0.0364893936, 0.0156103568, -0.0046809027, 0.0048916121, 0.0094589731, 0.0326216482, 0.0082780905, 0.0376430824, -0.0117651075, -0.0207314305, -0.0124385953, -0.0002511642, 0.0194871519, -0.0113881445, -0.0187630653, 0.0227114875, -0.0132045969, 0.0257120617, 0.0003344784, 0.0332966149, 0.0067720180, -0.0083309812, -0.0004408079, 0.0294845980, 0.0216674395, 0.0171025917, 0.0092149219, 0.0413749069, -0.0252889339, -0.0158284623, -0.0585935414, 0.0164698549, 0.0215838440, 0.0174756665, 0.0063347062, 0.0226943325, -0.0008107768, 0.0106062694, -0.0093882214, 0.0171887223, 0.0155958440, 0.0105997035, -0.0096344110, -0.0341506451, 0.0152059169, -0.0025395935, -0.0399555899, 0.0038816773, -0.0148977712, 0.0009807736, -0.0149874287, -0.0115477350, -0.0101180226, -0.0000569615, 0.0145438574, 0.0211200230, 0.0128250942, -0.0012638222, -0.0432957411, -0.0053946762, 0.0200022832, -0.0198917799, -0.0350949205, -0.0020429234, 0.0166487787, -0.0074118739, 0.0083154356, -0.0212173983, -0.0302242618, -0.0019590207, -0.0112602729, 0.0002421177, 0.0060089263, 0.0304930732, 0.0470845476, -0.0005125316, 0.0018663789, -0.0152066844, -0.0014513277, 0.0042408365, -0.0027918047, 0.0271996651, -0.0173184164, 0.0376102217, -0.0098319724, -0.0300745312, -0.0046227057, 0.0113915354, 0.0136239165, 0.0126943188, -0.0329511203, 0.0163138565, 0.0038416465, -0.0093569979, -0.0013590480, 0.0433009043, 0.0233006142, -0.0294383429, 0.0071176975, 0.0192797426, -0.0003178386, 0.0106878420, -0.0268656313, -0.0020378001, -0.0382772237, 0.0220969766, -0.0060402155, 0.0027572061, 0.0399540961, -0.0001066087, 0.0362024494, -0.0701409727, -0.0343532301, -0.0081046959, 0.0338868722, 0.0045752926, -0.0019412978, -0.0000009075, -0.0137692271, -0.0227789562, 0.0165976845, 0.0000156967, 0.0163410716, 0.0517738871, 0.0120230075, -0.0226007532, 0.0020301987, -0.0111480020, -0.0114520350, 0.0159290750, -0.0124105448, 0.0250273924, 0.0191399343, -0.0075538321, -0.0164694302, -0.0256939791, 0.0214853343, 0.0064802389, -0.0087194517, 0.0002294307, 0.0111694522, 0.0104539739, -0.0119791338, -0.0431797057, -0.0009149754, -0.0362334251, -0.0288960226, -0.0330626853, 0.0064085135, -0.0104286047, -0.0051210066, 0.0181472059, 0.0098437490, -0.0149549367, 0.0453814045, -0.0155040780, 0.0037255196, 0.0312652811, -0.0083092237, -0.0101141967, -0.0193801057, -0.0023709992, 0.0401077382, 0.0122630307, -0.0000042355, -0.0066115106, -0.0326040611, -0.0369389988, 0.0024262997, 0.0266448427, -0.0009627149, -0.0170598198, -0.0076189013, 0.0004918659, 0.0375837199, 0.0186708551, -0.0015314565, 0.0204788595, 0.0276988316, -0.0007924262, -0.0017416666, -0.0000009667, 0.0010686427, -0.0203916207, -0.0001722303, -0.0000592367, 0.0069166711, 0.0421640314, 0.0269670933, -0.0081416424, 0.0002332512, 0.0239616316, -0.0076329042, -0.0034180083, 0.0081206812, 0.0144477757, 0.0285692941, 0.0064867325, 0.0302363411, -0.0174308885, 0.0017123352, -0.0223898329, -0.0235420428, -0.0000234948, -0.0007756843, 0.0038320560, -0.0257080458, -0.0030592657, -0.0077026938, -0.0007481484, -0.0032710833, 0.0046646791, -0.0017309843, 0.0102881091, -0.0033421230, 0.0113665815, -0.0303756967, -0.0029590661, -0.0161077734, 0.0046582380, -0.0057814457, 0.0256419070, -0.0208565984, 0.0018900206, -0.0317473859, 0.0172897391, -0.0342970341, 0.0014410195, -0.0000541887, 0.0137257567, 0.0067457906, 0.0206759926, 0.0057211518, -0.0174698569, 0.0064344816, 0.0193989314, -0.0004405956, -0.0000550114, -0.0163463373, -0.0024795132, -0.0298988465, -0.0325561203, 0.0012506023, -0.0004232384, -0.0332727283, -0.0000043079, -0.0114687709, -0.0203484166, 0.0154412305, 0.0010436199, -0.0314244032, 0.0106074130, -0.0136803258, 0.0127668092, 0.0041538202, -0.0106945867, -0.0059520248, 0.0048624952, 0.0051543685, 0.0132329408, 0.0043480671, -0.0111742225, -0.0254711695, -0.0029599147, -0.0176325385, 0.0005566763, 0.0338209271, -0.0003543991, -0.0119251488, -0.0024254189, -0.0242407601, 0.0279797316, -0.0054312181, -0.0026812516, 0.0079412377, 0.0334479883, 0.0044343933, 0.0005547792, 0.0002752579, -0.0003382976, 0.0240564290, 0.0510162935, 0.0143875023, 0.0061915726, 0.0275004972, -0.0476522632, -0.0088801188, -0.0090884790, 0.0281230733, -0.0077169128, -0.0101808691, 0.0394321047, -0.0000020054, 0.0246141218, -0.0052630282, 0.0358294584, -0.0322417654, 0.0091524785, 0.0003806794, 0.0483853370, 0.0126087433, -0.0002102223, -0.0056540864, -0.0575299487, -0.0362847224, -0.0329967588, -0.0035276846, -0.0013590869, 0.0023605190, -0.0000001087, -0.0042899502, -0.0178548079, -0.0148016326, -0.0016005109, 0.0208620187, 0.0030886319, -0.0180690903, -0.0117547642, -0.0045336061, -0.0270243324, 0.0097747203, 0.0330291130, -0.0058300416, 0.0294687003, -0.0054857852, 0.0320686884, -0.0036239291, -0.0085793417, -0.0004791493, -0.0298422184, -0.0060723997, -0.0000102008, 0.0102842739, 0.0549400784, -0.0384293646, -0.0203935802, -0.0081252242, -0.0003292027, 0.0096921129, 0.0193150863, -0.0105353734, 0.0009967573, 0.0007671379, -0.0140048964, 0.0024600378, 0.0221751295, 0.0347493701, -0.0074807121, 0.0001478285, -0.0375544317, -0.0246060733, -0.0019037545, 0.0280316938, -0.0374391675, -0.0307891127, 0.0273135062, 0.0000029242, 0.0006987303, 0.0266598761, 0.0002219087, 0.0127794510, -0.0098292856, 0.0045358380, 0.0426967889, 0.0138935978, -0.0005744236, 0.0044962289, 0.0054514538, 0.0086691724, 0.0058477367, 0.0072389077, 0.0019811487, -0.0123910680, -0.0000005214, -0.0139692696, -0.0160541404, -0.0105952583, -0.0046044323, -0.0028145139, 0.0069610942, 0.0046433788, -0.0036633546, -0.0055086268, -0.0179113131, -0.0242275503, 0.0074020335, 0.0009996658, -0.0008652179, 0.0189907793, 0.0047914167, 0.0197138675, -0.0370931067, 0.0072170445, -0.0041201706, -0.0364024602, 0.0000810627, 0.0248275902, 0.0329207070, -0.0033961583, 0.0248561464, -0.0082018590, 0.0116045764, -0.0073245480, 0.0022619511, 0.0268941857, 0.0082787378, 0.0027182815, -0.0065727863, 0.0062925140, -0.0111388797, -0.0115407472, 0.0172681492, -0.0060734968, 0.0094199963, -0.0159786455, -0.0210806876, 0.0075981463, 0.0169230010, 0.0304771904, 0.0021182036, -0.0000821454, 0.0253346711, 0.0105768936, -0.0289044306, -0.0298702829, -0.0309268348, 0.0057725678, 0.0210037343, 0.0082015553, -0.0005639340, -0.0336761363, 0.0334374867, 0.0084194401, -0.0228968710, -0.0041904524, -0.0128810387, 0.0143336514, -0.0000029693, -0.0054564299, 0.0206532776, 0.0255994312, 0.0017105266, -0.0217703655, -0.0135192322, -0.0195193328, 0.0172395464, -0.0095813610, 0.0220151432, -0.0129714366, 0.0098924432, 0.0023506696, -0.0004188462, -0.0073435064, 0.0071112639, 0.0015400158, 0.0145073561, -0.0071700774, -0.0066519952, -0.0013770099, 0.0000184225, 0.0178825371, 0.0190046001, -0.0263417363, 0.0273073297, 0.0018584119, 0.0110067343, 0.0108761862, 0.0121215982, 0.0337316617, 0.0088401288, 0.0027109256, 0.0544983856, 0.0063241781, 0.0422508195, -0.0209476463, 0.0358576961, -0.0371400751, 0.0079587176, 0.0203272440, -0.0127030341, 0.0020199337, -0.0141106285, -0.0080898954, -0.0032399774, 0.0000177241, -0.0170331765, -0.0443024859, -0.0360122062, 0.0035500091, -0.0068920958, -0.0093150120, -0.0057935342, -0.0251455568, -0.0000541911, -0.0004605256, 0.0353623144, 0.0112181129, -0.0045417580, 0.0074164062, 0.0021195661, -0.0058769123, -0.0000007568, 0.0054494939, -0.0436986014, -0.0149009582, -0.0047669550, -0.0087234331, 0.0387412310, 0.0018680817, -0.0228974819, -0.0027582012, 0.0149608422, -0.0217383336, 0.0098119285, -0.0135193812, -0.0012364332, 0.0338539630, 0.0050448752, 0.0228018202, 0.0150981648, 0.0063569676, 0.0156055326, -0.0197147168, -0.0000683266, -0.0006359398, -0.0303971265, -0.0045133191, -0.0140452627, -0.0128955794, 0.0076456121, -0.0077954009, 0.0505405739, -0.0136753675, 0.0234933216, 0.0002363857, -0.0211175699, 0.0216549113, 0.0143458676, -0.0305943321, 0.0159354545, 0.0100838318, 0.0006862798, -0.0342118666, -0.0053488165, -0.0230349973, 0.0286263712, 0.0417576656, -0.0230113696, 0.0000030109, -0.0413473770, -0.0222021546, -0.0378709622, -0.0078591565, 0.0180115793, -0.0218762103, -0.0410251804, -0.0004008461, 0.0004179763, -0.0051874090, 0.0336805582, -0.0117030311, 0.0428457297, -0.0277780015, 0.0007296654, 0.0444217734, 0.0000000396, 0.0231912658, -0.0056935470, 0.0001544769, -0.0002383466, -0.0097949095, -0.0345098153, -0.0362778157, -0.0122327888, 0.0188938770, 0.0040514283, 0.0273016505, 0.0034176384, -0.0022067721, -0.0320220329, 0.0425715819, -0.0206892323, 0.0080536837, -0.0181246065, 0.0135179153, 0.0432488248, 0.0057910145, 0.0000128105, -0.0146101937, -0.0016258701, 0.0234606620, 0.0317255929, 0.0049268105, -0.0155484434, 0.0001447932, -0.0000804932, -0.0168737024, 0.0158469789, 0.0000244777, 0.0267572552, -0.0055313483, 0.0322146863, -0.0477199219, 0.0195634943, 0.0001460894, 0.0174072273, 0.0485072844, 0.0128751127, -0.0228994191, 0.0363350436, -0.0037524377, 0.0100806151, -0.0021059830, -0.0154428622, 0.0276282653, -0.0033593881, 0.0057249861, 0.0091468841, -0.0142687820, -0.0322616249, 0.0158274714, -0.0032127160, -0.0237461589, 0.0307199787, -0.0340141356, -0.0104014492, -0.0068243565, -0.0048593362, -0.0028297671, -0.0000001390, 0.0145948594, 0.0047860336, 0.0036209333, 0.0001369975, -0.0101352176, -0.0077172020, 0.0046955678, -0.0133896181, 0.0008783262, 0.0047182082, 0.0299730916, -0.0015317545, -0.0056343949, -0.0118328696, -0.0178083368, 0.0001255032, 0.0131766135, -0.0123276571, -0.0029146106, 0.0028652053, 0.0337584876, -0.0003617434, -0.0254167560, -0.0173036736, 0.0023179855, -0.0028792531, 0.0039064889, 0.0140426857, -0.0091669476, 0.0076494147, 0.0015183151, 0.0034995617, -0.0016008398, -0.0042709997, 0.0324970931, 0.0024070546, -0.0258664414, -0.0009278324, 0.0077275806, -0.0196332783, 0.0131295063, 0.0087741120, 0.0150498161, -0.0336113609, -0.0373361930, 0.0256676152, 0.0000039129, -0.0052358983, 0.0314627439, 0.0254358556, -0.0111752506, -0.0028828296, -0.0008167484, -0.0165928528, -0.0212679412, 0.0000084793, -0.0371779874, 0.0254322384, 0.0349423699, 0.0093655288, 0.0018315844, 0.0019214872, -0.0273284502, 0.0000001008, 0.0084738610, -0.0043776440, -0.0370224863, 0.0029223161, -0.0008032743, 0.0065656928, -0.0181898829, -0.0057166619, 0.0039005631, 0.0270317812, -0.0150353312, -0.0072938395, -0.0178453326, 0.0082384944, 0.0030093298, 0.0090744225, -0.0025910446, -0.0316803642, 0.0126754222, 0.0094778445, 0.0076504536, 0.0000029531, 0.0121149365, 0.0208423734, 0.0110371271, -0.0219808668, 0.0020607971, 0.0008848592, -0.0066625425, 0.0168744884, -0.0088829268, 0.0188879557, 0.0014803398, 0.0186399259, -0.0027994097, -0.0136612887, -0.0290601980, -0.0111037707, -0.0030194665, -0.0293236263, 0.0255135465, -0.0074482402, -0.0287225340, 0.0087079918, -0.0102236345, -0.0012861455, 0.0010456641, 0.0169654042, 0.0077532507, 0.0241446495, -0.0047291443, 0.0010838872, 0.0106677292, 0.0033395896, -0.0031652634, 0.0001203274, -0.0212098416, -0.0313454047, -0.0213525929, -0.0125880605, -0.0004902008, -0.0057801297, -0.0189062580, -0.0000130831, -0.0012395207, -0.0200024918, 0.0067762989, -0.0000930096, -0.0096476981, 0.0382900015, 0.0247271340, 0.0024311657, -0.0092469975, 0.0063071549, -0.0071232389, 0.0090266569, 0.0010672457, 0.0002378860, -0.0079546617, -0.0001912058, -0.0237681363, -0.0067622950, -0.0096212616, 0.0160670653, 0.0512280874, -0.0002011241, -0.0042756186, -0.0206477512, 0.0010191450, 0.0019469331, -0.0035462214, 0.0248540081, -0.0183176994, 0.0205753837, -0.0165822096, -0.0119872242, -0.0150643149, -0.0008009749, 0.0259995628, 0.0306551624, 0.0005867377, -0.0270734783, 0.0288734771, -0.0255352221, -0.0162955243, 0.0072905575, 0.0282228887, -0.0127734672, -0.0291411839, -0.0170863699, -0.0000252665, -0.0001939400, -0.0021742275, 0.0347191431, -0.0003492029, 0.0115315989, 0.0097101638, -0.0084732249, -0.0048260964, -0.0000025157, -0.0212091431, -0.0018143358, 0.0057520228, 0.0101540564, -0.0006720203, -0.0032788343, -0.0153589118, 0.0000000073, -0.0195949133, -0.0158694871, -0.0142811313, 0.0000103548, 0.0072259088, 0.0285746660, 0.0252781287, -0.0176813956, -0.0162102673, 0.0098833367, 0.0078124302, -0.0166097619, 0.0006615935, 0.0071024299, -0.0322762616, 0.0143906726, -0.0251666028, -0.0128468070, -0.0150286332, 0.0018594355, 0.0062026465, 0.0000043484, -0.0042113597, 0.0094891721, -0.0103273205, -0.0036109341, -0.0091842609, 0.0016486603, -0.0086113568, 0.0149447611, -0.0269664489, -0.0327698626, -0.0093920808, -0.0384154096, 0.0107158870, -0.0160898026, 0.0151692210, -0.0263559688, 0.0450142883, 0.0115014808, -0.0031735047, 0.0094232634, 0.0455207080, 0.0104644168, 0.0101647405, 0.0172212701, 0.0000042438, -0.0273256414, -0.0081502143, -0.0334532000, 0.0012618443, 0.0082441829, 0.0068868194, 0.0358767696, -0.0100041861, -0.0003037787, -0.0057493513, 0.0134501411, 0.0046355310, 0.0174892079, -0.0007121338, 0.0022113365, -0.0069993436, -0.0000149362, 0.0053470461, -0.0112187006, 0.0210021306, 0.0014329287, -0.0210814457, 0.0102209430, -0.0229775570, 0.0060640043, 0.0104793841, -0.0082834819, -0.0296965726, 0.0005069235, 0.0202126484, 0.0062092729, 0.0148715796, -0.0097760689, 0.0324091054, -0.0140503626, 0.0006760010, -0.0226138067, -0.0284464136, -0.0000034604, -0.0055740294, 0.0087920045, -0.0072262860, 0.0249353461, -0.0108732227, 0.0042134146, 0.0052982569, 0.0031647088, -0.0089195026, 0.0302476455, 0.0025274197, -0.0055813622, -0.0170284156, 0.0312892385, -0.0288531911, 0.0129940314, 0.0088516390, 0.0157123525, -0.0035361068, -0.0155828679, -0.0331823565, -0.0251524337, 0.0226283483, -0.0058578346, -0.0000821549, -0.0007817330, -0.0640736595, -0.0037480895, -0.0365779921, 0.0195772722, -0.0258053187, 0.0010259209, 0.0256711189, 0.0003523476, 0.0494052060, -0.0363163799, -0.0078017060, -0.0192960687, 0.0161927342, -0.0087908786, 0.0116582951, -0.0000001303, -0.0111022936, -0.0342695005, -0.0153021123, -0.0039663860, -0.0000764549, 0.0274686459, 0.0155757833, -0.0100419680, -0.0082827760, -0.0110532995, -0.0227746479, 0.0312573463, -0.0004135516, 0.0014646508, 0.0278700292, 0.0184021406, 0.0126132127, 0.0267769527, 0.0203995816, -0.0102251479, -0.0088186022, -0.0000111744, 0.0304167364, 0.0215271506, 0.0424904488, -0.0189376306, -0.0039983769, -0.0012378751, -0.0165843144, 0.0223793294, 0.0091758091, 0.0130549828, -0.0097063603, 0.0207249448, 0.0089610722, -0.0134960636, 0.0143229710, 0.0141128749, -0.0132365618, 0.0173688121, -0.0171644147, 0.0007883419, -0.0007826482, 0.0262933429, 0.0157739557, -0.0027475201, 0.0000004760, 0.0030310906, 0.0104725696, 0.0025376000, 0.0083804354, 0.0089254342, -0.0002349010, 0.0033850423, -0.0103198718, -0.0000002157, -0.0032675175, 0.0098298872, -0.0066922442, 0.0076818727, 0.0142918695, -0.0023715387, 0.0032998521, -0.0000000184, -0.0018099841, -0.0146662910, -0.0231869034, 0.0008118025, 0.0006726909, 0.0332830548, 0.0133610675, -0.0107199783, 0.0175161399, 0.0044755265, 0.0054153749, 0.0042332616, 0.0033073192, 0.0216976386, 0.0032075867, -0.0033710327, -0.0213055108, -0.0018013307, 0.0018664439, -0.0059389672, -0.0086200805, -0.0000077704, -0.0292221084, -0.0099434434, -0.0154938828, 0.0171196777, -0.0006692188, -0.0082539339, -0.0025204211, 0.0234116670, -0.0196260028, -0.0052771596, 0.0000445729, -0.0127282590, 0.0034959316, 0.0208876859, -0.0023080111, -0.0024674956, -0.0004930428, -0.0060798838, -0.0132125169, 0.0151559534, -0.0165224057, -0.0016890257, -0.0012537905, 0.0340698138, -0.0016121141, 0.0056634354, -0.0219949316, 0.0102377115, -0.0054874951, 0.0162897706, 0.0173669886, -0.0212408472, 0.0048090005, 0.0001861213, 0.0134229390, -0.0322768576, -0.0276267454, 0.0378054120, -0.0043178112, -0.0108051654, -0.0197975114, -0.0000365823, -0.0150175197, -0.0021122047, 0.0470172986, -0.0089170253, -0.0321494229, 0.0105913887, -0.0059746387, -0.0402424522, 0.0001782160, -0.0182722099, -0.0020639272, -0.0071048238, 0.0095109418, -0.0165349469, 0.0161732677, -0.0054601138, -0.0181872938, -0.0563737005, 0.0365514830, -0.0120348055, 0.0223955605, -0.0002088000, 0.0232251752, -0.0089511322, -0.0051932144, -0.0083447341, 0.0013717066, 0.0131695997, -0.0048702871, 0.0129568363, -0.0238781013, -0.0205981769, -0.0043217246, 0.0033202665, 0.0121457763, 0.0073389318, -0.0203671847, 0.0251897611, 0.0504077971, 0.0316669159, 0.0553594865, -0.0211788323, -0.0087091401, 0.0099460594, 0.0269804243, -0.0056466754, 0.0002641235, 0.0319605023, -0.0194730386, 0.0133925015, -0.0124316178, -0.0157617591, 0.0204493925, -0.0083027389, 0.0160124246, 0.0002385923, -0.0438707843, 0.0235831253, 0.0018681828, 0.0131829847, 0.0010117742, -0.0100116981, -0.0080077965, -0.0000001036, -0.0109413620, -0.0156690255, -0.0175216049, 0.0005548758, 0.0118149640, 0.0050397548, 0.0017463169, 0.0140725868, 0.0101259816, 0.0215620026, -0.0248829853, -0.0250203423, 0.0031842748, -0.0225803796, -0.0328742452, 0.0076743453, -0.0240276344, 0.0004063535, -0.0023891518, 0.0173551850, -0.0039075930, -0.0000717474, 0.0105801830, -0.0125747556, -0.0214587785, 0.0306200776, 0.0006091584, 0.0343163870, 0.0109941149, 0.0068930029, -0.0118130390, 0.0286567304, 0.0009744687, 0.0237691905, 0.0291159898, 0.0112728886, 0.0027811981, -0.0186338369, -0.0247074105, 0.0080153896, 0.0544110686, 0.0170456897, -0.0122802677, 0.0185928512, 0.0420658439, 0.0233860128, 0.0000126099, -0.0269216858, -0.0151492143, -0.0371180736, -0.0097638564, -0.0126965204, 0.0222025774, -0.0600478277, -0.0319780521, 0.0000710695, -0.0173866805, 0.0152402120, -0.0252434891, 0.0176441632, 0.0095353713, -0.0032564187, 0.0389734320, 0.0000000677, 0.0235616155, 0.0280054454, 0.0249189176, 0.0009420178, 0.0037696916, -0.0398388915, 0.0141383354, -0.0109040998, -0.0301377662, -0.0020713534, 0.0162072070, 0.0111487908, -0.0026642159, -0.0205752663, -0.0035166682, 0.0352429077, -0.0277381912, -0.0051526190, 0.0164354276, 0.0430133715, 0.0045258082, 0.0000064632, 0.0258425679, 0.0674244091, -0.0043335888, 0.0061297761, 0.0048537222, -0.0025346687, -0.0033079886, 0.0034233544, -0.0094301356, -0.0046347594, -0.0010193805, 0.0070177568, -0.0070387712, -0.0045193001, -0.0465298854, 0.0124858171, 0.0037081628, 0.0252081286, 0.0288028084, 0.0162243247, 0.0148772933, -0.0240276717, -0.0084716640, -0.0023272624, -0.0001118793, 0.0327155851, -0.0086171431, 0.0026504253, -0.0681926906, 0.0024134412, 0.0029450841, 0.0015291828, 0.0194786489, -0.0000001816, 0.0028307962, -0.0170167014, -0.0105836764, -0.0122351758, -0.0393009894, -0.0087428009, -0.0236638803, -0.0000001602, -0.0065167649, -0.0197558682, 0.0100662466, 0.0016155723, -0.0055177510, -0.0050099194, 0.0039611529, -0.0161278974, 0.0075703668, -0.0029518448, -0.0164414998, -0.0073622293, 0.0103576295, -0.0223525017, 0.0190295037, -0.0111804195, 0.0271426514, -0.0040478618, -0.0084687360, 0.0087124566, -0.0223862492, -0.0000895272, 0.0164128542, -0.0167880636, 0.0032766126, -0.0019321938, -0.0040700827, 0.0074084559, -0.0106026940, 0.0074199303, -0.0037517676, 0.0092121325, -0.0028471148, 0.0211802796, 0.0218700320, 0.0243478399, 0.0082617952, -0.0136753414, -0.0137274386, 0.0118217710, 0.0158189777, -0.0274886582, 0.0181469284, 0.0296909306, -0.0118625639, 0.0076672821, -0.0000485873, -0.0614751391, 0.0172064137, 0.0420053229, 0.0059986692, 0.0055466192, -0.0136383446, -0.0377654471, 0.0205148645, -0.0005132774, -0.0303212889, 0.0232100282, -0.0121449279, 0.0038746807, 0.0024168198, -0.0020378805, 0.0460189842, -0.0000001089, 0.0091767358, 0.0113916332, -0.0403251499, -0.0051275631, -0.0087565146, 0.0136713870, -0.0235891044, -0.0093140211, 0.0152093600, 0.0217695963, 0.0105815129, -0.0175309498, 0.0014474672, -0.0251289271, 0.0532634556, 0.0060190614, -0.0341047682, -0.0021402414, 0.0261971448, 0.0236109458, -0.0341379419, 0.0000858483, -0.0122337835, -0.0031222401, 0.0474249348, 0.0019627202, 0.0060866713, -0.0142683452, -0.0126946736, -0.0135907400, 0.0093606766, 0.0436965898, -0.0036553468, 0.0064615412, 0.0016345325, 0.0086261537, -0.0329307951, -0.0166870598, -0.0188787710, -0.0116112633, 0.0379017182, 0.0134130158, -0.0322065726, -0.0019607083, 0.0384761952, -0.0103993248, -0.0004390494, -0.0240126401, -0.0648055077, 0.0223123208, -0.0360984690, 0.0171341356, 0.0110469498, 0.0116719939, 0.0029870819, -0.0000866548, 0.0184831806, -0.0359095335, -0.0571565628, 0.0044084145, -0.0081777479, -0.0088551892, 0.0207630973, 0.0000002793, -0.0026424439, 0.0083020469, 0.0059655891, -0.0002555943, -0.0004906861, 0.0025157912, 0.0014920924, -0.0035843751, 0.0077073285, 0.0021557650, 0.0172471181, -0.0046276501, 0.0052691605, -0.0037068238, 0.0109852487, -0.0036480296, -0.0187000073, -0.0266032536, 0.0085151326, -0.0134700499, 0.0267805923, 0.0000675009, -0.0069453013, 0.0152316689, -0.0101044280, 0.0137558775, 0.0015753090, 0.0041861036, -0.0144008836, 0.0144324601, -0.0233332533, -0.0023082478, -0.0033038920, 0.0007104311, -0.0009658301, 0.0296745114, -0.0147150075, -0.0106633417, 0.0118675688, 0.0245049130, 0.0492654331, -0.0091779940, 0.0002709411, 0.0041143424, 0.0273938756, -0.0101637924, -0.0000036839, 0.0206472855, -0.0035585065, -0.0260702949, -0.0192898922, 0.0118672810, -0.0006384582, 0.0065144650, 0.0105010411, -0.0007430443, 0.0160276219, -0.0286227576, -0.0374452882, -0.0078662364, -0.0167681985, 0.0045223520, -0.0024233458, 0.0000000393, -0.0066538770, -0.0158464443, 0.0042100428, -0.0103070624, 0.0022877424, 0.0293785408, 0.0321296491, 0.0265173484, -0.0475736596, 0.0108126868, -0.0210970715, 0.0038151196, 0.0060395706, 0.0217317790, 0.0210882165, 0.0066686613, -0.0273789335, 0.0040785754, 0.0106264018, 0.0159259960, 0.0405687392, -0.0001149129, -0.0018633766, 0.0089229094, -0.0532028675, -0.0080507984, -0.0170302317, 0.0025825039, -0.0234984253, -0.0079016378, -0.0201279055, -0.0246528555, -0.0027040099, 0.0120300939, 0.0211464074, -0.0249757282, 0.0416874960, 0.0063877013, -0.0207945593, 0.0093065780, 0.0037272114, -0.0295740906, 0.0484084599, 0.0018193665, 0.0254123453, 0.0164058618, -0.0004272122, 0.0351207554, -0.0057436316, 0.0308971070, 0.0095679220, 0.0032938533, -0.0067892782, -0.0174992196, -0.0016072475, -0.0000008028, -0.0164928790, -0.0099201761, -0.0182635970, -0.0225211121, 0.0004904553, -0.0027236580, -0.0010644773, 0.0000005771, 0.0024607363, -0.0207125898, 0.0357148796, 0.0000359763, -0.0050080619, 0.0309631228, -0.0145565392, 0.0048929187, 0.0140371202, 0.0069061392, -0.0225833934, 0.0039321887, -0.0267255902, 0.0619092882, 0.0340740606, 0.0207051728, -0.0043343771, -0.0279656686, -0.0020001507, 0.0075244061, 0.0150116682, -0.0004495946, -0.0147502143, 0.0069141095, -0.0571667366, 0.0025501458, -0.0044102431, 0.0140121775, -0.0145885050, 0.0256844722, -0.0038469590, 0.0056654178, -0.0018438041, 0.0316788405, 0.0640522167, 0.0560048074, 0.0464051738, 0.0253613684, -0.0382678658, 0.0128410533, 0.0049692886, 0.0068998514, -0.0170980208, 0.0085618328, 0.0298481509, -0.0027046197, -0.0000008563, 0.0239913445, -0.0277148541, 0.0031931500, -0.0201875810, 0.0139357159, -0.0111563271, -0.0077207419, -0.0116363056, 0.0000101079, -0.0158766415, -0.0106877908, 0.0075191259, 0.0429595895, 0.0045964937, -0.0068852459, -0.0010328167, 0.0000001244, -0.0047885752, -0.0231418330, -0.0398459062, 0.0002733381, 0.0270968322, 0.0246964507, -0.0018812323, 0.0106636761, -0.0078880806, 0.0145060336, -0.0163043942, 0.0288239345, 0.0018065942, 0.0285603460, -0.0458299257, 0.0220196452, 0.0093132816, -0.0283499733, -0.0151260626, -0.0201656763, 0.0303437952, -0.0000064627, 0.0075503155, 0.0242744330, -0.0327353887, -0.0320552886, -0.0074620401, 0.0110097006, -0.0224383064, 0.0111244144, -0.0134378020, 0.0056040771, 0.0010133015, 0.0273424536, 0.0432467982, -0.0098258629, 0.0240920186, 0.0084789926, -0.0469334871, 0.0294928700, -0.0130683864, -0.0085982624, -0.0030066380, -0.0270730779, -0.0536555313, -0.0442081653, 0.0000558795, -0.0206333790, -0.0409261137, 0.0204836857, -0.0298718028, 0.0004444600, -0.0062886067, 0.0011174558, -0.0112311775, 0.0000889095, 0.0257704854, -0.0111226263, 0.0101125995, -0.0229801480, -0.0180595256, 0.0051130536, -0.0023080593, -0.0000009197, -0.0021608770, 0.0204803105, 0.0052684383, 0.0004303545, -0.0001370650, -0.0417262316, -0.0050591226, -0.0058977483, 0.0183158237, -0.0505696721, 0.0222846754, 0.0026716620, 0.0179917626, -0.0320485719, -0.0136345178, -0.0187704880, 0.0218754578, 0.0255288891, -0.0140575254, -0.0025789274, -0.0299197212, 0.0000120420, 0.0084788408, -0.0072741956, 0.0746038184, 0.0000933685, 0.0035502943, -0.0094856219, 0.0329945534, 0.0205930304, -0.0014744995, 0.0152737359, 0.0038463904, -0.0434942618, -0.0470257737, 0.0158786718, 0.0176653825, -0.0192573257, 0.0673069581, -0.0087651927, -0.0336845778, -0.0108315740, 0.0678066537, 0.0025058535, 0.0341085196, 0.0228272565, -0.0000250214, 0.0134769911, -0.0017864172, -0.0215298347, 0.0082474556, 0.0128158163, -0.0007922591, -0.0384551249, -0.0147453649, -0.0000239379, -0.0315302387, 0.0103012677, 0.0140071008, 0.0029455321, 0.0080863088, -0.0057476563, 0.0122511443, 0.0000007231, -0.0031257842, -0.0207130052, -0.0057804864, -0.0001579649, 0.0104323691, 0.0224721842, 0.0016494669, -0.0052851308, -0.0204439908, 0.0272236187, -0.0063813413, 0.0105871269, -0.0069493935, 0.0203082561, -0.0022298344, 0.0274253227, -0.0140276896, -0.0178263076, 0.0116940755, 0.0138357561, 0.0389514901, -0.0000064262, 0.0325259753, 0.0107573746, -0.0243988186, -0.0013912792, -0.0070039104, 0.0128428694, -0.0209544599, 0.0094222873, -0.0262265503, -0.0161164775, -0.0070939399, 0.0064656115, 0.0202441402, -0.0218283776, 0.0160876457, 0.0068218713, -0.0236076638, 0.0358143859, 0.0135347024, 0.0044389470, -0.0008441068, 0.0162981078, 0.0102671478, -0.0773912072, -0.0015174467, -0.0457349159, -0.0101059042, 0.0259356741, -0.0270960815, -0.0120617356, -0.0086021842, 0.0254619457, 0.0047491244, -0.0003410048, 0.0261709373, -0.0294551942, -0.0197011754, 0.0216028597, -0.0056258249, -0.0024072775, 0.0167357195, 0.0000000157, 0.0104205217, -0.0373905748, -0.0559296682, -0.0000549036, 0.0149203558, 0.0162097625, 0.0040562921, 0.0131786782, 0.0095194373, 0.0239431467, 0.0027017558, 0.0191482473, 0.0114550693, -0.0022532274, -0.0153523199, -0.0303936470, -0.0315241255, 0.0135086263, 0.0150419697, 0.0092429845, -0.0188561659, -0.0001436359, -0.0303421970, 0.0037382422, 0.0224873815, 0.0042572282, 0.0005747179, -0.0076723509, 0.0054501169, -0.0283494610, -0.0082432842, 0.0067366045, -0.0048979633, 0.0343078114, 0.0186113715, 0.0213857666, -0.0022110727, -0.0512116104, -0.0048258989, -0.0116243027, 0.0213598944, -0.0302733760, -0.0335755497, -0.0468141697, 0.0168056507, 0.0262430143, 0.0000014881, -0.0092599839, -0.0144415051, -0.0088278595, -0.0074267415, 0.0308299344, 0.0104469601, -0.0284406673, 0.0091032796, -0.0004528108, -0.0090903407, -0.0038703706, 0.0142163588, -0.0075986153, -0.0187047198, 0.0062107830, 0.0083002634, 0.0000001133, 0.0071561481, 0.0104705691, 0.0582081787, 0.0006680884, 0.0039939322, 0.0009825904, -0.0053156791, 0.0046471027, -0.0117272185, -0.0030113717, 0.0007392621, -0.0364016220, -0.0020845467, -0.0103298966, 0.0460974760, -0.0110662859, -0.0120075643, -0.0039521437, -0.0009036538, 0.0470260307, -0.0185204335, 0.0000077150, 0.0115354639, 0.0265832171, -0.0143039441, 0.0045129326, 0.0031356248, -0.0031944402, 0.0029291811, 0.0010933457, -0.0234498046, -0.0009456112, 0.0022667896, 0.0147223538, 0.0046904087, 0.0308674537, -0.0258304104, 0.0088456590, -0.0102425572, 0.0402816199, 0.0248703863, -0.0136569384, -0.0136093013, -0.0274928473, -0.0189451464, -0.0022844635, 0.0000802380, -0.0177179594, -0.0203279685, 0.0226512682, -0.0192394666, 0.0118369209, 0.0032515537, -0.0009575781, -0.0021014069, 0.0000798157, 0.0343590938, -0.0329113677, -0.0467811525, 0.0135346483, 0.0182928797, 0.0074650198, -0.0178854577, -0.0000002859, 0.0050522098, -0.0301690288, -0.0373100974, -0.0009753063, 0.0034431047, 0.0240877643, 0.0344165675, 0.0000325839, -0.0157920197, -0.0186934359, 0.0026371903, 0.0157690123, 0.0005135919, 0.0264047757, 0.0077626510, -0.0076668714, 0.0137987090, -0.0099697066, 0.0208997652, -0.0104452977, 0.0258894935, -0.0001264709, -0.0227992628, 0.0400925539, -0.0246401653, -0.0208464991, 0.0005896249, -0.0160437524, -0.0172497239, -0.0073196474, 0.0055602225, -0.0137761934, -0.0059847832, 0.0170363858, -0.0083752451, -0.0141086988, 0.0213361979, -0.0147102010, 0.0239862483, -0.0017264838, 0.0059918850, -0.0031496000, 0.0286956672, -0.0119857509, 0.0000579172, -0.0445442833, 0.0000030869, -0.0054185884, -0.0131051829, -0.0210793708, -0.0207079537, -0.0087034795, 0.0180247482, -0.0019656480, -0.0030025549, 0.0000135643, -0.0099666798, -0.0269260313, 0.0210312791, -0.0257697720, -0.0481835343, 0.0049440195, -0.0190432668, 0.0000000800, -0.0002916564, 0.0193888005, -0.0116119552, 0.0017318706, 0.0179974511, -0.0652284920, -0.0138447369, 0.0125641497, 0.0296705645, -0.0197292697, -0.0006487216, 0.0063001709, 0.0023239893, -0.0597069785, -0.0261431355, 0.0104651824, 0.0239289086, 0.0061735446, -0.0126334652, 0.0075921007, -0.0368636027, -0.0000000727, -0.0120847803, -0.0038681228, 0.0449219383, 0.0330515653, -0.0010587621, 0.0153077226, 0.0010915628, -0.0064951587, -0.0226036832, 0.0501879975, 0.0021050570, 0.0033307422, 0.0327996463, 0.0426310562, -0.0132243680, -0.0601523444, -0.0254220068, -0.0051571107, 0.0202563759, -0.0123119326, 0.0917032808, 0.0286632068, -0.0018716981, 0.0023504416, -0.0001881339, 0.0040692082, 0.0186789893, -0.0070676701, 0.0418626182, -0.0077449558, -0.0161797572, -0.0048706830, -0.0224508978, -0.0003739155, -0.0330621824, 0.0520870984, 0.0213106703, -0.0139155453, 0.0462833680, -0.0137616228, -0.0044319858, -0.0000005100, -0.0140374685, -0.0046638227, -0.0587766059, -0.0034426819, -0.0018023112, 0.0563777946, 0.0234156344, -0.0094629098, 0.0116725629, 0.0180404298, -0.0212804209, 0.0063785068, 0.0005881025, 0.0196030345, -0.0277220625, 0.0048439899, 0.0043560611, 0.0053872080, 0.0224676449, -0.0170040056, 0.0052859117, -0.0000512782, -0.0162122343, -0.0271376353, -0.0111547634, 0.0054082256, -0.0008778722, 0.0063990303, 0.0069451253, 0.0302347075, -0.0045905700, 0.0138237961, 0.0016731548, 0.0375745781, -0.0000941568, -0.0111815175, 0.0000619146, -0.0084277065, -0.0155740203, 0.0052332687, -0.0338190868, 0.0437699892, -0.0047724498, 0.0347736552, 0.0126951374, 0.0046041091, -0.0001340364, 0.0012771965, 0.0030578759, -0.0051250462, 0.0072480505, -0.0145532740, -0.0042461166, 0.0018285768, 0.0188611932, -0.0015577219, -0.0080401395, 0.0176476780, -0.0398300663, -0.0094366083, 0.0065940078, -0.0130579779, 0.0068942560, -0.0000031961, 0.0254654344, 0.0415808037, 0.0202859212, 0.0000311167, -0.0208853371, 0.0208598971, -0.0052048001, 0.0016964113, -0.0085242996, 0.0144677423, 0.0334231667, 0.0070848828, -0.0044506863, -0.0041112551, -0.0116914622, -0.0067136395, -0.0190573931, 0.0243230015, -0.0040128366, 0.0245174374, 0.0361529514, -0.0004882574, -0.0354211070, -0.0035503814, -0.0238132663, -0.0186997205, -0.0003121718, 0.0073956135, 0.0017961445, 0.0034661957, -0.0040157121, -0.0100558978, 0.0025602588, 0.0126794502, -0.0107512036, 0.0199391320, 0.0002332133, 0.0328393541, 0.0071858289, -0.0375776626, -0.0241656769, 0.0152963521, 0.0232289881, -0.0260247234, 0.0087709073, 0.0329818986, -0.0000002161, -0.0095842201, -0.0243736096, -0.0056960024, -0.0651166588, 0.0231456403, -0.0265206732, -0.0032615846, 0.0269779675, -0.0002028280, 0.0162927266, -0.0752563626, 0.0030288394, 0.0265796278, 0.0189370923, -0.0007037638, -0.0097851921, -0.0000000551, 0.0032550928, -0.0512064733, 0.0336240791, 0.0003822603, -0.0058357175, 0.0097734034, -0.0074633728, 0.0161134191, -0.0081796572, 0.0072996900, -0.0377970785, 0.0087639131, 0.0156564526, 0.0043183300, 0.0160153657, -0.0199076887, -0.0074103423, -0.0132829361, 0.0072266995, 0.0178025384, -0.0118016256, -0.0000258589, 0.0094140116, 0.0341525599, -0.0353889354, 0.0065772813, -0.0006129342, -0.0071500153, -0.0126173636, 0.0130286980, -0.0143137882, 0.0043363082, -0.0032702330, 0.0082570519, -0.0185177121, 0.0490851402, -0.0083587272, 0.0040526926, 0.0192907713, 0.0129198274, 0.0099532912, -0.0391472839, -0.0336074047, -0.0035588907, -0.0029267613, 0.0184953175, -0.0000124009, -0.0072303419, -0.0157152843, -0.0076364162, -0.0159768816, 0.0255469698, -0.0066987076, -0.0030979307, -0.0092250602, -0.0000170360, -0.0133708036, -0.0187170431, -0.0235347711, 0.0278831888, 0.0192527268, 0.0009578804, -0.0116279796, 0.0000002470, -0.0107377898, -0.0095120128, 0.0054275389, -0.0006625972, 0.0036103269, 0.0076816697, 0.0077295261, -0.0073866262, -0.0177867562, -0.0060658725, -0.0050267247, 0.0021678938, 0.0243078806, 0.0185578708, -0.0270807967, 0.0051302388, -0.0320306495, -0.0276439153, -0.0001430056, -0.0148602426, 0.0226486605, 0.0000006307, 0.0135223242, 0.0082284175, -0.0253428500, -0.0081725232, 0.0007735540, 0.0018612914, -0.0061950055, 0.0170854684, 0.0000763609, -0.0275211744, 0.0002241672, 0.0024671967, -0.0076178377, 0.0081771575, -0.0135016413, -0.0118967239, 0.0321502686, 0.0230862126, 0.0003759864, -0.0180642717, 0.0038616662, 0.0420541503, -0.0237043351, -0.0139304446, 0.0000079429, -0.0184001960, 0.0182523299, -0.0405696742, 0.0113999490, -0.0206548832, 0.0052468097, 0.0103560528, -0.0317715444, -0.0021633655, -0.0206728000, 0.0208010189, 0.0120163551, -0.0192044079, 0.0314889178, 0.0080691138, 0.0178054329, -0.0000009163, -0.0005762906, 0.0042345207, 0.0251949485, -0.0029443661, -0.0104741612, 0.0187886991, -0.0251703057, 0.0078655444, -0.0030532724, -0.0072818589, 0.0070702150, -0.0064735189, 0.0041321572, 0.0405950248, -0.0039791451, 0.0123789916, 0.0086851744, 0.0147135202, -0.0104987100, -0.0178306922, -0.0132266348, -0.0000383811, -0.0248022936, 0.0299808085, -0.0227165651, 0.0244737621, -0.0096238982, 0.0068126805, 0.0119853336, 0.0032356610, -0.0202972051, -0.0297626164, 0.0057376148, -0.0220364183, -0.0025502651, 0.0155315883, 0.0002817257, 0.0163947754, 0.0222584140, -0.0213061403, -0.0401578806, 0.0013227090, 0.0317738503, -0.0020502410, -0.0176909566, -0.0060398574, 0.0000010563, -0.0166419614, 0.0267823674, -0.0070935064, -0.0027304101, 0.0001051867, 0.0034903181, -0.0080814883, -0.0162348226, -0.0000004517, 0.0053456621, 0.0108152069, 0.0037820239, 0.0090135867, -0.0193550289, 0.0021184552, 0.0039959010, -0.0000004484, -0.0157474317, -0.0023588305, 0.0339156911, -0.0035642451, 0.0122977896, -0.0215379428, -0.0154789481, 0.0265907440, -0.0019480820, 0.0142852878, 0.0176549237, 0.0014193227, -0.0001500208, 0.0096472166, -0.0303662159, 0.0073657599, 0.0011860969, 0.0205492266, -0.0056634634, 0.0090845423, -0.0011644927, -0.0000102156, 0.0262146275, -0.0043283575, 0.0302096326, 0.0040877918, 0.0012147118, -0.0130477250, -0.0082351519, -0.0143635683, -0.0066968482, -0.0166339241, 0.0008927713, -0.0405679271, -0.0269309934, -0.0241691545, 0.0133516779, -0.0221664924, 0.0284537505, 0.0290377438, -0.0085638613, -0.0318917260, 0.0322287008, 0.0002288854, -0.0064369603, 0.0236965902, 0.0000075161, 0.0131711010, -0.0055846511, -0.0015848759, 0.0085284896, 0.0218372550, -0.0137251308, -0.0056265225, -0.0030015195, -0.0001052540, 0.0047725947, 0.0047618472, 0.0113625359, 0.0018444781, 0.0109702535, -0.0012687254, -0.0250047408, -0.0000000268, -0.0154826120, -0.0276497472, -0.0030836363, -0.0010493187, 0.0034448116, 0.0375495963, 0.0146121904, -0.0096624875, -0.0064405403, -0.0141059775, -0.0330375955, 0.0016823435, -0.0025211384, -0.0004568914, -0.0062912083, 0.0144009041, 0.0082992520, -0.0171544440, 0.0031983992, -0.0436169952, -0.0131356576, -0.0000010067, 0.0105746090, -0.0110614663, -0.0037074527, -0.0106235323, -0.0075043053, -0.0024953419, -0.0026424788, 0.0008929094, -0.0184013508, 0.0160014816, -0.0109253218, 0.0062202001, 0.0146768568, 0.0116823670, 0.0057938001, -0.0184309930, 0.0091350423, 0.0195177160, -0.0147303566, 0.0109697478, -0.0143394973, 0.0201744083, 0.0092265233, 0.0000517854, 0.0000009991, -0.0121413833, 0.0112363501, -0.0284230448, 0.0225191340, -0.0165539682, -0.0024314704, 0.0037860675, -0.0319316573, -0.0001399310, -0.0130031137, 0.0430013277, 0.0457028262, -0.0103012146, 0.0379143059, -0.0026466807, 0.0057440656, -0.0000007634, -0.0082337065, -0.0132552357, -0.0118720671, -0.0098344721, -0.0067090690, 0.0241342783, 0.0184138846, -0.0012263518, -0.0017189591, 0.0009373254, -0.0116506871, -0.0078204805, -0.0091517065, 0.0298901182, -0.0202910472, 0.0126262223, 0.0224640965, -0.0007059146, 0.0061469777, -0.0291262306, -0.0420744196, -0.0000725825, 0.0229236875, 0.0175914764, -0.0089169210, 0.0271219984, -0.0097195813, 0.0185210556, 0.0175554752, 0.0095363166, 0.0080063688, -0.0033047213, 0.0001864729, 0.0174452402, -0.0189425293, 0.0226443969, -0.0047301129, 0.0106498329, -0.0034601158, 0.0429429375, -0.0528176166, 0.0041541606, 0.0046255770, 0.0131172230, 0.0305669419, -0.0126362480, -0.0000425566, -0.0080825603, 0.0130609991, 0.0200881045, 0.0097339433, -0.0043289424, -0.0158589613, -0.0039375070, -0.0062676603, -0.0001367869, 0.0097671291, 0.0226446278, -0.0103000188, 0.0063892026, 0.0215248968, 0.0004697109, 0.0104428120, 0.0000000058, 0.0044903210, -0.0429710671, -0.0770948902, -0.0009727477, -0.0091713099, 0.0173315685, 0.0254275333, 0.0294561125, -0.0090570170, 0.0308492854, -0.0429459587, 0.0344573781, -0.0053237388, 0.0146496566, 0.0155961914, -0.0187515114, -0.0005827618, 0.0299991407, 0.0084121907, -0.0071723973, 0.0344657078, -0.0000075725, -0.0096851336, -0.0006549377, 0.0259688329, 0.0070117647, -0.0015842984, 0.0126322899, -0.0173156727, -0.0034762344, 0.0123464409, 0.0419859625, -0.0000789615, 0.0098505318, 0.0002924517, -0.0194236282, -0.0021827784, 0.0115784202, -0.0428674333, -0.0216065720, 0.0169706792, 0.0068194494, -0.0429557785, 0.0170390531, 0.0552612022, 0.0094866026, -0.0000554105, 0.0148414578, -0.0039913864, -0.0598012544, -0.0284073800, 0.0134956082, -0.0014546519, -0.0292058606, -0.0149915190, 0.0000048426, 0.0050712498, 0.0301455855, 0.0365025327, -0.0059450441, -0.0649391189, -0.0029131032, 0.0307633542, 0.0000003979, 0.0321265347, 0.0137924785, 0.0153644932, 0.0005537353, -0.0229247902, -0.0022577927, -0.0407582298, -0.0120214242, 0.0011891820, 0.0033476609, -0.0067748460, -0.0118372990, 0.0157642886, 0.0016482279, 0.0793045238, -0.0073521957, 0.0169125069, 0.0220540930, -0.0271702446, 0.0698692277, 0.0608785599, 0.0000218849, -0.0279172584, -0.0178380050, -0.0027387957, -0.0247648936, 0.0024455281, -0.0010738291, -0.0133176493, 0.0297385789, -0.0103897955, 0.0103595555, 0.0067403060, 0.0046644001, 0.0056886077, 0.0112364795, 0.0043307752, 0.0665291399, -0.0464867502, -0.0079961708, 0.0252537411, -0.0322977826, -0.0299341455, -0.0081363330, -0.0130418735, -0.0071346411, 0.0002564477, -0.0090147844, 0.0043679634, -0.0173155107, 0.0291684456, -0.0111451112, 0.0095375767, -0.0369660817, -0.0106839826, -0.0007199786, -0.0254413895, 0.0360582955, -0.0173654873, -0.0520902351, -0.0198096558, -0.0060475832, 0.0038687547, -0.0000007269, 0.0429911315, 0.0139529575, 0.0141719645, 0.0001304074, -0.0043611345, -0.0029836991, 0.0019546011, -0.0091015790, -0.0065858411, -0.0271548573, 0.0131811872, -0.0042863307, 0.0022366799, 0.0051961793, 0.0157197714, 0.0304035544, 0.0024112479, 0.0228091553, 0.0002058200, 0.0322911367, -0.0020262324, 0.0000565246, -0.0346976556, -0.0034116374, -0.0190879423, -0.0058160969, 0.0020756337, -0.0007626261, -0.0012898236, 0.0342925675, -0.0243861508, 0.0078951009, 0.0021286809, 0.0011522061, 0.0257689711, -0.0115681393, 0.0188660100, 0.0111564994, -0.0243478306, -0.0328663550, -0.0263248179, 0.0313171558, 0.0563520826, -0.0062404461, -0.0688677952, 0.0651445240, 0.0000138108, 0.0295314826, 0.0390696377, 0.0302728955, 0.0086836778, 0.0111172246, -0.0072350856, -0.0443299077, 0.0057232822, 0.0000194556, -0.0452178903, 0.0202906318, 0.0197781567, -0.0106016127, 0.0113776773, -0.0044358610, -0.0790142119, 0.0000002498, 0.0050114212, -0.0307643395, -0.0107904095, 0.0055316314, -0.0076025869, 0.0227396451, 0.0095528867, -0.0294328071, -0.0308407396, -0.0003022736, -0.0225819852, -0.0308769196, -0.0031722251, -0.0390317813, -0.0221085083, -0.0258589722, -0.0032704701, -0.0021315245, -0.0035414773, 0.0114080170, -0.0029974857, -0.0000317802, -0.0433167517, -0.0181018803, 0.0132859936, -0.0100639127, 0.0041251387, -0.0039307424, -0.0061473050, 0.0287941806, -0.0080633899, 0.0289071500, 0.0006925194, -0.0448461734, -0.0205444451, 0.0310300346, -0.0116725946, -0.0145764481, 0.0139543936, -0.0261707772, 0.0093173450, -0.0180458203, -0.0509699881, 0.0235680323, 0.0203839540, -0.0116999391, 0.0000263703, -0.0070426213, -0.0044111232, 0.0299864653, -0.0075386944, -0.0165798478, -0.0236135107, -0.0055506672, 0.0150594097, 0.0002806987, 0.0111202672, -0.0289144125, -0.0329725631, -0.0140705453, 0.0256086215, 0.0063290931, 0.0092149433, -0.0000024757, 0.0055664834, 0.0168944076, -0.0005554994, 0.0000497210, -0.0137556354, 0.0356425792, 0.0110190604, 0.0325867943, -0.0068778368, 0.0075498405, 0.0064249723, 0.0048681586, -0.0000329869, 0.0065332069, -0.0012880710, -0.0151899047, -0.0303942524, 0.0130448360, -0.0015575410, -0.0064256005, 0.0222242232, -0.0002009123, -0.0336172879, 0.0117665948, -0.0385346785, -0.0061141783, 0.0019337283, 0.0015204106, 0.0139863016, -0.0028639555, -0.0262188297, -0.0032804480, 0.0025426408, 0.0194073860, 0.0223585386, 0.0258217212, 0.0231266376, -0.0023326471, -0.0189481881, -0.0198464803, 0.0019447217, -0.0026548530, -0.0177031141, 0.0099804970, 0.0067433501, -0.0117515242, -0.0000008291, -0.0309556890, -0.0277197417, 0.0075960346, -0.0266196113, -0.0147213647, 0.0054221232, -0.0023810600, 0.0160842501, 0.0000250613, 0.0390036330, -0.0170530397, -0.0003085535, 0.0028162536, 0.0270538293, -0.0059559401, 0.0174395591, -0.0000000833, 0.0006146987, 0.0054731579, -0.0368158557, -0.0000535988, 0.0113652591, 0.0078762416, 0.0179159157, 0.0147294318, 0.0081055043, 0.0362697616, 0.0116403289, -0.0147235235, 0.0038374632, -0.0136614162, 0.0183015577, -0.0081369234, -0.0072412211, 0.0343214832, -0.0108509939, 0.0136872195, -0.0196247958, 0.0000023540, -0.0130297551, 0.0115138022, 0.0054648370, -0.0176913869, 0.0013536781, 0.0063853031, 0.0100053949, 0.0103997411, -0.0158893447, -0.0125696734, 0.0016825114, -0.0383573920, -0.0276146103, -0.0210889541, -0.0505634360, -0.0394272432, 0.0503139347, -0.0193670001, 0.0091789048, -0.0114911171, -0.0484832264, -0.0070855254, 0.0006560782, 0.0278670602, -0.0000086980, -0.0004379217, -0.0191203076, -0.0228293911, 0.0158951003, 0.0252681319, -0.0032421877, 0.0090708444, -0.0093808528, -0.0000996359, -0.0084818443, 0.0045987326, 0.0043748957, -0.0031946013, 0.0062585250, 0.0022084229, -0.0000575085, 0.0000010442, -0.0129820220, 0.0251474157, 0.0019158706, 0.0004779292, -0.0023936215, 0.0223926585, -0.0120368134, -0.0326642394, 0.0294339824, -0.0068474617, -0.0084379204, 0.0084861191, 0.0302260350, 0.0074131601, -0.0185233224, 0.0020009468, -0.0378682055, -0.0070973341, 0.0037559788, -0.0153439268, -0.0056873485, 0.0000178563, -0.0139943957, -0.0279404353, 0.0176570266, -0.0080945892, 0.0041021015, 0.0005683313, -0.0015801480, 0.0123230340, 0.0140960040, 0.0020284906, -0.0029332861, 0.0077034314, 0.0212395787, 0.0198709927, -0.0040973653, 0.0231329799, -0.0160260983, -0.0206893347, -0.0034181352, 0.0043213144, -0.0244747940, 0.0047537899, 0.0149314543, -0.0079299388, -0.0000405617, -0.0102026230, 0.0047008200, -0.0320032761, -0.0063193473, 0.0005713566, -0.0105367117, -0.0063864589, -0.0162353963, -0.0000196494, -0.0084012896, 0.0006421434, -0.0205281470, 0.0005096681, 0.0101988744, -0.0030907728, -0.0044690240, -0.0000000184, 0.0005186325, -0.0303652566, -0.0111359758, -0.0012446229, 0.0018764099, 0.0139622502, 0.0023225143, 0.0096915588, -0.0273563974, 0.0124073131, -0.0068650432, 0.0151752541, 0.0021154732, 0.0250396449, -0.0088194115, 0.0262418371, -0.0226204805, 0.0058926344, 0.0214411784, 0.0045364513, 0.0053690840, -0.0000116840, -0.0035990635, 0.0236948561, -0.0331638902, 0.0301847924, -0.0145488633, 0.0119884182, -0.0108658755, 0.0031005151, -0.0133918934, 0.0102410670, -0.0008438159, 0.0381359346, 0.0449490324, 0.0160820521, 0.0143336728, 0.0017218794, -0.0200356189, 0.0059543648, 0.0128998486, -0.0068093315, 0.0055042105, -0.0040529990, 0.0031135534, 0.0224127490, -0.0000000543, 0.0014209492, -0.0171177741, 0.0071895197, -0.0026380823, 0.0090145590, -0.0039327187, -0.0261252038, -0.0207985044, -0.0000028067, -0.0008366582, 0.0199396033, 0.0106100254, -0.0020867495, -0.0026485103, -0.0012250682, -0.0041031395, 0.0000000204, 0.0007099858, 0.0026425205, 0.0239466410, -0.0029890861, 0.0025580167, -0.0071184984, 0.0195457954, 0.0116644707, 0.0031716332, -0.0102505209, 0.0021478841, -0.0084807407, 0.0153994244, -0.0026155219, -0.0121937227, 0.0092837680, -0.0107999239, -0.0137667023, 0.0043456941, -0.0046278439, 0.0008128195, -0.0000007690, 0.0044594076, -0.0110928779, 0.0050675012, -0.0072458880, 0.0000899804, 0.0031346676, -0.0064511728, 0.0262348522, -0.0346139334, -0.0157828778, 0.0000680650, -0.0235360228, 0.0247587431, 0.0316000916, -0.0243844036, -0.0042717438, 0.0155997239, 0.0116708558, 0.0140341874, -0.0221247673, -0.0059214369, 0.0388421305, 0.0141195720, 0.0204971600, 0.0001221389, -0.0056412467, -0.0016361295, -0.0279547665, -0.0291026551, 0.0016292869, 0.0135775656, -0.0220153369, -0.0007388104, -0.0014324111, -0.0177892968, -0.0035605030, -0.0335734561, 0.0147698727, 0.0080192760, 0.0017046966, -0.0087290555, -0.0000001475, 0.0059533985, 0.0075991373, 0.0315543450, 0.0001123696, -0.0076728356, 0.0106791202, -0.0079895994, 0.0055432115, -0.0066568367, 0.0198302697, 0.0230349191, 0.0169622879, -0.0073355390, 0.0158085842, -0.0083546340, 0.0065592565, -0.0331143178, 0.0082739433, -0.0034979584, -0.0078785066, 0.0697528049, -0.0000732347, -0.0173082184, 0.0183979087, -0.0062114703, 0.0094150649, -0.0022760627, -0.0052336119, -0.0115274899, -0.0012100656, -0.0172358453, -0.0037908815, -0.0023867844, 0.0295425095, 0.0079943109, 0.0289947614, 0.0147800166, 0.0211574007, -0.0008241476, -0.0071190032, 0.0011188249, -0.0153710516, 0.0172396861, -0.0195233636, -0.0147672920, -0.0000591091, 0.0000025417, -0.0169681124, 0.0036348198, 0.0242707841, 0.0165667273, -0.0226082765, -0.0022602952, -0.0026798854, -0.0107499352, 0.0005562679, 0.0053925891, 0.0376296118, 0.0310717747, -0.0280864742, 0.0433255434, -0.0013775001, -0.0153068919, -0.0000024182, -0.0027911875, 0.0256051980, -0.0082747554, -0.0003788059, -0.0034018846, 0.0167227946, 0.0128279077, 0.0124287922, -0.0104583083, 0.0098881982, 0.0147854164, -0.0295609627, -0.0214325078, -0.0005347446, -0.0008273115, 0.0174150299, 0.0007696214, -0.0081345998, 0.0012771770, -0.0119040739, -0.0183630958, 0.0001665290, 0.0218146443, -0.0131373638, -0.0237568412, 0.0007181583, 0.0024767609, 0.0246463027, 0.0244169403, 0.0082880668, 0.0055785226, 0.0228953585, 0.0017185538, 0.0277276691, 0.0375573970, 0.0078754025, -0.0091862641, 0.0208414607, -0.0191809256, 0.0444946252, -0.0084025348, -0.0164568722, -0.0551522784, 0.0208480302, 0.0197440144, -0.0153364642, -0.0000800267, -0.0169349536, -0.0334780365, -0.0574370883, -0.0452436693, 0.0161911231, 0.0244063791, 0.0045102355, -0.0301790349, 0.0002231336, -0.0171408560, 0.0061863940, -0.0008477453, 0.0378836095, -0.0063152402, -0.0021330952, 0.0157077760, -0.0000001133, 0.0336214043, 0.0360335596, 0.0417054258, 0.0005198477, 0.0053870208, -0.0190746728, -0.0099049881, 0.0049408153, -0.0275379308, 0.0151292626, 0.0479293056, 0.0032259712, -0.0127476929, 0.0153961778, -0.0352269076, 0.0455845892, -0.0153794484, 0.0278151538, -0.0168160740, -0.0084132925, 0.0464624688, 0.0000361852, 0.0063737449, -0.0018418125, -0.0083497958, -0.0209084898, -0.0013758760, 0.0007601086, -0.0188879240, 0.0053621507, -0.0370676816, 0.0074283085, 0.0034564463, -0.0100161666, 0.0232902430, 0.0008633314, 0.0151157156, 0.0065842145, 0.0228448939, -0.0030311213, -0.0042907121, -0.0276066586, 0.0242852252, 0.0074683526, 0.0066211270, 0.0126211764, 0.0000029882, 0.0170071926, 0.0048758467, -0.0048066787, -0.0222027265, 0.0047901403, -0.0171502810, 0.0098134605, 0.0075274687, -0.0000021033, 0.0075494652, -0.0102184033, 0.0353639573, 0.0079553807, 0.0082170572, -0.0028061322, -0.0237041637, -0.0000000095, -0.0031248899, -0.0306879114, -0.0016908880, -0.0015937311, -0.0015734371, 0.0224396959, 0.0014607399, -0.0146227805, -0.0192131121, 0.0076465416, -0.0268938914, -0.0142049519, 0.0063723815, -0.0110923834, -0.0006999298, -0.0031292022, 0.0387657285, 0.0204803888, -0.0081299217, -0.0134314178, -0.0106355809, -0.0000402024, 0.0105544813, -0.0098639298, 0.0019230236, 0.0117757339, -0.0087164398, 0.0113322437, -0.0047298139, -0.0095652798, 0.0200385936, 0.0054418603, -0.0003502432, 0.0083729224, -0.0182277057, 0.0166397672, -0.0013774208, 0.0133448727, -0.0020486314, 0.0375194326, -0.0176645350, -0.0317354575, -0.0284720138, 0.0104522267, 0.0173351318, -0.0259497333, -0.0002771588, 0.0096607693, -0.0092411619, 0.0307974629, 0.0223931689, -0.0014466806, 0.0009122065, -0.0609644391, 0.0057647941, 0.0001210550, -0.0103015788, 0.0191665404, 0.0123327598, -0.0257573538, -0.0124041578, -0.0039793295, 0.0253871102, -0.0000004905, 0.0140183317, -0.0010993994, -0.0016149952, 0.0000447860, 0.0008715994, -0.0143784452, 0.0129436320, -0.0019476602, -0.0176230874, -0.0188355837, 0.0063751196, -0.0034125189, -0.0104407966, -0.0098916590, -0.0051917802, 0.0296522602, -0.0040363511, 0.0326891541, 0.0055361320, 0.0297448859, 0.0134518426, -0.0000884083, -0.0172708277, 0.0161742307, 0.0072981627, 0.0097885691, 0.0024510061, -0.0009579838, -0.0230020471, -0.0123632727, -0.0302637760, 0.0030681454, -0.0088260313, 0.0272638332, 0.0130395684, 0.0088976268, 0.0290677790, -0.0045663617, -0.0478279777, -0.0073303101, 0.0088573862, 0.0381805114, 0.0455039144, 0.0047989856, 0.0078562703, 0.0045946641, -0.0001051481, -0.0148403579, -0.0114115505, -0.0060433135, -0.0232369918, -0.0033391076, -0.0085160341, 0.0078216465, -0.0008074001, -0.0003017129, 0.0118832625, -0.0110382345, 0.0201655384, -0.0098479064, 0.0023849104, -0.0032211910, -0.0076882960, -0.0000001893, 0.0124101425, 0.0127573870, 0.0107826553, 0.0005110134, -0.0064210510, 0.0279463157, 0.0118082445, -0.0001652660, -0.0192602649, 0.0389655381, 0.0217635334, -0.0153372586, 0.0119774062, 0.0035458973, 0.0110073201, 0.0019836272, -0.0184483416, 0.0238339491, -0.0159324389, 0.0140158320, 0.0172829702, -0.0000145970, 0.0125094950, 0.0180282053, -0.0055658231, -0.0055036023, -0.0000990411, -0.0004678278, -0.0041097729, 0.0080758911, 0.0048317588, -0.0271528438, 0.0027820223, -0.0128534809, 0.0085211499, -0.0084239943, 0.0099157309, 0.0213065241, 0.0229547080, 0.0054827863, -0.0371976756, -0.0262726601, -0.0390678421, 0.0183685161, 0.0273418464, 0.0203703586, 0.0000121603, -0.0028722798, 0.0005534941, -0.0106687471, -0.0249457546, 0.0091761500, -0.0150868548, -0.0041477326, 0.0116494941, -0.0000011864, -0.0075583919, -0.0549749956, -0.0045413813, 0.0248014200, 0.0199738834, -0.0067109130, 0.0153025044, -0.0000000053, -0.0022304661, -0.0243347157, 0.0251144804, 0.0001567572, -0.0047421078, 0.0429156534, -0.0273565743, -0.0043354970, -0.0097344331, 0.0159737431, -0.0003392204, -0.0168000069, -0.0007490861, 0.0284401216, 0.0050407946, 0.0150820743, -0.0066619823, -0.0017446050, -0.0100590764, 0.0085838316, 0.0129670547, 0.0000094562, 0.0193666499, 0.0105682118, -0.0235116594, 0.0154876877, -0.0013469618, -0.0028611813, -0.0219818763, -0.0189625565, -0.0182898566, -0.0149335582, -0.0108823152, -0.0112989061, -0.0012805732, 0.0068513765, 0.0262544099, -0.0336955525, 0.0221198797, 0.0345153883, 0.0059196712, -0.0118598025, -0.0224085636, -0.0061878818, -0.0164329838, -0.0019150114, -0.0001436840, -0.0153971715, -0.0158493780, 0.0161488187, -0.0317586213, -0.0093986411, -0.0074983002, 0.0234419331, -0.0222643949, 0.0012651687, -0.0082260808, 0.0055192220, 0.0097739734, -0.0203460194, -0.0001411777, -0.0019540826, 0.0228088666, -0.0000000310, -0.0040171645, 0.0048634908, 0.0028273731, 0.0007861271, -0.0098259216, 0.0089193452, -0.0101344250, -0.0074454355, -0.0040948330, 0.0154373618, -0.0266181640, 0.0301584173, 0.0096696345, 0.0534238294, 0.0191802792, 0.0100160781, -0.0182975382, 0.0202594306, 0.0065337461, 0.0067656967, 0.0174338575, -0.0001617191, 0.0038160023, 0.0190185122, -0.0340132378, -0.0135956630, -0.0040010633, 0.0013774984, 0.0176544469, 0.0230989233, 0.0017547329, 0.0293170437, 0.0027297370, 0.0054222909, 0.0712723657, 0.0285609830, 0.0211994927, 0.0314582027, -0.0545176230, -0.0245437473, -0.0030526407, -0.0203584135, -0.0078629237, 0.0078353481, 0.0012041633, -0.0019068311, 0.0000003557, 0.0107102543, -0.0236385837, 0.0050531034, -0.0360145271, -0.0109655829, 0.0063847508, 0.0225047898, 0.0178606790, 0.0000060829, -0.0111374641, -0.0113831097, 0.0029973511, 0.0244602412, 0.0227679461, -0.0131277256, -0.0015876796, 0.0000000274, 0.0008306910, -0.0008511794, -0.0106539028, 0.0000474080, 0.0187060833, 0.0055267513, -0.0054784021, -0.0116883721, 0.0102456445, 0.0354063287, 0.0229031574, 0.0105903940, -0.0152870277, 0.0374774188, -0.0222890880, 0.0196621474, -0.0204354282, -0.0206503626, 0.0125827193, -0.0329070240, 0.0099190250, 0.0000031885, 0.0181213971, -0.0273669939, -0.0243653953, -0.0360736810, 0.0013866398, 0.0082929786, 0.0193689428, -0.0373434648, 0.0012701228, 0.0026630454, 0.0012140288, 0.0419172831, 0.0260657798, -0.0279851593, 0.0080695208, -0.0112117212, -0.0258414466, 0.0326098576, 0.0280887708, -0.0174243376, -0.0286632348, -0.0206823722, -0.0293299370, -0.0274328664, 0.0000172534, -0.0219570827, 0.0003056857, 0.0049093105, 0.0280848462, 0.0033516553, 0.0052994657, 0.0142647484, 0.0100815278, -0.0000210891, 0.0161982719, -0.0188958775, -0.0120657450, -0.0140282493, -0.0547865070, 0.0130710788, 0.0126482295, -0.0000023658, -0.0045254175, -0.0083401604, -0.0117768319, -0.0066376883, 0.0005394188, -0.0453845076, -0.0270795077, 0.0020906918, 0.0251129288, -0.0262660813, 0.0048107444, 0.0129487915, 0.0208057873, -0.0346884504, 0.0180454571, -0.0384800732, -0.0031446505, 0.0263006799, -0.0173797235, 0.0184716880, -0.0501542464, -0.0000421967, -0.0116077671, -0.0092766434, 0.0556754246, 0.0115569374, -0.0040544965, -0.0012514814, 0.0037246307, 0.0384938195, 0.0015557256, 0.0221715085, 0.0024536939, -0.0541142486, -0.0260457955, 0.0151864700, -0.0110677108, 0.0034687463, 0.0166728180, -0.0384603478, -0.0139482077, -0.0105763916, 0.0243618693, 0.0088587096, 0.0221240465, 0.0070830015, 0.0000005532, -0.0230695345, -0.0080441106, -0.0374558270, -0.0058253957, 0.0151723949, -0.0131884236, 0.0090185422, -0.0347114429, 0.0000037226, -0.0168187562, 0.0068401503, 0.0139731122, 0.0231018271, 0.0147338193, -0.0106203584, 0.0155720264, -0.0000000041, -0.0070744455, -0.0180404559, 0.0152092502, 0.0001778141, -0.0093782376, 0.0252852272, -0.0043222024, -0.0275365915, -0.0311749317, 0.0243655723, -0.0184822064, -0.0092083281, -0.0128611168, 0.0314677805, 0.0018117469, 0.0171776209, -0.0335756689, 0.0297091771, 0.0021362056, 0.0213538297, -0.0052955826, -0.0000190099, 0.0209448002, 0.0208251234, -0.0202600807, 0.0088233352, 0.0015685136, -0.0055723786, -0.0223502535, 0.0133749386, -0.0148339095, -0.0011889730, 0.0024203679, -0.0177405328, 0.0026729011, -0.0035369368, 0.0138100442, -0.0025387327, 0.0082606263, 0.0209749937, 0.0138489753, -0.0135089643, -0.0169549882, 0.0283191949, 0.0313565396, -0.0425002947, -0.0001657958, -0.0289407969, -0.0201752931, 0.0302993581, -0.0016345418, -0.0250775479, -0.0138216661, -0.0227519888, -0.0074416301, -0.0000440690, 0.0039235093, 0.0168440305, -0.0289241057, 0.0266946815, 0.0241203438, -0.0044951541, 0.0376810357, -0.0000000601, 0.0095158108, 0.0015002869, -0.0493699871, 0.0000170810, -0.0066662477, 0.0086791031, -0.0116377398, 0.0149817504, 0.0178382918, 0.0319077931, 0.0260044020, -0.0334139653, 0.0196606629, -0.0270861387, -0.0007845847, -0.0121612912, -0.0136962552, 0.0018355133, -0.0019127108, 0.0119697638, -0.0021953408, -0.0000389607, -0.0589172654, -0.0052507874, -0.0366910398, -0.0008981517, 0.0023694045, 0.0071423631, -0.0074442369, -0.0105270408, -0.0013853241, -0.0052110599, -0.0009956650, 0.0107591962, -0.0013528921, 0.0234714411, -0.0408880003, -0.0236041732, -0.0122899367, 0.0076246373, 0.0541282333, -0.0101098474, -0.0270742234, 0.0056728702, 0.0063701123, -0.0105898660, -0.0000146855, -0.0109708887, 0.0118058175, -0.0438014902, -0.0408661328, 0.0146672800, 0.0154364295, -0.0326227769, -0.0445681736, 0.0000235849, -0.0337365903, -0.0055401651, 0.0208313670, -0.0173439514, -0.0429534540, 0.0016172384, -0.0007806663, 0.0000000957, 0.0046003861, 0.0145174088, 0.0774981081, 0.0011876386, -0.0240536630, -0.0043741954, -0.0500917360, 0.0138898715, -0.0055133738, -0.0283768531, 0.0131762754, -0.0119883595, 0.0064344746, 0.0089563671, 0.0288435072, 0.0248708129, -0.0268640276, 0.0306442715, -0.0248123296, 0.0721572414, 0.0028746752, 0.0000066846, -0.0014326436, 0.0281642824, -0.0148256719, 0.0063900398, 0.0006206502, -0.0123675922, -0.0118752494, 0.0322142877, -0.0575509183, 0.0149249593, 0.0015311686, -0.0555237271, 0.0306517258, 0.0404194407, 0.0180816222, 0.0203318913, 0.0041452441, -0.0064773061, 0.0018273250, -0.0377340131, 0.0391680002, 0.0022139119, -0.0029797577, 0.0106134424, 0.0000058696, 0.0056120194, -0.0167828519, 0.0067434642, -0.0571833998, 0.0135865854, -0.0099012544, -0.0107995784, 0.0069817645, -0.0001694983, 0.0326630771, -0.0425647125, -0.0176094659, -0.0079230759, 0.0126705170, -0.0001940340, -0.0216129646, -0.0000000292, 0.0131658027, -0.0084128417, -0.0135208536, -0.0000016824, -0.0000184796, 0.0391100124, 0.0032016118, 0.0186521932, -0.0120937824, 0.0156706702, -0.0025318523, -0.0163952205, -0.0059289029, -0.0011218707, 0.0339156948, -0.0053342045, -0.0081236586, -0.0005096919, -0.0094714109, -0.0001513406, 0.0101886978, -0.0000781117, -0.0087037664, 0.0160223413, 0.0003767972, -0.0068791909, 0.0027035042, -0.0124044772, -0.0186719354, -0.0013574716, -0.0219857655, -0.0198110454, -0.0051251594, -0.0088048102, -0.0000491405, 0.0032323226, -0.0070871650, -0.0238609277, 0.0499997623, 0.0068409848, -0.0010358852, -0.0365971774, -0.0138154440, -0.0305732898, -0.0423944145, 0.0269102566, 0.0000080253, 0.0152358608, 0.0577144548, 0.0119412653, -0.0224180259, -0.0018641766, 0.0001481794, -0.0118079167, -0.0314311385, 0.0000049302, -0.0313745514, 0.0836715475, 0.0620176569, -0.0379174054, -0.0531934388, -0.0070242225, -0.0549770184, 0.0000001470, 0.0034485913, -0.0057707601, -0.0198191945, 0.0069240504, -0.0249733068, -0.0366702229, -0.0057427166, -0.0086026648, -0.0225009285, -0.0280645397, -0.0015052011, -0.0344206914, 0.0064978930, -0.0452057533, 0.0168646779, 0.0013349897, 0.0541652851, -0.0027638439, -0.0207357053, 0.0222822633, 0.0169934053, -0.0000025835, 0.0346817374, -0.0078688748, 0.0258766990, 0.0157824960, -0.0037821427, 0.0070926985, 0.0095660035, 0.0222790744, 0.0159400403, 0.0128157791, 0.0015622602, -0.0005114013, 0.0025174716, 0.0263970215, -0.0195080079, -0.0112567293, -0.0107637290, 0.0029642754, -0.0171737485, -0.0269641075, 0.0371819884, 0.0008968207, -0.0094266776, -0.0060368613, -0.0000012918, -0.0261593834, -0.0107242214, 0.0250376258, 0.0276175458, -0.0023215283, -0.0206565503, -0.0142026143, -0.0107980529, 0.0000477354, -0.0197325535, 0.0364144556, -0.0034020096, 0.0002611119, 0.0249827784, 0.0012175803, 0.0159030333, -0.0000001297, 0.0000936162, 0.0062912339, 0.0070601981, 0.0000013532, -0.0086515862, 0.0000768643, 0.0252742600, -0.0077576912, 0.0079560969, -0.0175561327, -0.0115844775, -0.0096148811, 0.0076360805, 0.0075623398, -0.0220270976, -0.0125867920, -0.0470896997, 0.0014573956, 0.0045440281, 0.0217643715, -0.0052697682, -0.0000068151, -0.0209972207, -0.0242175367, -0.0288566872, -0.0050393008, -0.0004634749, 0.0034842435, 0.0294549894, 0.0279954765, -0.0082327109, -0.0188282691, -0.0007179578, -0.0018587474, 0.0169877056, 0.0087316195, -0.0060478253, -0.0108371386, 0.0014836241, -0.0057952600, -0.0005536365, 0.0285589173, 0.0004088155, 0.0147754382, 0.0170454439, -0.0078983679, 0.0001897598, 0.0129432408, -0.0067226985, 0.0078990627, -0.0040676561, -0.0224339887, -0.0252960213, -0.0066268402, 0.0210277494, 0.0001356947, -0.0223408733, 0.0013115518, 0.0009207807, 0.0217414070, 0.0064844219, -0.0101233749, 0.0190320555, -0.0000039539, 0.0018424059, 0.0257608984, 0.0113091376, -0.0007934413, -0.0119529404, 0.0217363071, 0.0136413602, 0.0001688605, -0.0010250870, 0.0233402159, 0.0233452283, -0.0220781844, -0.0211126730, -0.0018386199, -0.0161352456, -0.0170526151, -0.0318970159, -0.0031739820, -0.0090497984, 0.0204740837, 0.0415420271, 0.0000535921, -0.0116955554, -0.0152572710, -0.0385208838, -0.0212628432, 0.0030926659, 0.0154135330, 0.0212708209, 0.0125809815, -0.0427809060, -0.0129898498, -0.0011367123, 0.0062053963, -0.0238325708, 0.0106244497, 0.0188591629, -0.0021197514, -0.0023496870, 0.0122845573, 0.0160563178, -0.0030795233, -0.0075100362, -0.0000270319, -0.0029559738, 0.0165295228, 0.0000004572, -0.0121156182, 0.0043147295, -0.0030304485, -0.0297928676, 0.0171034839, 0.0054881931, -0.0106171863, 0.0085225655, -0.0000006595, 0.0197027512, -0.0480115786, -0.0095264986, 0.0197920203, 0.0402126499, 0.0068091089, 0.0003290084, 0.0000000113, -0.0061658546, -0.0100181773, 0.0195726752, -0.0003467237, -0.0033500753, 0.0159651618, -0.0018410571, 0.0035785008, 0.0079177720, 0.0154115167, -0.0077551189, -0.0079460340, -0.0149681345, 0.0276958235, -0.0137022855, 0.0081904037, -0.0057295985, -0.0164966099, 0.0073976726, -0.0180655103, -0.0308994204, 0.0000004400, 0.0180622004, 0.0482815243, -0.0269332007, -0.0118100373, 0.0000398018, -0.0079516964, -0.0160800163, -0.0232982505, 0.0088260537, -0.0174249820, 0.0003733135, -0.0135371536, -0.0067892829, -0.0151685737, 0.0016538724, -0.0059399158, 0.0462657027, 0.0323232524, 0.0209008697, -0.0199353062, -0.0246665236, -0.0049557216, 0.0153615912, -0.0025601843, 0.0000010057, -0.0217208005, -0.0153085208, -0.0273458678, -0.0156848561, 0.0039312961, -0.0061825649, -0.0052209287, -0.0023797415, -0.0000014290, 0.0141706103, -0.0100629469, -0.0001998467, 0.0158978663, 0.0203317441, 0.0032862665, 0.0083422223, 0.0000000010, 0.0219433233, 0.0065513011, 0.0010493079, 0.0000117644, -0.0070727328, 0.0017281234, 0.0053748391, 0.0125482390, -0.0036216124, 0.0062341220, 0.0105798151, -0.0060160370, 0.0016140894, 0.0121543184, -0.0108819697, 0.0029323448, -0.0105619766, 0.0069364747, -0.0048961551, -0.0004531643, 0.0092115663, 0.0000000169, -0.0015068110, 0.0093145100, -0.0232690368, 0.0028345222, 0.0001587214, -0.0023380267, 0.0011731267, 0.0013833431, 0.0032850644, -0.0256891549, 0.0003921652, 0.0149404434, -0.0130204130, -0.0086049810, -0.0002595114, 0.0096684815, 0.0215235464, 0.0135935051, -0.0092524271, -0.0054493663, -0.0094609829, 0.0130841108, -0.0067463098, -0.0005922729, 0.0000000480, -0.0179456398, -0.0131230596, -0.0454409011, 0.0229103137, 0.0050581265, -0.0056600100, 0.0043937666, -0.0402534008, -0.0000393117, 0.0107880533, 0.0089293169, 0.0143384328, 0.0122974226, 0.0123368828, 0.0026476667, 0.0128864823, -0.0000009982, -0.0151440315, 0.0070570353, -0.0232531894, -0.0027247490, -0.0032486664, 0.0102220755, -0.0045078560, 0.0031668122, 0.0166376159, 0.0010417965, 0.0056802123, 0.0030421496, -0.0175907705, 0.0222166181, -0.0071574608, 0.0123889176, -0.0164508130, -0.0043002800, -0.0035816173, 0.0064189574, -0.0210084748, -0.0000260612, 0.0056204535, 0.0302213747, -0.0002497013, 0.0086690504, -0.0061799362, -0.0186558086, 0.0208079871, 0.0423647575, -0.0237988625, -0.0016759051, -0.0126287779, -0.0226311516, -0.0121507375, 0.0134653822, -0.0131048411, 0.0015508411, 0.0301676486, -0.0147438189, -0.0176784452, 0.0094296532, -0.0003944332, -0.0119992448, -0.0156650767, -0.0080173463, 0.0000000979, -0.0047002370, 0.0156342164, -0.0398232676, 0.0262156855, -0.0068581770, 0.0004954913, 0.0063669533, 0.0071423366, -0.0000358868, 0.0056661959, -0.0020419410, -0.0042287190, 0.0042153392, -0.0132826539, 0.0020779993, 0.0104958508, 0.0000006659, 0.0075654271, 0.0068930499, -0.0122365728, -0.0000516764, 0.0043426142, 0.0115359500, -0.0275388993, -0.0070961183, -0.0034011309, -0.0028958998, 0.0049646688, 0.0043534772, 0.0236455407, -0.0132549917, 0.0165444184, -0.0038501481, 0.0109673766, 0.0097064730, 0.0029556535, -0.0032447290, -0.0078401333, -0.0000029328, -0.0031259423, -0.0036828853, 0.0354688838, 0.0051523112, -0.0052391370, -0.0086587425, 0.0057266848, 0.0036927289, 0.0097824419, 0.0046044961, 0.0000226821, -0.0105200596, -0.0519032218, -0.0178881977, 0.0180008188, 0.0127871074, 0.0112934206, 0.0171975587, -0.0135349864, 0.0126314918, 0.0152809396, -0.0036095711, 0.0138102695, -0.0201538950, 0.0000015309, -0.0117055839, -0.0015549824, -0.0246955547, -0.0084353816, 0.0070679854, -0.0124132568, -0.0003136586, -0.0096997935, 0.0000012341, 0.0233160984, 0.0068449387, 0.0021844681, 0.0141477492, 0.0104240756, 0.0031794813, -0.0027512379, 0.0000000472, -0.0081522893, -0.0151413120, -0.0206081737, 0.0000312484, 0.0055155694, -0.0044920691, 0.0161045454, 0.0221815500, -0.0061875274, 0.0152896028, -0.0125682997, -0.0021826131, 0.0079336455, 0.0117328083, -0.0144059164, -0.0077949776, -0.0120253759, 0.0062741176, -0.0039479425, 0.0059672678, -0.0002515776, -0.0000001881, 0.0081690624, -0.0077543971, -0.0078059109, 0.0245950520, -0.0010588790, 0.0004184805, 0.0081762634, -0.0110730873, 0.0012016183, -0.0118486909, 0.0003808424, 0.0237137284, 0.0181674734, -0.0118572889, 0.0017831934, -0.0106286341, 0.0129731987, 0.0299030133, 0.0090874834, -0.0026302682, 0.0163364243, 0.0240192357, -0.0005941541, 0.0283662211, 0.0000050954, -0.0319033079, 0.0092624826, -0.0311071817, 0.0517464466, 0.0132554071, -0.0040683923, -0.0193909220, -0.0415450446, -0.0000045112, -0.0266381484, 0.0416318327, 0.0093839662, 0.0183098372, 0.0241828039, -0.0011795805, 0.0132072661, -0.0000117653, -0.0267158505, 0.0068866955, -0.0052901311, -0.0050931708, 0.0023962455, 0.0118957730, 0.0056587821, -0.0033818197, -0.0067995242, 0.0036607175, -0.0111787412, 0.0018496859, 0.0095862439, 0.0133690154, -0.0184073634, 0.0056036320, -0.0290979352, -0.0086623877, 0.0144636733, -0.0071734167, -0.0082408171, -0.0000154775, -0.0013606716, 0.0149232401, -0.0042511909, 0.0041344264, -0.0006375985, -0.0088276491, 0.0201272350, 0.0474229492, -0.0173896961, -0.0091530615, -0.0001858992, 0.0094713559, -0.0035965203, 0.0161659010, -0.0387371704, -0.0053542117, 0.0244587772, 0.0145951994, -0.0056147641, 0.0239492953, -0.0046404134, -0.0075654276, 0.0031366290, -0.0117277037, 0.0000001156, -0.0075471750, -0.0124110971, 0.0000309765, 0.0140245035, -0.0005060121, -0.0092782369, -0.0030097594, -0.0042784782, 0.0000000493, 0.0067973249, 0.0032496140, 0.0151903611, 0.0030344054, 0.0128232352, -0.0005060425, -0.0041251522, -0.0000000768, 0.0071110888, -0.0201463141, -0.0111273425, 0.0000195567, 0.0025256448, 0.0204368997, 0.0055187093, -0.0083074514, -0.0171483476, 0.0089779729, -0.0180955324, -0.0242880676, 0.0026699596, 0.0084958700, 0.0018650872, 0.0142320124, 0.0134913968, -0.0074367695, -0.0037401065, -0.0277866013, -0.0314233676, -0.0000004201, -0.0137003046, 0.0088915862, 0.0075573488, 0.0154823130, 0.0002473973, 0.0046141455, -0.0076626521, -0.0041298829, -0.0084060803, -0.0042155432, -0.0008032937, 0.0073840031, 0.0256743636, 0.0131012630, 0.0021546534, -0.0053807427, -0.0119549250, 0.0239270627, 0.0105229495, -0.0017160256, 0.0038131936, 0.0218992885, 0.0240698028, -0.0053826626, -0.0000422202, 0.0036451765, 0.0148116928, -0.0079835448, 0.0102622826, -0.0213110205, -0.0010812843, -0.0092776110, -0.0314077660, 0.0004992590, -0.0027425759, 0.0192199852, 0.0360254310, -0.0166214071, -0.0330580287, -0.0028520073, 0.0269751456, 0.0000002867, 0.0003299991, 0.0204760563, 0.0236992929, 0.0005196389, -0.0138875246, 0.0091613252, -0.0320297368, -0.0053584445, -0.0277833343, 0.0306249652, 0.0296944510, -0.0204935484, 0.0078149047, -0.0047622314, 0.0238213744, 0.0411783382, -0.0244321581, 0.0636710748, -0.0274306908, 0.0456552245, 0.0512870364, -0.0000323383, -0.0044951816, -0.0128308153, 0.0106388805, 0.0093386713, -0.0000678082, -0.0143727669, 0.0061148554, 0.0057779201, -0.0163010620, 0.0121151758, -0.0000235575, -0.0618222356, -0.0043119779, 0.0508422330, -0.0249613896, 0.0348869264, -0.0104262354, -0.0211724583, 0.0135596823, -0.0373376980, -0.0431091525, -0.0001928701, 0.0087680407, -0.0204276815, -0.0001805987, -0.0041377447, -0.0042659901, 0.0038639735, -0.0087951301, -0.0196486842, -0.0141730169, -0.0048371013, -0.0045417752, 0.0000441012, 0.0050617559, 0.0146536324, -0.0043790252, -0.0337846875, -0.0131892329, -0.0006599826, 0.0232068282, -0.0000107553, 0.0024100828, 0.0345383435, 0.0348303579, -0.0000891351, -0.0041201920, -0.0092817526, -0.0175755844, -0.0041370853, -0.0079953270, -0.0107488949, 0.0261799339, -0.0131560834, -0.0036276153, 0.0205230843, 0.0129692061, 0.0146104908, 0.0050120680, 0.0325474143, -0.0296637863, 0.0576142184, 0.0118988035, 0.0001135140, 0.0081867455, -0.0042088018, 0.0110075865, -0.0003353088, 0.0029330060, -0.0109604485, 0.0307316724, -0.0039057152, -0.0319264233, -0.0068178298, -0.0001980359, -0.0350032821, -0.0234384891, 0.0308573879, 0.0007366918, 0.0080028949, 0.0094516044, -0.0230806153, -0.0016853921, -0.0086578010, 0.0113453502, -0.0028606346, -0.0042123375, 0.0337967314, 0.0000233104, -0.0046380982, 0.0236057211, 0.0308408141, 0.0204303376, 0.0172246173, 0.0149378041, -0.0374721773, 0.0058870227, 0.0001059466, -0.0109904949, 0.0204321984, 0.0365477353, -0.0309645869, -0.0166103076, -0.0002272454, -0.0124752512, 0.0000003384, -0.0036484990, -0.0228852201, -0.0257238615, 0.0022994208, 0.0288427584, 0.0017829071, 0.0178228896, -0.0106120314, -0.0170099195, -0.0214391556, -0.0148837091, 0.0156795252, 0.0306761917, -0.0258541424, -0.0015097704, 0.0064042173, 0.0174403805, -0.0047007618, 0.0069897678, 0.0012177008, -0.0164627824, -0.0000310856, -0.0091133406, -0.0373457633, 0.0353596099, -0.0037216553, 0.0008615293, -0.0088425679, -0.0133806225, -0.0253588762, 0.0266502053, 0.0218767934, 0.0025318919, -0.0175166316, 0.0411558710, 0.0086993184, 0.0058338577, -0.0010782768, -0.0169495549, 0.0167383440, 0.0011335487, 0.0080208760, -0.0166197903, 0.0238785818, 0.0137346378, -0.0125861708, 0.0000147098, 0.0155078145, -0.0125263752, 0.0080738589, -0.0105221709, -0.0092963986, -0.0201779045, -0.0210188199, 0.0097052604, 0.0000000551, 0.0142715024, -0.0272278823, -0.0001121073, -0.0100428890, 0.0219186898, 0.0010419614, 0.0061798878, -0.0000013537, 0.0043666889, 0.0139913801, -0.0096499110, -0.0037743673, -0.0042457222, 0.0217759572, 0.0085794413, 0.0179612786, 0.0153158782, 0.0000006788, 0.0101935072, -0.0259040780, -0.0191002265, 0.0128571624, -0.0042373040, -0.0094543332, 0.0186355524, -0.0218021236, -0.0066492497, 0.0036600919, -0.0062927748, -0.0000851796, -0.0135521311, 0.0007785573, -0.0369142778, 0.0018813288, 0.0007180469, -0.0069298125, 0.0265243109, -0.0000782333, -0.0187103301, -0.0133542679, -0.0112616839, 0.0042864499, 0.0143406382, 0.0060780854, 0.0180899370, -0.0056792409, 0.0011609654, -0.0119511615, -0.0013423918, 0.0073647527, -0.0145769855, 0.0098857041, 0.0064303372, -0.0218804646, 0.0000001166, 0.0038717783, -0.0040362952, 0.0072102956, -0.0210366044, 0.0042821765, -0.0055559427, -0.0029238807, 0.0092801824, -0.0000007270, 0.0182603616, -0.0417025648, -0.0137301534, -0.0037567427, -0.0017271920, 0.0015227174, 0.0061004618, -0.0000000254, -0.0000622552, 0.0146705890, -0.0112612182, -0.0014550863, 0.0010587656, 0.0177775379, -0.0248393416, 0.0124402698, 0.0213082694, 0.0129948324, 0.0139499363, -0.0359390751, -0.0123829814, -0.0031404078, 0.0116307875, -0.0070175505, 0.0152603099, -0.0034628678, -0.0034847446, -0.0042339824, -0.0167471040, -0.0000000257, 0.0067806644, -0.0055129454, 0.0115808574, -0.0141916117, 0.0002411848, -0.0090058139, 0.0121592470, -0.0174614601, -0.0022209974, 0.0009641054, -0.0038106092, -0.0202203393, -0.0000694958, -0.0007497213, 0.0065663448, -0.0054645063, 0.0141053293, 0.0195567887, 0.0155634740, -0.0222946163, -0.0256618075, 0.0102306288, 0.0220929813, 0.0241243746, -0.0000199509, -0.0183278751, -0.0001291313, -0.0126014734, -0.0025517133, -0.0043834336, 0.0055744364, -0.0404088981, -0.0155187063, -0.0000018193, 0.0077436864, 0.0414127074, -0.0107619064, -0.0078277607, 0.0234505851, -0.0017485864, 0.0103285629, 0.0000000014, 0.0210031383, 0.0307204090, -0.0051992596, 0.0003710496, 0.0087490324, 0.0082654404, 0.0194839519, 0.0069694007, -0.0198976882, -0.0028851901, 0.0232131556, 0.0049028737, -0.0010441140, 0.0083575863, 0.0130730411, 0.0242236312, 0.0233296715, 0.0156990923, 0.0159564111, 0.0135074528, 0.0392167382, 0.0000007661, -0.0028579738, 0.0172268394, -0.0145686725, -0.0087109581, 0.0004931504, 0.0003519558, 0.0027703643, 0.0174587015, 0.0099296309, -0.0006583019, 0.0024515500, 0.0032736217, 0.0156949032, -0.0026127009, -0.0232896060, 0.0420200750, -0.0121480376, 0.0027078947, 0.0097575290, 0.0044448520, -0.0425380617, 0.0014683269, -0.0094000604, -0.0007419782, -0.0000007791, 0.0108683975, -0.0015338489, 0.0004178265, -0.0034397689, 0.0046963957, -0.0059619052, -0.0179715101, -0.0245502163, -0.0000004359, 0.0074651628, 0.0100767547, 0.0077337655, 0.0023976313, 0.0075435918, 0.0007054459, -0.0158361234, 0.0000000090, 0.0048662033, -0.0079779476, -0.0286130551, -0.0008734347, -0.0042460999, 0.0182466209, 0.0172546431, 0.0117367413, -0.0004085090, 0.0316960625, 0.0068302774, -0.0191478245, -0.0076978491, -0.0004088026, -0.0118014002, 0.0336937904, -0.0300878100, 0.0094344998, -0.0059093200, 0.0042066243, 0.0071396325, -0.0000001721, 0.0021326761, 0.0043632411, -0.0002188941, -0.0206292458, -0.0005455121, 0.0019359380, -0.0070641586, 0.0223516449, -0.0157568771, -0.0067854533, -0.0045042750, -0.0195721127, 0.0023615982, -0.0135164130, 0.0180459023, -0.0052321423, 0.0078442441, 0.0020398670, 0.0084102005, -0.0000394904, -0.0154768210, -0.0002927767, 0.0112731224, 0.0031884329, 0.0000000074, -0.0149801439, -0.0142775839, -0.0115122804, -0.0166469049, 0.0038973407, -0.0043039396, -0.0179117285, -0.0031677797, -0.0000002886, 0.0092987409, 0.0138180917, 0.0083857682, 0.0078945272, 0.0053860601, 0.0003434750, 0.0072626192, 0.0000000003, -0.0039582499, 0.0031562941, 0.0056809206, 0.0000081939, -0.0001707216, 0.0007424687, 0.0105510941, -0.0041042287, -0.0084226271, -0.0072348178, 0.0001242557, -0.0081733437, 0.0085170837, -0.0041386806, 0.0044039567, -0.0031152763, 0.0194609668, 0.0076056919, 0.0062524425, 0.0051445938, -0.0049305446, 0.0000000003, 0.0034525543, -0.0087988628, 0.0001242616, -0.0045201443, 0.0004174702, -0.0055569187, 0.0006376854, 0.0050707329, -0.0128558204, -0.0125221452, 0.0000568856, -0.0006548194, -0.0137017481, -0.0189590100, 0.0092473663, 0.0011887409, 0.0024874907, 0.0200008713, 0.0001236915, -0.0007255581, -0.0058342102, 0.0394853875, 0.0147130657, -0.0299539566, -0.0000004029, -0.0176059101, -0.0051630456, 0.0064685089, -0.0050701899, -0.0251059737, -0.0049151131, -0.0242426135, 0.0025971658, -0.0011103156, -0.0020357824, -0.0019724532, -0.0173884425, -0.0148511492, 0.0116158482, 0.0037899558, 0.0224948805, -0.0000007493, 0.0122934282, 0.0170917548, -0.0204144884, 0.0000279159, -0.0160834324, 0.0090271635, -0.0020989047, 0.0390305370, 0.0039988998, 0.0227675270, 0.0242787320, 0.0089307595, -0.0149689820, 0.0116349077, -0.0088158930, 0.0126322042, -0.0065642796, 0.0185547918, -0.0113063520, -0.0098944148, 0.0245291237, -0.0000086812, -0.0294691510, 0.0288162436, -0.0345115885, 0.0039237309, 0.0023406816, 0.0018757255, 0.0013314753, 0.0007175434, -0.0406201184, 0.0087572103, -0.0000481174, 0.0135867791, 0.0124355974, 0.0325458422, 0.0202661604, -0.0028153646, -0.0209741425, -0.0320064165, -0.0062878169, 0.0036800213, 0.0021176711, 0.0218092594, 0.0133093465, 0.0429353788, 0.0000084606, 0.0043135784, 0.0536878705, -0.0055323630, 0.0452614650, -0.0034140642, 0.0033885287, -0.0028109928, -0.0034450623, -0.0000178077, -0.0356920548, 0.0216552019, 0.0150470650, -0.0073902318, 0.0211974215, -0.0024986139, 0.0058837193, -0.0000019078, -0.0143740475, -0.0036016379, -0.0116442079, 0.0012447203, 0.0045309728, 0.0349514037, 0.0095296483, 0.0103395805, -0.0285884179, 0.0347892791, 0.0123592932, -0.0177140366, -0.0095331054, 0.0103958342, -0.0091294432, -0.0016115108, -0.0073990044, -0.0149347940, 0.0316633843, -0.0005512586, 0.0102222469, -0.0000371589, -0.0020989422, 0.0002761935, -0.0183806680, -0.0050380626, 0.0002565863, -0.0263424907, 0.0237687454, 0.0040682387, 0.0178522374, -0.0209956169, -0.0078428490, 0.0140608922, 0.0006581053, -0.0162634496, -0.0084932595, 0.0113140941, -0.0174810011, 0.0078390064, 0.0083246212, 0.0239430424, -0.0042550317, 0.0185779762, 0.0074121091, 0.0229573660, -0.0001199811, 0.0046894206, 0.0064496440, -0.0309468117, -0.0303208772, -0.0179854780, -0.0094793178, -0.0152772656, -0.0038316124, 0.0000832819, -0.0184378438, -0.0164079890, 0.0449800789, 0.0032926141, -0.0152379442, -0.0108789066, -0.0082836030, -0.0000031420, 0.0012574880, 0.0034731424, 0.0218106527, 0.0002434548, -0.0034144528, 0.0140930470, 0.0014516847, -0.0069838222, -0.0040368740, 0.0227929950, 0.0357932448, -0.0172914770, -0.0200519618, -0.0071115256, 0.0003722477, -0.0146438209, -0.0320932455, 0.0051719267, -0.0320884250, 0.0204835776, 0.0137712862, -0.0000023464, 0.0335988253, 0.0115701389, -0.0044552721, -0.0069975923, 0.0034653132, 0.0003461119, -0.0107477019, 0.0245848633, -0.0377185307, -0.0105758430, 0.0043488424, -0.0086625135, -0.0210387725, 0.0074182339, 0.0141315609, 0.0094294222, 0.0252051950, 0.0138274468, -0.0046491530, -0.0085410355, -0.0121317049, 0.0081703207, -0.0084986882, 0.0244980752, 0.0000009980, -0.0099902423, 0.0069349157, 0.0259072557, 0.0391413383, 0.0110793794, -0.0040735463, -0.0129500376, -0.0102464696, 0.0000079912, -0.0034727065, 0.0144502195, -0.0124780796, 0.0030101771, 0.0369018354, 0.0021980715, -0.0159467030, 0.0000000258, -0.0169985350, -0.0094672227, -0.0233597439, -0.0098036649, 0.0119095622, 0.0211184938, 0.0092241280, 0.0082645044, -0.0120465262, 0.0110543761, -0.0176488198, 0.0051796725, 0.0058033089, 0.0004423397, -0.0342748538, 0.0212824158, -0.0114830723, -0.0151403937, 0.0177492723, -0.0560783744, -0.0057152631, -0.0000117150, 0.0021056666, -0.0061730663, 0.0104397181, -0.0146355219, -0.0033821582, -0.0026272731, -0.0045267171, -0.0010234904, -0.0030984376, -0.0007631799, -0.0008013144, 0.0149035584, 0.0107685700, 0.0090419846, -0.0178012606, -0.0225421414, 0.0069107022, 0.0293277036, 0.0026066329, 0.0062316833, -0.0199454036, 0.0270582661, 0.0232353918, -0.0322337821, -0.0000680404, -0.0135739837, -0.0258544479, -0.0313100480, -0.0009856997, -0.0149116227, -0.0142331542, -0.0140177682, -0.0095834760, 0.0002561445, 0.0060660364, -0.0070557622, 0.0044923578, -0.0079760533, 0.0201972462, -0.0002686368, 0.0044706077, -0.0000039793, 0.0065863323, 0.0310907364, 0.0122992359, -0.0000617581, -0.0121272029, 0.0098958788, -0.0050192378, 0.0138474042, -0.0160183553, -0.0043551661, 0.0139807994, -0.0146092176, -0.0065695485, 0.0180771034, -0.0280590560, 0.0030166768, -0.0264082327, -0.0063813711, -0.0129468814, 0.0343174674, 0.0247451756, 0.0000576661, -0.0081583811, 0.0059311055, -0.0376004763, 0.0239072032, -0.0006677610, -0.0028469942, 0.0229316782, -0.0064561167, -0.0267070364, -0.0276256893, -0.0022125249, 0.0046500326, -0.0026870356, -0.0013255920, 0.0097180046, 0.0043965969, 0.0238471311, 0.0010295546, 0.0008727461, 0.0221898593, 0.0176240113, 0.0239905063, 0.0168260597, 0.0289914552, -0.0000005811, 0.0030948049, 0.0085513527, 0.0112123741, -0.0289204735, -0.0021272374, -0.0019353820, -0.0039773146, 0.0223846193, -0.0000155366, -0.0039399290, -0.0365842618, -0.0127468454, -0.0126723526, 0.0213681832, 0.0012028362, -0.0244144090, -0.0000001859, 0.0052866549, -0.0121524418, -0.0115673933, -0.0054105679, 0.0008608173, 0.0283188820, -0.0042190384, 0.0169844627, -0.0078315651, 0.0224930122, 0.0075437743, 0.0043276204, -0.0033949739, 0.0106829628, -0.0305050593, 0.0164119676, -0.0075518400, -0.0153036267, -0.0088159293, -0.0346148871, 0.0330498032, 0.0000039620, 0.0014677754, 0.0062011075, -0.0380926207, -0.0274738614, -0.0036265764, -0.0081673590, -0.0050730295, -0.0301755667, -0.0112846065, 0.0074979882, -0.0042000106, 0.0320422575, 0.0202963389, 0.0436386317, 0.0014402457, -0.0149448300, -0.0157782324, 0.0155407907, -0.0030709356, -0.0336659998, -0.0266108699, -0.0317659900, -0.0024335210, 0.0016623070, -0.0000010864, 0.0019917951, -0.0103703337, 0.0092999311, -0.0174516141, 0.0123743350, -0.0087573621, -0.0044627623, -0.0017126079, 0.0000049051, 0.0214484558, -0.0330432020, 0.0194149241, -0.0080456594, 0.0076369513, 0.0033861073, 0.0123620685, -0.0000000172, 0.0091775199, -0.0036214206, 0.0066894526, 0.0000146809, -0.0045539499, -0.0123709682, 0.0021252700, 0.0061862059, 0.0215101931, 0.0127514489, 0.0104063721, -0.0172067955, -0.0076630432, 0.0141353840, -0.0013236363, 0.0159540307, 0.0061157630, -0.0129731596, 0.0038122935, -0.0065395199, -0.0193950403, -0.0000034396, 0.0106631555, 0.0343526416, -0.0160454549, 0.0152381212, -0.0003693279, -0.0082288813, -0.0058911908, -0.0174686573, -0.0095663313, -0.0263055861, -0.0002032220, 0.0108429538, 0.0081921630, -0.0276325028, 0.0199380610, -0.0089596435, 0.0257035512, 0.0224171802, -0.0031815970, 0.0046912706, 0.0295992326, 0.0194960628, -0.0222132206, 0.0496022291, 0.0000011858, -0.0169189461, 0.0135980388, 0.0292590745, 0.0053691603, 0.0130701493, 0.0004461570, -0.0251516309, 0.0141485920, -0.0000001128, -0.0185352899, -0.0277789831, -0.0017487393, -0.0215087328, 0.0249783881, 0.0092339749, 0.0020290834, -0.0000000472, 0.0018741649, -0.0187485795, 0.0007050094, -0.0019088144, 0.0114559252, 0.0353123881, -0.0132042132, 0.0014624720, 0.0093222465, 0.0047638067, 0.0109455604, -0.0178588368, -0.0026732839, 0.0121220602, -0.0094640888, 0.0336187929, -0.0037699221, -0.0150650842, 0.0165712368, -0.0205419529, -0.0147227077, 0.0000590469, -0.0278698187, 0.0251357984, -0.0179907084, -0.0181337986, 0.0037580314, -0.0171582270, -0.0150114819, 0.0004725384, 0.0014072707, 0.0059212954, -0.0164232012, -0.0473228246, 0.0167190954, 0.0330398344, 0.0000033205, 0.0045414269, 0.0220154990, -0.0024046388, 0.0162498448, -0.0072599999, -0.0320639722, -0.0035619736, -0.0039476641, -0.0058085537, 0.0000002656, -0.0047904658, 0.0332442336, -0.0040372116, -0.0189898610, -0.0020764815, -0.0028223949, 0.0082327724, 0.0079501998, -0.0000004138, -0.0097907130, -0.0103992531, 0.0137846889, -0.0178464092, -0.0062767048, 0.0007156623, -0.0142329847, 0.0000000060, 0.0020827781, -0.0108676804, -0.0115261730, 0.0000162399, 0.0014429509, 0.0184480920, -0.0144445011, -0.0019444400, -0.0017511741, 0.0072427439, 0.0114999050, -0.0341800302, 0.0053561651, 0.0060345866, 0.0079947291, 0.0087661808, 0.0205853879, -0.0032916099, -0.0007127434, 0.0051616114, -0.0005136445, 0.0000000645, 0.0054735173, -0.0309996195, 0.0088304682, -0.0163623914, 0.0001884095, -0.0006771806, 0.0037695328, -0.0129271066, -0.0010191732, -0.0022876572, -0.0014989672, -0.0254548993, 0.0277553592, 0.0036468937, 0.0228924584, 0.0011725670, -0.0142748915, 0.0271697026, -0.0078109563, -0.0195366796, -0.0104547422, -0.0087607084, -0.0177385230, -0.0162573196, 0.0000034714, 0.0104388315, -0.0154069178, 0.0175951272, -0.0127093596, 0.0045586266, -0.0002420549, 0.0343744271, -0.0003745823, -0.0000817626, 0.0082964199, -0.0181381442, -0.0102632558, 0.0261784252, -0.0247920565, -0.0009213805, -0.0069445446, 0.0000002119, -0.0316825993, -0.0018426540, -0.0074324356, -0.0008610740, -0.0014895807, -0.0049081817, -0.0466872975, -0.0323959067, 0.0291261878, -0.0186574962, -0.0117946947, 0.0057869381, 0.0109833032, -0.0215807278, 0.0421738811, -0.0232552569, 0.0356064439, 0.0126694199, 0.0120277330, -0.0039843270, -0.0216308124, -0.0000129485, 0.0110558812, -0.0467482097, 0.0443373173, 0.0091261892, -0.0018580657, 0.0095248744, 0.0101847518, 0.0057686376, -0.0035518990, 0.0175851118, -0.0000830983, -0.0115870852, -0.0140385889, -0.0067050601, 0.0064479420, -0.0080366451, -0.0302708503, 0.0148515599, -0.0069408780, -0.0069432887, 0.0114157340, 0.0098530194, 0.0229063388, -0.0059186537, 0.0000003477, -0.0139868483, 0.0031670092, -0.0361630358, 0.0137189394, -0.0017685883, -0.0082702637, -0.0005263446, 0.0007835436, -0.0000001156, 0.0163857527, -0.0291904099, 0.0207936261, 0.0125224330, 0.0324481912, -0.0015334918, -0.0064259931, 0.0000000000, 0.0025531307, -0.0178044941, -0.0309635121, -0.0004036757, 0.0086959330, 0.0227610301, 0.0107332487, 0.0134232827, 0.0050310530, 0.0224801451, -0.0073429747, -0.0142585244, -0.0055962405, 0.0190875977, -0.0159365628, -0.0042011435, -0.0184735805, -0.0197630096, -0.0060701435, -0.0222021770, -0.0308975670, 0.0000022060, 0.0019388944, -0.0075160912, -0.0073296051, 0.0064373743, 0.0001215849, -0.0075673684, -0.0134199485, -0.0107424669, -0.0099010672, -0.0086337775, -0.0007043543, 0.0257926416, 0.0138634350, -0.0009024760, 0.0069509218, -0.0059022270, 0.0250262264, 0.0487142392, -0.0143325794, 0.0038758754, -0.0076632858, 0.0252468754, 0.0143001955, -0.0228736531, -0.0000105114, 0.0094919652, -0.0122191189, 0.0158557594, -0.0132142613, -0.0007183504, -0.0163383968, -0.0190964732, -0.0153648201, -0.0000000001, -0.0046113431, 0.0078471834, 0.0149812326, -0.0060074306, 0.0026965886, 0.0017770062, -0.0015809145, 0.0000000285, 0.0026881816, 0.0289704874, -0.0059560589, 0.0000375195, -0.0039512902, 0.0040883636, -0.0017399115, 0.0300868414, 0.0027926737, 0.0176817458, 0.0187326614, -0.0321455449, 0.0040051709, -0.0286644269, 0.0077395625, -0.0122832004, 0.0015622850, 0.0061920742, -0.0142941233, 0.0120105334, 0.0275387000, 0.0000107619, -0.0126050273, 0.0080997162, -0.0200128984, -0.0038476179, 0.0004312229, -0.0208179671, 0.0269809440, 0.0148123205, -0.0080272034, 0.0039925152, 0.0002566227, 0.0080215652, 0.0052469098, 0.0032223575, -0.0197053645, 0.0069396687, 0.0162503812, -0.0169902686, 0.0355697535, -0.0228642412, -0.0363137275, -0.0198886767, -0.0100952303, 0.0213601030, 0.0000157294, -0.0194265358, 0.0129663805, 0.0220130309, 0.0026102816, 0.0056955181, 0.0114662172, -0.0273503661, -0.0036879857, -0.0000010012, -0.0018712111, -0.0086212009, 0.0301047694, -0.0155295152, -0.0185048394, 0.0005862217, 0.0208343510, 0.0000002801, 0.0083774328, 0.0070831263, 0.0450279191, 0.0012293847, 0.0005469755, -0.0215302259, -0.0203445815, -0.0038701505, -0.0055594617, -0.0205031373, 0.0251885522, -0.0097191948, 0.0027688381, 0.0100009795, 0.0026780835, 0.0308466088, -0.0014739810, -0.0063450877, -0.0186544769, 0.0324692279, 0.0085009905, 0.0000050942, 0.0262682196, 0.0391213298, 0.0197435506, 0.0261670444, -0.0007289575, -0.0170976408, -0.0207762215, -0.0163987223, 0.0006409844, -0.0017600188, 0.0014859512, -0.0242796335, 0.0071119685, 0.0341934599, 0.0085095651, 0.0231136661, 0.0281453319, -0.0038628376, -0.0021139090, -0.0123828165, 0.0408552289, -0.0085673071, -0.0152512388, -0.0004508310, 0.0000021819, 0.0084101735, -0.0150641408, 0.0136734480, -0.0149095245, 0.0154798655, -0.0127065266, -0.0118102422, -0.0014527091, -0.0000002724, 0.0269794296, -0.0639845878, -0.0087421676, -0.0082308995, 0.0088498425, 0.0057328930, -0.0178168360, -0.0000006096, 0.0014568385, 0.0059206262, 0.0146313328, -0.0026560267, 0.0076916763, 0.0059529822, -0.0046032276, 0.0026203978, 0.0025858355, 0.0061410088, 0.0154430289, -0.0048571462, -0.0057163048, 0.0136503726, 0.0017762471, 0.0062840665, 0.0071289483, 0.0079767741, -0.0175435431, -0.0319262855, -0.0033080534, 0.0000019126, 0.0239266548, 0.0072924499, -0.0035505951, -0.0108650466, -0.0007020412, -0.0203493629, 0.0006221735, -0.0114831580, -0.0234449953, -0.0110132126, -0.0029121477, -0.0089968322, -0.0062520476, 0.0023864328, 0.0182245560, -0.0086451042, 0.0467364751, 0.0262775254, -0.0065628299, -0.0170489866, -0.0074406774, -0.0019028466, -0.0200365391, 0.0482996069, 0.0000181286, -0.0043450329, 0.0191238932, -0.0047224397, 0.0303517897, 0.0133938538, 0.0077909171, -0.0287931059, 0.0072480743, -0.0000043229, -0.0255906042, 0.0325613394, -0.0183002986, -0.0259689484, -0.0003390086, 0.0018806395, -0.0219077729, 0.0000002296, -0.0214419980, -0.0394250080, 0.0068215914, -0.0007780782, 0.0043048663, 0.0098311733, -0.0006196058, -0.0089080790, -0.0296630021, -0.0264796019, 0.0032568539, 0.0248842072, 0.0298120230, -0.0047628023, -0.0283249430, 0.0291436836, 0.0031991843, 0.0154516771, 0.0165676102, -0.0084066112, 0.0001679229, -0.0000407371, 0.0117554488, -0.0166958105, 0.0300031211, -0.0012204892, -0.0012159614, -0.0245459918, -0.0146831768, 0.0221187193, 0.0122978166, 0.0161970258, 0.0014356371, -0.0376745611, -0.0242897440, 0.0431609079, -0.0253363606, -0.0201313589, 0.0255200248, -0.0082637947, -0.0156464633, -0.0025491717, -0.0000221427, -0.0000926026, 0.0161973871, -0.0099501750, 0.0000000467, -0.0030873921, -0.0092611667, -0.0099400766, -0.0035954544, -0.0075094867, -0.0132731069, -0.0145789068, -0.0055675581, -0.0000088052, 0.0056332233, 0.0125807002, -0.0023790339, 0.0141391912, 0.0205504876, 0.0013021358, 0.0240419768, 0.0000000000, 0.0140071213, 0.0115629667, 0.0045996741, 0.0001768003, 0.0009824063, -0.0096805906, 0.0156412590, -0.0041168560, 0.0083967131, -0.0146807823, 0.0002466930, -0.0010347778, 0.0068453685, -0.0020785935, -0.0053914934, -0.0078427605, 0.0099915899, 0.0080309985, 0.0033208581, 0.0001113936, -0.0237808321, 0.0000002191, -0.0089930873, 0.0080496185, -0.0105548501, -0.0123526054, 0.0002686004, -0.0011452278, 0.0126063274, 0.0091078933, 0.0127575211, -0.0059747580, -0.0049728914, 0.0040737223, -0.0186721534, -0.0087667312, -0.0120978840, 0.0032156347, -0.0066594891, 0.0034044816, 0.0070552840, 0.0045422865, 0.0012044924, 0.0159266368, 0.0271562040, -0.0095533095, -0.0000168642, 0.0398153923, -0.0075278417, 0.0084406883, -0.0351673551, -0.0063094674, -0.0115448665, 0.0029940186, 0.0052196397, -0.0000004747, 0.0138390427, -0.0199797004, -0.0246714726, -0.0249912664, 0.0077141449, -0.0036641299, 0.0245987810, -0.0000061260, -0.0038910685, 0.0194842964, 0.0206836462, -0.0025452061, -0.0031961028, 0.0147139961, 0.0205831677, 0.0107412329, 0.0148026142, 0.0064927605, 0.0310190972, -0.0276498348, -0.0312410761, 0.0111404955, 0.0015017742, -0.0061205407, -0.0083313016, -0.0275171548, -0.0053222375, 0.0091446554, 0.0047773090, 0.0000690003, -0.0049797967, -0.0012291058, -0.0494490154, -0.0014394184, -0.0058224276, -0.0014871416, 0.0205937624, 0.0050243884, -0.0285330564, -0.0302430075, -0.0011137601, 0.0034354043, -0.0126948012, 0.0137674175, -0.0015166716, -0.0048431745, 0.0106315995, -0.0214949306, 0.0176198538, -0.0007652477, -0.0093085393, 0.0025353071, -0.0031144589, -0.0086932909, -0.0000000040, -0.0258292295, 0.0113520008, -0.0187642183, -0.0063929060, 0.0021525195, -0.0016759232, -0.0027474004, -0.0010422493, 0.0000000396, 0.0196780115, -0.0032757742, -0.0017481366, 0.0161680747, -0.0052490640, -0.0003738135, 0.0006606124, 0.0000000723, 0.0042568790, -0.0101302499, -0.0097874394, -0.0001597940, -0.0002872076, -0.0168827996, -0.0196632557, 0.0130450036, 0.0090673640, 0.0101216342, 0.0070755067, 0.0135671720, -0.0010224159, 0.0095160436, -0.0092577999, -0.0011713877, -0.0016983816, -0.0067105293, -0.0167319030, 0.0023911267, 0.0183434058, -0.0000000017, 0.0047568036, 0.0258329734, 0.0266404022, 0.0038604152, -0.0002535681, -0.0021829596, -0.0079394067, -0.0050733387, -0.0074871518, 0.0160651524, 0.0002662847, -0.0048310505, -0.0090518212, -0.0156991780, 0.0203953106, 0.0078239739, 0.0247237068, -0.0032118768, -0.0100761931, -0.0131529467, -0.0141890179, -0.0010719362, -0.0150657240, -0.0050339894, -0.0000000008, -0.0091194687, -0.0020408551, -0.0062655048, -0.0065266211, 0.0061559039, -0.0007720359, 0.0005010545, 0.0048581394, 0.0000002521, -0.0052456306, -0.0020052495, -0.0101820370, 0.0142248757, 0.0043741884, 0.0001158236, -0.0168391597, -0.0000000097, 0.0123235621, -0.0010569579, -0.0034176775, -0.0000119940, -0.0131254792, -0.0078154579, 0.0080536753, 0.0043606157, -0.0036114452, 0.0041035539, -0.0028492771, 0.0038937896, -0.0099842884, -0.0130977714, -0.0175589137, -0.0125941560, 0.0017464913, -0.0052035153, -0.0093097193, -0.0106014041, 0.0077604279, 0.0000000001, 0.0007489355, 0.0108926008, -0.0039097387, -0.0030347193, 0.0001701349, 0.0120804291, -0.0108592119, 0.0009510231, -0.0072706956, 0.0183990560, 0.0000854147, 0.0168800764, 0.0096837692, 0.0095381336, 0.0041807839, -0.0127723180, 0.0016153113, 0.0018050568, -0.0126889022, 0.0003357862, -0.0044543971, 0.0019682818, 0.0169758871, -0.0096914498, 0.0000000247, -0.0084815957, -0.0130716357, -0.0345300622, 0.0074712727, 0.0000091478, -0.0068803723, -0.0003321338, -0.0185060613, -0.0001072763, 0.0126981866, 0.0058662090, -0.0145945540, 0.0264893565, 0.0252972506, 0.0012852163, 0.0167669524, 0.0000000362, 0.0097452663, -0.0023440379, -0.0085654957, -0.0000759153, -0.0071663829, -0.0013159895, 0.0152326627, 0.0056025973, 0.0144818937, 0.0193102546, -0.0019232805, 0.0153629705, 0.0061189374, 0.0020638702, -0.0040611168, -0.0221959352, -0.0191058945, 0.0106142983, -0.0058951424, 0.0151988966, -0.0052212821, -0.0000000215, -0.0079135643, -0.0038467585, -0.0095322300, -0.0047356104, -0.0035140642, -0.0026978846, 0.0171833336, 0.0322441943, 0.0014955621, -0.0030357526, 0.0002485747, -0.0043459977, -0.0156137887, -0.0053071538, -0.0178068317, 0.0024488789, 0.0185467321, -0.0074232128, -0.0182773117, 0.0058327615, -0.0226458646, -0.0101521146, -0.0189323165, -0.0103419060, 0.0000000212, -0.0119822547, -0.0153659005, -0.0132487910, -0.0151825547, 0.0243600104, -0.0015614250, 0.0038663689, 0.0000097756, 0.0000339633, 0.0095054721, -0.0045920829, -0.0202518906, 0.0238158684, 0.0041212286, 0.0002007149, -0.0103192460, -0.0000005483, -0.0199289005, 0.0119259162, 0.0093733296, 0.0001472554, 0.0073236516, -0.0085022878, -0.0079586478, -0.0160511546, 0.0191873312, -0.0032683485, -0.0007790903, -0.0063494327, 0.0037093677, -0.0334948786, 0.0040073148, -0.0053660325, 0.0184335671, 0.0073036510, -0.0032032111, -0.0083297919, -0.0127272336, 0.0000000162, -0.0065292004, -0.0222305153, -0.0000500664, -0.0104855113, 0.0008371067, 0.0151020773, 0.0014868531, 0.0065030647, -0.0133112539, 0.0023129396, 0.0004468354, 0.0151890554, 0.0152806686, 0.0038550147, -0.0030854500, -0.0102186855, -0.0028963222, 0.0102267638, -0.0000666143, 0.0027925866, -0.0115289045, -0.0213187039, 0.0011337848, -0.0005567328, 0.0000000039, 0.0044494602, -0.0096063809, 0.0037233981, 0.0052229343, 0.0030954345, -0.0008298624, 0.0236765426, 0.0048119533, -0.0000099512, 0.0120939938, -0.0218743663, 0.0054470180, -0.0011823754, 0.0110009247, 0.0022473619, 0.0067984974, 0.0000000164, 0.0192823429, -0.0042062118, -0.0182996150, 0.0000032452, -0.0078998320, 0.0182400215, 0.0070937444, -0.0032589750, 0.0005138434, 0.0056335363, -0.0122891907, 0.0026711219, 0.0060420134, 0.0087644001, -0.0115055908, -0.0008981854, -0.0061246091, 0.0021906826, 0.0053292769, -0.0009314588, -0.0067317262, 0.0000000007, -0.0151178185, -0.0083191134, -0.0088930465, 0.0021697734, 0.0001167705, 0.0011462615, -0.0034276552, -0.0022726087, 0.0118061397, -0.0026689693, -0.0068716789, -0.0025781046, -0.0020397147, -0.0046648462, 0.0011013164, -0.0043582646, -0.0179938544, -0.0045802579, -0.0104705589, 0.0058062258, -0.0078269094, -0.0074693463, -0.0065034255, -0.0157064013, -0.0000013488, -0.0173864793, -0.0270060878, -0.0247731805, 0.0184643082, -0.0005288413, -0.0126973642, 0.0009076091, -0.0132548520, -0.0001114216, 0.0121109923, 0.0161788315, -0.0090514785, 0.0333602764, 0.0144741097, 0.0005538785, -0.0023357256, 0.0000001385, -0.0041992865, 0.0022172595, -0.0230948906, -0.0000233278, -0.0120968623, 0.0092199948, 0.0127469869, 0.0014997066, 0.0030462507, 0.0081006363, -0.0156986322, 0.0055912957, 0.0009499847, -0.0219053756, -0.0047992840, -0.0208342578, -0.0196158197, 0.0100976061, 0.0078939768, 0.0003905064, -0.0016384800, -0.0000001090, -0.0015039884, -0.0098974425, 0.0012154817, -0.0028675578, -0.0002185106, 0.0059025101, 0.0099868728, 0.0389573686, 0.0013818984, -0.0006625626, 0.0001166452, 0.0067010093, -0.0275413468, -0.0006023844, -0.0155350603, -0.0077682850, 0.0081533054, 0.0139597729, -0.0090205949, 0.0221814029, -0.0010920824, 0.0105009200, 0.0016227327, -0.0000764221, 0.0000000006, -0.0098821232, -0.0078706127, -0.0128658144, 0.0005811423, 0.0021914486, -0.0045802966, -0.0067461329, -0.0113933673, -0.0000000304, -0.0130294375, 0.0032216283, 0.0163591336, -0.0148877604, 0.0122023039, 0.0008147541, 0.0036505088, -0.0000001605, 0.0028361303, 0.0003352566, -0.0101811746, -0.0043589924, -0.0035252823, 0.0160758514, 0.0013839629, 0.0031921901, -0.0036105604, 0.0051122727, 0.0026134467, -0.0056282431, -0.0044986312, 0.0203951616, 0.0060507986, 0.0019645926, -0.0023763974, -0.0068706186, -0.0016775691, 0.0236343332, 0.0009604389, -0.0000000010, -0.0118955998, -0.0136562483, -0.0114702517, 0.0055065262, 0.0000460553, -0.0006664056, 0.0049026646, 0.0172019918, -0.0166079886, -0.0021331704, -0.0177127309, -0.0089622485, -0.0016959275, -0.0070150304, -0.0139673455, -0.0036958505, 0.0070060254, -0.0143759688, -0.0140027842, 0.0141569469, -0.0223202165, 0.0375589803, 0.0383948460, 0.0453889631, -0.0000016392, 0.0007674313, 0.0135786887, -0.0037180108, -0.0198444743, -0.0005241857, 0.0062397858, -0.0059339637, 0.0168580078, -0.0001181898, -0.0097667705, 0.0005959015, 0.0204623993, -0.0376139134, 0.0055585578, -0.0063036643, 0.0233151112, -0.0000039830, 0.0037344105, -0.0019700597, -0.0015363310, 0.0011163149, -0.0017494152, 0.0299897566, 0.0036992813, 0.0006547443, 0.0023561055, 0.0127818882, 0.0258886982, 0.0070010955, 0.0046361727, 0.0044057518, 0.0002667981, 0.0476553552, -0.0253241006, -0.0155261494, -0.0086305672, 0.0057528918, -0.0177447982, -0.0000042056, -0.0235670898, 0.0464211442, -0.0310852714, -0.0208817404, 0.0033706652, -0.0053742905, -0.0252480544, 0.0085685262, -0.0006201256, 0.0127831958, 0.0013960664, -0.0424821228, 0.0159661733, 0.0084454129, 0.0047141267, 0.0082757985, 0.0013143810, 0.0054307845, 0.0008393939, -0.0012978908, -0.0290579665, 0.0155049749, 0.0077954736, 0.0013093310, -0.0000040400, 0.0314241424, 0.0247615688, 0.0051536690, -0.0191917010, -0.0094781974, -0.0080755604, -0.0013994396, 0.0019222186, -0.0000006028, 0.0064100293, -0.0126872612, -0.0148514062, -0.0234616306, -0.0082817040, -0.0020308793, 0.0054399725, -0.0000063905, -0.0020223265, -0.0052281632, 0.0071521755, -0.0028497323, 0.0025923939, 0.0041347733, 0.0136401476, 0.0049690725, 0.0142758936, -0.0117847864, 0.0259712804, -0.0024498662, -0.0130403209, 0.0091754962, -0.0025284444, 0.0132605443, -0.0030247774, -0.0116210962, -0.0201206375, 0.0167006161, -0.0034920913, -0.0000900429, -0.0085110087, 0.0211913306, -0.0334036164, -0.0019443212, -0.0116398381, -0.0027506435, -0.0029969409, 0.0163588673, 0.0028326618, -0.0153892701, 0.0007560847, -0.0174689181, -0.0140670501, -0.0033788844, 0.0218123104, 0.0096808942, -0.0016585245, -0.0282910615, 0.0050188443, 0.0138988672, 0.0211412013, 0.0071479990, 0.0042613340, 0.0014811159, -0.0000173770, -0.0454627573, 0.0168644674, 0.0063107722, 0.0181564335, 0.0157968290, 0.0068631647, -0.0104818717, 0.0091749877, 0.0000138036, 0.0114329616, 0.0187513102, 0.0145115899, 0.0172180533, 0.0093016718, -0.0005629977, 0.0148938447, 0.0001527080, -0.0184065737, -0.0001886363, 0.0053909891, 0.0008715795, 0.0142483776, 0.0118071139, -0.0285021625, 0.0028306160, -0.0080175884, 0.0073211873, -0.0021242392, 0.0068848622, 0.0202001203, -0.0091152862, -0.0233458299, 0.0283935927, 0.0074076145, 0.0115235411, 0.0117662856, -0.0048236595, -0.0077649280, -0.0000051237, 0.0059215180, 0.0101476032, 0.0288768280, 0.0155981639, 0.0000087749, -0.0144869797, -0.0135170370, -0.0163839478, 0.0210363101, -0.0072748889, 0.0022081954, 0.0125912540, 0.0027528815, -0.0138492230, -0.0074316734, -0.0007864020, 0.0148435319, 0.0253836419, 0.0060536857, 0.0075458158, -0.0036375707, 0.0142845791, -0.0043029627, -0.0111128893, 0.0000001095, 0.0142869363, -0.0028178191, 0.0038545944, -0.0047872593, 0.0001233930, -0.0130947363, -0.0059101908, -0.0046996130, -0.0000000293, 0.0124766836, -0.0278032329, -0.0102472045, -0.0069296174, 0.0055949069, -0.0007282570, 0.0050734370, -0.0000010124, 0.0011641799, 0.0149909938, 0.0099153277, -0.0018003321, -0.0008156953, 0.0040535172, -0.0037611315, 0.0126645621, 0.0123754200, 0.0199733134, 0.0240942799, -0.0112313777, -0.0136404186, 0.0138685247, 0.0003884953, -0.0122718094, 0.0121831885, -0.0044289529, -0.0147893773, 0.0259181466, 0.0158286653, -0.0000004085, -0.0075347782, -0.0116121983, -0.0101097953, -0.0071865986, -0.0039395792, -0.0039371811, 0.0205364283, 0.0125219291, -0.0095432913, -0.0116898520, -0.0054196189, 0.0041959491, -0.0133539997, -0.0153340250, -0.0013516241, -0.0082139652, 0.0260481518, -0.0180959236, 0.0020569225, -0.0014539170, -0.0281133968, -0.0066013741, 0.0012692196, -0.0095003424, 0.0000000000, 0.0178843811, 0.0003767543, -0.0096403090, -0.0187478364, 0.0128146280, 0.0034981901, 0.0052147373, 0.0113890069, 0.0000000493, 0.0155791491, -0.0226056855, -0.0251003578, 0.0194986351, 0.0060561206, 0.0011782141, -0.0049261386, 0.0000001278, -0.0117330933, 0.0018413176, -0.0035403881, -0.0001416218, -0.0011799874, -0.0167793259, 0.0024783763, 0.0105391312, -0.0002787074, -0.0071961917, -0.0013520439, -0.0005605335, -0.0027792035, -0.0138952574, 0.0012856503, -0.0125441356, 0.0067809038, -0.0057470938, -0.0039214287, 0.0055845310, -0.0037466972, 0.0000000001, 0.0081906365, 0.0073824865, 0.0064563644, 0.0088559752, -0.0035912136, 0.0036483526, 0.0048909686, -0.0075699631, -0.0100518409, 0.0035982060, 0.0001446185, 0.0337169208, -0.0080598732, 0.0085612806, -0.0016075058, -0.0123293987, -0.0024358758, -0.0011234066, 0.0104592443, 0.0023043968, -0.0019454603, 0.0260095093, 0.0120690446, 0.0146642122, -0.0000000109, -0.0202756375, 0.0123383496, 0.0024643790, 0.0025442305, 0.0025782995, 0.0039658314, -0.0277359709, -0.0016171968, 0.0000009085, -0.0104229432, 0.0159140639, 0.0100102955, -0.0199117456, 0.0015158748, -0.0019385134, -0.0003914864, 0.0000000358, 0.0178407934, 0.0080852285, 0.0056720632, 0.0002229937, -0.0015223511, 0.0115475217, 0.0127008129, -0.0027434709, -0.0014738406, 0.0052541061, 0.0066173775, -0.0000136752, 0.0235075857, -0.0064124656, 0.0048073656, 0.0052188989, -0.0014723452, 0.0157555118, -0.0026190509, -0.0013646707, -0.0075809513, 0.0000000070, -0.0092071453, 0.0160848927, -0.0257852320, -0.0150793446, 0.0025056328, 0.0020027617, -0.0153727997, 0.0011395509, 0.0064282175, 0.0045342143, 0.0012834027, -0.0220796242, 0.0239750259, 0.0222177673, -0.0221006013, 0.0073883203, 0.0076613510, -0.0014097191, -0.0105053494, 0.0036062135, -0.0446994714, 0.0024100966, -0.0083298944, -0.0040410077, 0.0000000019, -0.0051360610, -0.0132102845, 0.0057528317, -0.0012265261, 0.0040775016, -0.0062344973, -0.0053237951, -0.0039752754, -0.0000004168, 0.0051680114, -0.0171166323, 0.0092386566, 0.0069162352, 0.0008708787, 0.0022188874, -0.0011881083, -0.0000000001, 0.0038441047, -0.0032469768, 0.0125185102, -0.0008839631, -0.0050391513, -0.0062413090, -0.0016015901, 0.0022989870, -0.0001725236, 0.0045489985, 0.0123049561, -0.0160034802, -0.0070716538, -0.0125927180, 0.0023299281, -0.0111344494, -0.0168235991, 0.0064300150, -0.0060457722, 0.0220764540, -0.0094137741, 0.0000000016, -0.0139807072, -0.0178949162, 0.0000495364, -0.0063350718, -0.0001257902, 0.0031772091, 0.0055812458, 0.0130968839, -0.0044769985, -0.0088315206, -0.0018996494, -0.0100661675, -0.0090011368, -0.0079107666, -0.0042954204, -0.0087132016, 0.0182223469, -0.0006988405, 0.0044680708, -0.0015928901, -0.0137191601, 0.0139724975, -0.0055210157, 0.0038352392, -0.0000000000, -0.0077931182, -0.0008753622, 0.0054796119, -0.0004990046, 0.0064058811, -0.0022162141, -0.0060352893, 0.0023661926, 0.0000016728, 0.0023916503, 0.0035028616, -0.0026739091, 0.0078839771, 0.0103349397, 0.0006489027, -0.0048485394, 0.0000000310, -0.0033699456, -0.0018245134, 0.0117778378, 0.0000014548, 0.0016398993, 0.0035240236, -0.0091195507, -0.0106962156, 0.0181411281, -0.0029131526, -0.0010590313, -0.0027885814, 0.0095891887, -0.0035994898, -0.0094707320, -0.0062941392, 0.0163453370, -0.0066202092, -0.0009844360, -0.0014111515, 0.0005642828, 0.0000000000, 0.0004430661, -0.0084604425, -0.0011116813, -0.0029149493, 0.0000655321, 0.0037482348, 0.0004500220, -0.0066733803, -0.0011738082, -0.0035120156, 0.0000295041, 0.0000300749, 0.0026154211, 0.0002215735, 0.0018508148, 0.0014117213, 0.0065574921, 0.0183109641, -0.0068876632, 0.0012230937, -0.0255229026, 0.0297243316, 0.0064920839, -0.0008216529, 0.0000179730, 0.0099769915, -0.0154552720, -0.0005391558, -0.0206504241, -0.0085573802, -0.0154775446, -0.0174918976, -0.0003412838, 0.0000000001, -0.0077951620, -0.0150643522, -0.0028739881, -0.0328426845, 0.0072613098, -0.0041484516, 0.0143396202, -0.0000003249, 0.0002476272, 0.0274218507, 0.0232755933, -0.0028668959, -0.0026460474, 0.0211264864, -0.0012629671, 0.0006254824, 0.0198026635, 0.0011542398, 0.0233374685, -0.0202013031, -0.0122889429, 0.0135067785, -0.0046776035, 0.0048044682, -0.0017668074, -0.0191064849, -0.0123021770, 0.0114352619, 0.0100575201, -0.0000384898, -0.0137826838, 0.0163142662, -0.0428024344, -0.0074214861, 0.0006645057, -0.0098065427, 0.0262480360, 0.0007482787, -0.0289657600, -0.0226563737, -0.0051120580, -0.0131221013, 0.0060379445, 0.0075000362, 0.0112409117, 0.0040186788, 0.0222832486, -0.0205239076, -0.0036383013, 0.0011904098, -0.0010210220, 0.0136511000, -0.0034558743, 0.0082103666, 0.0000020789, 0.0105510261, 0.0144903334, 0.0193155501, 0.0289327167, 0.0221785698, 0.0026825552, 0.0015042324, -0.0058201295, -0.0000022060, -0.0120417420, 0.0113631645, -0.0101483958, -0.0127184112, 0.0070475810, 0.0008100745, -0.0090620993, 0.0000002538, -0.0231105052, -0.0038169187, -0.0106175728, 0.0008499442, 0.0036042137, -0.0039956081, 0.0256633647, 0.0200970005, -0.0341922641, 0.0013735024, -0.0102422377, 0.0030267397, -0.0137477126, -0.0049261781, 0.0009253427, 0.0050622984, -0.0118550267, 0.0134449564, 0.0068278178, 0.0016663061, 0.0101937745, -0.0000024158, 0.0023271376, -0.0218904875, 0.0078387232, 0.0146946711, -0.0145576401, -0.0015839911, 0.0031223735, 0.0114903180, 0.0025075285, -0.0018181314, 0.0009986568, 0.0243595056, 0.0321667045, 0.0028233198, -0.0036604297, -0.0183348041, -0.0121671474, -0.0066312007, -0.0077105695, 0.0447122306, 0.0160926450, 0.0127604567, 0.0144454995, 0.0240359101, -0.0000297992, 0.0408149064, 0.0186607298, -0.0255010687, -0.0352652781, -0.0033506120, 0.0042695971, -0.0006189181, 0.0163307339, 0.0000014029, -0.0255622156, -0.0124591114, 0.0072844629, -0.0210634079, -0.0049962602, -0.0080920374, -0.0146859353, -0.0000007662, -0.0056871395, 0.0131347878, 0.0296946764, -0.0024508298, -0.0100321174, 0.0071158474, 0.0033665875, 0.0050241295, -0.0029442436, 0.0016660198, 0.0084508648, 0.0084995059, 0.0015842094, 0.0102205919, -0.0261727683, 0.0035101024, -0.0221035611, -0.0238813199, -0.0214165486, 0.0010515728, 0.0431260020, -0.0000023270, -0.0046750065, -0.0125035606, -0.0346198715, 0.0163421407, -0.0038743226, 0.0040020905, 0.0173235778, -0.0185281243, -0.0192453414, -0.0044556228, 0.0017317411, 0.0296576433, -0.0019032542, 0.0250381045, 0.0080315061, 0.0105961477, -0.0184193682, 0.0027490810, -0.0200210512, -0.0149812670, 0.0409753658, -0.0037228742, -0.0130265635, -0.0065652318, 0.0000005725, -0.0161788408, -0.0175810717, -0.0022956445, 0.0180012323, 0.0110396342, -0.0133799948, 0.0146935172, -0.0095382407, 0.0000005125, 0.0168621708, 0.0024593843, 0.0011033880, 0.0255849212, 0.0173207298, 0.0002464969, -0.0041401265, -0.0000387045, -0.0135625238, -0.0088674044, -0.0295331515, -0.0000373518, -0.0043349522, 0.0105375024, 0.0041761487, -0.0087028099, 0.0004836632, 0.0093724541, -0.0149054946, 0.0078319088, -0.0053583574, -0.0008659250, -0.0070739491, -0.0147307003, -0.0051011085, 0.0005908466, 0.0072592706, -0.0160740912, -0.0120978598, -0.0000008597, -0.0008065026, -0.0038704921, 0.0064081722, 0.0026626836, 0.0000638350, 0.0015943561, 0.0054050419, 0.0171920564, 0.0008136020, -0.0095916865, -0.0047829608, 0.0141536267, 0.0093867555, -0.0239000544, -0.0022498469, -0.0111903986, 0.0066471142, 0.0112792067, -0.0008482191, 0.0213861391, -0.0191603806, -0.0003140983, 0.0019139563, -0.0114765493, -0.0000074073, 0.0251814481, -0.0045286873, 0.0052535119, -0.0157991331, -0.0038135534, -0.0129724983, -0.0054534297, 0.0027676946, -0.0000009070, 0.0049122320, -0.0299042370, 0.0066504474, 0.0017147288, 0.0042873607, -0.0024541717, 0.0160698351, -0.0000060749, 0.0008355998, 0.0025293177, 0.0140145915, -0.0053844708, -0.0216062982, -0.0068889633, 0.0109894397, -0.0181103293, 0.0263729803, 0.0008756427, 0.0142630022, -0.0232628491, -0.0257621780, 0.0121872369, -0.0051970021, 0.0066441302, -0.0187833793, -0.0125863375, -0.0152246756, 0.0265702903, -0.0089846011, 0.0000095522, 0.0004937384, 0.0034676718, -0.0269449409, -0.0044203238, -0.0018696255, 0.0141003542, 0.0049097603, 0.0159843229, -0.0110783791, -0.0176978596, -0.0010236142, -0.0074060401, -0.0256651007, -0.0156215634, 0.0177749190, -0.0048699281, 0.0059061525, 0.0023843730, -0.0016119938, 0.0002286601, 0.0023679957, 0.0220395513, 0.0042361636, -0.0091477763, -0.0000006572, -0.0092449859, -0.0044356072, -0.0008814417, 0.0013976251, 0.0080862576, -0.0074594659, -0.0014029978, -0.0052276840, 0.0000000507, 0.0149766440, 0.0033734809, -0.0034211716, -0.0052273395, 0.0084928377, -0.0049750223, 0.0020239996, -0.0000000532, -0.0204780381, 0.0042890222, -0.0132728741, 0.0004017636, 0.0037998029, 0.0247806050, -0.0063730362, 0.0104216803, 0.0000194963, 0.0082238549, 0.0057751802, -0.0132125765, -0.0088409698, -0.0009062120, -0.0077025192, -0.0047286646, -0.0068013393, -0.0151208835, 0.0044062342, -0.0054260055, 0.0121926842, -0.0000041642, -0.0025372580, 0.0041463845, -0.0055745593, 0.0183825959, -0.0060237534, -0.0121426396, 0.0213373583, 0.0016292302, -0.0086725196, -0.0131438859, -0.0028505230, 0.0100343842, 0.0137816714, -0.0132316025, 0.0068198582, -0.0101460330, 0.0067099701, 0.0076579507, -0.0022027837, 0.0173366182, 0.0042317300, 0.0005716915, -0.0137363644, 0.0009444901, 0.0000000076, -0.0100068664, -0.0010643522, -0.0083015421, -0.0008535433, 0.0068893153, -0.0041103717, -0.0149863614, -0.0117653925, 0.0000001938, -0.0045797606, 0.0033986855, -0.0014975683, 0.0079074232, 0.0060865437, -0.0007709328, 0.0006979202, -0.0000002545, -0.0021896202, 0.0003758676, 0.0184313767, 0.0000003289, -0.0040727668, -0.0050108307, -0.0147850597, -0.0179149583, 0.0122751314, -0.0104074376, 0.0030765764, -0.0064003845, -0.0030307795, 0.0120816110, -0.0031392439, 0.0051644729, -0.0011151072, -0.0004878100, -0.0049478873, 0.0148203019, 0.0030732986, 0.0000000048, -0.0000109974, 0.0005760628, 0.0001697417, 0.0006700821, -0.0000000798, -0.0093733156, 0.0079214489, 0.0063897949, -0.0154786445, 0.0008784237, -0.0001693334, -0.0209596362, -0.0021977241, 0.0073890756, 0.0042174133, -0.0087664248, 0.0221493673, 0.0106085949, -0.0164839625, 0.0030040350, -0.0199391376, 0.0145880030, 0.0020656195, 0.0073770308, -0.0000001300, -0.0161777772, 0.0075382311, 0.0148282954, -0.0124485753, 0.0123632941, 0.0003946785, 0.0030132977, 0.0061245379, 0.0000012957, 0.0215637311, -0.0201818701, -0.0117250672, -0.0024770198, 0.0109767104, 0.0026115379, 0.0076426496, 0.0000000060, -0.0129564460, -0.0008938934, -0.0150663862, -0.0021766124, 0.0049211336, 0.0150688458, -0.0210966356, 0.0268861894, 0.0026728634, 0.0207291357, 0.0001753058, 0.0029165433, 0.0081875715, 0.0056613884, 0.0116072036, -0.0057618143, 0.0010905820, 0.0072912797, 0.0058050985, -0.0108885029, 0.0068798633, -0.0000002469, -0.0009182032, 0.0072906320, 0.0182047877, 0.0035489090, -0.0060632154, -0.0145202819, 0.0066305939, -0.0170383379, 0.0039195991, -0.0064668702, 0.0002771563, 0.0282599088, 0.0132600367, -0.0211526658, -0.0072739138, 0.0000641921, -0.0003688881, 0.0094275651, 0.0242847614, -0.0019850852, -0.0283285193, -0.0238713119, -0.0107146604, 0.0224354323, 0.0000000000, -0.0195534695, 0.0052303565, 0.0158194304, -0.0444828123, 0.0254974030, 0.0070484779, 0.0064490396, 0.0130687077, 0.0000006225, 0.0114239790, -0.0279183500, -0.0095150340, -0.0123892296, -0.0065050866, 0.0023460169, -0.0002760821, 0.0000001731, -0.0094616888, 0.0044788090, 0.0135130687, 0.0000107192, 0.0078824135, -0.0010997222, -0.0119674802, 0.0182729177, 0.0060427035, -0.0105790738, 0.0092291376, 0.0031669999, -0.0019978983, -0.0086848661, 0.0080987103, 0.0164956078, 0.0272706803, 0.0149110556, -0.0085575450, 0.0189866647, 0.0028693918, -0.0000000002, 0.0189165827, 0.0181941688, 0.0147022549, -0.0047965352, -0.0045129573, -0.0099427998, -0.0057400288, -0.0137340818, 0.0064342595, -0.0000755739, 0.0017643828, 0.0033765433, 0.0063050166, 0.0012235098, -0.0063416064, -0.0032117772, 0.0049512777, 0.0069495672, -0.0003881837, -0.0021818213, 0.0157693028, -0.0155801727, 0.0020754605, -0.0143109942, 0.0000011500, -0.0007596817, -0.0244477745, -0.0048029255, 0.0127927326, 0.0015053351, 0.0024856986, 0.0101505341, -0.0150672309, 0.0000782398, 0.0089580016, 0.0102177914, -0.0132504925, 0.0182017647, 0.0097216275, 0.0014542904, -0.0001038287, 0.0000132262, 0.0155383265, -0.0062547144, -0.0089624748, 0.0007501376, 0.0042073783, -0.0261454210, 0.0129638184, -0.0192483943, 0.0160339419, -0.0082491916, -0.0165526699, -0.0024173358, 0.0014776170, -0.0077679176, 0.0108509725, 0.0180638935, 0.0283482894, -0.0085829515, 0.0124467760, -0.0102773653, -0.0160770826, -0.0000000355, -0.0020323580, -0.0058744922, 0.0059970487, -0.0016037597, 0.0035260736, 0.0149544533, 0.0013242811, 0.0080982372, 0.0055218772, -0.0046839872, 0.0011699662, 0.0015920134, 0.0030354934, -0.0203461703, 0.0031647854, 0.0059027039, -0.0110334298, 0.0135086346, -0.0066182534, 0.0086884266, 0.0084893676, -0.0042595030, -0.0036781360, -0.0001037373, -0.0000000002, -0.0271991976, -0.0094299773, -0.0150230005, -0.0303252675, 0.0176073816, -0.0049924194, 0.0049532442, -0.0011314843, -0.0000000420, 0.0011631373, -0.0209143404, -0.0093937200, 0.0164550599, 0.0182618499, 0.0010003587, 0.0001430610, 0.0000000486, -0.0117056398, -0.0056383517, -0.0005381668, -0.0000366455, 0.0043384372, -0.0026698879, -0.0086412989, -0.0029097432, 0.0028905503, -0.0002748100, -0.0104536889, 0.0032293259, -0.0078697698, 0.0074184695, -0.0104579888, 0.0000590985, -0.0004600197, -0.0042530326, -0.0087974826, 0.0062217722, -0.0033304763, -0.0000000008, 0.0146375280, 0.0162026435, 0.0046014306, 0.0020989140, -0.0002344828, -0.0058346521, -0.0053180847, -0.0037091468, -0.0104213115, 0.0060746823, -0.0000652245, 0.0340973288, 0.0008248386, 0.0022776749, -0.0105422288, -0.0133090885, 0.0049977666, 0.0225882586, -0.0115823708, -0.0044029136, -0.0191623680, 0.0234481469, 0.0204551835, -0.0136323990, -0.0000000004, 0.0152696297, -0.0056583709, -0.0140057625, -0.0054651741, -0.0115580652, -0.0180793442, -0.0142707815, -0.0034954783, -0.0000000037, 0.0428164154, -0.0121238455, -0.0086899716, 0.0028498759, 0.0064706365, -0.0066926060, 0.0079073803, -0.0000003791, 0.0055751726, 0.0002587234, -0.0457601845, -0.0112614138, 0.0000229237, 0.0113900118, 0.0248634331, 0.0348566249, 0.0063430858, 0.0506627150, 0.0263558589, 0.0069711427, -0.0085179843, 0.0037182765, -0.0025840034, 0.0115045523, -0.0122902449, 0.0018089893, -0.0172982421, 0.0338334106, 0.0260337293, 0.0000000234, -0.0166216213, 0.0067291199, -0.0139722535, -0.0272083133, -0.0043087197, -0.0033970345, -0.0117119364, 0.0221229494, 0.0136864968, 0.0008492003, -0.0002779647, -0.0126525480, -0.0292181186, -0.0268508606, -0.0083215451, 0.0006427605, 0.0308638327, -0.0207902882, 0.0141700795, -0.0222288221, -0.0651524290, 0.0166145377, 0.0134720774, 0.0356398933, -0.0000007898, -0.0111464802, 0.0154278185, 0.0099443523, -0.0099969590, 0.0092829876, 0.0041658431, -0.0177999325, 0.0263658464, 0.0000757675, -0.0275266431, -0.0168670751, 0.0301187467, -0.0103277499, -0.0081712268, -0.0063393144, 0.0116906846, 0.0000008939, -0.0040093604, 0.0050324751, 0.0378894098, 0.0006571328, 0.0006416028, 0.0023897451, -0.0187296830, 0.0024163728, -0.0005930170, -0.0039653215, 0.0172920600, 0.0104112113, 0.0093283933, -0.0002626473, -0.0178204700, 0.0084878895, -0.0222774222, -0.0035199763, -0.0127054509, -0.0046206983, 0.0053277863, -0.0000086061, 0.0024902681, 0.0158037934, -0.0143247740, -0.0074958252, -0.0004167245, -0.0158799458, 0.0112926997, -0.0237501785, -0.0051471493, 0.0017786451, 0.0018523444, -0.0036602926, 0.0199980717, 0.0183191225, -0.0042338222, 0.0101054311, 0.0120143909, 0.0073230229, 0.0026840584, -0.0168911833, 0.0046963100, -0.0091615804, -0.0191538036, -0.0137543743, -0.0000000863, -0.0090362784, -0.0025595336, 0.0234668702, 0.0013140547, 0.0134430407, -0.0031366968, 0.0110881981, 0.0102157351, 0.0000000228, 0.0231414773, -0.0351215489, -0.0136838229, 0.0254509132, 0.0139169367, -0.0010099220, 0.0050707855, -0.0000006312, -0.0098402519, 0.0028890746, -0.0056592305, 0.0000098679, -0.0060661831, -0.0042672725, -0.0118610598, -0.0103554931, 0.0085407421, 0.0093444753, 0.0060748304, -0.0021755314, -0.0068789590, -0.0027354003, -0.0083488626, -0.0070332694, -0.0184389241, -0.0034939342, -0.0096325167, -0.0070288414, -0.0122206379, 0.0000002022, 0.0142556047, 0.0171348825, -0.0005029036, -0.0182583034, -0.0022251403, 0.0098465178, -0.0067320457, 0.0010218020, -0.0010009392, -0.0043616756, -0.0013729053, -0.0013305931, -0.0061807586, -0.0204399433, 0.0192447696, -0.0142965112, 0.0304809511, 0.0151941199, -0.0086285314, -0.0030764265, -0.0330329388, 0.0096395919, -0.0130088357, 0.0216988344, -0.0000031909, -0.0203009993, 0.0084830811, 0.0141263306, 0.0360169560, 0.0289441869, -0.0161877517, -0.0256498437, -0.0023818645, 0.0001159551, 0.0053169960, 0.0198691413, 0.0186753031, -0.0081460206, 0.0043186625, -0.0066729761, -0.0081140408, 0.0000004041, -0.0361052081, -0.0082441764, -0.0228019357, 0.0025090436, 0.0115335630, 0.0204350315, 0.0085664941, -0.0067671449, -0.0126663838, -0.0132709350, -0.0141352378, 0.0164006762, 0.0239967126, -0.0108509604, 0.0097113168, 0.0026481273, -0.0129194045, 0.0192126818, 0.0027223991, -0.0058607198, -0.0063143824, -0.0000232750, -0.0010247241, -0.0090431497, -0.0039123576, 0.0180293527, -0.0048137647, -0.0181792136, -0.0096943779, -0.0090239458, 0.0187957864, -0.0234475434, 0.0016884258, 0.0123512382, 0.0416619778, -0.0188588258, -0.0081733670, -0.0003863976, -0.0011958383, 0.0167616010, -0.0115557881, 0.0340427049, 0.0097532393, 0.0082516484, 0.0098385978, -0.0023262664, 0.0000000003, -0.0089081815, 0.0010510923, -0.0011102965, -0.0047679599, 0.0005981538, -0.0033160490, -0.0165988822, -0.0052556302, -0.0000000056, -0.0042938651, 0.0152016170, -0.0102144452, 0.0132807856, 0.0103617487, 0.0000552336, 0.0033261252, 0.0000000031, 0.0061308425, -0.0023103929, -0.0082062613, 0.0000439785, -0.0000700966, -0.0029560279, 0.0119836684, 0.0062274537, -0.0030988876, 0.0040179160, 0.0010810995, -0.0004461820, -0.0067954315, -0.0113510042, -0.0066930717, -0.0108904196, 0.0008627271, 0.0041167485, -0.0014999603, -0.0003480801, -0.0015286413, 0.0000000076, -0.0084451931, -0.0072304369, -0.0058208960, -0.0016171436, -0.0026696296, 0.0035339843, 0.0017403688, 0.0106984638, 0.0022836349, 0.0010571261, 0.0000500856, 0.0055738869, 0.0042223143, -0.0013280375, -0.0121255126, 0.0027554259, 0.0009156941, 0.0028383401, 0.0084192799, -0.0021102051, -0.0144538162, 0.0114869243, 0.0238445494, -0.0235501472, -0.0000000009, 0.0310516655, 0.0135855051, -0.0062769288, -0.0122268395, -0.0176109001, -0.0135212243, -0.0060707694, -0.0068685329, -0.0000001268, 0.0155497743, -0.0280677285, -0.0257223602, -0.0034575004, -0.0029822146, -0.0012531031, 0.0134240231, -0.0000005314, -0.0035461348, -0.0173566174, -0.0165925436, -0.0020629792, -0.0008435210, 0.0088271722, 0.0232514832, 0.0241677146, 0.0113046682, 0.0151476283, 0.0133797294, -0.0091402922, -0.0260141362, 0.0197519753, 0.0096488809, 0.0002924167, 0.0232025590, -0.0095027601, -0.0052751512, 0.0206065644, 0.0129838008, -0.0000106843, -0.0031675652, -0.0028152557, -0.0024064612, 0.0060701254, -0.0102650356, -0.0034177515, 0.0219760872, 0.0155552346, -0.0128366342, -0.0140383504, -0.0003697735, 0.0023991109, -0.0247139372, -0.0034356851, 0.0068501732, -0.0026593250, 0.0119827641, -0.0233541708, 0.0255994909, -0.0134064900, -0.0067860321, -0.0076295994, -0.0186619125, 0.0068861837, 0.0000000000, -0.0039197290, -0.0079976153, 0.0073864493, 0.0038204147, 0.0102711450, 0.0007933179, -0.0065988339, 0.0045503560, -0.0000001602, -0.0074847126, 0.0160988811, 0.0119471159, -0.0020197928, -0.0035890371, 0.0027613877, -0.0126368916, -0.0000007880, -0.0072656926, 0.0103458697, 0.0170294512, 0.0000007750, -0.0004275546, -0.0133233676, -0.0149065359, -0.0183597915, 0.0070043490, 0.0038045656, -0.0018561630, -0.0173482206, -0.0098250527, -0.0065903040, 0.0063721668, -0.0007116148, 0.0007238738, -0.0034486235, -0.0004026352, -0.0067775133, -0.0038839770, 0.0000000000, 0.0105812931, -0.0044915071, 0.0087223966, -0.0073599019, 0.0001837924, 0.0204927865, -0.0096905744, 0.0018166936, -0.0177808478, 0.0138200531, -0.0000219574, -0.0066141253, 0.0077512525, 0.0031527563, 0.0106816310, -0.0069858129, 0.0143386647, 0.0261750165, -0.0138312513, 0.0057102898, -0.0278273728, -0.0054697706, -0.0001567809, -0.0035270976, 0.0000000000, 0.0162513126, 0.0010600591, -0.0148460101, 0.0037449286, 0.0016050198, 0.0045344285, 0.0022831934, -0.0043268795, 0.0000000004, -0.0121020591, 0.0129637159, 0.0103422869, 0.0047360044, -0.0084671583, -0.0004839403, -0.0022037255, -0.0000000289, -0.0001522001, 0.0021428175, -0.0053049386, 0.0000025478, -0.0001610915, 0.0040973253, -0.0004170302, -0.0062820166, -0.0032945604, 0.0085301157, -0.0110533349, -0.0112578114, -0.0015199886, -0.0021317864, -0.0080306884, -0.0079681138, -0.0115624666, -0.0015885843, 0.0019242682, 0.0072706202, -0.0073132482, 0.0000000000, 0.0030540430, -0.0159938131, -0.0016211394, 0.0078756223, -0.0000294392, 0.0084133800, -0.0056446418, -0.0004746825, -0.0104894778, 0.0066274367, 0.0000268747, 0.0107793082, -0.0095558614, 0.0016081083, 0.0006564602, 0.0041760579, -0.0207764227, 0.0141504556, -0.0037981377, 0.0099013122, 0.0024088654, 0.0011923554, 0.0112811951, -0.0024078442, 0.0000000003, -0.0277547780, -0.0147052966, -0.0364859924, 0.0039420733, -0.0009556604, -0.0030605907, -0.0070054987, -0.0141183166, -0.0000450683, -0.0000367156, 0.0182536021, -0.0060773594, 0.0322287828, 0.0222237334, 0.0012266885, 0.0142503968, -0.0000000001, 0.0158861224, -0.0003095389, 0.0004383948, 0.0000165161, 0.0009811203, 0.0009997075, 0.0141867837, -0.0048739812, -0.0016814204, -0.0011942501, -0.0010211570, 0.0120041743, 0.0119485445, -0.0070760879, -0.0119216433, -0.0139053082, -0.0051578009, 0.0131557621, 0.0014862752, -0.0006659849, -0.0086880159, 0.0000000000, -0.0070139337, -0.0054096910, -0.0123114912, -0.0072386190, 0.0002695450, -0.0019860556, 0.0024427429, 0.0199223831, 0.0120832277, 0.0009755477, 0.0001666258, -0.0023394753, -0.0144020477, -0.0132971816, -0.0177722033, 0.0052059498, 0.0077158273, 0.0052255336, -0.0139330607, 0.0051622628, -0.0056235725, 0.0275979545, -0.0059307399, -0.0094642919, 0.0000000097, 0.0293629970, 0.0048403949, -0.0049043098, 0.0251789447, 0.0010089247, -0.0066687013, 0.0018501353, -0.0045087812, 0.0000007479, -0.0035505032, 0.0103528854, 0.0097799329, -0.0034813248, 0.0176012442, 0.0020943005, -0.0076720137, 0.0000000018, 0.0120490035, 0.0213397797, 0.0116408393, 0.0000722343, -0.0001645117, 0.0051029469, 0.0116549637, 0.0069646365, -0.0120740021, 0.0016553369, -0.0101776365, -0.0041873623, -0.0015277544, -0.0071718208, -0.0110800415, -0.0008807838, -0.0004650904, -0.0185081381, 0.0045436928, -0.0215479024, 0.0080518313, 0.0000000002, -0.0129563361, -0.0246388689, -0.0443051234, -0.0076869596, 0.0005464312, 0.0007477793, 0.0065921186, -0.0141740022, 0.0167202447, -0.0190888252, -0.0002505519, 0.0155564863, 0.0107780164, -0.0086801592, -0.0000976670, 0.0137558114, -0.0128500545, -0.0102937315, -0.0156605784, 0.0296001136, 0.0082116723, -0.0090113431, -0.0102685057, -0.0021443833, 0.0000000000, -0.0026110080, -0.0020697096, 0.0102239456, 0.0005864397, 0.0018646824, -0.0083276676, 0.0081659975, -0.0003551423, 0.0000001340, -0.0016595686, -0.0009745329, -0.0061291424, 0.0033317613, -0.0020720630, 0.0011884447, -0.0032142028, 0.0000000003, 0.0046204962, -0.0055101682, -0.0033462851, 0.0000003183, -0.0013435516, -0.0057771504, 0.0050109206, -0.0015794940, -0.0031617961, 0.0000666027, -0.0029217619, 0.0006127815, -0.0101676211, -0.0034748872, -0.0021824969, -0.0054497793, -0.0036043420, -0.0008113835, -0.0026254063, 0.0105060786, 0.0101936534, 0.0000000000, -0.0039021838, -0.0006552147, 0.0049923565, -0.0035152845, -0.0000586604, 0.0027583099, -0.0019915020, 0.0143716540, 0.0028214024, 0.0053241001, -0.0000085375, -0.0044520274, 0.0060267919, 0.0027687729, 0.0003897293, -0.0015744445, -0.0012693668, -0.0105671221, -0.0046149334, -0.0016709380, -0.0076547791, -0.0126465289, 0.0021639306, -0.0071720392, 0.0000000031, -0.0248915181, -0.0217628516, -0.0311548505, -0.0030947288, -0.0018191444, -0.0035037720, -0.0041482626, -0.0082653388, 0.0001965592, -0.0014231858, 0.0092160581, -0.0147229359, 0.0370276645, 0.0280084051, -0.0003517821, 0.0131170209, -0.0000000870, 0.0212600492, -0.0038886487, -0.0065513584, 0.0000102657, 0.0057443641, 0.0044412245, 0.0189264957, -0.0155726252, 0.0027942141, 0.0002845405, -0.0103457561, 0.0090194754, 0.0194827728, -0.0108092166, -0.0071368525, -0.0130056608, -0.0003026627, 0.0086011682, 0.0047270823, -0.0024156645, -0.0193894319, 0.0000000000, -0.0057506235, -0.0067585013, -0.0103260670, -0.0174523536, 0.0004613760, 0.0074845161, 0.0042050388, 0.0144755682, 0.0191862937, 0.0009654873, 0.0000979850, -0.0019385436, -0.0079630427, -0.0102999154, -0.0128812753, 0.0080762412, -0.0021326335, 0.0083077252, -0.0157051105, 0.0103765018, -0.0097617982, -0.0067011523, 0.0072012697, -0.0085506104, 0.0000000000, -0.0032088023, -0.0007380561, 0.0128212459, -0.0017366229, -0.0034565728, -0.0023581409, 0.0052459878, -0.0043225088, -0.0000001389, 0.0167041775, -0.0026476777, -0.0113756172, -0.0028572639, 0.0025145609, -0.0006502733, 0.0282795727, 0.0000000001, 0.0001971651, -0.0036260618, 0.0012593365, 0.0000164220, -0.0006586066, -0.0171650648, 0.0000633797, -0.0009710999, 0.0081788432, -0.0089608599, 0.0020770051, 0.0024268623, -0.0092336815, 0.0063417945, 0.0004887325, -0.0040841531, -0.0031060951, -0.0033105460, -0.0029779847, 0.0102404235, -0.0273962170, 0.0000000000, 0.0020630290, 0.0196135417, 0.0090042716, 0.0095568849, -0.0000273837, -0.0037964180, -0.0079758437, -0.0036488879, 0.0026584519, 0.0019978832, 0.0000077727, -0.0113713304, -0.0193321016, 0.0011539329, -0.0073624062, -0.0101643717, 0.0063996394, -0.0122174975, -0.0009782317, 0.0011003030, 0.0032109229, 0.0192704257, 0.0183849819, 0.0133759975, -0.0000189561, -0.0150708389, 0.0159884058, 0.0023278401, 0.0028835062, 0.0019349866, 0.0031320981, -0.0083899507, 0.0050862720, -0.0000668199, -0.0181724355, -0.0063333921, 0.0155274961, -0.0016154982, 0.0019262806, -0.0061026909, 0.0284010991, -0.0000006529, -0.0131120067, 0.0065025287, 0.0167471915, -0.0074071656, -0.0075994045, 0.0053293016, -0.0176982451, -0.0080902027, -0.0080045601, -0.0001549259, 0.0069471388, -0.0111088092, -0.0074455305, 0.0099784797, -0.0173968505, 0.0020315880, -0.0240372401, -0.0078732772, -0.0071265227, 0.0210542716, 0.0146336909, -0.0000237841, 0.0007456856, -0.0220850259, -0.0108869802, 0.0143475682, -0.0063613341, -0.0022362894, 0.0098515321, 0.0039341399, -0.0032392358, -0.0245822296, 0.0011191027, 0.0053766901, -0.0163875893, -0.0024496487, 0.0052989097, 0.0001346627, 0.0282593518, 0.0034691354, 0.0005043135, -0.0063704215, -0.0026320997, 0.0154249081, 0.0148778670, -0.0130901476, -0.0000000167, 0.0128471814, 0.0120049501, 0.0124544594, -0.0008975963, -0.0074245478, 0.0020051885, -0.0087953461, -0.0014172362, 0.0000000660, -0.0052989060, -0.0230346844, 0.0014958805, -0.0125142988, -0.0079738786, -0.0049585295, 0.0252116267, 0.0000000174, -0.0076906718, 0.0125929872, 0.0264920723, -0.0010646016, -0.0029952866, -0.0109892515, -0.0095763858, 0.0052883434, 0.0070452890, -0.0005693781, 0.0156339295, -0.0122599937, -0.0101376921, 0.0092932815, -0.0078507904, 0.0038420677, 0.0112970015, 0.0045321626, -0.0046740454, 0.0132494029, -0.0148537504, -0.0000115754, -0.0050500431, -0.0102886148, 0.0053015179, 0.0045244079, -0.0124007547, -0.0002844501, 0.0207633711, -0.0084968898, -0.0086904988, -0.0163216386, -0.0003527456, 0.0012228241, -0.0175258629, 0.0088712508, -0.0006652374, -0.0152997011, 0.0097121680, -0.0054124827, 0.0123613244, -0.0089972541, 0.0038096274, 0.0154238325, -0.0167357959, 0.0058769439, -0.0000004459, 0.0039532389, -0.0086475518, 0.0193939954, 0.0123123564, 0.0043708053, -0.0000602506, 0.0106048556, 0.0151008749, -0.0000303070, -0.0120451553, 0.0092170620, 0.0162332132, -0.0138170533, 0.0246384293, -0.0097884405, -0.0035151872, -0.0000000698, -0.0122070462, 0.0238431245, 0.0148535427, 0.0003888193, -0.0012221579, 0.0146959787, -0.0145270089, -0.0024724668, -0.0045519578, 0.0096011665, -0.0173953716, 0.0077957883, 0.0075480859, 0.0020767148, -0.0019984250, 0.0151445111, -0.0036244269, -0.0185917951, 0.0127609540, -0.0295900945, -0.0053009996, -0.0000004413, 0.0082512395, -0.0076506520, -0.0181392469, -0.0146327149, -0.0003840588, 0.0046719802, 0.0069491505, -0.0307075400, 0.0080932220, 0.0084473118, -0.0038631854, 0.0161607210, 0.0239198413, -0.0000979126, 0.0076083764, 0.0117639899, 0.0086504659, 0.0063175452, -0.0098636309, 0.0316970237, -0.0192439388, 0.0025965308, 0.0024237446, -0.0062461151, 0.0000000001, 0.0009851871, -0.0003263132, 0.0080307331, -0.0016174185, -0.0038198417, -0.0010701919, -0.0017909572, 0.0027270482, -0.0000000005, 0.0042416835, -0.0018887717, -0.0021197700, 0.0007051580, 0.0058488376, 0.0006900395, 0.0157934427, 0.0000000474, -0.0000578276, 0.0056113158, 0.0173429307, 0.0002655082, -0.0005868386, -0.0091145849, 0.0007515530, -0.0009377850, 0.0034695605, -0.0108446656, 0.0043679774, -0.0024400600, -0.0023742469, 0.0032329201, -0.0009695785, -0.0018707216, 0.0002368923, 0.0008339609, -0.0011875133, 0.0041231452, -0.0186781157, 0.0000000008, 0.0019696690, 0.0122505557, -0.0043818043, 0.0048962780, -0.0033389609, -0.0041855439, -0.0019408425, -0.0067330999, 0.0039924434, 0.0008588612, 0.0000407917, -0.0004840169, -0.0183054842, 0.0015550309, -0.0101576913, -0.0072139511, 0.0079891505, -0.0000487438, -0.0019847902, 0.0053751389, 0.0022920270, 0.0115497997, 0.0032713064, -0.0169185642, 0.0000000000, 0.0069020996, 0.0049487185, -0.0015855152, 0.0123000331, -0.0005892854, -0.0056566526, -0.0011816344, 0.0013481990, 0.0000000020, 0.0028366661, 0.0157339815, 0.0104377829, 0.0132470280, 0.0045203338, 0.0009946456, 0.0021923373, -0.0000000120, -0.0023604918, 0.0012410957, 0.0000323564, 0.0000169115, -0.0003633730, -0.0061528319, -0.0038309814, 0.0021895391, 0.0018873492, 0.0006827505, 0.0007891172, -0.0132244863, -0.0034026825, -0.0019279984, 0.0012266072, -0.0032561081, -0.0000939918, -0.0015823576, 0.0018269904, -0.0018709435, -0.0031155422, 0.0000000000, -0.0046005952, -0.0025729034, 0.0045534270, 0.0084566679, -0.0000529806, -0.0006244347, 0.0042159916, -0.0186525676, 0.0015440898, -0.0022639916, 0.0000284160, -0.0006303315, -0.0122583453, -0.0142110568, -0.0013092459, -0.0022156886, 0.0060014906, 0.0011423192, -0.0020980425, 0.0061305240, 0.0132520385, 0.0127506601, -0.0065270024, 0.0153567428, -0.0000000000, -0.0072754431, 0.0079085846, -0.0084735611, 0.0026454842, 0.0057978411, -0.0036563308, -0.0038711659, 0.0019915432, 0.0000000016, -0.0160849355, 0.0155670168, 0.0134134311, -0.0036658498, -0.0060128439, -0.0014861635, -0.0098036565, -0.0000000000, -0.0049151517, -0.0025156676, -0.0046734158, -0.0000275311, 0.0021682994, 0.0068244017, -0.0193277169, -0.0048768604, -0.0148686701, 0.0069815461, -0.0094546331, 0.0010973326, 0.0065551978, 0.0031732982, -0.0134505024, -0.0089631537, -0.0210180096, -0.0092925038, -0.0008254783, 0.0003169429, 0.0379414484, -0.0000000000, 0.0003450222, -0.0028188070, -0.0060279220, -0.0034847809, 0.0007212210, -0.0006886937, -0.0032307643, 0.0029982026, -0.0009341514, -0.0003505996, 0.0004748804, 0.0117189353, 0.0012968510, -0.0072474284, 0.0024289482, 0.0166155975, -0.0123393731, 0.0159121417, -0.0120972320, -0.0015074016, -0.0003011946, -0.0032941396, 0.0017116080, -0.0005877928, 0.0000000002, 0.0059248288, -0.0025602346, 0.0017285740, 0.0043178247, -0.0004593477, -0.0092932852, -0.0060389829, -0.0032300467, 0.0000001117, 0.0144811692, 0.0011247515, -0.0034950627, -0.0026926503, 0.0103646340, -0.0004794741, 0.0179317091, -0.0000000438, 0.0042200028, 0.0097583188, 0.0103566842, 0.0000108988, -0.0042980430, -0.0021682507, 0.0046415683, 0.0017913189, 0.0047161207, 0.0034587029, 0.0033399609, 0.0021502292, -0.0033319991, 0.0047857170, 0.0002548202, -0.0014494420, -0.0015370637, -0.0076729418, -0.0054263528, 0.0091227209, 0.0079908110, 0.0000000000, 0.0024442207, 0.0106077408, -0.0106900986, -0.0021251761, -0.0000769030, 0.0045770318, -0.0001671111, 0.0018759024, 0.0021996074, -0.0084876893, 0.0000286616, -0.0064553581, -0.0032502951, -0.0106633045, -0.0016181874, -0.0028231395, 0.0094029941, 0.0007915605, -0.0161381084, 0.0090314997, -0.0196059272, 0.0131913209, -0.0006610542, 0.0008799069, -0.0000000000, 0.0051977723, 0.0008737005, -0.0022266025, 0.0020537395, 0.0014833957, 0.0015376072, -0.0026559895, -0.0034493241, 0.0000000000, -0.0043195081, 0.0057277712, 0.0027804202, -0.0038288867, 0.0030539460, 0.0010432120, 0.0030269313, 0.0000000227, -0.0001720030, 0.0074276319, 0.0146484477, 0.0000010355, 0.0005121488, 0.0027232561, -0.0012630317, 0.0038965561, -0.0035640879, 0.0016414410, -0.0038416176, 0.0031428651, 0.0059571834, 0.0116764233, -0.0062184487, 0.0033892549, 0.0032831614, -0.0075623193, -0.0000847003, 0.0004550239, 0.0060108905, -0.0000000000, 0.0007314635, 0.0006974746, -0.0103332847, 0.0009960654, 0.0000101537, -0.0027489050, 0.0045238649, -0.0037894633, -0.0053333952, -0.0070967413, -0.0000167741, 0.0012020953, -0.0008153984, -0.0035977631, 0.0040152851, 0.0047802022, 0.0042214370, 0.0027336064, -0.0073815393, 0.0032169502, 0.0025356729, 0.0178940427, 0.0078100809, -0.0136884274, -0.0000000230, 0.0222799852, 0.0051927259, 0.0037321849, -0.0062935576, -0.0068872115, -0.0123707745, 0.0023185662, -0.0061120219, -0.0000002683, 0.0110379821, -0.0207370408, -0.0153903691, -0.0083028004, 0.0084351646, 0.0009326504, 0.0153819900, -0.0000003529, -0.0028451742, 0.0082071694, 0.0159299523, -0.0041629458, -0.0014481564, 0.0027017521, -0.0001910484, -0.0035792070, 0.0140233906, 0.0060743513, 0.0169946365, -0.0181005951, -0.0229058806, 0.0218627881, -0.0011929062, -0.0015855375, -0.0058542746, -0.0163450390, -0.0090876333, 0.0224441160, 0.0090134041, -0.0000036192, -0.0047078580, -0.0115200737, -0.0165362824, -0.0009695934, -0.0038020455, -0.0037977160, 0.0150661413, 0.0134364571, -0.0087393830, -0.0151712950, 0.0002036687, -0.0019590571, -0.0260004941, -0.0018252019, 0.0064767678, 0.0023740819, 0.0151547557, -0.0121900775, 0.0003274766, -0.0022936065, -0.0230008122, 0.0016620804, 0.0014529623, -0.0152786579, 0.0000000038, 0.0025530886, -0.0129878065, -0.0150854876, -0.0111941081, 0.0033259669, -0.0051452676, -0.0146972388, -0.0112913875, -0.0002617432, 0.0127925416, 0.0110114599, -0.0016141656, 0.0032414673, 0.0101375170, -0.0015564195, -0.0014001477, 0.0000003230, 0.0107617257, 0.0001653351, -0.0189432148, 0.0001543986, 0.0005310240, 0.0086137224, 0.0156994797, -0.0055747493, 0.0085411053, -0.0024467257, -0.0165124498, 0.0051367935, 0.0095041124, 0.0007357356, 0.0237054303, 0.0109465420, 0.0276589487, 0.0167929605, 0.0042945696, -0.0065619233, -0.0194649342, 0.0000000001, 0.0090151113, -0.0199367683, 0.0073538977, -0.0160706434, 0.0005178719, 0.0021491814, 0.0096960878, -0.0028249186, 0.0130015472, 0.0073600584, -0.0089807725, -0.0074083512, -0.0031659151, -0.0121255824, 0.0032282253, -0.0033694180, -0.0047414540, 0.0075816605, -0.0209364109, 0.0088954931, -0.0014332943, 0.0337197222, 0.0021669958, -0.0061317394, -0.0000040612, 0.0141753945, 0.0167712327, 0.0187008083, -0.0160078648, -0.0030632485, -0.0069646505, 0.0028186534, -0.0052465280, -0.0001379886, -0.0050162431, -0.0092092194, -0.0171152391, 0.0049390970, 0.0124217467, -0.0026862090, 0.0100475848, -0.0000044871, -0.0219086129, -0.0051583257, 0.0256924648, -0.0000489719, -0.0076288022, 0.0117313880, 0.0033109603, -0.0099248998, -0.0041423957, -0.0045241918, 0.0150497044, -0.0257215444, -0.0189684369, 0.0173987448, -0.0193089489, 0.0172602013, -0.0139527172, -0.0200309232, -0.0060558827, -0.0092752874, 0.0046816315, -0.0000018505, 0.0026269329, 0.0144703686, -0.0072370837, 0.0028905908, -0.0103171906, -0.0025227920, -0.0019981591, 0.0036921331, -0.0069379173, -0.0121183395, -0.0006976443, -0.0146616846, -0.0117388023, 0.0163131393, 0.0262219310, -0.0055351639, 0.0108903814, 0.0067019854, 0.0114006223, -0.0034095808, -0.0020718046, -0.0181541014, -0.0071686115, -0.0182204489, 0.0000000193, -0.0010917002, -0.0217297785, -0.0088845920, 0.0041233683, -0.0006114907, -0.0077336826, 0.0138345109, -0.0088117309, -0.0002728520, 0.0060966131, 0.0002580839, -0.0068100146, 0.0194225423, 0.0216772761, 0.0008953155, 0.0029303823, -0.0000001725, 0.0134312967, -0.0036766599, -0.0177555177, -0.0000903975, -0.0030236996, -0.0078167273, 0.0222263131, -0.0157407392, 0.0088218637, -0.0010714078, -0.0154513083, 0.0024163865, -0.0019405864, -0.0069332407, -0.0073922379, -0.0064590755, 0.0075181234, 0.0041031409, 0.0052941306, -0.0002453755, -0.0209645256, 0.0000000027, -0.0044690263, -0.0164980981, -0.0021679455, -0.0102924705, 0.0007845570, 0.0146913044, 0.0025524676, 0.0175180230, 0.0064334124, 0.0048972508, -0.0000712389, 0.0046766670, -0.0112836678, -0.0106206881, 0.0047489316, -0.0122197131, -0.0047336458, 0.0060093193, -0.0186556801, 0.0132242227, -0.0171820149, 0.0024476510, -0.0012452804, -0.0161773972, 0.0000000245, 0.0181038212, -0.0032056724, 0.0101049934, -0.0048809461, -0.0079844799, -0.0053331256, -0.0029227098, -0.0054448382, -0.0000000095, -0.0038560906, -0.0100826547, -0.0035025598, -0.0063036089, 0.0041224421, -0.0007409024, 0.0145762935, 0.0000000415, -0.0018287557, 0.0057918909, 0.0267791655, -0.0038780353, -0.0016792894, -0.0151864933, 0.0032642449, -0.0004449977, 0.0053176428, -0.0114212222, 0.0038791625, -0.0130382413, -0.0163070261, 0.0137098795, -0.0051412666, -0.0112474374, 0.0024405327, -0.0139937242, -0.0075949659, 0.0033763165, -0.0205888748, -0.0000023825, 0.0014973393, -0.0067427070, -0.0031165518, 0.0069487775, -0.0058361501, 0.0017714887, 0.0132237719, -0.0077950400, -0.0112273367, -0.0173340756, 0.0000200441, -0.0017251895, -0.0178699996, 0.0026789792, -0.0049102525, -0.0129142599, 0.0064513874, -0.0059408871, 0.0009552221, 0.0049925004, 0.0121695707, -0.0060815020, -0.0018510403, -0.0261082873, 0.0000000012, 0.0253020376, -0.0140952189, 0.0050188499, -0.0081704427, -0.0049911649, -0.0115902731, -0.0057298723, -0.0033569853, -0.0000038029, 0.0194045361, -0.0152715072, -0.0033101593, -0.0050695660, 0.0130322985, -0.0009169839, 0.0038449357, -0.0000020766, -0.0005701019, 0.0111546749, 0.0107650971, -0.0014857959, -0.0069640111, 0.0009183807, 0.0141075281, 0.0096345358, 0.0147065846, 0.0024962581, -0.0016254340, -0.0071792793, -0.0206392445, 0.0034334909, 0.0054322588, 0.0001368465, 0.0154735204, -0.0106841372, 0.0050150156, 0.0066266069, -0.0051103253, 0.0000000079, 0.0025854444, -0.0134763401, -0.0001657060, -0.0028707222, -0.0045632897, 0.0101370784, 0.0147557901, -0.0013649601, -0.0109888585, -0.0089400923, -0.0008614314, 0.0065033915, -0.0174284447, -0.0083871074, 0.0168414954, -0.0161026176, 0.0122637656, 0.0035402607, -0.0024815600, 0.0119013963, -0.0069658617, 0.0026242270, -0.0310347732, -0.0006862889, 0.0000000000, 0.0113772331, 0.0037882498, 0.0025421386, -0.0004984357, 0.0063544270, -0.0102001252, 0.0067441668, 0.0163501818, -0.0000000863, -0.0070285825, 0.0058435365, -0.0155285420, -0.0001389705, 0.0014536231, 0.0023279111, -0.0030836486, -0.0000007093, -0.0000494374, 0.0227566101, 0.0314719863, -0.0000002001, 0.0003837577, -0.0170221832, 0.0087555042, -0.0019001375, -0.0204951782, -0.0056672515, 0.0119301360, -0.0104386527, -0.0158891082, -0.0228377338, -0.0046556792, -0.0012094325, -0.0080336602, -0.0098834820, -0.0051293261, -0.0023639461, 0.0036303462, 0.0000000000, 0.0009412505, 0.0046697576, -0.0002073687, -0.0140867634, -0.0001397176, 0.0232762340, 0.0011458111, 0.0084091239, 0.0000575353, 0.0033012272, 0.0000501350, -0.0002755348, 0.0049595232, 0.0029317485, 0.0014387362, -0.0080691576, 0.0040532448, -0.0097506177, -0.0183081385, 0.0217627287, -0.0140393628, -0.0010172462, -0.0016158435, -0.0148474667, 0.0000000000, 0.0163611230, -0.0070883497, -0.0070865755, -0.0029421400, 0.0058193086, -0.0008074000, -0.0010945953, 0.0050776084, -0.0000014488, 0.0121835954, -0.0033824542, -0.0049581705, 0.0041936329, 0.0115811564, -0.0031482272, -0.0065651196, -0.0000014834, -0.0067519932, 0.0122840153, 0.0084442338, 0.0000554094, -0.0010996958, -0.0022922226, -0.0121209584, -0.0123421475, -0.0016139862, 0.0112085817, -0.0077992007, -0.0101080714, -0.0076065254, -0.0114680212, 0.0119688315, 0.0166928470, 0.0152429109, -0.0031598536, 0.0098484866, -0.0147476420, -0.0062758736, 0.0000000000, 0.0121875554, -0.0167956818, 0.0089846561, -0.0085956603, 0.0006076894, 0.0233458914, 0.0107753770, -0.0083018998, -0.0120099625, 0.0094751287, -0.0012324760, 0.0080252569, 0.0046553370, -0.0048811776, 0.0184985921, -0.0083587281, 0.0079194363, 0.0323978886, -0.0074725160, 0.0067173429, -0.0374938808, 0.0243135225, 0.0086085591, -0.0053335875, -0.0000000000, 0.0035193700, 0.0175543185, 0.0025205163, 0.0053293346, 0.0052034184, 0.0015615822, -0.0103659295, -0.0058955108, 0.0000000005, -0.0111359451, 0.0132580362, 0.0122989109, -0.0056595961, -0.0119970245, 0.0000286849, 0.0022701230, -0.0000000000, -0.0052092383, 0.0090544764, 0.0125097558, 0.0001034375, 0.0008741695, 0.0016861774, -0.0224543121, 0.0019721403, -0.0096765868, -0.0048078639, -0.0101251556, 0.0008039424, 0.0041841250, 0.0054340642, 0.0101742791, 0.0046963883, 0.0170975104, 0.0099599399, -0.0033279029, 0.0068690851, 0.0057197255, -0.0000000000, 0.0096596312, -0.0110926190, 0.0021221978, 0.0037049851, 0.0006821210, -0.0079795402, 0.0070418236, -0.0281790532, 0.0004500041, -0.0049908157, -0.0011506206, 0.0020143446, 0.0133103896, -0.0044042422, 0.0073355506, 0.0056766020, 0.0007590636, 0.0172377974, -0.0091432957, 0.0058108182, 0.0056840125, 0.0023131743, -0.0024354472, -0.0075111510, 0.0000000052, -0.0195853394, -0.0228627995, -0.0097356252, 0.0233090557, -0.0009601328, -0.0010817240, -0.0039956970, -0.0237830840, 0.0000026166, -0.0099704778, 0.0249593500, 0.0019686869, 0.0313246697, 0.0164854508, 0.0066988082, -0.0081502823, 0.0000000307, 0.0152602065, -0.0024000870, -0.0074487193, 0.0004426913, -0.0048293839, -0.0067582964, 0.0209387615, -0.0096965926, -0.0024051084, -0.0196245927, -0.0129458196, 0.0015466539, 0.0099098831, -0.0043945028, -0.0076647229, -0.0099776657, -0.0048875962, 0.0020925438, -0.0002719590, -0.0196619015, -0.0026041290, 0.0000000097, -0.0115243243, -0.0029241086, -0.0170482844, -0.0052127396, 0.0036132068, -0.0118776355, -0.0043546571, 0.0091249123, 0.0045407880, -0.0083906278, 0.0004882092, -0.0004188671, 0.0088933092, -0.0127840033, -0.0160162188, 0.0021882826, -0.0023631337, 0.0032107576, -0.0065210499, 0.0053479197, 0.0100767296, 0.0185482781, 0.0001942818, -0.0111937234, -0.0000000000, 0.0154106235, -0.0014419752, 0.0048310952, 0.0083929515, 0.0027300376, -0.0023535634, 0.0022688634, -0.0053342236, 0.0000000003, 0.0078027551, 0.0119873341, 0.0020270273, -0.0008163597, 0.0180848967, 0.0012990048, 0.0045786789, -0.0000000047, -0.0016574628, 0.0086048674, 0.0083627561, 0.0000044472, -0.0004565806, -0.0058583454, -0.0020617025, -0.0020477471, 0.0022967353, 0.0095328055, -0.0056822607, -0.0110424953, -0.0089167412, 0.0046186079, -0.0005193182, 0.0012750931, 0.0036911904, -0.0187619813, 0.0050897156, -0.0056649959, -0.0069156913, -0.0000000000, 0.0047455425, -0.0020732097, -0.0094048921, -0.0036404165, -0.0000703401, 0.0084425425, 0.0018481491, -0.0135098584, -0.0019535883, -0.0001039166, -0.0002112916, 0.0037207906, 0.0041473992, -0.0049774498, 0.0054504238, 0.0002464739, 0.0100318193, 0.0092120962, -0.0109034972, 0.0162310470, -0.0312609561, 0.0007428806, 0.0042818994, 0.0005077663, -0.0000000000, -0.0077342694, 0.0067612035, -0.0094443168, 0.0080272993, -0.0048505417, 0.0040988545, 0.0116646364, 0.0125250183, -0.0000000003, -0.0030525608, 0.0169341657, 0.0074056443, 0.0050615263, 0.0076231873, -0.0005443371, 0.0054778224, 0.0000000000, -0.0033786115, -0.0053754332, 0.0061103073, 0.0000171575, 0.0003807935, -0.0067314948, -0.0216965359, 0.0008540968, -0.0062697893, -0.0075020478, -0.0063912696, 0.0053313710, 0.0025302344, 0.0044037201, -0.0152221574, -0.0069261002, -0.0232728496, -0.0007788196, 0.0035570834, -0.0099533424, 0.0041659581, 0.0000000000, 0.0084270500, 0.0140147805, 0.0050099883, 0.0075293994, 0.0000937491, 0.0053372900, -0.0006975323, -0.0113421362, 0.0047965674, 0.0068695890, 0.0005122375, 0.0042606122, -0.0324026458, -0.0105720907, -0.0047799409, -0.0052063684, 0.0017889487, 0.0120208943, -0.0149258608, 0.0012818130, 0.0163760073, 0.0125411963, -0.0067636119, 0.0113654891, -0.0000062960, -0.0143135432, 0.0103887962, 0.0240906570, 0.0003773120, 0.0067132320, 0.0030699982, -0.0036347869, 0.0040047886, 0.0000164737, -0.0216578618, 0.0117102191, 0.0154649783, -0.0001594056, 0.0049252543, -0.0025233291, 0.0104863057, 0.0000002121, -0.0142590776, 0.0065657455, 0.0359072126, -0.0004293899, -0.0013257106, -0.0086492943, -0.0360582843, -0.0258936081, 0.0018742920, -0.0079747522, 0.0142234722, -0.0073844600, -0.0014639803, 0.0008112197, -0.0094951540, 0.0095653553, -0.0089171007, -0.0043763625, -0.0052437582, -0.0062524807, -0.0088215973, -0.0000008596, 0.0062221610, -0.0016388737, 0.0104818027, -0.0024740407, -0.0010729148, -0.0046494622, -0.0070588300, -0.0110332612, -0.0070937937, 0.0124874506, -0.0003618741, 0.0077431281, -0.0110175628, 0.0209275242, 0.0031709010, -0.0026206214, 0.0110780988, 0.0223634783, -0.0010857293, -0.0002249659, -0.0127198314, -0.0023817485, -0.0200113710, -0.0117640551, 0.0000000003, 0.0203724876, -0.0104872566, 0.0160162691, 0.0148257865, 0.0065889643, -0.0069298102, 0.0084225954, 0.0020510131, 0.0000000733, -0.0127393845, -0.0037011560, 0.0088086519, 0.0057953345, 0.0027670991, -0.0000496065, -0.0051317415, -0.0000002597, -0.0001954353, 0.0100318938, 0.0181598682, 0.0000090830, -0.0025688107, -0.0085623749, -0.0041585118, -0.0249683615, -0.0028480615, -0.0091977641, -0.0024090444, -0.0184770040, -0.0119198719, -0.0009621055, -0.0161969252, 0.0004177329, -0.0046296539, -0.0049405345, -0.0010249976, 0.0021686091, 0.0024162163, 0.0000000002, 0.0022564284, -0.0164728183, -0.0141705126, -0.0042763115, -0.0001456632, 0.0133007141, 0.0116129527, 0.0018702745, -0.0070778895, -0.0022013807, 0.0001316777, 0.0055734292, 0.0047919797, -0.0027905724, 0.0163295232, -0.0056438390, 0.0018428155, 0.0100025982, -0.0078853201, 0.0166788660, -0.0049394867, -0.0114745945, -0.0091712307, -0.0164225977, -0.0000047924, 0.0157419983, -0.0142496368, 0.0062479307, 0.0001967293, 0.0013966580, -0.0056251809, -0.0204705261, 0.0060511488, 0.0000007554, 0.0058371038, 0.0132702235, 0.0135021331, 0.0212607905, 0.0267529059, -0.0077717542, 0.0028320421, 0.0000023517, 0.0017101924, -0.0023757415, 0.0040738252, -0.0036290961, -0.0088479612, 0.0066577904, -0.0016039683, -0.0274000950, 0.0110195326, -0.0054386454, -0.0242192894, -0.0047916835, 0.0082035707, -0.0102645978, -0.0063019684, 0.0168887787, 0.0041895579, -0.0008460820, 0.0186667293, -0.0295881592, -0.0198396575, -0.0000001482, 0.0084823333, -0.0224208012, 0.0061724805, 0.0057992828, 0.0003816210, 0.0246145986, -0.0027747736, -0.0180737078, 0.0103889182, -0.0017388922, -0.0068086255, 0.0182830319, 0.0023693340, -0.0105204210, 0.0201097596, -0.0115250302, -0.0095765833, 0.0306684989, 0.0060708956, 0.0077086082, -0.0007713991, -0.0036327150, -0.0024101820, 0.0014129325, 0.0000000000, 0.0086147599, 0.0053803045, -0.0061684446, 0.0009179453, -0.0005797543, -0.0004048209, 0.0007051801, 0.0019624426, 0.0000000011, -0.0050339005, 0.0048953835, 0.0003016168, 0.0018620200, -0.0028870744, -0.0005789421, -0.0042673978, 0.0000000019, 0.0031916592, -0.0012339114, -0.0006100560, 0.0000085563, -0.0007082645, -0.0072476557, 0.0074253227, 0.0009254961, -0.0027860964, -0.0077599585, -0.0010586204, 0.0017852952, 0.0017627524, -0.0056790635, -0.0021514313, -0.0033265518, 0.0114572756, 0.0013418990, -0.0008380840, -0.0048333365, 0.0001385927, 0.0000000000, 0.0015378605, -0.0028729360, 0.0016916761, 0.0039993953, -0.0008161004, 0.0040951944, -0.0004958999, -0.0007174908, 0.0002288911, 0.0001095035, 0.0000594821, 0.0058678980, 0.0014635234, -0.0016290949, -0.0021217493, -0.0020842229, -0.0089302883, 0.0023812356, -0.0059040948, 0.0025666482, 0.0083849328, -0.0148100266, -0.0020967915, -0.0124706440, -0.0000000000, 0.0169304609, 0.0260321237, 0.0045007057, -0.0173460934, -0.0104070045, 0.0058571999, 0.0009434453, 0.0207895041, -0.0000000155, -0.0126866065, -0.0140172942, -0.0085808001, -0.0009075633, -0.0056645279, 0.0004282167, 0.0133863799, -0.0000000001, 0.0010373431, 0.0101136072, 0.0183069315, -0.0000921840, 0.0007643783, -0.0140971178, 0.0200634059, 0.0222987887, -0.0026935018, -0.0117739197, 0.0142576452, -0.0060856384, -0.0012224861, -0.0071974187, -0.0038472952, -0.0002444957, 0.0261680279, -0.0095895072, 0.0126840957, -0.0065340064, -0.0302378554, -0.0000000004, 0.0090970695, 0.0290997643, 0.0014865440, 0.0110626305, -0.0095919184, 0.0059904763, 0.0053947712, -0.0090686921, 0.0012956171, -0.0131105520, -0.0000321549, 0.0016710535, -0.0114516960, 0.0059982017, -0.0020125499, -0.0218989383, 0.0000594591, -0.0097315619, 0.0111842398, 0.0105265724, 0.0310559291, 0.0109544238, -0.0090674357, 0.0065668672, 0.0000000000, 0.0218400173, -0.0072820410, -0.0175793972, -0.0037284121, 0.0027931207, -0.0153095666, 0.0035351573, -0.0088500660, -0.0000000001, 0.0040869522, -0.0006441766, 0.0112248715, -0.0048239469, 0.0060393699, 0.0012018741, -0.0098679205, 0.0000000035, -0.0011045944, 0.0152047202, 0.0107256779, -0.0000004811, -0.0003533607, 0.0155267948, -0.0038718614, 0.0025954244, 0.0056748148, 0.0026587967, -0.0108082080, -0.0032444363, -0.0005145774, 0.0197950900, 0.0054242988, 0.0005354264, -0.0002014066, -0.0158355143, -0.0017084087, -0.0102662016, 0.0353434496, 0.0000000000, 0.0034572957, 0.0066193808, -0.0142425923, -0.0075761895, 0.0001531841, -0.0073368037, 0.0008274284, -0.0085117910, 0.0019000217, -0.0044738157, 0.0000079044, 0.0098976307, -0.0050514736, -0.0152273430, 0.0170155894, 0.0166715644, -0.0057674479, 0.0109450305, -0.0273252390, 0.0107035702, 0.0045393645, -0.0015311481, -0.0020749471, -0.0033158602, 0.0000000000, 0.0112296091, -0.0035894644, -0.0084499996, -0.0091783646, -0.0003580253, -0.0086804405, 0.0007803725, -0.0063217599, 0.0000000002, 0.0108217802, 0.0004279812, 0.0021675134, 0.0051332521, 0.0034521827, 0.0010687002, -0.0116503648, 0.0000000000, 0.0005943083, -0.0069055548, -0.0248646867, 0.0000012360, -0.0008562480, 0.0137403179, 0.0149313249, 0.0074625118, 0.0074710157, 0.0062609790, -0.0018454982, -0.0046266131, -0.0062274067, 0.0046548340, 0.0047165370, -0.0000675495, -0.0028282967, -0.0003351094, -0.0036573773, 0.0066989968, 0.0171846077, 0.0000000000, -0.0002567315, 0.0003708689, -0.0004499878, -0.0084467037, -0.0000115558, 0.0012355933, -0.0026719752, 0.0085344398, 0.0007840496, -0.0009374046, 0.0000271730, -0.0001611143, -0.0026611751, -0.0138519350, 0.0077666556, 0.0033326838, -0.0016333752, 0.0078032673, 0.0000084164, -0.0060344869, -0.0002447605, 0.0084955217, 0.0042085019, 0.0004249733, 0.0000000000, -0.0098294634, -0.0018962689, -0.0111253625, 0.0013740903, 0.0004435776, -0.0020078041, -0.0065759015, -0.0129317446, 0.0000000418, -0.0026050394, 0.0166584738, -0.0036285878, 0.0106159113, 0.0103988647, 0.0017217440, -0.0031610569, 0.0000000005, 0.0032274334, -0.0040898719, 0.0026486630, 0.0000050220, -0.0004908670, -0.0045007304, 0.0137077672, 0.0013727646, -0.0064545744, -0.0068939296, -0.0023177937, 0.0006045685, -0.0015049984, -0.0070925727, -0.0019390949, -0.0083038881, 0.0005531482, 0.0077952021, -0.0009764131, -0.0033497429, -0.0036692289, 0.0000000000, -0.0070128948, -0.0055931369, -0.0023229704, 0.0004123783, 0.0000094802, 0.0024714724, -0.0051432466, 0.0084672114, -0.0036457796, 0.0002165581, 0.0000486335, 0.0008305762, 0.0038895775, -0.0010521038, -0.0098068099, -0.0004443777, 0.0032680710, 0.0062495517, -0.0034456111, 0.0046996232, -0.0048492756, -0.0163221136, -0.0054271650, 0.0020912448, 0.0000000033, 0.0027397256, -0.0155439526, 0.0032913052, 0.0121551957, 0.0040142559, 0.0044579958, 0.0025857885, 0.0082474342, 0.0000002562, 0.0042175287, 0.0093575018, -0.0021317028, 0.0124263205, 0.0104497792, 0.0015963905, -0.0010893070, 0.0000000785, 0.0190551821, -0.0014861296, 0.0009763333, 0.0000561346, -0.0037092669, -0.0045479885, 0.0053297048, -0.0068382393, 0.0074156905, -0.0037846144, -0.0031632946, 0.0028807283, 0.0048200330, -0.0008381877, 0.0007826323, -0.0050365739, -0.0083742607, 0.0017406337, 0.0064221942, -0.0048419810, -0.0078613544, 0.0000000000, -0.0040221699, -0.0095617073, -0.0052349870, 0.0024109676, 0.0003481662, 0.0013926396, -0.0055782604, -0.0070264675, 0.0014940479, 0.0074295029, 0.0000355413, 0.0116382260, -0.0101345554, -0.0074986052, -0.0093346927, -0.0040779542, -0.0097391270, 0.0058529708, 0.0003197973, 0.0003997025, 0.0087310318, -0.0012005965, -0.0026303686, 0.0017591073, 0.0000000000, -0.0015755588, -0.0005152540, -0.0058923964, -0.0007655364, 0.0004489040, -0.0015089624, 0.0020724037, -0.0013509212, 0.0000000004, 0.0004532451, 0.0043085320, 0.0005936542, 0.0080540720, 0.0022963397, -0.0001556797, -0.0043133013, 0.0000000066, 0.0034632622, -0.0009481983, -0.0015589573, 0.0000003421, -0.0003974180, -0.0027637999, 0.0003389602, -0.0027908445, -0.0007537764, -0.0016549708, -0.0070200278, -0.0008007891, -0.0015161762, -0.0092712371, 0.0027832405, -0.0028892069, 0.0026910047, 0.0038796193, 0.0012565447, -0.0014136255, -0.0037006990, 0.0000000000, 0.0014986309, -0.0058392873, 0.0035544238, -0.0006103793, -0.0000808063, 0.0047351667, -0.0066251992, 0.0043729171, -0.0005339964, 0.0104899993, 0.0000190405, -0.0001813200, -0.0012714542, -0.0025860849, 0.0006284758, -0.0007666931, -0.0012035574, 0.0082731247, -0.0039916416, 0.0020769027, -0.0146110039, 0.0132339904, 0.0136831310, -0.0010514662, 0.0000000002, -0.0270159692, -0.0020313740, -0.0187021513, 0.0052929474, -0.0003881594, -0.0019306085, -0.0133902282, -0.0169444252, 0.0000000990, -0.0059350021, 0.0182111319, -0.0055036601, 0.0264159180, 0.0197498892, 0.0018724010, 0.0111341877, 0.0000000046, 0.0105033629, -0.0025736976, 0.0028810590, 0.0000046187, 0.0006851004, -0.0046323072, 0.0085650403, -0.0053867744, -0.0086648287, -0.0064292178, 0.0015665131, 0.0045520612, 0.0044186250, -0.0035114335, -0.0157646053, -0.0172759145, -0.0186815094, 0.0063587087, -0.0013239419, -0.0041660876, -0.0042734919, 0.0000000000, -0.0145250084, -0.0073435507, -0.0125827240, -0.0036490152, 0.0000027623, -0.0028966181, -0.0022632941, 0.0161725041, 0.0036905517, -0.0060947347, 0.0000567514, -0.0005416423, -0.0055787698, -0.0047963108, -0.0225598682, 0.0075967456, 0.0142359482, 0.0099066002, -0.0029773172, -0.0003947230, -0.0079086376, -0.0030442106, -0.0007186615, 0.0007105748, 0.0000000000, 0.0016869210, 0.0004669528, -0.0006758490, -0.0010321860, 0.0005258889, -0.0013908915, -0.0014139685, -0.0008057113, -0.0000000021, -0.0000049422, -0.0012670738, 0.0007604967, 0.0029720606, 0.0008576144, 0.0003283747, -0.0038696581, 0.0000000002, -0.0004632654, -0.0023177990, -0.0006567085, 0.0000001627, -0.0006076983, -0.0021322430, -0.0009443447, 0.0016814732, -0.0001116688, -0.0020978649, -0.0039023282, 0.0001266320, -0.0007517830, -0.0040513044, 0.0002861475, -0.0018656108, 0.0014054994, 0.0010723940, -0.0008556407, -0.0029997556, -0.0016576305, 0.0000000000, 0.0012548113, -0.0001432856, 0.0009507973, 0.0007233415, -0.0000693682, 0.0036200944, 0.0000455086, 0.0004682692, 0.0004529691, 0.0025435891, 0.0000116823, 0.0005949454, 0.0005256236, -0.0019376383, -0.0012437782, 0.0008896958, -0.0016348528, 0.0020480989, 0.0003482104, -0.0002242978, 0.0024843649, 0.0081638489, 0.0095434552, -0.0050174128, -0.0000177192, 0.0065918737, -0.0066187163, 0.0136962822, -0.0088636503, -0.0032180210, 0.0000364573, 0.0034872065, 0.0109931706, -0.0001426937, 0.0188991167, -0.0181017704, -0.0005187877, -0.0169506241, 0.0187728591, -0.0080271047, 0.0213723704, -0.0000006972, -0.0136768110, -0.0012523792, 0.0166050568, -0.0040119677, 0.0003444664, 0.0103503671, 0.0008820205, -0.0055818111, 0.0076123350, 0.0063454579, 0.0065461630, -0.0072041163, -0.0024953291, 0.0202243216, 0.0106623741, 0.0202017836, -0.0002963613, -0.0133268982, -0.0058949753, -0.0077276146, -0.0074295891, -0.0000069994, 0.0001971139, -0.0015687873, 0.0094350073, 0.0025411583, -0.0043319543, 0.0018930829, 0.0081979753, -0.0091727981, 0.0028120454, -0.0008763419, -0.0053449520, -0.0301869772, 0.0006059140, -0.0127318650, 0.0126280636, -0.0102371546, 0.0347582996, -0.0066214856, -0.0042533944, -0.0042969594, -0.0311025213, -0.0137152616, 0.0001700187, -0.0071699782, -0.0000000000, 0.0228469931, 0.0163078718, 0.0129896384, -0.0077439328, -0.0048907716, 0.0001695894, 0.0110906744, 0.0075529735, -0.0000000078, -0.0001568379, -0.0125945648, -0.0078557637, -0.0079021249, -0.0048658899, 0.0000125813, 0.0112455692, 0.0000000120, -0.0028613682, -0.0049323216, 0.0260431226, -0.0001378531, 0.0009772937, -0.0094880210, 0.0046973419, -0.0033038196, -0.0004366338, -0.0153212808, 0.0039425991, -0.0072677941, 0.0027095715, 0.0023610287, -0.0036128690, 0.0065732128, 0.0230054855, 0.0016376465, 0.0002196315, 0.0022758497, -0.0080966456, -0.0000000003, 0.0121537466, 0.0222255792, 0.0118584065, 0.0058382032, -0.0112345153, -0.0042627463, 0.0013289518, -0.0079696495, 0.0024729131, 0.0011215095, -0.0000219526, -0.0041186591, -0.0070275855, 0.0100879315, 0.0014747246, -0.0190849900, 0.0034421729, -0.0062697195, 0.0090283761, -0.0018413443, 0.0103814797, 0.0011133791, 0.0040665781, 0.0127432728, -0.0000000601, -0.0066098757, -0.0152443089, 0.0107221911, -0.0015028866, -0.0009381172, 0.0037070524, 0.0078411764, 0.0049203066, -0.0000041675, 0.0002941781, 0.0144335274, 0.0089855799, 0.0039455257, 0.0050467728, -0.0070156106, 0.0136769963, 0.0000002750, -0.0055067004, 0.0095082251, -0.0022327779, -0.0000639500, 0.0001091550, -0.0020889682, -0.0154846692, -0.0247469470, 0.0110274432, -0.0149730947, -0.0044089169, 0.0073037734, 0.0111877145, 0.0054813777, 0.0009135347, -0.0024062684, -0.0041435277, 0.0029809356, 0.0019648857, -0.0087177055, -0.0005855729, -0.0000000244, 0.0047588656, -0.0030727917, 0.0063863466, -0.0009773143, -0.0000653011, -0.0074802148, -0.0000684491, -0.0071782079, 0.0044506448, 0.0122726327, -0.0009067826, -0.0081386892, -0.0084396545, -0.0026485065, 0.0079098232, 0.0079723392, -0.0047700871, -0.0035451364, -0.0023308969, -0.0020543896, 0.0053633866, -0.0015332157, -0.0006527429, 0.0004442921, 0.0000000000, 0.0006184301, 0.0006612354, -0.0014167206, -0.0015218506, 0.0003207574, -0.0014041414, -0.0021388496, 0.0021899305, 0.0000000002, 0.0003605703, 0.0019026343, 0.0003193692, 0.0020408276, 0.0005423063, 0.0003675125, -0.0041931574, 0.0000000002, -0.0004460755, -0.0016922686, -0.0010250538, 0.0000028545, -0.0008839222, -0.0042491565, -0.0000803210, 0.0018083211, -0.0014436622, -0.0035296958, -0.0017266028, -0.0003061696, -0.0005208785, -0.0059651397, -0.0004498155, -0.0016405941, 0.0048969085, 0.0020474740, -0.0004223605, -0.0027684544, -0.0018481762, 0.0000000000, 0.0011549739, 0.0001739737, 0.0018401647, 0.0011456542, -0.0002601953, 0.0007256987, -0.0002952215, -0.0008339210, 0.0012073817, 0.0024319098, 0.0001626790, 0.0017082649, 0.0003731308, -0.0001823227, -0.0027202659, -0.0001712248, -0.0007551837, 0.0020724966, -0.0056480002, 0.0004609502, 0.0044175545, -0.0093989046, -0.0088726450, 0.0005792941, 0.0000000000, 0.0002508850, -0.0127881998, 0.0030579288, 0.0029305748, 0.0022869110, 0.0019830649, 0.0088756559, 0.0031064821, 0.0000000000, -0.0011749904, -0.0019009940, 0.0045554792, 0.0077885650, -0.0042022746, 0.0011074243, -0.0052361949, -0.0000000003, 0.0015009434, -0.0005545762, 0.0052273646, -0.0000102077, -0.0034269094, -0.0087546455, -0.0036307813, 0.0005949008, 0.0050651981, -0.0084217675, -0.0023182707, -0.0027026390, 0.0091495607, -0.0059677102, 0.0037749847, -0.0014649876, -0.0012546076, -0.0019849725, -0.0002066010, -0.0123847090, -0.0070647551, 0.0000000000, -0.0035741935, -0.0041100676, -0.0002881542, 0.0029773093, -0.0001915127, -0.0064593419, -0.0039260695, -0.0080955233, 0.0032256248, 0.0088469386, 0.0000234066, 0.0026036529, -0.0046815891, 0.0032568707, -0.0014915984, -0.0029077900, -0.0015921462, 0.0023408101, -0.0018784697, -0.0058528921, 0.0042206021, 0.0038345049, 0.0047948202, 0.0019391222, -0.0000000000, 0.0020543579, -0.0124482978, -0.0011672524, -0.0129107740, 0.0026571353, 0.0055177421, 0.0045976196, 0.0036632982, -0.0000000000, 0.0199252460, -0.0044515338, -0.0010420387, -0.0114763891, 0.0037734662, -0.0004675228, -0.0032137623, -0.0000000000, -0.0060408693, 0.0006641762, -0.0122930361, -0.0000005859, 0.0018876345, 0.0067273648, -0.0044274330, 0.0033313988, 0.0004687048, 0.0018458026, -0.0006251012, 0.0005206623, -0.0010732289, 0.0076794745, 0.0061014323, 0.0059042210, -0.0033446841, -0.0060028583, 0.0020305200, 0.0042603170, -0.0054529868, -0.0000000000, -0.0020967312, -0.0087318271, 0.0065980768, -0.0019466481, 0.0003837885, 0.0005808721, 0.0042282101, -0.0130215259, 0.0006883126, -0.0010426376, -0.0000518687, -0.0039955121, 0.0034005137, -0.0073417784, 0.0062080338, -0.0003587438, 0.0115655307, 0.0036857820, -0.0031706281, -0.0088287201, -0.0065976526, 0.0080286656, 0.0010156272, 0.0002564197, 0.0000000000, 0.0057365075, 0.0004848989, -0.0087336171, -0.0006159646, 0.0006686696, -0.0016723478, -0.0037791361, -0.0001412176, 0.0000000010, 0.0016863336, 0.0046955384, 0.0007950119, 0.0015773268, 0.0049535478, 0.0008802582, 0.0000241829, 0.0000000404, 0.0006743836, 0.0073801884, 0.0117748193, 0.0000037797, -0.0006860403, -0.0030913893, -0.0003934737, 0.0016682395, -0.0012333210, -0.0024319079, -0.0017832365, -0.0006672613, -0.0027695012, -0.0021561049, 0.0000090020, -0.0040612114, 0.0015113833, -0.0059022768, -0.0005794873, -0.0016440654, -0.0005469618, 0.0000000000, 0.0009295708, 0.0022446583, -0.0116458507, -0.0002296457, -0.0000673368, -0.0013294064, -0.0008924971, -0.0042865984, 0.0002428167, 0.0006142248, 0.0001211991, 0.0059873639, -0.0035419727, -0.0011410835, -0.0034913323, 0.0029844041, 0.0020626232, 0.0057616793, -0.0130317705, 0.0141134663, -0.0091395015, 0.0019830251, -0.0018662275, -0.0020030604, -0.0000000000, -0.0025320780, -0.0025019299, -0.0048766951, 0.0032219887, 0.0010525795, -0.0001458690, 0.0056588878, -0.0014337704, -0.0000000000, -0.0065221768, 0.0052948720, 0.0032699099, 0.0054519153, 0.0011059587, 0.0005024931, 0.0026645490, -0.0000000000, 0.0058274684, 0.0022714643, 0.0049938625, 0.0000005148, -0.0004977975, -0.0013472026, -0.0048445594, -0.0001012806, -0.0000656297, 0.0060013593, 0.0006535531, 0.0023500822, 0.0071250997, 0.0056058387, -0.0073533072, 0.0030503327, 0.0015630231, -0.0031875840, 0.0008227132, 0.0019192159, 0.0000146683, 0.0000000000, -0.0008884000, -0.0012260966, -0.0059920307, 0.0007243953, 0.0000183381, 0.0003105267, 0.0010447516, -0.0016097461, -0.0059945043, -0.0054844585, -0.0000254350, 0.0005666020, 0.0019472319, -0.0046629151, 0.0015988826, -0.0006686280, 0.0040326104, 0.0058636991, -0.0051427237, -0.0005660438, -0.0023692239, 0.0047982181, 0.0020066497, -0.0089104623, -0.0000000000, 0.0267495960, 0.0075924844, -0.0052089803, -0.0085153915, -0.0068775518, -0.0174761470, 0.0016465196, 0.0050564627, -0.0000000004, 0.0062487945, -0.0144174024, -0.0030067880, -0.0007676317, 0.0052084401, -0.0029157905, 0.0010678158, -0.0000000093, -0.0030022445, -0.0013136392, -0.0037385891, -0.0002017130, 0.0004591123, 0.0052351253, 0.0187868886, 0.0139117735, 0.0015065362, 0.0056289039, 0.0084285336, -0.0070246044, -0.0077772019, 0.0060160910, 0.0025811042, 0.0082569988, 0.0100019500, -0.0139795141, -0.0032436862, -0.0018565293, 0.0098395534, -0.0000000232, 0.0055142608, 0.0112468060, -0.0126296775, -0.0025411015, -0.0023434069, 0.0062137512, 0.0066498318, 0.0079828212, 0.0011502847, -0.0093880659, -0.0000133246, 0.0011747553, -0.0162480418, -0.0117074763, 0.0121032782, -0.0046201330, 0.0014922664, -0.0009787789, 0.0006234457, -0.0051541119, 0.0056325593, -0.0015473261, -0.0015094322, 0.0000369727, 0.0000000009, -0.0257682223, -0.0152776185, -0.0052152695, 0.0055266051, 0.0039251619, 0.0089001348, -0.0146518219, -0.0063349865, -0.0000009838, -0.0099105733, 0.0256162919, 0.0006546504, 0.0160484817, 0.0081434641, 0.0009279045, 0.0063763098, 0.0000000342, 0.0080284150, 0.0022896030, 0.0145204291, -0.0005636233, 0.0005524773, -0.0132230772, -0.0059396131, -0.0183559153, 0.0062637040, -0.0146850925, -0.0014061561, 0.0121755227, 0.0204022359, -0.0080001671, -0.0016678525, -0.0020992067, -0.0036362573, 0.0033910654, -0.0014424310, -0.0134866796, -0.0103512276, -0.0000000000, -0.0051916535, -0.0119729331, -0.0111144511, -0.0021007361, 0.0000233478, -0.0067748888, -0.0000767212, 0.0022429323, 0.0083533227, 0.0049360874, -0.0001884163, 0.0022803156, -0.0087299943, 0.0078012957, -0.0200467277, 0.0046265619, 0.0125140958, -0.0025839456, -0.0081006885, -0.0030091924, 0.0012284194, 0.0039359732, 0.0088127423, -0.0038148428, -0.0000040658, 0.0304206982, 0.0157038886, 0.0048553636, -0.0137674445, -0.0054198606, -0.0114367018, 0.0020887556, 0.0051852642, -0.0001608635, -0.0010073306, -0.0172848888, -0.0030865090, -0.0103605799, -0.0064489278, -0.0050868662, -0.0019491883, -0.0000010408, -0.0140387984, -0.0202116631, -0.0175512154, -0.0028483812, -0.0054150308, 0.0195114408, 0.0100055719, 0.0116022751, 0.0036361844, 0.0194082092, 0.0061957226, -0.0021477717, -0.0093249120, 0.0167379007, 0.0039455434, 0.0315976478, 0.0012874661, -0.0101310303, 0.0036055688, 0.0003264712, 0.0056228600, -0.0000013008, 0.0031669859, 0.0099401204, 0.0037110918, 0.0065380093, -0.0160325319, 0.0044045243, 0.0009392225, 0.0089560114, -0.0058095125, 0.0030332380, -0.0040256893, -0.0027115645, 0.0047836965, -0.0030647730, 0.0272304770, 0.0048901574, -0.0091675101, -0.0163046699, 0.0213087630, -0.0074776537, 0.0003566961, 0.0043503842, 0.0042083459, -0.0031284317, 0.0000000061, -0.0130559970, -0.0137618212, -0.0158591866, 0.0108784139, -0.0025774038, -0.0023654485, -0.0007504912, -0.0100361910, 0.0000010307, 0.0009386588, 0.0143877193, -0.0048843091, 0.0188098960, 0.0188857242, 0.0023654609, 0.0135882217, -0.0000000009, 0.0168665797, 0.0090994891, 0.0125955176, 0.0000487166, -0.0008185258, -0.0069520185, 0.0133973463, -0.0019857376, -0.0013875633, -0.0098390132, -0.0026940159, 0.0049857339, 0.0026600899, -0.0049995780, -0.0122956047, -0.0158772431, -0.0090942038, -0.0048995405, 0.0003015659, -0.0030914200, -0.0069669159, 0.0000000000, -0.0065054526, 0.0001347337, -0.0209002625, -0.0070011397, 0.0001357792, -0.0040692305, -0.0035292702, 0.0070568547, 0.0134317111, -0.0043091127, 0.0002835165, -0.0008889217, -0.0147137204, -0.0091656158, -0.0190760735, 0.0052134721, 0.0047786809, -0.0040790206, -0.0121346246, 0.0128669497, 0.0040945075, -0.0125940796, 0.0004408124, -0.0029151777, 0.0000000000, 0.0098826224, 0.0067918492, 0.0039176005, -0.0031162745, -0.0015511174, -0.0035160980, 0.0000033354, 0.0012442102, -0.0000000032, 0.0055759181, 0.0053114272, -0.0008467073, 0.0129706608, 0.0064743557, 0.0018109557, 0.0030227061, -0.0000000016, 0.0008647856, -0.0069567305, 0.0040344344, 0.0000284972, -0.0003397232, -0.0079031140, 0.0078233844, 0.0008595103, -0.0005434812, -0.0037681309, 0.0021222560, -0.0102862669, -0.0040072640, -0.0008082125, -0.0013449945, -0.0021238287, 0.0123395761, 0.0031127583, 0.0015127941, 0.0026011087, -0.0108271921, 0.0000000002, 0.0030012450, 0.0124242930, 0.0048164460, 0.0007533640, -0.0063223108, 0.0074060550, -0.0052416055, 0.0040310007, 0.0005644405, 0.0022970596, 0.0000291650, 0.0000289556, -0.0147259403, 0.0026893986, -0.0041206861, -0.0135235339, 0.0043327683, 0.0070495591, 0.0107604805, -0.0032726626, -0.0038258906, -0.0033049481, 0.0038353275, -0.0080669532, 0.0000000000, -0.0036902118, -0.0082580186, 0.0003642158, 0.0058841454, -0.0047635036, -0.0040867575, 0.0045627379, -0.0010285354, -0.0000000084, 0.0025747193, 0.0024562825, -0.0040283808, 0.0182330403, 0.0153445825, -0.0004835566, 0.0195105541, -0.0000004210, 0.0103542199, 0.0055554234, 0.0115300305, 0.0000143996, -0.0005238845, -0.0054551205, 0.0051314412, -0.0104721515, 0.0057851374, -0.0080149220, 0.0024394244, 0.0007497320, -0.0036126324, 0.0049112993, -0.0135910576, -0.0091159390, -0.0079746731, -0.0035244976, -0.0018049732, -0.0032372652, -0.0037146383, 0.0000000000, -0.0051677781, 0.0105984397, -0.0126763145, -0.0093002031, -0.0006183666, -0.0056113810, -0.0002850536, 0.0025868015, 0.0143972691, -0.0005511381, 0.0000667480, -0.0105708307, -0.0234352965, -0.0096883299, -0.0059549990, -0.0040794951, 0.0063161380, -0.0116023533, -0.0048713973, 0.0061862217, -0.0031690458, -0.0065610255, -0.0044761137, 0.0016107142, 0.0000000000, 0.0182983819, 0.0004679826, -0.0087247770, -0.0017116744, 0.0001197269, -0.0084784226, 0.0018198104, -0.0008787500, -0.0000000000, -0.0004584492, 0.0018111359, 0.0022708522, 0.0101503385, -0.0026069926, -0.0004134179, -0.0057267607, -0.0000001361, -0.0000371257, -0.0014009210, -0.0113156838, 0.0000001166, -0.0005335871, 0.0076758489, 0.0122647211, 0.0045869080, 0.0001999734, 0.0026812486, -0.0106443278, 0.0040556956, -0.0008067057, -0.0009854125, -0.0006489892, -0.0006611106, 0.0020691697, 0.0025934372, -0.0012568377, 0.0029113523, 0.0180815384, 0.0000000000, 0.0079896534, -0.0010803724, 0.0030532526, -0.0029900596, -0.0001014673, 0.0043590283, -0.0021591890, 0.0109413508, 0.0017993395, 0.0059339046, 0.0000306180, 0.0028304998, -0.0016315393, -0.0115520786, 0.0125787947, 0.0036430813, -0.0050341235, 0.0038618005, -0.0018685767, -0.0004716431, 0.0067820614, -0.0049550338, -0.0134425284, 0.0039462959, 0.0000000000, -0.0003690877, -0.0195123050, -0.0037893455, 0.0048070485, 0.0028175437, -0.0073955772, 0.0118335234, 0.0043155188, -0.0000003282, -0.0018715474, 0.0075883307, 0.0057001188, 0.0079035666, 0.0032698947, 0.0001638506, 0.0000293264, -0.0000000358, 0.0125828497, 0.0218820442, 0.0137724523, 0.0000105698, -0.0002107113, 0.0028048852, -0.0000552717, -0.0067978757, 0.0095444517, -0.0048549785, -0.0074183531, -0.0025064538, 0.0014317337, -0.0011533024, -0.0077732704, -0.0101420674, -0.0099826446, -0.0188078210, -0.0011275777, -0.0134156784, 0.0262470860, 0.0000000000, -0.0044849603, -0.0036539861, -0.0174818169, -0.0153558068, 0.0001150724, -0.0038075505, 0.0061220070, -0.0056302263, 0.0153431427, 0.0025976456, 0.0000679108, -0.0005511757, -0.0020108321, -0.0068067415, 0.0031013777, 0.0092644412, -0.0075775469, -0.0040340694, -0.0218723509, 0.0092596393, 0.0114973076, -0.0190640073, -0.0137712080, 0.0012798681, 0.0000000000, 0.0056696953, -0.0177906752, 0.0255076922, 0.0001262333, 0.0032963739, 0.0134141399, 0.0188984349, 0.0183228869, -0.0000000000, -0.0042012921, 0.0040592966, 0.0035134673, -0.0171202309, -0.0112373931, 0.0009726486, 0.0006649785, -0.0000000000, -0.0056781238, 0.0114791458, 0.0140398853, 0.0000047038, -0.0041690986, -0.0108513813, -0.0131097557, -0.0078394059, 0.0097399428, -0.0145078972, -0.0003862081, 0.0023720199, 0.0165820401, -0.0097585712, 0.0029742685, 0.0062965965, -0.0026392154, -0.0044711949, -0.0000454715, -0.0116602816, -0.0165968612, -0.0000000000, 0.0049319314, -0.0046152626, -0.0005352541, 0.0021692025, 0.0002711635, -0.0117825074, 0.0003376119, -0.0227799620, 0.0015835150, 0.0064923647, -0.0000110339, -0.0004993657, 0.0018981472, 0.0184380244, -0.0035978465, -0.0105367573, -0.0016472106, -0.0016206299, -0.0017204480, -0.0042602019, 0.0118798232, -0.0044581452, -0.0045045014, -0.0008586420, 0.0000000001, -0.0071054935, -0.0126455212, -0.0012871942, 0.0046520275, 0.0012591917, 0.0008389656, -0.0056668632, -0.0095727667, 0.0000001230, -0.0012162831, 0.0162769724, -0.0014032843, 0.0080948155, 0.0051158457, 0.0065547158, -0.0103261853, 0.0000000093, 0.0155937262, -0.0061133327, 0.0030227490, 0.0003919668, 0.0006233201, -0.0106322346, 0.0145215020, 0.0023430616, -0.0051371930, -0.0150233330, -0.0052528693, -0.0006303214, 0.0092115905, -0.0086584156, 0.0026406732, -0.0098775346, -0.0035881831, 0.0045898925, -0.0036216106, 0.0023803790, -0.0054897466, 0.0000000006, -0.0049346709, 0.0049670283, -0.0057038800, 0.0050256466, 0.0042645903, -0.0040579443, -0.0122964801, 0.0031968509, -0.0023227634, -0.0022929148, 0.0004070220, 0.0049645123, -0.0033887005, 0.0046375510, -0.0226238202, -0.0033168588, -0.0078672040, 0.0125830714, -0.0018628259, 0.0033084601, 0.0055908491, -0.0154642621, -0.0121306786, 0.0031139778, 0.0000000000, 0.0054845223, -0.0130517809, -0.0033495554, 0.0023761389, 0.0033652328, 0.0023001689, 0.0106824515, 0.0076227915, -0.0000000080, -0.0037942054, 0.0061004329, 0.0142858634, 0.0125990221, -0.0062617795, 0.0012240072, -0.0098883063, -0.0000000000, 0.0049221334, 0.0052329060, 0.0019263857, -0.0000294104, 0.0001251486, -0.0027584138, -0.0026119836, 0.0020835956, 0.0023912152, -0.0023053654, -0.0052100304, -0.0014549545, 0.0061160717, -0.0107826004, 0.0070253676, -0.0010338200, 0.0008633312, -0.0015473897, 0.0013967853, -0.0149745187, -0.0078717386, 0.0000000000, 0.0039885584, -0.0110299047, 0.0056031742, -0.0010378071, -0.0000524532, 0.0052341018, 0.0007832049, -0.0090812743, 0.0077950926, 0.0088810893, -0.0000009102, 0.0081084017, -0.0034838440, -0.0095616076, 0.0107961353, -0.0003703890, -0.0102353096, 0.0019785909, 0.0002415395, -0.0043897186, 0.0105047664, -0.0024790487, 0.0003661416, -0.0036467928, -0.0000000000, 0.0153560489, -0.0016905542, -0.0005476972, -0.0060559404, -0.0013546854, -0.0050647939, 0.0039655417, 0.0009334368, 0.0000000000, 0.0048540742, 0.0088308128, 0.0011361161, -0.0061789919, 0.0029087772, -0.0000406052, -0.0043183928, 0.0000000000, -0.0037156092, -0.0085106324, -0.0167960171, -0.0000000462, 0.0003458273, 0.0056036348, 0.0052676606, -0.0003062229, 0.0064352020, -0.0042793648, -0.0047609042, -0.0026642438, -0.0012227297, 0.0031392826, -0.0008183338, 0.0016048064, -0.0052672625, -0.0007119741, -0.0046996381, 0.0014490215, 0.0126129175, 0.0000000000, 0.0028820422, -0.0036230781, 0.0029978566, 0.0035361580, 0.0001057916, 0.0025700452, -0.0005676619, 0.0047334200, -0.0002520639, 0.0041137412, -0.0000073894, -0.0014161151, 0.0055383528, -0.0069210124, 0.0063009392, -0.0009995876, -0.0032426019, 0.0051978212, -0.0058819097, -0.0008853404, 0.0000398700, 0.0029817633, -0.0022758972, 0.0051340889, -0.0000047559, 0.0189295486, -0.0106486343, 0.0041129403, -0.0065223346, 0.0003510091, -0.0176517908, 0.0150748389, -0.0019458297, -0.0001734324, 0.0072639077, -0.0005273105, 0.0064344290, -0.0133930380, -0.0116676576, -0.0064269579, -0.0109582543, -0.0000151540, -0.0167139471, -0.0071921898, -0.0206813272, -0.0006315287, -0.0014622385, 0.0125099178, 0.0086478218, -0.0032424936, 0.0090591572, 0.0080067813, -0.0042047496, 0.0083838431, -0.0022279224, 0.0138430363, 0.0104253171, 0.0253728926, -0.0050760275, -0.0041071679, -0.0080282120, 0.0029509170, 0.0126031581, -0.0000005569, 0.0075100637, -0.0087400377, 0.0078050327, -0.0046577468, 0.0001694514, 0.0086016692, -0.0034237376, 0.0152685102, 0.0029308875, 0.0104386741, -0.0027037656, -0.0159561187, 0.0080484999, -0.0179318320, 0.0285478514, 0.0146233998, -0.0108003058, -0.0129281506, 0.0006939273, -0.0020323924, -0.0056218798, -0.0049977303, -0.0148098720, 0.0006414155, 0.0000000000, 0.0129471123, -0.0112551358, 0.0070380969, -0.0033453531, -0.0000139136, -0.0153413648, 0.0116713205, -0.0033393358, 0.0000000022, 0.0029839117, 0.0003743917, 0.0053290688, 0.0087108603, 0.0086496342, 0.0015701957, -0.0042320490, 0.0000000388, 0.0109967338, -0.0003913575, 0.0068967328, -0.0000020778, -0.0022063490, 0.0022799021, 0.0096677067, -0.0105487695, 0.0093518682, -0.0137329660, -0.0075082295, -0.0100827748, -0.0038456258, 0.0032190406, -0.0022301716, -0.0032052794, 0.0004450037, -0.0052467929, -0.0040509971, -0.0015938547, 0.0127927782, 0.0000000000, 0.0035104828, 0.0075732060, -0.0094335927, -0.0084278509, -0.0001189771, -0.0054111462, -0.0105139660, 0.0044431733, 0.0106308563, 0.0054100524, 0.0001025484, -0.0023445191, -0.0046702111, -0.0055982941, 0.0095201302, -0.0019178063, -0.0083464989, 0.0061051226, -0.0119015155, 0.0060348068, -0.0000064881, 0.0040958961, 0.0016109938, 0.0004972477, -0.0000001869, -0.0050502629, -0.0311308727, -0.0018100655, 0.0051491121, 0.0036217195, -0.0102472426, 0.0193218365, -0.0092321588, -0.0001374606, 0.0110415490, 0.0094673755, -0.0034959600, 0.0155989295, 0.0138275623, -0.0019487485, 0.0028769972, 0.0000002396, 0.0126524772, 0.0124631701, 0.0126066804, -0.0003468808, -0.0014062189, 0.0083502969, 0.0091433758, -0.0242917333, 0.0116256913, -0.0019564733, -0.0096649602, 0.0050134747, 0.0215242989, 0.0063769096, -0.0042165373, -0.0024272448, -0.0055632605, -0.0193582512, -0.0079134051, 0.0030517005, 0.0295198336, -0.0000000101, -0.0046526738, -0.0152700339, -0.0119795306, -0.0179975070, -0.0000665866, -0.0073366649, 0.0043015978, 0.0110060349, 0.0245417077, 0.0090091694, -0.0005800386, -0.0177115612, -0.0006891608, -0.0040318044, 0.0013537409, 0.0191535614, 0.0134036262, -0.0151166115, -0.0288612414, 0.0095384335, -0.0238397773, -0.0019925493, -0.0040501868, 0.0009272875, 0.0000000000, 0.0019049697, 0.0012524677, -0.0017619098, -0.0014040325, 0.0003073581, -0.0012328890, -0.0022045865, -0.0002074337, 0.0000000000, -0.0002806390, 0.0017764961, 0.0009491654, 0.0012082722, -0.0016480424, 0.0004533479, -0.0042462661, -0.0000000000, -0.0003936711, -0.0016772260, -0.0008312045, 0.0000004280, -0.0008191257, -0.0032499204, 0.0011331959, 0.0006896604, -0.0011633177, -0.0035017580, -0.0000190625, -0.0001216886, -0.0004489041, -0.0010409795, -0.0008401113, -0.0019613735, 0.0020627421, 0.0016721749, -0.0007429590, 0.0011763689, -0.0022050170, 0.0000000000, -0.0004879928, -0.0008264605, 0.0002569374, 0.0024426272, -0.0001180785, -0.0001063571, -0.0005630921, -0.0000664127, 0.0008228873, 0.0005711416, 0.0000146143, 0.0013970442, 0.0007825158, 0.0004825056, -0.0037709689, -0.0002804211, -0.0023109608, 0.0031110966, -0.0017361345, 0.0009792484, 0.0046284362, 0.0007067529, -0.0014076817, -0.0096429018, -0.0000000000, -0.0011221556, 0.0202743169, 0.0009789295, -0.0000742454, -0.0100090355, 0.0066330787, -0.0036633075, 0.0141811622, -0.0000000000, -0.0239159074, -0.0101558594, -0.0065576001, 0.0054885023, -0.0052040434, -0.0006014537, 0.0082513271, 0.0000000000, -0.0007766558, 0.0053036953, 0.0261826031, -0.0000176217, 0.0007221524, -0.0128247961, 0.0110712601, 0.0043770885, -0.0038293926, -0.0175232068, -0.0024326823, 0.0018506201, 0.0074620643, -0.0127603579, -0.0092559531, -0.0054485146, 0.0193570163, -0.0001651108, 0.0125503391, -0.0105869314, -0.0139031131, -0.0000000000, 0.0116935438, 0.0240927674, 0.0094353016, 0.0125487149, -0.0095807901, -0.0011921460, -0.0004784920, -0.0031822822, -0.0048517231, 0.0012134672, 0.0000037323, 0.0048216661, -0.0023481599, 0.0212742407, -0.0091254041, -0.0145446779, 0.0058203526, -0.0037781042, 0.0051105754, 0.0091543021, 0.0175785832, 0.0021286153, 0.0046884497, 0.0027142232, 0.0000000000, 0.0011910830, -0.0065512639, -0.0102273636, 0.0037509589, 0.0024096263, -0.0013813672, 0.0010905500, -0.0002065010, 0.0000000000, 0.0064822375, 0.0097281151, 0.0168602671, 0.0104412148, 0.0120171085, 0.0009796800, -0.0018657359, -0.0000000000, 0.0012527284, 0.0006942304, -0.0091325492, -0.0000001405, 0.0000643155, 0.0044543357, -0.0131045841, 0.0012398117, 0.0038153047, 0.0029940114, 0.0006820001, -0.0013081592, 0.0003862726, 0.0149756866, 0.0020963054, -0.0003428064, -0.0111373262, -0.0030307726, 0.0019117680, -0.0037138641, 0.0064091529, -0.0000000000, -0.0006186065, -0.0047838758, -0.0093214484, -0.0034100101, 0.0001339077, 0.0013373464, 0.0032384559, -0.0091686454, 0.0016554279, -0.0062390710, 0.0000048370, 0.0166226793, -0.0127942003, -0.0212805923, 0.0166944321, 0.0092698550, -0.0082918908, 0.0160225965, -0.0077210451, 0.0013504323, 0.0063319625, -0.0050786957, 0.0052663456, -0.0029565685, 0.0000000000, 0.0026265418, 0.0057511996, -0.0033586507, -0.0021041578, -0.0016318436, 0.0006251893, -0.0031497001, 0.0058780354, 0.0000000004, -0.0002899786, 0.0049978928, 0.0067025633, 0.0045412555, 0.0033789065, 0.0009550932, 0.0009340702, -0.0000000000, 0.0001348916, 0.0012047585, -0.0064170337, -0.0000000225, -0.0010262396, -0.0045400276, -0.0006941439, 0.0063369866, 0.0015174706, -0.0046371268, 0.0000728484, 0.0003205491, -0.0064764055, 0.0025998568, 0.0005368888, -0.0077963374, 0.0006437446, 0.0003485943, 0.0012431714, 0.0007483519, -0.0026838256, 0.0000000000, -0.0003153276, 0.0026457387, -0.0013886349, 0.0027585365, -0.0000295495, 0.0034897886, 0.0000698349, -0.0094826976, -0.0004168250, -0.0002526718, 0.0000264288, 0.0147755779, -0.0036507971, -0.0080257868, 0.0047216052, 0.0003919356, -0.0150276609, 0.0109117916, 0.0040463717, 0.0026445303, 0.0088720098, -0.0030497583, -0.0034998443, 0.0006382675, 0.0000000000, -0.0011339623, -0.0011707970, -0.0019322338, -0.0005210788, 0.0004815906, -0.0015482833, -0.0026986576, -0.0004938713, 0.0000000058, 0.0010073633, 0.0024055671, -0.0005372313, 0.0003088255, 0.0002904229, 0.0009619716, -0.0041662054, 0.0000000000, 0.0028595689, -0.0032499640, -0.0000630807, 0.0000027374, -0.0010797656, -0.0021399048, 0.0034544931, 0.0019090367, -0.0029109581, -0.0004544540, -0.0005069788, -0.0017932844, -0.0025388089, -0.0012808880, 0.0039622434, -0.0038665691, 0.0007369129, 0.0024776708, -0.0009855184, 0.0016781823, -0.0020436109, 0.0000000000, -0.0046947794, -0.0023887719, -0.0014489199, 0.0022724699, 0.0000125874, 0.0015634712, -0.0029233664, -0.0011027557, -0.0014360568, 0.0009578359, 0.0000310266, 0.0044989316, 0.0020646334, 0.0005807389, -0.0058240159, -0.0003351667, -0.0011350067, 0.0077629331, -0.0025575277, 0.0013518067, -0.0005210262, 0.0040505049, 0.0023587216, -0.0004481237, 0.0000000005, -0.0029584749, -0.0008108441, -0.0069239340, 0.0045638299, 0.0040686806, -0.0029170713, -0.0116813462, -0.0093819415, 0.0000000285, 0.0025084354, 0.0090636350, 0.0058771120, 0.0026680485, 0.0079782568, 0.0016704057, -0.0014311018, 0.0000000000, -0.0022266645, -0.0046509840, -0.0026353614, 0.0000303408, -0.0012209726, -0.0070489305, 0.0059723677, 0.0032611985, -0.0023597227, -0.0055602049, 0.0001633180, -0.0005814050, -0.0041768015, 0.0038228880, -0.0022419596, -0.0024605880, -0.0047221752, 0.0041068657, -0.0012217222, 0.0050196345, -0.0014350612, 0.0000000000, -0.0055382615, -0.0036407628, -0.0091739818, 0.0008467572, 0.0000701908, 0.0010074023, -0.0050511835, 0.0055698929, -0.0067149452, -0.0035923035, 0.0000266006, 0.0056717778, 0.0044119409, -0.0069806725, -0.0024066907, 0.0001111729, -0.0056134379, 0.0055964286, -0.0044731260, 0.0032927610, 0.0057097753, -0.0011110567, -0.0004748255, 0.0000881872, 0.0000000000, -0.0013112531, -0.0002170611, -0.0023432830, -0.0006186441, 0.0004476613, -0.0010893920, -0.0033476891, -0.0005404542, 0.0000000001, 0.0012832457, 0.0014169624, 0.0035808191, 0.0014302037, 0.0015969849, 0.0005911370, -0.0015631433, -0.0000000000, -0.0003931808, -0.0012512142, -0.0005960007, 0.0000001184, -0.0007763501, -0.0013076768, -0.0001996793, 0.0017827860, 0.0004118563, -0.0008749650, 0.0002177628, -0.0008853152, -0.0004459923, 0.0002084469, 0.0005789344, -0.0015609829, 0.0007795140, 0.0016982562, -0.0002831271, 0.0010103708, -0.0018841256, 0.0000000000, -0.0011547614, 0.0003977384, -0.0007373003, 0.0005912451, -0.0000825663, -0.0007133566, -0.0005620349, -0.0013921859, -0.0003907787, -0.0000041439, 0.0000130699, 0.0029108280, 0.0002553755, -0.0014299707, -0.0011254848, 0.0007378418, -0.0019791210, 0.0031617587, -0.0020299817, 0.0011785106, 0.0010991712, -0.0010540792, -0.0037108802, 0.0018089771, 0.0000000000, -0.0018113567, -0.0007218104, 0.0011800840, 0.0026690857, 0.0006311155, -0.0017138012, -0.0018074018, -0.0001866628, 0.0000000012, -0.0006059082, 0.0063204416, -0.0024158193, -0.0020461259, 0.0036799477, 0.0007639411, -0.0059304428, -0.0000000000, 0.0020348832, -0.0032717541, 0.0016481469, 0.0000010982, -0.0036498483, -0.0013842920, 0.0104766572, 0.0021642721, -0.0053181471, -0.0010468919, -0.0007176446, -0.0008702101, 0.0000371620, -0.0020267409, 0.0036673225, -0.0045545110, -0.0001047404, 0.0014017544, -0.0008768637, -0.0001536830, -0.0003505470, 0.0000000000, -0.0066256267, -0.0038014774, -0.0028772524, 0.0016906735, -0.0000891458, 0.0032622372, -0.0035326018, 0.0005973266, -0.0011565560, -0.0014036795, 0.0000264517, 0.0027333568, 0.0043887729, -0.0025255342, -0.0035320767, -0.0007816188, -0.0011389576, 0.0053178770, -0.0020316632, 0.0022591411, -0.0022595397, 0.0001673697, -0.0015332421, -0.0006460095, 0.0000000000, 0.0003860533, -0.0006072365, 0.0013468127, -0.0012060815, -0.0003115450, -0.0011738417, -0.0021853398, -0.0004950278, 0.0000000000, -0.0007862937, 0.0012399661, -0.0001695624, 0.0038235560, 0.0030242729, 0.0004383725, -0.0019046478, -0.0000000000, -0.0003407607, -0.0017554120, 0.0117841354, -0.0000001296, -0.0007818640, 0.0014475862, 0.0008922881, 0.0010277585, 0.0012782267, 0.0016552904, -0.0006810890, -0.0030686583, -0.0008974986, -0.0043513044, 0.0010776129, -0.0019676578, 0.0029192530, 0.0064563779, 0.0011004393, -0.0024100663, -0.0024964171, 0.0000000000, -0.0040936638, -0.0019607623, 0.0021038915, 0.0012047036, -0.0000785362, -0.0009304860, -0.0009045764, -0.0015434574, 0.0007010116, 0.0002384796, 0.0000123457, -0.0015964039, -0.0006411571, -0.0014846955, -0.0046071936, -0.0004851357, 0.0005796338, 0.0030929327, -0.0009852804, 0.0011652911, -0.0028109900, 0.0156197790, 0.0128782084, 0.0008669697, -0.0000127937, 0.0149922483, -0.0010690397, 0.0084518548, -0.0051508425, -0.0055961246, -0.0009335448, 0.0070257857, 0.0091729155, -0.0002353415, 0.0016704667, -0.0052072722, -0.0038609265, -0.0096525755, -0.0037668077, -0.0078560291, 0.0073667904, -0.0000017462, -0.0087908320, 0.0089601818, 0.0003856684, -0.0034890610, -0.0047418470, 0.0105097443, -0.0021541445, 0.0026294701, 0.0024077112, 0.0070036179, 0.0076113143, 0.0091780191, 0.0006647225, 0.0023505252, 0.0036373795, 0.0159517638, 0.0008723920, -0.0081079258, -0.0021914786, 0.0014603701, -0.0006958098, -0.0000030618, -0.0039252671, -0.0073120585, 0.0057407655, 0.0011028955, -0.0004267817, 0.0048068273, 0.0038380858, 0.0032260884, -0.0000097824, 0.0100292228, -0.0034335449, -0.0195123758, -0.0020266240, 0.0130117228, 0.0080903452, 0.0097955437, 0.0058476753, -0.0253483970, 0.0033072201, -0.0013591066, -0.0011224957, -0.0000056562, -0.0027447776, 0.0026992534, 0.0000000000, 0.0052428809, 0.0045797308, 0.0012757067, -0.0004796991, -0.0023535425, 0.0065781805, 0.0038572992, 0.0076265009, -0.0000000000, -0.0061326786, -0.0058602267, -0.0094155315, -0.0067940555, -0.0124703646, -0.0003853372, -0.0012745949, -0.0000000000, 0.0003615928, 0.0066058775, 0.0020960537, -0.0000697295, 0.0007402893, -0.0083057154, -0.0029313441, 0.0004560830, -0.0012924348, -0.0171092022, 0.0015776828, 0.0048179417, 0.0059000030, -0.0109515032, -0.0071990890, 0.0038121522, -0.0075271674, -0.0047957245, 0.0002298065, -0.0015599829, -0.0005862238, 0.0000000000, 0.0090703294, 0.0001628917, 0.0077471975, 0.0022594794, -0.0007706026, 0.0063760364, 0.0029767221, 0.0034494179, 0.0016592266, 0.0030843664, -0.0000149906, -0.0051712710, -0.0014389935, 0.0158112403, -0.0032010220, -0.0044038962, 0.0009438986, -0.0111234495, 0.0003912480, -0.0025666587, 0.0116498517, 0.0175820235, 0.0097476244, 0.0089647034, -0.0000000062, -0.0040505594, -0.0127052674, -0.0028416943, 0.0005692699, 0.0004423014, -0.0040121912, 0.0080762189, -0.0040550176, -0.0000008421, 0.0029670387, 0.0085498914, 0.0022758152, 0.0056999270, 0.0176111199, -0.0069598900, 0.0030176588, -0.0000000131, -0.0123644425, 0.0041713212, -0.0179081950, -0.0001265627, -0.0004941135, 0.0116057238, -0.0056438497, -0.0111961486, 0.0025046845, 0.0033777137, 0.0036518562, 0.0085697845, 0.0030613362, 0.0129863257, -0.0067352913, 0.0103995269, -0.0164878983, -0.0048047965, 0.0016236970, -0.0161232483, 0.0082588065, -0.0000000011, 0.0007126402, -0.0182178486, -0.0056236214, -0.0086616939, 0.0007706942, 0.0043539247, 0.0019235817, 0.0021391877, 0.0004816732, 0.0026844800, -0.0006449503, -0.0035642714, -0.0043013543, -0.0251987614, 0.0212263707, 0.0162452329, 0.0036664624, -0.0022902044, 0.0055129305, -0.0026407579, -0.0040948903, -0.0012632903, -0.0013910424, -0.0005435219, 0.0000000000, 0.0000819314, 0.0001791752, 0.0006849259, -0.0016130481, 0.0001979998, -0.0014571903, -0.0027075864, -0.0001594198, 0.0000000000, 0.0000898842, 0.0019993375, 0.0012451550, 0.0018715074, 0.0011741660, 0.0004149699, -0.0016465222, 0.0000000000, -0.0005539568, -0.0018382566, 0.0093127498, 0.0000001445, -0.0010711210, -0.0013990288, 0.0009728367, 0.0011737208, 0.0008403998, -0.0019412598, -0.0005933236, -0.0018915116, -0.0007847478, -0.0026470690, 0.0002803915, -0.0016826168, 0.0030658026, 0.0056807892, -0.0005912195, 0.0003246710, -0.0030180360, -0.0000000000, -0.0026229476, -0.0009765988, 0.0013521649, 0.0024098041, -0.0000965532, -0.0010585696, -0.0008830861, -0.0017836482, 0.0013965484, 0.0008025779, 0.0000174541, 0.0002714682, -0.0000007614, -0.0001469851, -0.0051178909, -0.0006838734, -0.0006386855, 0.0037957728, -0.0016880955, 0.0011638561, 0.0016903881, 0.0005707188, -0.0029884411, 0.0018694990, 0.0000000000, -0.0040815049, -0.0028044002, 0.0018068007, 0.0001747757, 0.0028698940, -0.0034052497, -0.0028420510, -0.0089212470, 0.0000000000, -0.0005567896, 0.0036227074, -0.0012467809, 0.0025711737, 0.0031820927, 0.0009520845, -0.0019813708, 0.0000000000, -0.0031383049, -0.0040673553, 0.0092632445, 0.0000006968, -0.0006681373, -0.0047871764, 0.0058396165, 0.0034276880, -0.0027052350, -0.0013718785, -0.0011517206, -0.0033664224, -0.0007224504, 0.0009178573, -0.0044087693, -0.0019878098, -0.0022202996, 0.0060719117, -0.0026987346, 0.0071454858, -0.0026414602, 0.0000000000, -0.0067387898, -0.0023937449, -0.0058528464, 0.0038886170, -0.0000796167, -0.0012003507, -0.0062315473, 0.0023641144, -0.0000844557, -0.0024984633, 0.0000205488, -0.0044623320, 0.0042381762, 0.0026427405, -0.0107859960, -0.0002694321, 0.0031374705, 0.0001557812, -0.0078466870, -0.0005157025, 0.0024932437, 0.0084570656, 0.0099009806, -0.0007442757, -0.0000000000, -0.0008872604, -0.0039019508, -0.0095392605, 0.0015304611, 0.0016764898, -0.0004128310, -0.0039992719, -0.0020715820, 0.0000000000, 0.0065254620, 0.0077683385, 0.0123501802, -0.0020982015, 0.0076625091, -0.0006260471, 0.0043995092, 0.0000000000, 0.0023972197, 0.0058285496, -0.0190732647, -0.0000257306, 0.0017616486, 0.0098220753, -0.0121195195, 0.0012376650, 0.0059106559, 0.0131661762, 0.0023646930, 0.0001534114, -0.0018936290, 0.0146884667, 0.0055525037, 0.0046985117, -0.0066580768, -0.0083288094, 0.0012503577, -0.0008875629, 0.0143162692, -0.0000000000, -0.0031469811, -0.0075634615, -0.0117775016, -0.0085865967, 0.0003976187, 0.0016074013, 0.0071347761, -0.0030468914, -0.0046842322, -0.0067045679, -0.0000347420, 0.0102297198, 0.0001443745, -0.0163510554, 0.0157849491, 0.0112920832, -0.0101445885, -0.0056784283, -0.0046380358, -0.0021578162, -0.0043650749, -0.0025284737, -0.0017914175, 0.0007878608, 0.0000000000, -0.0004685164, 0.0001996040, -0.0016877904, -0.0009898209, 0.0001953559, -0.0012324267, -0.0018188754, 0.0000577107, 0.0000000008, 0.0023277309, 0.0008235036, 0.0015005615, 0.0015533725, 0.0013026012, 0.0009278939, -0.0032080903, -0.0000000000, 0.0007130069, -0.0021708359, -0.0004929247, 0.0000017891, -0.0010038859, -0.0020231656, 0.0010016053, 0.0017350493, 0.0004210841, -0.0009603079, -0.0001762568, -0.0005145043, -0.0009936608, -0.0007795491, 0.0011300475, -0.0032101895, 0.0021836229, 0.0032242066, -0.0009209429, 0.0020897076, -0.0018387508, 0.0000000000, -0.0005891139, 0.0000867840, -0.0001347059, 0.0022706171, -0.0000847303, -0.0013696559, -0.0011395557, -0.0021747772, 0.0002190959, 0.0012656929, 0.0000257550, 0.0029930137, 0.0002658289, -0.0008575395, -0.0055040205, 0.0004485232, -0.0016718342, 0.0047617387, -0.0025738950, 0.0017692775, 0.0025289494, -0.0010346802, 0.0020346052, -0.0018767876, -0.0000000000, -0.0020105953, -0.0015544047, -0.0031684043, 0.0040603527, 0.0016890730, -0.0000785280, 0.0019701419, -0.0029249522, -0.0000000002, -0.0045862487, 0.0047825114, 0.0057814163, 0.0054114168, -0.0008253318, 0.0001846566, 0.0026946601, -0.0000000000, 0.0008502342, 0.0011288951, 0.0008069149, 0.0000001685, -0.0003981586, -0.0019813306, -0.0045911889, 0.0016884442, -0.0000742244, 0.0079496261, -0.0016992686, 0.0006583448, 0.0067931390, 0.0019339710, -0.0074729258, 0.0042247488, -0.0008068433, -0.0036839307, 0.0011857970, 0.0039176573, -0.0036689821, 0.0000000000, -0.0021992342, -0.0009520641, -0.0085864700, 0.0016017342, 0.0000059553, 0.0011917142, 0.0013302896, 0.0019547017, -0.0070800353, -0.0016635315, -0.0000265689, -0.0008495586, 0.0018184334, 0.0021283384, 0.0013930931, -0.0006343888, 0.0048149824, 0.0131322155, -0.0042621237, -0.0006574229, -0.0031334511, -0.0041530598, 0.0044064182, -0.0107606184, -0.0000000000, 0.0124064088, 0.0135317482, -0.0061827400, 0.0008831641, -0.0067192805, 0.0034181103, 0.0025413618, 0.0142902751, -0.0000000000, -0.0138960779, -0.0022280116, 0.0094503108, 0.0117182303, 0.0033761454, -0.0001697270, 0.0075456677, -0.0000000000, 0.0011613934, 0.0024463206, 0.0098081641, -0.0001344997, 0.0005129666, -0.0042187148, -0.0014982850, 0.0046284236, -0.0040480825, -0.0027825057, 0.0023322874, -0.0017522854, 0.0002745976, 0.0005379119, -0.0058479710, -0.0032384745, 0.0129654584, 0.0010585148, 0.0090569798, -0.0111481650, -0.0076363571, 0.0000000000, 0.0050388696, 0.0073588998, -0.0012506805, 0.0062938575, -0.0076986938, 0.0018701707, 0.0012427538, -0.0125740822, -0.0006762814, -0.0028194583, -0.0000051163, 0.0166993048, -0.0045482521, -0.0069574658, 0.0131864352, -0.0026713260, -0.0121875536, 0.0079638874, 0.0066102715, 0.0056293677, 0.0106842238, 0.0061975149, -0.0028016586, 0.0053417110, 0.0000000003, -0.0144999949, -0.0101338476, -0.0120314071, 0.0000790213, 0.0046427110, -0.0042662988, 0.0026285532, -0.0114410575, -0.0000000035, 0.0031908641, 0.0146252876, -0.0020358632, 0.0016969538, 0.0011495515, 0.0001754332, -0.0095790429, -0.0000000035, -0.0091179181, -0.0031916797, -0.0047423490, 0.0000691991, 0.0007290685, 0.0004509748, 0.0144374361, 0.0011609495, 0.0009235805, -0.0021688805, -0.0056641931, 0.0099617336, 0.0164975002, -0.0020089531, -0.0000671002, -0.0003145236, -0.0023738956, 0.0008080113, -0.0049513485, 0.0010452542, 0.0066101025, -0.0000000000, -0.0015699374, -0.0139202448, -0.0010245981, -0.0033144944, 0.0001878495, 0.0037074266, -0.0004037908, 0.0143441912, 0.0000943256, -0.0017665256, -0.0000702012, -0.0172514040, 0.0021575661, 0.0022095037, -0.0107430834, -0.0000100461, 0.0155601948, -0.0064071789, -0.0147544630, -0.0021870045, -0.0033114343, 0.0047411174, 0.0135605847, -0.0077417409, -0.0000076118, 0.0150285987, 0.0168079026, 0.0020519136, -0.0038943517, -0.0066795307, 0.0030074674, 0.0045855166, 0.0129333055, -0.0001061385, -0.0151935155, -0.0112533094, 0.0029156208, 0.0040481347, 0.0059531927, -0.0043665972, 0.0284443758, -0.0000008867, -0.0095254630, 0.0009681587, 0.0148504134, -0.0059177419, -0.0027990066, 0.0032245943, -0.0048887692, 0.0000178844, -0.0039517488, -0.0037018005, 0.0052634208, -0.0014158480, 0.0025975101, 0.0111840740, -0.0053786212, 0.0093562780, 0.0058030821, -0.0027040881, 0.0048971535, -0.0070433775, -0.0121193454, -0.0000017062, 0.0020632066, 0.0133176167, 0.0018917230, 0.0099409781, -0.0169570036, -0.0037962575, 0.0029232434, -0.0095642041, -0.0032660288, -0.0034589656, -0.0028898278, 0.0021364854, -0.0029717188, -0.0094446819, 0.0256286301, 0.0016914187, -0.0058596670, -0.0095011359, 0.0075431387, 0.0057928516, 0.0062447488, 0.0039296956, 0.0011306495, 0.0016418463, 0.0000000001, -0.0062014638, -0.0019737259, -0.0112653561, 0.0023862035, 0.0016885380, -0.0022030305, -0.0103648445, -0.0094998004, 0.0000000534, 0.0000511679, 0.0157723278, 0.0028015249, 0.0085638417, 0.0117166024, 0.0020391021, -0.0096260728, 0.0000000049, -0.0008878508, -0.0039203037, -0.0004830312, 0.0000295305, -0.0021811279, -0.0054475176, 0.0152286366, 0.0036325799, -0.0053733182, -0.0078643719, -0.0043013892, -0.0013412058, -0.0004646123, -0.0057792603, -0.0007584028, -0.0082264682, 0.0018331256, 0.0061431383, 0.0009177134, -0.0008331163, -0.0029937942, 0.0000000000, -0.0011188120, -0.0023378632, -0.0000817215, 0.0014707346, 0.0001324181, 0.0028119718, -0.0051389043, 0.0064181900, -0.0067804609, 0.0008090559, 0.0000705038, 0.0044428832, 0.0002112612, -0.0041494388, -0.0093921283, -0.0017263007, 0.0004411269, 0.0119865742, -0.0024111101, 0.0054806350, 0.0032180736, -0.0064000501, -0.0000966578, 0.0000093585, 0.0000000000, 0.0049160081, 0.0086703710, -0.0017141744, -0.0023090797, -0.0032165535, -0.0004059371, -0.0020702474, 0.0095633222, 0.0000000000, -0.0073016696, 0.0050776154, -0.0020112684, 0.0003116238, -0.0040711095, 0.0004445883, -0.0012222017, 0.0000000000, -0.0000264047, 0.0017651874, 0.0074288519, -0.0003595522, -0.0005576994, -0.0127832284, 0.0032350488, 0.0091248062, -0.0021143660, -0.0107919695, -0.0005932148, 0.0015084483, -0.0022162865, -0.0093685081, -0.0033024689, -0.0064070239, 0.0058945064, 0.0003135565, 0.0032143637, -0.0030724043, -0.0070797657, 0.0000000000, 0.0014530795, 0.0052359761, 0.0034546566, 0.0082757305, -0.0049597719, 0.0078317570, 0.0005609157, -0.0035889337, 0.0023548377, 0.0007403239, 0.0000352296, 0.0076364712, 0.0000613377, 0.0081683965, -0.0071365247, -0.0046391697, -0.0101598687, -0.0009948539, 0.0046439576, 0.0018067997, 0.0146998949, 0.0106054330, 0.0055858633, -0.0013285549, 0.0000000000, 0.0018544152, 0.0043016667, -0.0144491093, 0.0032750124, -0.0034916769, 0.0008624262, -0.0094874976, -0.0072544105, 0.0000000027, -0.0034653526, 0.0117524192, -0.0000068677, 0.0118110748, 0.0102913883, -0.0002893835, -0.0009746078, -0.0000000001, -0.0058352193, 0.0019874729, -0.0020084956, -0.0000063734, 0.0005233425, -0.0042168340, 0.0150370393, -0.0023041244, 0.0000576434, -0.0150258532, -0.0025239300, 0.0037497596, 0.0035761227, -0.0099156210, -0.0064262077, -0.0072029210, -0.0022991234, 0.0047779139, 0.0017005269, -0.0052897302, -0.0026510351, 0.0000000000, 0.0062948880, 0.0009537144, 0.0075415797, 0.0032882900, -0.0002203996, 0.0009106441, -0.0018733451, 0.0082058189, -0.0094378311, 0.0034702686, 0.0000358239, -0.0020681941, -0.0131647950, 0.0020659540, -0.0089613292, -0.0029358398, 0.0039058612, 0.0051456713, 0.0036033802, 0.0083548184, 0.0123628825, -0.0017513911, 0.0010214692, -0.0007056117, 0.0000000000, 0.0010689001, 0.0015185894, -0.0024258385, -0.0017199881, 0.0004400162, -0.0018091955, -0.0019464579, 0.0020779495, 0.0000000000, -0.0001456618, 0.0018264474, 0.0071096178, 0.0060730749, 0.0048027998, 0.0004944729, 0.0009716268, 0.0000000000, -0.0006309575, -0.0025592814, -0.0000712167, -0.0000001643, -0.0006555511, 0.0001745558, -0.0009365801, 0.0005374551, 0.0001861491, 0.0007166613, 0.0013097991, -0.0010638265, -0.0011969816, 0.0035941009, 0.0011285460, -0.0023582641, 0.0013098622, 0.0024308681, 0.0017256343, -0.0030413400, -0.0034461585, -0.0000000000, -0.0004809075, -0.0000108945, -0.0033191394, 0.0011820282, -0.0001313157, -0.0020491141, -0.0016356299, -0.0055277152, 0.0009026810, -0.0018960232, 0.0000182899, 0.0060984949, -0.0009369678, -0.0128319785, 0.0039889491, 0.0017170348, -0.0050513251, 0.0074739307, 0.0006026883, 0.0036264604, 0.0013971132, 0.0127740521, 0.0051982063, 0.0037579103, -0.0000000000, -0.0072423075, -0.0075393384, -0.0201230496, 0.0065056961, 0.0016398393, -0.0008468252, -0.0092699556, -0.0162003953, -0.0000000000, 0.0030847071, 0.0226152334, 0.0011739519, 0.0158233978, 0.0133985821, -0.0003223476, -0.0059202979, 0.0000000000, -0.0051803105, 0.0014366335, -0.0015004047, 0.0000000921, 0.0002949174, 0.0018582242, 0.0086583383, -0.0050185742, 0.0035584245, -0.0045307898, -0.0042168559, 0.0010230904, 0.0034691463, -0.0009033071, -0.0064178398, -0.0062507754, -0.0152074732, 0.0062345183, 0.0025786462, -0.0018448567, 0.0033016703, -0.0000000000, -0.0052795652, -0.0091325203, 0.0032951317, -0.0022372771, 0.0002369360, 0.0023871304, -0.0013294843, 0.0077887955, -0.0093216896, 0.0005732964, 0.0000107350, -0.0108526824, -0.0149860950, -0.0054972302, -0.0163054913, 0.0017939734, 0.0084960163, 0.0037458311, -0.0029078261, 0.0014708595, 0.0025661383, 0.0009986770, -0.0059457440, 0.0042700558, 0.0000000000, -0.0060167690, -0.0080911275, -0.0030676238, -0.0008774652, 0.0031858045, 0.0005664734, 0.0035352434, -0.0120578287, -0.0000000000, 0.0010249157, 0.0051623438, -0.0041588107, -0.0001247599, -0.0067307553, -0.0001564855, -0.0026984641, 0.0000000000, -0.0004729985, -0.0011348855, -0.0005785688, 0.0000800666, 0.0013529011, -0.0008577667, -0.0020116540, -0.0019558275, 0.0031388854, -0.0042255172, -0.0037367458, 0.0042611184, 0.0080365110, 0.0025822374, -0.0077102040, 0.0023769226, -0.0147776017, 0.0032484799, -0.0077418704, 0.0110959522, 0.0063237422, -0.0000000000, -0.0057240669, -0.0124154780, -0.0063213143, -0.0010522025, 0.0001127724, 0.0005853556, -0.0008830582, 0.0059538838, -0.0001712908, -0.0021502594, -0.0000128213, -0.0163686015, -0.0001095745, 0.0044290372, -0.0079715122, 0.0014523304, 0.0063326340, -0.0051025120, -0.0125131868, -0.0061026160, 0.0051027881, -0.0091696279, -0.0118878828, -0.0019454111, 0.0000000000, -0.0114762513, -0.0059199585, 0.0029589580, 0.0041005686, 0.0045285844, -0.0017562166, -0.0064342893, -0.0055188281, 0.0000000878, 0.0014239714, 0.0025180404, 0.0024472442, 0.0021749106, -0.0022592412, 0.0045238715, -0.0115607651, 0.0000000049, 0.0074824342, -0.0088686803, -0.0047070007, 0.0003182686, 0.0003805830, -0.0083457539, 0.0050865561, 0.0069317115, -0.0044832216, -0.0054066153, -0.0039922926, -0.0088830926, -0.0035797104, -0.0076364167, 0.0029380578, -0.0104291355, -0.0072852415, 0.0030835166, -0.0062406901, 0.0089876102, -0.0003902981, 0.0000000000, -0.0066391346, 0.0061272350, -0.0055479002, 0.0015546991, 0.0026031712, -0.0041333088, -0.0123050585, 0.0030528861, -0.0017877081, -0.0005809057, 0.0002973595, 0.0074387803, 0.0029390114, 0.0053351349, -0.0144299688, -0.0021950826, -0.0062970668, 0.0108560622, -0.0012058965, -0.0015857416, 0.0067998092, 0.0041007516, 0.0030890070, -0.0013240596, 0.0000000000, -0.0035780102, 0.0001812053, -0.0131824911, 0.0039651510, 0.0004826025, -0.0025740319, -0.0032498562, -0.0073251515, -0.0000000000, -0.0067856512, 0.0067785764, 0.0136631969, 0.0119270179, 0.0067968341, 0.0004496366, 0.0030568892, -0.0000000000, -0.0027137436, -0.0001792588, 0.0111517413, -0.0001540935, 0.0000920645, -0.0058726026, 0.0002222270, -0.0001355430, -0.0005264895, -0.0047717905, 0.0006501456, 0.0005742367, 0.0055318517, 0.0049409964, -0.0061967354, -0.0002243148, 0.0002461158, 0.0044924133, 0.0017411553, -0.0077524767, -0.0011563193, 0.0000000000, 0.0000158167, 0.0003993147, -0.0035343976, 0.0019300336, -0.0000838465, -0.0001914321, -0.0021808459, -0.0027377382, -0.0039908169, -0.0065842010, -0.0000017860, 0.0044569671, -0.0035943254, -0.0169037376, 0.0051142299, 0.0024936206, -0.0028432319, 0.0048667821, -0.0047678761, 0.0021490469, 0.0081368424, 0.0043340325, 0.0032105357, -0.0031963794, 0.0000000000, 0.0049614203, 0.0002677886, -0.0028638497, 0.0040524243, -0.0017949537, 0.0033707346, -0.0007264438, -0.0000045795, 0.0000000000, 0.0036406005, 0.0048720669, 0.0059583229, 0.0018559265, 0.0055122511, -0.0002737083, 0.0023239169, 0.0000000000, 0.0025124971, -0.0002709187, -0.0097313998, 0.0000000202, 0.0003720523, 0.0052725291, -0.0092402706, -0.0020730093, 0.0043116864, 0.0014141093, -0.0007963208, -0.0007524025, -0.0018852055, 0.0045483978, -0.0024149560, 0.0001760455, -0.0121432021, -0.0001309766, 0.0000338464, -0.0067520496, 0.0032140461, 0.0000000000, -0.0037061018, -0.0066609578, -0.0045458106, -0.0052260803, 0.0001087345, 0.0002899068, 0.0033705865, -0.0041968711, -0.0008041961, -0.0031679103, -0.0000094989, 0.0048572505, -0.0026233841, -0.0145916967, 0.0122100962, 0.0034334932, -0.0082199359, 0.0010490553, 0.0007031123, -0.0018226984, 0.0040803915, 0.0029460979, 0.0202105846, -0.0029705218, -0.0000048796, 0.0168868043, 0.0038944692, -0.0037215662, 0.0002717452, -0.0034732663, -0.0048994785, 0.0092266239, 0.0028051960, -0.0000724562, 0.0001228990, 0.0021826597, 0.0055363812, 0.0016238019, 0.0054330206, -0.0042471890, 0.0148387942, -0.0000004359, -0.0097677838, 0.0005589459, -0.0175416581, -0.0018048729, -0.0015895143, 0.0088091586, -0.0001448062, 0.0010896592, 0.0020746256, 0.0094779404, 0.0049617677, 0.0068794847, -0.0016315422, 0.0089484397, -0.0056326473, 0.0064857225, -0.0052697086, -0.0018377885, -0.0009332968, -0.0029954475, 0.0043397755, -0.0000006835, 0.0002817703, -0.0008167263, 0.0045460025, 0.0038108213, -0.0114981104, -0.0005284313, 0.0009640990, 0.0034605735, -0.0013674438, 0.0070237722, -0.0025837503, 0.0019090920, -0.0094164563, -0.0149548585, 0.0180526990, 0.0096810395, -0.0143009378, -0.0116966190, 0.0159141980, -0.0009094444, 0.0053258091, 0.0051167496, 0.0042832326, 0.0026101589, 0.0000000000, 0.0027344264, -0.0017080051, -0.0108108958, -0.0004083905, -0.0002932819, -0.0024647166, -0.0091337310, -0.0053183413, 0.0000000005, 0.0022942696, 0.0136007667, 0.0081436625, 0.0074559599, 0.0121860728, 0.0015621941, -0.0053038546, -0.0000000000, -0.0013545199, -0.0009887225, -0.0070783896, 0.0000006942, -0.0019320539, -0.0031425774, 0.0006412109, 0.0038359589, -0.0015645737, -0.0070626601, 0.0007502911, -0.0011291059, -0.0035415597, 0.0020151627, -0.0006803588, -0.0067578619, -0.0042060693, 0.0034463236, 0.0012561205, -0.0001855340, -0.0006482062, 0.0000000000, 0.0002317528, -0.0017544391, -0.0043928167, -0.0006147609, -0.0000768146, 0.0011095810, -0.0037158141, -0.0047950200, -0.0048382180, -0.0011606909, 0.0000759795, 0.0119165070, -0.0061588986, -0.0120737972, -0.0018043345, 0.0026284845, -0.0128668053, 0.0096615301, -0.0001483738, 0.0069330167, 0.0088804998, 0.0142710814, 0.0115616489, 0.0099093700, -0.0000001705, -0.0106353210, -0.0158378016, -0.0210340004, 0.0058435611, 0.0007751049, -0.0048529441, -0.0090010343, -0.0099282339, -0.0000120991, 0.0034247350, 0.0260833688, 0.0052982271, 0.0110928304, 0.0114011951, -0.0041066692, -0.0052578938, -0.0000002568, -0.0040453309, 0.0000719471, -0.0213546064, -0.0013900572, -0.0037805424, 0.0066743512, 0.0144461617, -0.0044833208, -0.0044701700, -0.0023176207, 0.0009206804, 0.0072364127, 0.0068335896, -0.0069100261, -0.0009576355, -0.0022800933, -0.0147903170, 0.0016490060, -0.0006667211, 0.0001582584, 0.0090032294, -0.0000000008, 0.0021168338, -0.0141101945, 0.0006731962, -0.0040802625, 0.0006398538, 0.0035410370, -0.0046187043, 0.0197786409, -0.0058582961, 0.0051064184, -0.0002497419, -0.0126021821, -0.0118254805, -0.0050692554, -0.0149025843, 0.0118743842, 0.0058133602, -0.0019892654, 0.0076811733, 0.0000787744, -0.0017289481, -0.0043086060, -0.0012721109, -0.0018435398, 0.0000000000, 0.0021722049, 0.0041864798, 0.0053032963, 0.0087826112, -0.0023054786, -0.0011095151, 0.0057451171, 0.0094754882, 0.0000000001, 0.0014971946, -0.0038096583, -0.0044753393, -0.0039525442, 0.0084911780, 0.0005802882, 0.0019402372, 0.0000000000, 0.0012182767, -0.0044712946, -0.0080797365, 0.0000001618, -0.0011471319, 0.0000410520, 0.0072474927, 0.0016345468, -0.0048348461, -0.0001010125, -0.0018575032, -0.0040701986, -0.0119932629, -0.0004962634, 0.0001735481, -0.0036483083, 0.0025629008, 0.0010309714, 0.0058214157, 0.0009292911, 0.0012775653, 0.0000000000, -0.0049142856, -0.0006887101, -0.0025159041, 0.0070420257, -0.0000818882, 0.0005061555, -0.0031019754, -0.0092806313, 0.0012453862, 0.0011627197, 0.0000146379, 0.0076732067, 0.0016716275, -0.0062283766, -0.0039078230, -0.0015361694, -0.0138134733, -0.0031428423, 0.0009189617, 0.0066387919, 0.0000816335, -0.0136246588, -0.0081663253, 0.0092023108, 0.0000000000, -0.0074827480, -0.0002932245, -0.0206189938, -0.0120002944, -0.0033541466, 0.0135246823, -0.0013833945, -0.0062568015, -0.0000000000, -0.0118944058, 0.0232721902, 0.0050886376, -0.0073376400, 0.0151734538, -0.0008916710, 0.0060877777, 0.0000000000, -0.0010028736, 0.0074417056, 0.0243967902, -0.0000000000, 0.0007551502, 0.0015312071, 0.0150786312, -0.0089249248, -0.0013219694, -0.0185983535, -0.0061941957, -0.0061167451, 0.0124563193, 0.0000063110, 0.0023340089, 0.0197671782, -0.0013646680, -0.0030153741, 0.0121174995, -0.0107923020, -0.0036351259, -0.0000000000, 0.0105286520, 0.0189187601, -0.0011159176, 0.0090068392, -0.0004581051, -0.0064930413, -0.0085305218, 0.0060761208, -0.0010796519, 0.0031108211, -0.0000354942, -0.0068088095, -0.0052547627, 0.0143043967, -0.0116992388, -0.0032568509, 0.0131404744, -0.0020577386, -0.0204850603, 0.0068776980, 0.0296134893, 0.0209663138, 0.0131659200, -0.0078402273, 0.0000000000, -0.0129253296, 0.0071275248, -0.0050411774, 0.0158664007, 0.0034720788, -0.0088821910, 0.0102042025, -0.0146291098, -0.0000000479, -0.0023919186, 0.0233418532, 0.0089236991, 0.0101858284, 0.0005840479, -0.0003395015, 0.0011353369, 0.0000000000, -0.0095509058, -0.0176821817, -0.0018957218, -0.0002944009, -0.0053857770, -0.0020804685, -0.0014295548, -0.0099895606, 0.0067886231, 0.0208203495, -0.0005721055, -0.0070271101, 0.0109163709, 0.0235794205, 0.0098983943, -0.0001505661, 0.0166941565, 0.0177643877, -0.0075635351, -0.0089530749, 0.0132149570, -0.0000000000, -0.0188566484, -0.0297574364, 0.0117748501, 0.0075094011, -0.0006505557, -0.0076792110, 0.0161854364, -0.0053635249, 0.0053457064, -0.0036820075, -0.0000238912, -0.0109226042, 0.0026788672, -0.0161664914, 0.0086016823, 0.0196133032, 0.0102841379, 0.0084883040, -0.0054448787, -0.0011162106, -0.0195077006, 0.0408248380, 0.0219916627, -0.0300994497, 0.0000000045, -0.0215548221, 0.0096463133, -0.0073258081, 0.0200795885, 0.0024942628, -0.0074485200, 0.0066249934, -0.0189727936, -0.0000780227, -0.0061817886, 0.0447676182, 0.0195108876, 0.0144854784, -0.0109659042, -0.0041682459, 0.0169958435, 0.0000000050, -0.0164215639, -0.0339893363, 0.0062011085, -0.0054272776, -0.0036760459, -0.0085141100, -0.0048554940, -0.0162919983, 0.0144210914, 0.0273110215, -0.0006943893, -0.0172950383, 0.0369397476, 0.0322292261, 0.0147515731, -0.0005873686, 0.0247301944, 0.0336708166, -0.0246234871, 0.0028056221, -0.0188654382, -0.0000066269, -0.0405138247, -0.0638946146, 0.0228654761, 0.0224856380, -0.0043713837, -0.0055154208, 0.0172682926, -0.0112951035, 0.0125183621, -0.0199509710, -0.0023432369, -0.0398931541, 0.0110798627, -0.0081436941, 0.0132565228, 0.0247057285, 0.0159223508, 0.0164899901, -0.0004727514, -0.0045806062, -0.0310176387, -0.0033045243, -0.0084755057, 0.0001447176, 0.0000000000, 0.0001603030, -0.0007368687, 0.0059992331, -0.0012377664, 0.0022953739, -0.0014765142, 0.0004584401, 0.0000284829, 0.0000000027, 0.0002106321, -0.0013607373, -0.0029248854, -0.0038985962, -0.0003360920, 0.0009946136, -0.0046598236, -0.0000000000, 0.0030369181, -0.0052478849, 0.0031848876, 0.0000017863, -0.0033439863, -0.0030610810, 0.0032206541, 0.0020227337, -0.0068154312, -0.0001848262, -0.0002741436, -0.0033751018, -0.0080532702, -0.0005401711, 0.0027195513, -0.0032119439, -0.0018272121, 0.0031847488, -0.0011405923, 0.0033797717, -0.0024495593, 0.0000000000, -0.0064590452, -0.0012178348, -0.0050252373, 0.0025338982, -0.0000304253, -0.0005974420, -0.0049930280, 0.0000089120, 0.0001528267, 0.0013060893, 0.0000297426, 0.0033223799, 0.0077272803, 0.0024358076, -0.0046849726, -0.0021205281, -0.0033237867, 0.0015938161, -0.0016792063, 0.0012085099, -0.0006095612, 0.0604761653, 0.0377615280, -0.0657162070, 0.0000000281, -0.0169007424, 0.0097283507, -0.0161419176, 0.0293689035, 0.0165281165, -0.0156075573, -0.0169511139, -0.0622107685, 0.0000376039, -0.0134758130, 0.0538514629, 0.0433080196, 0.0339409970, -0.0373386182, -0.0117165828, 0.0142459292, 0.0000000047, -0.0080562728, -0.0472290628, -0.0013985805, -0.0073238066, 0.0021470403, -0.0038117075, 0.0120442612, -0.0226172395, 0.0109660672, 0.0445374325, 0.0081561999, -0.0327194259, 0.0572054610, 0.0421180874, 0.0123006925, -0.0189866982, 0.0490951613, 0.0474843644, -0.0486547388, 0.0338049121, -0.0198449250, -0.0000069083, -0.0432229787, -0.1126329452, 0.0155780381, 0.0302134920, -0.0015424611, -0.0044567734, 0.0086502898, 0.0231852606, -0.0001057181, -0.0338407867, -0.0032145947, -0.0799779892, 0.0413002819, -0.0189595446, 0.0272311009, 0.0181447044, 0.0341848582, 0.0409848802, 0.0015164932, -0.0018901174, -0.0247686282, -0.0017723768, -0.0014364599, 0.0003811014, 0.0000000000, -0.0018290976, -0.0003922728, -0.0003405216, -0.0008801295, 0.0002775012, -0.0011013371, -0.0037064790, -0.0005479005, 0.0000000005, 0.0014223281, 0.0015468315, 0.0030698034, 0.0020024315, 0.0004486878, 0.0005119668, -0.0032607915, 0.0000000000, -0.0004827110, -0.0014545260, -0.0010200480, 0.0000001704, -0.0007025981, -0.0016342783, 0.0003799286, 0.0016175990, 0.0003707633, -0.0007393789, -0.0001380505, -0.0015883880, 0.0000438484, -0.0009059012, 0.0003647635, -0.0014873953, 0.0018325646, 0.0013834434, -0.0003403826, 0.0019024929, -0.0017797068, 0.0000000000, -0.0012519115, -0.0001893076, 0.0004166915, 0.0007544811, -0.0001027135, -0.0001533133, -0.0005200887, -0.0006452675, -0.0002329321, 0.0017856165, 0.0000134939, 0.0010501037, -0.0012604132, 0.0022249266, -0.0040116622, -0.0002957681, -0.0007079396, 0.0125332214, -0.0018572600, 0.0007625613, 0.0015276514, -0.0029196893, -0.0017274518, 0.0002918805, 0.0000000000, -0.0008954434, 0.0001209491, -0.0020982448, -0.0020046909, -0.0000670219, -0.0013537151, -0.0038261239, 0.0005234666, 0.0000000006, 0.0028727793, 0.0000218814, 0.0011423543, 0.0001970145, -0.0014928292, 0.0006216332, -0.0042331615, 0.0000000000, 0.0018973813, -0.0020433464, -0.0012150870, 0.0000004826, -0.0010940344, -0.0009537330, 0.0003125760, 0.0020713850, 0.0005130434, -0.0000708001, -0.0004768476, -0.0006368889, -0.0022224628, -0.0008875282, 0.0051435977, -0.0028723858, 0.0015811014, 0.0028160231, -0.0009703225, 0.0013207373, -0.0019831990, 0.0000000000, -0.0030327712, -0.0016649099, -0.0001070222, 0.0015338103, -0.0001125320, 0.0023788051, -0.0012341068, -0.0027211956, -0.0019664075, 0.0016536524, 0.0000248448, 0.0060610268, -0.0003179964, 0.0000355031, -0.0049723010, 0.0008032548, -0.0012537441, 0.0065929173, -0.0007221177, 0.0005052292, 0.0007297235, -0.0011515524, -0.0008707322, 0.0006173434, 0.0000000000, 0.0001726704, 0.0000323832, 0.0001100560, -0.0009238252, 0.0004017321, -0.0011461226, -0.0022926137, -0.0004572517, 0.0000000001, 0.0010072838, 0.0008886373, 0.0009743052, 0.0013433263, 0.0002244630, 0.0004669973, -0.0019966147, -0.0000000000, -0.0003318480, -0.0016931277, -0.0001939220, 0.0000001718, -0.0006703340, -0.0011118784, 0.0007922197, 0.0008760847, 0.0001322157, -0.0009790481, -0.0004648357, -0.0003307886, -0.0006849993, -0.0005994422, 0.0006151134, -0.0017295582, 0.0015859751, 0.0014881453, -0.0005937554, 0.0015902024, -0.0025116166, 0.0000000000, -0.0009102384, -0.0004105277, 0.0004052363, 0.0008158482, -0.0000710617, -0.0006923209, -0.0007298993, -0.0006939084, 0.0007831604, 0.0005964584, 0.0000119524, 0.0007858996, 0.0001542926, -0.0006534196, -0.0027939342, -0.0000675178, -0.0009814056, 0.0015536862, -0.0008958199, 0.0011020919, 0.0017857772, -0.0091197398, -0.0077937008, 0.0239090901, -0.0000252465, 0.0144422762, -0.0114561543, -0.0235243943, -0.0178552270, -0.0006686993, -0.0011140257, 0.0048889369, -0.0025945734, -0.0005688603, -0.0080685960, 0.0312161986, 0.0018592547, 0.0056010536, 0.0378403030, -0.0099090673, -0.0038710411, -0.0000013542, -0.0118054803, 0.0228207838, 0.0311824679, -0.0030090001, -0.0049382742, 0.0072712596, 0.0096588647, -0.0137388185, 0.0012431305, -0.0102655245, 0.0042342460, -0.0057007447, -0.0048393575, 0.0056025242, -0.0144776301, 0.0389354415, -0.0096670529, -0.0026542421, 0.0246942565, -0.0263563450, 0.0039304905, -0.0000092379, 0.0060930462, 0.0092887729, 0.0247164387, 0.0066587399, -0.0139892939, 0.0075338148, -0.0031981620, -0.0035120684, -0.0079286033, 0.0142972292, -0.0036415146, -0.0138289705, -0.0183968376, 0.0032522311, 0.0000266636, 0.0121049853, 0.0148188509, -0.0158457663, -0.0096444944, 0.0012035578, 0.0363200158, -0.0226541702, -0.0085639404, 0.0209076926, -0.0000000001, 0.0068180263, -0.0133127999, -0.0299384184, -0.0111704422, -0.0018592520, 0.0061437474, 0.0008126333, -0.0161614232, -0.0000000010, -0.0064322646, 0.0427515917, 0.0026138879, -0.0097436374, 0.0194694474, -0.0011827931, 0.0026601946, -0.0000000000, -0.0017282859, 0.0144166993, 0.0260445531, -0.0000001073, 0.0009167804, 0.0026059542, 0.0104714828, -0.0128430370, 0.0040885243, -0.0111521464, -0.0060148584, -0.0187760070, 0.0077316859, 0.0033716289, 0.0013293572, 0.0251066480, -0.0039084279, 0.0115222614, 0.0212938525, -0.0145013258, -0.0040624314, -0.0000000000, -0.0092151240, 0.0038498896, 0.0222428907, 0.0110212415, -0.0005881950, 0.0069636954, -0.0052960142, -0.0036975644, -0.0041337735, 0.0137634287, -0.0000388337, -0.0215529073, -0.0051506674, 0.0141738085, -0.0154057927, 0.0021220036, -0.0034729096, -0.0092541976, -0.0098544266, 0.0003221993, 0.0420641489, 0.0091624828, 0.0180855226, 0.0007316515, -0.0000000026, 0.0093355244, -0.0038506465, -0.0051532602, -0.0007511021, -0.0037024387, -0.0038655149, 0.0069224383, -0.0008914710, -0.0000006428, 0.0024740915, 0.0081593459, -0.0013912118, -0.0043196366, 0.0018769637, -0.0072438125, 0.0108927209, -0.0000000073, -0.0108606452, 0.0048020622, -0.0245314408, -0.0003833629, -0.0002026032, 0.0171334408, -0.0043750498, -0.0033421796, 0.0036303373, 0.0106473956, 0.0064402996, 0.0046655303, 0.0040048631, 0.0080102123, -0.0026331646, 0.0111165680, -0.0098869670, -0.0034727268, -0.0019489875, -0.0036168271, 0.0083398130, -0.0000000003, 0.0019018311, -0.0107452152, 0.0020161485, -0.0043023368, 0.0002874574, 0.0027655286, 0.0034010275, 0.0066059530, -0.0021654740, 0.0096266791, -0.0006574307, -0.0094607407, -0.0066228928, -0.0038649831, 0.0135302171, 0.0111312754, -0.0036100685, -0.0078193722, 0.0124483434, -0.0042810696, -0.0048529562, 0.0042481632, 0.0002293844, 0.0071515716, 0.0000000000, 0.0003601007, -0.0031523563, -0.0138505446, 0.0024756957, -0.0051313420, -0.0017929890, -0.0023740032, -0.0158150308, 0.0000000000, -0.0180572495, 0.0344691388, 0.0156425238, 0.0153798880, 0.0027877965, 0.0004176518, 0.0007517550, -0.0000000000, 0.0023019821, -0.0031131841, 0.0144600170, 0.0000000247, -0.0009419349, -0.0026217424, -0.0132626388, -0.0035963175, -0.0024364681, 0.0043047052, 0.0011563953, -0.0194729846, 0.0099341897, 0.0113122202, 0.0066519505, -0.0002641325, -0.0020164365, 0.0123678613, 0.0047904286, -0.0008991309, 0.0231355950, 0.0000000000, -0.0238604452, -0.0140379909, 0.0145021537, 0.0221834779, -0.0001025866, 0.0033007418, 0.0054144687, -0.0041495827, -0.0145854447, 0.0085468469, 0.0000160888, -0.0084730759, -0.0028544648, 0.0086036976, -0.0150079820, 0.0036532586, -0.0075236680, 0.0019891385, 0.0057431250, -0.0046671657, 0.0144726401, -0.0150632067, -0.0063398518, 0.0156400297, -0.0000000029, -0.0075997808, -0.0003914168, -0.0348970890, 0.0037350517, 0.0052410266, 0.0029117686, -0.0189427920, -0.0233468190, -0.0000121591, -0.0067135184, 0.0544443727, 0.0058769383, -0.0087994915, 0.0110102696, 0.0005673149, 0.0000358171, -0.0000000000, -0.0003436175, 0.0073826448, 0.0325228870, -0.0016280557, -0.0238957368, -0.0043099038, 0.0059302626, -0.0092705349, -0.0060914154, -0.0111863073, -0.0098429341, -0.0174358152, -0.0029701330, 0.0087818485, 0.0056589469, 0.0101043778, -0.0001128875, 0.0062315930, 0.0108962189, 0.0046701371, 0.0099224271, -0.0000001285, -0.0093405135, -0.0010970939, 0.0050646826, 0.0115599241, -0.0035098461, 0.0096497303, -0.0129532982, 0.0046060346, -0.0057057012, 0.0014369709, 0.0002261669, -0.0119984681, -0.0005107671, 0.0172927305, -0.0132321836, 0.0077163605, -0.0001789405, 0.0068031549, -0.0268690009, 0.0021388235, 0.0318220817, 0.0258283596, 0.0091414163, -0.0279539656, -0.0000000523, -0.0026785645, 0.0027097852, -0.0041340007, 0.0096795131, 0.0063582985, -0.0066443300, 0.0188592151, -0.0101703797, -0.0000354308, -0.0088465353, 0.0116663938, 0.0079207812, 0.0135986069, 0.0001022431, -0.0044837901, 0.0033697935, -0.0000000377, -0.0143133281, -0.0198166091, -0.0009507163, -0.0014420629, 0.0005469121, 0.0027828757, 0.0093062399, -0.0087740840, 0.0016081575, 0.0124264527, -0.0009017516, -0.0092224544, 0.0236549862, 0.0193459000, -0.0051586279, -0.0105722668, 0.0062818779, 0.0201213434, -0.0172034055, -0.0076061520, -0.0162523799, -0.0000012205, -0.0309365485, -0.0506999493, 0.0009644649, 0.0100631816, -0.0027678106, -0.0028185891, 0.0120510375, -0.0054197717, 0.0074006901, -0.0153419394, -0.0015384615, -0.0179156344, 0.0173122995, -0.0004622091, 0.0191379599, 0.0021895324, 0.0088328244, 0.0030970387, 0.0023005910, -0.0010812215, -0.0065041212, 0.0120902257, 0.0060346024, 0.0043124417, 0.0000000000, -0.0114652840, 0.0069980733, -0.0028373655, 0.0107336724, 0.0000364523, -0.0018546032, -0.0038790598, -0.0128303915, -0.0000000025, -0.0081844572, 0.0212141573, 0.0113237593, 0.0031037298, -0.0100826565, 0.0005901475, -0.0006277456, -0.0000000000, 0.0015292026, -0.0084954696, 0.0041345432, -0.0000073243, -0.0022732585, -0.0038671237, -0.0074555431, -0.0045722243, 0.0029771319, 0.0130795268, 0.0065197512, -0.0072996877, 0.0040277289, 0.0079774223, 0.0162012707, 0.0061536371, 0.0082258852, 0.0119550396, -0.0021803107, 0.0047202990, 0.0011519432, -0.0000000000, -0.0078006107, -0.0034262552, 0.0144903082, 0.0111964410, -0.0001156491, -0.0058889799, 0.0042409706, 0.0012552950, -0.0061121439, 0.0057598902, 0.0000278403, -0.0133473435, -0.0054070917, -0.0033212856, -0.0058984607, 0.0120122675, 0.0046123196, 0.0095862187, -0.0007250168, -0.0005400425, -0.0068170479, 0.0429194681, 0.0296295099, -0.0324194171, -0.0000052220, -0.0153849833, -0.0013564097, 0.0162607506, 0.0365691148, -0.0087538678, -0.0119122714, 0.0216152091, -0.0419382341, -0.0024663650, -0.0177178830, 0.0477195419, 0.0238615833, 0.0046565626, -0.0374973342, -0.0086518312, 0.0404675156, -0.0000022694, -0.0121362610, -0.0446413755, 0.0119454013, -0.0180725046, -0.0048654587, -0.0194029845, -0.0064588054, -0.0244515631, 0.0161474571, 0.0558391213, 0.0117237587, -0.0220700018, 0.0498741567, 0.0357257873, 0.0573471002, 0.0165211428, 0.0315863341, 0.0445759781, -0.0360091925, 0.0328626446, -0.0091324663, -0.0001620293, -0.0374016017, -0.0544101372, 0.0354399383, 0.0326039419, -0.0068187150, -0.0044412841, 0.0238417890, 0.0023684623, 0.0202772729, -0.0102430368, -0.0088792434, -0.0833673999, 0.0014762537, -0.0257308334, 0.0084677357, 0.0595061742, 0.0074246745, 0.0149709191, 0.0068287579, -0.0038708369, -0.0700980574, 0.0102529014, 0.0065600332, -0.0207664482, 0.0000000000, 0.0056198821, 0.0059071514, 0.0047598346, -0.0014163834, -0.0058690528, 0.0000700884, 0.0028136123, 0.0020741350, -0.0000000001, -0.0099706929, -0.0089403465, 0.0031644451, 0.0112013500, -0.0074763359, -0.0003512243, 0.0065207370, 0.0000000000, -0.0003317238, -0.0029230099, 0.0077512832, -0.0000000361, 0.0006157834, -0.0068014660, -0.0033487938, -0.0028358849, 0.0054786634, -0.0079949060, 0.0007562456, -0.0021716193, 0.0026899998, -0.0082123009, -0.0039331354, -0.0059044263, 0.0024444370, 0.0043271021, -0.0012399765, 0.0012612927, -0.0132840453, -0.0000000000, 0.0026208179, 0.0002701972, 0.0087889833, 0.0075412686, -0.0017443253, -0.0015183027, 0.0010742650, -0.0052210018, -0.0023961216, -0.0012135342, -0.0000116950, 0.0019637179, 0.0015126162, 0.0042404346, 0.0045946431, -0.0080191987, 0.0001409503, -0.0029718066, 0.0089043155, -0.0033439370, 0.0079423031, -0.0213437378, -0.0073358375, 0.0203154348, -0.0000008845, -0.0058390344, -0.0123651065, -0.0400068983, -0.0073176702, 0.0024657410, -0.0004937233, -0.0077609355, -0.0088801151, -0.0000084609, 0.0029921657, 0.0428647399, 0.0030149957, -0.0120474882, 0.0161856785, -0.0016763360, -0.0010324707, -0.0000000127, 0.0002734013, 0.0154465344, 0.0125668040, -0.0000264847, 0.0021462021, 0.0083985887, 0.0009890307, -0.0074241329, -0.0004021279, -0.0071283062, -0.0042967573, -0.0003557816, 0.0084554888, -0.0003022034, 0.0081121298, 0.0232864972, -0.0066662095, 0.0008754724, 0.0117585221, -0.0057569067, 0.0089652864, -0.0000000014, 0.0085208649, 0.0122578954, 0.0052098995, 0.0023736889, 0.0001487829, 0.0045056520, -0.0028251112, 0.0105161136, -0.0022545068, 0.0109202582, -0.0003358741, -0.0065945364, -0.0141200367, 0.0097176647, -0.0119271670, 0.0092895748, 0.0009433519, -0.0072533363, -0.0274347439, 0.0032977855, 0.0209037215, 0.0346893817, 0.0075641568, -0.0235063527, -0.0000110220, 0.0109441271, 0.0082011353, 0.0128663257, -0.0127616618, -0.0086348262, 0.0035932120, 0.0083844298, 0.0066140089, -0.0001671199, -0.0081663253, -0.0164607745, 0.0037965560, 0.0170149226, -0.0118472166, -0.0077165654, 0.0069673993, -0.0000007577, -0.0130544426, 0.0023113119, 0.0020197963, -0.0021269373, -0.0013783089, 0.0056603984, -0.0101755485, -0.0035482612, 0.0088190902, -0.0020155595, 0.0137944203, 0.0003895076, -0.0015269967, -0.0056583593, -0.0133069195, 0.0014816292, -0.0061545824, -0.0068638041, -0.0097396066, 0.0016455367, -0.0127234934, -0.0000039965, 0.0058976323, -0.0113876713, 0.0090716975, 0.0028488105, 0.0001557123, 0.0022402396, -0.0012278885, 0.0056207376, -0.0024769017, 0.0018301866, -0.0026003041, -0.0240698308, -0.0011871912, 0.0057788314, 0.0175395217, -0.0101561164, 0.0285916254, -0.0165897794, 0.0066338670, -0.0068467553, -0.0029569129, -0.0046704044, -0.0060242633, -0.0002323479, 0.0000000000, -0.0040577459, -0.0005828509, -0.0005318745, -0.0006220963, 0.0016513623, -0.0015220226, -0.0072743110, -0.0016018735, 0.0000000363, 0.0028160817, 0.0019052189, 0.0022117125, 0.0015316850, -0.0000807831, 0.0018154545, -0.0074345232, -0.0000000000, 0.0013622732, -0.0043182336, 0.0001481337, 0.0000136819, -0.0013963218, -0.0045036240, 0.0017686409, 0.0043332563, -0.0015957353, -0.0012920904, -0.0016057825, -0.0045632459, -0.0037366375, -0.0030980350, 0.0036627629, -0.0047182622, 0.0016944392, 0.0035275030, -0.0011963078, 0.0042675412, -0.0025473554, 0.0000000000, -0.0044158539, 0.0016332550, -0.0017418833, 0.0017982338, -0.0000024554, -0.0004952903, -0.0030679314, -0.0010671861, -0.0009212424, 0.0010969264, 0.0000525275, 0.0059903678, 0.0021181351, 0.0034575909, -0.0074205822, -0.0011468338, -0.0026682997, 0.0099752611, -0.0031914110, 0.0004753054, 0.0019415815, 0.0154145649, 0.0128902690, -0.0204672422, -0.0000000000, -0.0018171531, -0.0016728092, -0.0227014199, 0.0037042163, 0.0025439877, -0.0014683063, 0.0030289702, -0.0223070439, 0.0000000000, -0.0111320261, 0.0419657528, 0.0188744273, 0.0251864847, 0.0016850347, -0.0014152313, 0.0064339447, 0.0000000000, -0.0036407497, -0.0130683715, 0.0119406674, -0.0000000054, 0.0021882879, -0.0035413180, 0.0098722009, -0.0168050267, 0.0036277126, 0.0054665823, -0.0011356173, -0.0267490316, 0.0185005385, 0.0197602455, -0.0063471179, -0.0013740789, 0.0166462436, 0.0272471197, -0.0006253199, -0.0048737577, -0.0031768316, 0.0000000000, -0.0261508822, -0.0465272851, 0.0219183937, 0.0222379211, -0.0014624334, 0.0010183344, 0.0109730111, -0.0162276812, -0.0068173842, -0.0076777954, 0.0000043921, -0.0228719320, 0.0110926572, -0.0023459021, 0.0053940206, -0.0006531746, -0.0021342046, 0.0124618169, 0.0020399704, -0.0027956415, 0.0246366616, -0.0097157340, -0.0069993515, 0.0023600091, -0.0000000000, -0.0047875326, -0.0016203180, -0.0133366091, -0.0051498292, -0.0023549085, 0.0118289832, -0.0076184450, -0.0103665330, 0.0000000002, -0.0016564757, 0.0259109363, 0.0081108576, -0.0019978287, 0.0164231043, -0.0008773074, 0.0066748853, -0.0000000000, -0.0010447368, 0.0078647835, 0.0222185049, 0.0000002442, -0.0000252734, 0.0030138730, 0.0055812304, -0.0094651990, 0.0010380270, -0.0182108004, -0.0058387723, -0.0103642279, -0.0053318953, 0.0028563768, 0.0034809951, 0.0093646990, -0.0057341401, 0.0047547990, 0.0096390285, -0.0051389672, -0.0124464389, 0.0000000000, -0.0023672201, 0.0054073329, 0.0028565153, 0.0084868642, 0.0001500333, 0.0004374440, -0.0078032063, -0.0020864767, -0.0033083379, 0.0014199419, -0.0000092148, -0.0032968274, -0.0070657316, 0.0068239709, -0.0002138070, -0.0032235116, 0.0071327947, 0.0005432593, -0.0136446422, 0.0059342412, 0.0344177224, 0.0049747680, -0.0025116666, -0.0062448741, 0.0000000000, 0.0012211645, 0.0005097917, 0.0049340418, -0.0016718995, -0.0009231048, -0.0023802246, -0.0019940238, -0.0010881978, 0.0000000000, 0.0001802321, 0.0014824641, 0.0011670494, 0.0022696846, -0.0005952381, 0.0005046821, -0.0041349554, 0.0000000000, -0.0007091627, -0.0040849382, -0.0001537067, 0.0000000078, -0.0014307759, 0.0000097579, 0.0000113687, 0.0015290977, 0.0027866894, -0.0013471403, 0.0020132312, -0.0070535168, -0.0040756329, 0.0011371127, 0.0000684042, -0.0047168438, -0.0012725057, 0.0009934985, -0.0029541899, 0.0033543620, -0.0018970481, 0.0000000000, -0.0068224892, -0.0051061162, -0.0025613431, 0.0040096245, -0.0001198769, -0.0013270898, -0.0036985707, -0.0033066594, -0.0007664405, -0.0032466236, 0.0000183621, -0.0013912075, 0.0049076877, 0.0041783564, -0.0022562761, -0.0040908637, 0.0043419376, 0.0098975636, -0.0015431670, 0.0020786433, 0.0032920879, 0.0031552999, 0.0014717167, 0.0013812279, 0.0000000000, 0.0037006037, 0.0008484692, -0.0146288089, 0.0006793058, 0.0031383359, -0.0011060105, -0.0025784604, -0.0027692690, -0.0000000000, 0.0049302620, 0.0124214496, 0.0156727415, 0.0055016447, 0.0084333653, 0.0001891027, -0.0038118621, 0.0000000000, 0.0000278350, 0.0005149850, -0.0119383465, 0.0000000007, 0.0003008877, 0.0074809105, -0.0083968751, 0.0020973824, 0.0044538467, 0.0041326093, -0.0001985318, 0.0003812386, 0.0010272891, 0.0147644104, 0.0021366463, -0.0011707372, -0.0021104198, 0.0005559607, -0.0033002265, -0.0019857788, 0.0072291121, 0.0000000000, -0.0044371011, -0.0119705023, -0.0099024586, -0.0054849405, 0.0001726704, 0.0020703722, 0.0009507753, -0.0103102578, -0.0013956830, -0.0058392705, 0.0000133715, 0.0104500419, -0.0062732995, -0.0242700018, 0.0165482610, 0.0085845068, -0.0131149972, 0.0078860996, -0.0105663640, 0.0021330260, 0.0027896126, 0.0514952727, 0.0342606083, -0.0303315967, -0.0000008020, -0.0214525349, -0.0067767636, -0.0118111465, 0.0325304233, -0.0000145725, -0.0108238077, -0.0018833237, -0.0416251235, -0.0002318518, -0.0005076663, 0.0593422577, 0.0299930107, 0.0075317039, -0.0258066021, -0.0087424004, 0.0208635461, -0.0000010864, -0.0145223048, -0.0337424539, 0.0038341370, -0.0045145135, -0.0017453786, -0.0065290239, -0.0069818920, -0.0186796673, 0.0171078332, 0.0453413986, 0.0065031126, -0.0160182714, 0.0437083915, 0.0387102142, 0.0281656086, 0.0031965717, 0.0416460410, 0.0384278186, -0.0329797342, 0.0294413120, -0.0035130165, -0.0000270224, -0.0398999900, -0.0700950250, 0.0243707225, 0.0241900105, -0.0012058817, -0.0052929604, 0.0160035715, 0.0108366460, 0.0096446108, -0.0138664823, -0.0040219193, -0.0700940713, 0.0094988262, -0.0143729560, 0.0158153307, 0.0378612876, 0.0253772084, 0.0220691375, 0.0030672259, -0.0047950735, -0.0464440100, -0.0081437528, -0.0094605107, 0.0151799498, -0.0000000064, -0.0109287761, -0.0129059032, -0.0568427369, 0.0099568134, 0.0131096691, 0.0147216702, -0.0203444883, -0.0449810438, -0.0000013109, -0.0096935648, 0.0811288804, 0.0198051650, -0.0033935935, 0.0186718702, 0.0000993681, -0.0055454141, 0.0000000303, 0.0086863078, 0.0144349048, 0.0494733490, -0.0003312673, -0.0118925199, -0.0049144314, 0.0132097024, -0.0280836113, 0.0000056534, -0.0049008885, 0.0045957132, -0.0407854281, 0.0180997457, 0.0200073440, 0.0177785438, 0.0309700780, 0.0130574796, 0.0324614383, 0.0168154296, -0.0001733573, -0.0026705675, -0.0000000212, -0.0284681469, -0.0177397374, 0.0357300900, 0.0222967975, -0.0003882196, 0.0002116594, -0.0128152221, 0.0044321045, -0.0124811521, -0.0078140898, 0.0013638745, -0.0510699637, -0.0047293147, -0.0033075346, -0.0229133759, 0.0279547330, 0.0148306182, 0.0157987531, -0.0288449824, 0.0111214742, 0.0449554473, 0.0225691665, 0.0124413082, -0.0233815797, -0.0000000000, -0.0027311705, 0.0026297944, -0.0019049500, 0.0081763333, 0.0027969179, -0.0047146864, -0.0127866715, -0.0206348971, -0.0000000170, -0.0051956512, 0.0188658647, 0.0165082924, 0.0117406379, -0.0197603125, -0.0014739312, -0.0026040303, 0.0000000000, 0.0034343814, -0.0084545147, -0.0039034425, -0.0000023473, -0.0001234075, 0.0011903628, 0.0032139844, 0.0022581876, 0.0004409704, 0.0244823042, 0.0080601620, -0.0076419795, 0.0099590747, 0.0067250398, 0.0067448053, -0.0088971388, 0.0123829516, 0.0172952358, -0.0085801827, 0.0187704600, -0.0065747388, -0.0000000000, -0.0088491403, -0.0220562778, 0.0158897173, 0.0089765750, -0.0000557144, -0.0051484271, 0.0058195330, 0.0054809367, -0.0069919941, -0.0039968463, -0.0000037945, -0.0307538919, 0.0056575043, -0.0051872167, 0.0073501626, 0.0000699320, 0.0102398815, 0.0115185380, 0.0078310315, -0.0021971595, -0.0052426653, -0.0197212826, -0.0124323713, 0.0189616363, -0.0000000001, 0.0041073728, -0.0078183981, -0.0244297273, -0.0040914584, -0.0027044090, 0.0070635197, -0.0015779804, -0.0113206217, 0.0000000000, -0.0034906156, 0.0398792624, -0.0043654591, -0.0083536468, 0.0234118775, -0.0010555420, 0.0014939498, 0.0000000000, -0.0010215208, 0.0140549541, 0.0212902147, 0.0000002046, 0.0003416608, 0.0015602279, 0.0105637237, -0.0128452620, 0.0010510267, -0.0182117280, -0.0064052232, -0.0170767363, -0.0009000864, 0.0062283003, -0.0026458101, 0.0216044690, -0.0131627964, 0.0010490227, 0.0230955649, -0.0099542756, 0.0062528718, 0.0000000000, -0.0069243559, 0.0110870553, 0.0150547056, 0.0092034154, 0.0003930930, 0.0085082715, -0.0039312695, -0.0045902906, -0.0055291806, 0.0075657251, -0.0000368871, -0.0110111600, -0.0073052486, 0.0125704184, -0.0105980011, 0.0037203401, 0.0007304553, -0.0086395675, -0.0167938452, 0.0056296075, 0.0438104123, 0.0033367900, 0.0070450520, 0.0027465299, -0.0000033783, 0.0141362594, 0.0033570237, 0.0023378157, 0.0007639326, -0.0028061967, -0.0059883655, 0.0085449014, 0.0070601315, -0.0000521362, -0.0032875012, 0.0023277835, 0.0003919220, 0.0011873343, 0.0025283773, -0.0048921034, 0.0073562427, -0.0000004246, -0.0110161919, 0.0024010839, -0.0106112640, -0.0008856846, -0.0000877213, 0.0042396775, -0.0009687645, -0.0011610480, 0.0005807069, 0.0004520691, 0.0066371378, 0.0088099698, 0.0015883057, 0.0068541616, -0.0052463268, 0.0115406858, -0.0032939801, -0.0049711769, 0.0020324376, -0.0061798319, 0.0039933696, -0.0000007037, 0.0033144169, 0.0003962463, 0.0044490783, -0.0000963352, -0.0002019788, 0.0011679208, 0.0011909022, 0.0033262440, -0.0008910362, 0.0057778391, -0.0022636398, 0.0004493659, -0.0099251885, -0.0090941424, 0.0151402066, 0.0077934065, -0.0037767058, -0.0093993694, 0.0096897511, -0.0003414573, 0.0038065016, -0.0272117909, -0.0196550973, 0.0009552347, -0.0000001063, 0.0023577609, -0.0155053884, -0.0557293743, -0.0096444087, 0.0045525427, 0.0135201421, -0.0157979801, -0.0316722952, 0.0000000261, -0.0102400715, 0.0650311187, 0.0198915228, 0.0081386641, 0.0240930561, -0.0009400776, -0.0063274163, -0.0000000000, 0.0026988541, 0.0210870784, 0.0434643142, 0.0000067223, -0.0027404148, -0.0016299187, 0.0078699058, -0.0181832630, -0.0030809289, -0.0274931174, -0.0024304662, -0.0358928330, 0.0007953969, 0.0051985397, -0.0124055911, 0.0183708426, -0.0114607066, 0.0226063803, 0.0183557551, -0.0067931046, -0.0094440542, 0.0000000004, -0.0012069029, -0.0082067624, 0.0227128454, 0.0136039918, 0.0001451654, 0.0140252421, -0.0107177095, -0.0047042300, -0.0156960450, -0.0031190338, 0.0008250885, -0.0160994604, -0.0018538409, 0.0065708370, -0.0036039304, -0.0030750129, 0.0006122867, 0.0163201429, -0.0294148996, 0.0050318837, 0.0724645704, -0.0013585110, 0.0115022231, 0.0129771903, -0.0000001944, 0.0051427642, -0.0013494038, -0.0165807735, -0.0020348541, -0.0004617108, -0.0045335740, -0.0001358807, 0.0060312194, -0.0000116885, 0.0048064818, 0.0112081179, 0.0073446459, -0.0026285220, 0.0097949775, -0.0032813770, 0.0045282603, -0.0000000930, -0.0011195418, 0.0079517299, -0.0175720975, -0.0002054124, -0.0000201137, 0.0142962178, -0.0012548279, 0.0013848131, 0.0009028314, 0.0131546138, 0.0087847095, 0.0080410233, 0.0066683907, 0.0019336783, 0.0080900155, 0.0048387451, -0.0010891519, -0.0070870616, 0.0002232430, -0.0048417728, 0.0170233548, -0.0000000031, 0.0099829035, 0.0042710048, -0.0020177811, -0.0013533145, -0.0002665282, -0.0022493275, 0.0014071412, 0.0003224401, 0.0003772940, 0.0065428689, -0.0005166633, 0.0120212482, -0.0153400348, -0.0117538786, 0.0022944370, 0.0138644865, -0.0086267656, -0.0097949896, 0.0031792000, 0.0010618713, -0.0016124877, 0.0082226768, 0.0060744998, -0.0051256167, -0.0000000413, -0.0305177961, -0.0008817286, 0.0148708653, 0.0077138776, -0.0037960235, -0.0091138547, 0.0186552554, -0.0171541981, -0.0000565766, -0.0059346636, 0.0211609267, -0.0095620546, -0.0229531694, 0.0079150070, -0.0025451747, 0.0032373033, 0.0000000002, -0.0107276747, -0.0116605498, -0.0090666963, -0.0034966164, -0.0193037763, 0.0177994110, -0.0012520908, 0.0005026216, 0.0181856137, 0.0161132049, 0.0049742851, -0.0083567053, -0.0060885758, 0.0390922353, 0.0172593370, 0.0323000923, 0.0045050667, 0.0117556993, -0.0014770408, -0.0031576611, -0.0138089508, -0.0000025886, -0.0171634331, -0.0040607089, 0.0076402673, 0.0017970575, -0.0012033038, -0.0094110370, 0.0249400418, 0.0136532141, -0.0123482654, 0.0150418850, -0.0020492079, -0.0142260017, 0.0097084958, 0.0001267113, 0.0070699677, 0.0347627066, 0.0112833884, 0.0088926684, -0.0204037167, 0.0030949737, -0.0567552857, -0.0394553877, -0.0093202973, 0.0348518342, -0.0000011384, 0.0492331758, -0.0074301823, -0.0475239381, 0.0015232841, -0.0079894774, 0.0458128527, -0.0218926668, -0.0138795217, -0.0000007884, -0.0024815737, 0.0576409288, -0.0061346567, -0.0208827499, -0.0071892906, 0.0019005202, -0.0175026525, -0.0000000000, -0.0004091635, 0.0190547276, 0.0143384794, 0.0000014553, -0.0014177676, 0.0168870948, -0.0129794683, -0.0124025298, -0.0132436333, 0.0030638771, 0.0059801051, 0.0010782707, -0.0073141744, -0.0044465736, 0.0048412653, 0.0698570982, -0.0099287936, -0.0009617734, 0.0269327480, -0.0054004481, 0.0255248602, 0.0000000392, 0.0093700960, -0.0052265227, -0.0030353954, -0.0213952679, -0.0000571901, 0.0298315529, -0.0055670091, 0.0306968689, -0.0077588111, 0.0062262435, 0.0012137113, -0.0144311618, -0.0325893499, -0.0284098629, -0.0158999544, 0.0404565968, -0.0165670868, -0.0065859607, 0.0123340003, -0.0099082664, 0.0268981345, 0.0360880271, 0.0417059027, -0.0713109300, -0.0000007550, 0.0036411458, 0.0063819978, -0.0412107222, 0.0282129534, 0.0144301634, -0.0245188605, -0.0178284831, -0.0257498939, 0.0000003722, -0.0564197414, 0.0024991333, 0.0562809072, 0.0548008047, 0.0021752196, -0.0026593949, 0.0463554785, 0.0000000005, 0.0023106101, 0.0022975376, -0.0151694966, 0.0005667523, 0.0026506567, -0.0034707235, 0.0352670811, -0.0102313049, -0.0465758033, 0.0132355466, 0.0232498590, -0.0242888015, -0.0098336479, 0.0328498520, -0.0487959199, -0.0238324199, -0.0236139633, 0.0354363099, -0.0211020056, -0.0031054982, -0.0202397890, 0.0000009546, 0.0063840328, -0.0337563083, -0.0185950398, -0.0004013017, -0.0091411974, -0.0040114289, 0.0180495605, 0.0158119276, -0.0068230401, -0.0358304158, -0.0004379122, -0.0007966555, 0.0180091504, -0.0507102758, 0.0469598584, -0.0052855816, -0.0052308044, -0.0007977806, -0.0012087877, 0.0336937308, 0.0235881023, 0.0166479349, 0.0080884388, -0.0056053651, -0.0004113551, -0.0073744645, 0.0185679831, -0.0178782512, 0.0036029278, 0.0378654078, -0.0172561966, -0.0001876248, 0.0105408309, 0.0000975809, -0.0487771854, -0.0111647714, 0.0651136413, -0.0056846864, 0.0146738132, -0.0065489034, 0.0225453731, -0.0000010116, -0.0274378899, 0.0161312316, 0.0148402806, -0.0048812870, -0.0146348746, -0.0247972142, 0.0075811576, -0.0090055261, -0.0103080906, -0.0192358326, 0.0174739230, -0.0334229209, 0.0017046796, 0.0159742367, -0.0102307601, 0.0007017922, -0.0003916352, -0.0097253909, -0.0194634087, 0.0196891353, -0.0033572030, -0.0000256991, 0.0312905163, 0.0153660495, 0.0092174923, 0.0125214448, -0.0112455990, -0.0132900113, 0.0062820097, -0.0083157970, -0.0168959685, -0.0415058099, -0.0068816119, -0.0053857896, -0.0107752671, -0.0406413786, 0.0392640606, 0.0057857493, 0.0242869686, 0.0116354702, -0.0288327150, 0.0267888028, 0.0251749717, 0.0039587202, 0.0028857470, -0.0324957818, 0.0000000120, -0.0144055588, -0.0043841093, -0.0008677527, -0.0162769668, 0.0233026370, -0.0088329967, 0.0159974229, -0.0099583780, -0.0000112146, -0.0138262799, -0.0037874193, 0.0260997508, 0.0066781682, -0.0077478178, -0.0025240169, -0.0063236505, 0.0000000219, -0.0047956230, -0.0152176274, -0.0109096039, -0.0002355765, -0.0253320318, 0.0014632398, 0.0056451322, -0.0213443823, -0.0053507122, 0.0233691949, 0.0019606669, -0.0298545603, 0.0070635057, 0.0174446870, 0.0011303850, -0.0044293241, -0.0001270539, 0.0214197543, -0.0158090852, 0.0231279228, -0.0084960423, -0.0000011111, -0.0186649896, -0.0502297655, 0.0020305712, 0.0054764473, -0.0000230935, -0.0046515269, 0.0099390447, 0.0120050916, -0.0102123795, -0.0103666391, -0.0003958550, -0.0149965510, 0.0291832611, 0.0087023936, -0.0077024833, -0.0006119097, 0.0121363169, 0.0115400441, -0.0014591351, 0.0021776685, -0.0328583010, 0.0035229546, -0.0138046723, 0.0146623543, -0.0008026274, -0.0117356097, 0.0153599503, 0.0262721255, 0.0295294486, 0.0207806639, 0.0044584824, 0.0158947445, 0.0171510372, -0.0000884008, -0.0051327269, -0.0134530133, -0.0123379324, -0.0370490886, 0.0087876162, 0.0020438058, 0.0090157380, 0.0000000865, -0.0004108971, 0.0379838496, -0.0048875515, -0.0010225234, 0.0069713704, -0.0197567120, -0.0244941711, 0.0207779836, 0.0037077293, -0.0293317717, -0.0142652700, 0.0251507349, -0.0076586124, -0.0249643754, 0.0234655030, -0.0048194644, 0.0033102282, -0.0034524233, 0.0096467519, -0.0085009839, 0.0023462251, 0.0000159595, -0.0231431201, 0.0588470288, 0.0033081970, 0.0233887397, -0.0008898149, -0.0036671718, -0.0158803351, -0.0256968178, 0.0090765674, 0.0095707234, -0.0049591572, 0.0165355895, 0.0273535158, 0.0145497695, -0.0347080603, -0.0106970137, -0.0174948908, -0.0541655160, 0.0083788550, 0.0149897058, 0.0244396962, 0.0000495832, 0.0241374485, -0.0197546296, -0.0000283630, 0.0000019404, 0.0122392569, 0.0283394698, 0.0304626897, 0.0027848254, -0.0065780208, 0.0343429893, -0.0058852448, -0.0002536500, -0.0044327867, 0.0028944542, 0.0034626049, -0.0042187274, -0.0289928410, -0.0034261167, 0.0183311682, -0.0000000226, -0.0108454041, -0.0132257231, 0.0031606546, -0.0036479237, -0.0113508236, -0.0056390017, 0.0123944758, 0.0045691114, 0.0140993092, 0.0184246209, 0.0079434980, -0.0184573401, 0.0140067050, 0.0216596425, 0.0247834492, 0.0016507270, -0.0060847029, 0.0049606520, -0.0245679002, 0.0436178483, -0.0041669672, -0.0001189413, -0.0054519265, -0.0073456080, -0.0026899613, 0.0231092293, -0.0068312087, -0.0034361081, 0.0053059282, 0.0059135649, 0.0127159832, -0.0162681714, -0.0011470539, -0.0299243629, -0.0115946680, -0.0255777184, 0.0059848959, 0.0176569000, -0.0029087025, -0.0115151461, 0.0305811595, 0.0075360844, -0.0153928744, 0.0024644870, 0.0007018201, 0.0016722864, 0.0000000304, -0.0040239636, 0.0053836601, 0.0221841857, 0.0002710047, 0.0022256994, -0.0005330329, 0.0134267695, -0.0066539077, -0.0000484756, -0.0118654389, -0.0078573767, 0.0142069701, 0.0038625440, -0.0046230489, -0.0004023214, 0.0051060091, 0.0000000050, 0.0038661866, -0.0071355049, 0.0251106098, -0.0034107105, -0.0195368584, -0.0108562578, -0.0261298902, -0.0043196972, 0.0102741793, 0.0084183896, 0.0029553305, -0.0167116784, 0.0002113011, 0.0096195266, 0.0179536566, 0.0091568828, -0.0162918475, 0.0189936645, -0.0012915477, 0.0146195870, 0.0078784786, -0.0000017450, -0.0132976267, 0.0119377766, 0.0098860096, 0.0156537592, -0.0015794433, -0.0013767967, 0.0010019441, -0.0050409161, -0.0196507033, 0.0069405045, -0.0000413489, -0.0058208867, -0.0155793792, 0.0164794996, -0.0100028943, 0.0118397437, 0.0038354795, 0.0030084501, 0.0038642366, -0.0114676896, -0.0156217208, 0.0095496634, 0.0078847064, -0.0148929432, -0.0000312702, 0.0040453067, -0.0095148571, -0.0704379976, -0.0110915694, -0.0061821453, -0.0188474692, 0.0076402850, -0.0127752963, -0.0000094818, -0.0081831869, 0.0225584991, 0.0370577648, 0.0154910265, 0.0187483244, -0.0015242451, -0.0107146455, 0.0000000229, 0.0003133410, 0.0067367242, 0.0200840235, -0.0001512556, 0.0011267237, -0.0009648029, -0.0075867428, 0.0019940739, 0.0118521275, -0.0117195835, 0.0073473449, -0.0256959852, -0.0162215997, 0.0005403818, -0.0136124669, -0.0090194708, -0.0106629683, 0.0206761919, 0.0007690241, -0.0178595670, 0.0157098807, -0.0000063745, -0.0052192933, -0.0302074887, 0.0230578426, 0.0116201034, -0.0001457372, 0.0032554336, 0.0011093374, -0.0226840861, -0.0080961520, 0.0010305875, 0.0013257201, -0.0001806898, 0.0095643252, -0.0117222629, 0.0121347681, -0.0032123949, -0.0030606943, 0.0036508425, -0.0228959769, 0.0003710848, 0.0227993373, 0.0163850207, -0.0197620839, -0.0172076169, 0.0000184937, 0.0077736159, 0.0382599533, -0.0449118577, -0.0287224576, 0.0102977147, -0.0016652941, -0.0006901532, -0.0078278594, -0.0002205214, -0.0156005044, -0.0601111017, 0.0513420627, 0.0065991003, -0.0222950485, 0.0067761499, -0.0479289629, -0.0000000201, 0.0019224619, 0.0085293641, -0.0293783918, 0.0003363274, -0.0090367356, 0.0148286419, -0.0369106755, 0.0091170799, -0.0094697773, 0.0360386595, 0.0188932884, 0.0375379622, -0.0501529016, 0.0138940429, -0.0302153211, 0.0074641914, -0.0367228985, -0.0058249324, -0.0228381716, 0.0176197235, 0.0655723065, 0.0000012181, 0.0721385852, -0.0059583839, -0.0253774002, -0.0219640527, -0.0006797992, -0.0048891059, 0.0059536393, 0.0253215395, -0.0184096172, 0.0067657884, -0.0028811377, 0.0263489857, -0.0234530941, -0.0626428351, 0.0489263684, 0.0022615313, 0.0384985842, -0.0021544655, -0.0409004092, 0.0067160251, -0.0144630866, -0.0173221324, -0.0225889944, -0.0065591191, -0.0000208031, 0.0292649269, -0.0021892358, -0.0771614537, -0.0175091866, 0.0003598675, 0.0165662784, -0.0041831583, -0.0155689614, 0.0000440236, 0.0003140805, 0.0134335710, 0.0194396134, -0.0018695635, 0.0147148697, 0.0016623932, -0.0503192171, 0.0000000001, -0.0044475077, -0.0129215801, -0.0231271908, 0.0000716494, -0.0084489305, 0.0292046256, 0.0107916761, -0.0054216753, -0.0124355694, 0.0108152181, -0.0016205797, 0.0215266701, -0.0297371764, 0.0211139452, -0.0222272538, 0.0091388151, -0.0113790259, -0.0042584371, -0.0058343671, -0.0128559601, 0.0589965247, 0.0000002144, 0.0356230363, -0.0387446880, -0.0301811453, -0.0218047164, -0.0003066304, 0.0164517034, 0.0000485045, 0.0435487181, -0.0115868021, -0.0121416356, 0.0021848262, -0.0038803918, -0.0256654490, -0.0617419034, 0.0225732811, 0.0137222353, 0.0273631066, 0.0173759721, -0.0469232425, 0.0074958699, 0.0151075236, -0.0287610888, -0.0292190891, 0.0045984420, 0.0000025132, 0.0206913892, 0.0276690256, 0.0335260481, 0.0292345881, 0.0039769816, -0.0135829318, -0.0147532318, 0.0007554162, 0.0000182047, -0.0130933579, -0.0131126242, 0.0263125524, 0.0051273531, -0.0219463259, -0.0012369647, -0.0019617199, -0.0000000022, 0.0007182930, -0.0104962988, -0.0301695298, 0.0011918524, 0.0131800268, -0.0053439741, -0.0035460659, -0.0089393351, -0.0102689965, -0.0033741009, -0.0124399923, -0.0090613263, -0.0076923049, -0.0290544480, -0.0125701772, 0.0051648705, 0.0012429847, -0.0187506974, 0.0012309932, 0.0338272676, -0.0078572836, 0.0000005540, -0.0072522284, 0.0069501568, -0.0063546151, 0.0000831827, 0.0053697159, 0.0027520729, -0.0053201048, 0.0086533139, 0.0024827304, -0.0065361657, -0.0015668345, -0.0058719576, 0.0216698013, 0.0178848431, -0.0178475846, -0.0236944128, 0.0090507148, 0.0077463645, 0.0278440062, -0.0101163145, -0.0071568680, -0.0073675094, -0.0111844810, -0.0162948817, -0.0000009815, -0.0039345296, 0.0107007120, -0.0631373301, -0.0203531943, 0.0031549190, 0.0064251702, -0.0111897802, -0.0244599711, -0.0000030076, -0.0097552100, 0.0175614376, 0.0245680865, -0.0117600318, 0.0016342918, -0.0025224569, -0.0148823978, 0.0000000000, -0.0017124389, 0.0119160358, -0.0041147606, 0.0000005396, -0.0007265803, 0.0211378764, -0.0014780553, -0.0171825271, -0.0040878202, -0.0008650707, -0.0087523498, 0.0093971994, -0.0149721606, 0.0177985672, 0.0089633651, 0.0181926303, -0.0017747626, 0.0304805227, -0.0059255231, 0.0162202343, 0.0277964175, 0.0000001890, 0.0249974169, 0.0060246019, -0.0103726685, 0.0007650838, 0.0000866995, -0.0046800906, -0.0009111192, 0.0272662602, -0.0179557409, -0.0106680449, -0.0000031750, -0.0099075576, -0.0043067127, -0.0242933575, 0.0164545700, 0.0179564450, 0.0135353981, 0.0060327775, -0.0595043078, 0.0101835662, 0.0278461650, -0.0036080496, -0.0024206787, 0.0267624911, 0.0000184053, -0.0122109428, 0.0124325035, -0.0185397547, 0.0086203795, -0.0051282337, -0.0130048310, 0.0047939485, -0.0132899564, -0.0002207688, -0.0185284708, 0.0250316970, 0.0169982594, -0.0186265893, 0.0082196267, -0.0094006807, 0.0021434412, -0.0000014414, -0.0094200550, 0.0192478411, 0.0211114790, -0.0049323770, -0.0300483238, 0.0000279908, -0.0213558972, -0.0193589907, -0.0014424192, 0.0092184925, 0.0079628415, 0.0175364036, -0.0188312195, 0.0179466326, 0.0301221851, 0.0328662246, -0.0152218407, -0.0053766370, 0.0137732802, 0.0023185080, 0.0238467958, -0.0000893104, 0.0583825596, 0.0574087910, 0.0271951221, -0.0122386310, -0.0068341629, -0.0122602563, 0.0022935090, 0.0306773800, -0.0234333389, 0.0292852093, -0.0036868355, 0.0011024933, -0.0496664457, -0.0454325490, 0.0244326573, 0.0511318259, 0.0254370887, 0.0137904948, -0.0284921713, 0.0266740527, -0.0234978627, 0.0370196737, 0.0236166399, 0.0176328216, -0.0000537876, -0.0054228343, 0.0191177111, 0.0913031250, 0.0223588031, -0.0152903805, -0.0183937270, -0.0044845673, 0.0030345751, -0.0028620667, -0.0103299217, -0.0084190574, -0.0118258586, 0.0186762959, 0.0122935716, -0.0059773577, 0.0251075272, -0.0000119561, -0.0267548170, -0.0618197583, -0.0245729256, -0.0156780742, 0.0209573209, -0.0287540480, -0.0048694951, 0.0068822741, 0.0265053194, 0.0225974340, -0.0109222950, 0.0217477232, 0.0292444788, 0.0405468121, 0.0006780542, -0.0047011301, 0.0289330203, -0.0268535744, -0.0046708756, -0.0073348926, 0.0109847290, -0.0000606333, -0.0401051976, 0.0216894727, 0.0221230723, 0.0270865466, -0.0054786718, -0.0034643582, 0.0074523762, -0.0198609270, 0.0212531146, -0.0288881548, -0.0142619442, -0.0184043515, 0.0071292790, -0.0306209493, 0.0089369603, 0.0252985992, -0.0072171199, 0.0342786349, 0.0743292496, -0.0134707578, -0.0303997789, 0.0504844151, 0.0138599314, -0.0013933301, -0.0000296137, -0.0065432726, 0.0211642981, -0.0517375208, 0.0216423701, 0.0233450383, -0.0196684338, -0.0284795091, -0.0305148344, -0.0000160787, -0.0406012461, 0.0445650890, 0.0598667935, 0.0177469570, 0.0206931084, -0.0080413446, -0.0081013544, -0.0000000109, -0.0067259357, -0.0107909134, 0.0162659045, -0.0011341729, -0.0108339414, -0.0043107606, 0.0106621794, -0.0145225180, -0.0084941071, 0.0266162101, 0.0175977442, -0.0403665863, -0.0097374376, 0.0283184573, 0.0017613345, -0.0055919900, 0.0043729944, -0.0004474222, -0.0113780331, 0.0006763203, 0.0493593886, -0.0000112523, -0.0035845102, -0.0239185393, -0.0137595264, 0.0105373347, -0.0057432968, 0.0027192710, 0.0140945632, 0.0006274238, -0.0083982171, -0.0456687734, 0.0004419855, -0.0220018867, -0.0129923681, -0.0445945673, 0.0129531566, 0.0361216515, 0.0133624813, 0.0200257320, -0.0415379293, 0.0310076792, -0.0092593916, 0.0105021512, -0.0390609466, 0.0136710843, 0.0002004940, -0.0059154155, -0.0143269869, 0.0576606952, 0.0263934787, 0.0286078621, 0.0050199972, 0.0533871204, 0.0318547077, -0.0003120291, -0.0408475399, -0.0802130997, -0.0104746912, 0.0154306758, 0.0226612799, 0.0098535521, 0.0181718804, 0.0000002145, -0.0055175615, -0.0101618422, 0.0229027886, -0.0012178841, 0.0233988464, -0.0134035340, -0.0219753403, -0.0131238345, 0.0055493088, -0.0738955289, -0.0096485158, -0.0000243649, 0.0211750958, -0.0290163122, -0.0097668031, -0.0532972217, -0.0262104403, 0.0031247251, 0.0050296001, -0.0305865705, 0.0048996983, -0.0013997527, -0.0602341294, 0.0047837519, -0.0215499345, 0.0050053294, -0.0038737347, 0.0108875828, 0.0060281465, 0.0283532739, -0.0174879003, -0.0103474269, -0.0095984023, -0.0022668748, -0.0002000480, 0.0316936336, -0.0247078445, -0.0394184217, 0.0200849567, -0.0191576071, 0.0867965221, -0.0214936137, -0.0065974584, -0.0207932275, -0.0162060484, 0.0319492593, -0.0000000669, 0.0004336662, 0.0015785039, -0.0077329017, -0.0050011696, 0.0060426597, 0.0064913766, -0.0224259216, -0.0058153281, 0.0000000500, 0.0006220362, 0.0124291889, -0.0188850425, -0.0211717673, 0.0056219553, -0.0014210538, 0.0032012071, -0.0000000000, 0.0045854631, 0.0269633904, 0.0158787146, 0.0000139735, -0.0029127926, -0.0037821771, 0.0016551560, -0.0020270001, -0.0001333078, -0.0150114410, 0.0045553958, -0.0005744189, -0.0174158588, -0.0071036052, 0.0185492337, 0.0276970118, -0.0091758799, -0.0158326607, 0.0212186873, 0.0077534588, 0.0143521102, 0.0000000080, 0.0221439376, 0.0614100061, 0.0089110574, 0.0019325170, 0.0002415674, 0.0020996246, -0.0081978254, 0.0038893081, -0.0085593257, 0.0089936014, -0.0000435747, -0.0049247970, -0.0132800108, 0.0142780589, -0.0149900308, 0.0137185603, 0.0007104302, -0.0142660253, -0.0065906798, 0.0023408497, 0.0336043090, -0.0108002080, -0.0155077334, 0.0041638068, -0.0000093759, 0.0318599455, 0.0093915993, -0.0282422137, -0.0018722317, -0.0059296330, 0.0053170305, -0.0055305385, 0.0025370587, -0.0001450622, -0.0009149725, 0.0003700446, 0.0160619300, -0.0339621902, -0.0188285336, 0.0020880697, -0.0251003038, -0.0000000095, 0.0016128800, 0.0149717061, -0.0059853480, 0.0001895452, 0.0027588457, 0.0164807942, -0.0054213307, -0.0037097121, -0.0067761433, 0.0145219322, 0.0128178345, 0.0191395599, -0.0144662997, -0.0208081622, -0.0009455288, 0.0318400897, -0.0049596545, 0.0006759053, -0.0080484031, 0.0236749277, 0.0529186167, 0.0000005223, 0.0383990668, 0.0071938112, -0.0231520738, -0.0236823391, 0.0000649576, 0.0030759042, 0.0032082570, 0.0363130122, -0.0067905826, -0.0014844529, 0.0011356306, -0.0069603217, -0.0235381946, -0.0345196128, 0.0090973107, 0.0144385276, -0.0004972237, 0.0021527600, -0.0345892459, 0.0074999789, 0.0004022307, -0.0209222361, -0.0185626037, 0.0222858991, 0.0000115148, -0.0138235250, 0.0053633000, -0.0094511854, 0.0031258150, 0.0082755322, 0.0410232767, -0.0188113339, -0.0042526880, -0.0000204810, 0.0015425667, 0.0263570342, -0.0409507118, -0.0104888044, 0.0221928749, 0.0035727106, -0.0019916755, -0.0000000466, 0.0130138192, 0.0651684478, 0.0532601625, 0.0003391292, -0.0071997605, 0.0015330927, -0.0088856863, -0.0120113101, -0.0117895976, -0.0144750448, 0.0083952481, 0.0134163741, -0.0411407091, -0.0251971316, 0.0140783219, 0.0267168526, -0.0284226499, 0.0024665515, 0.0284122229, -0.0105647277, -0.0287126321, -0.0000029366, 0.0249375254, 0.0417337343, 0.0164353214, -0.0171162598, -0.0001522777, 0.0109290546, -0.0019513180, -0.0040641273, -0.0221006833, 0.0628852993, -0.0002982246, 0.0278992280, -0.0072216215, 0.0548962280, -0.0252889115, 0.0053463830, 0.0054065967, -0.0299674422, -0.0002056267, 0.0047751665, 0.0030726923, 0.0165072326, 0.0113469660, -0.0119055593, 0.0000006732, -0.0074171033, 0.0008875328, 0.0005147436, 0.0333000645, -0.0007720719, 0.0009507586, -0.0062113381, -0.0095090847, 0.0000019954, -0.0067078555, -0.0039379057, 0.0029968091, 0.0014604073, 0.0025132983, 0.0016808256, 0.0077694408, 0.0000000000, 0.0061286949, -0.0053679207, 0.0159775168, 0.0000312823, -0.0019944198, 0.0101632001, 0.0198490061, 0.0022961781, -0.0097526237, -0.0041291788, 0.0063014575, -0.0105031375, -0.0022456243, 0.0118323416, -0.0060423063, -0.0058803083, -0.0057775378, 0.0142368693, -0.0020940632, 0.0107480539, -0.0037254845, 0.0000021414, -0.0023917416, -0.0041697812, -0.0188406557, 0.0058529829, -0.0005093417, -0.0011733391, 0.0017925140, 0.0151991965, -0.0155592766, -0.0184495728, 0.0002201493, -0.0073736003, -0.0016731289, -0.0029457931, -0.0096673099, -0.0067490144, 0.0129752997, -0.0034166174, -0.0073846122, 0.0193291008, -0.0011593488, 0.0241628829, -0.0041985014, 0.0012236105, -0.0000176409, -0.0243539419, 0.0201778002, -0.0651231036, 0.0052244333, 0.0082790852, -0.0093937265, -0.0288547650, -0.0135561088, -0.0000338364, -0.0201838948, 0.0073252115, 0.0042602792, -0.0048204530, 0.0184410736, -0.0048369775, -0.0168859623, -0.0000000000, -0.0066187987, -0.0036039448, -0.0087701641, -0.0000045872, -0.0161857009, 0.0209266469, 0.0016950030, -0.0259737056, -0.0334380828, 0.0209278017, 0.0039765933, 0.0167219508, -0.0143395988, 0.0269053057, 0.0044781659, 0.0078803869, -0.0135547211, 0.0141114425, 0.0025415483, 0.0085259601, 0.0340492800, -0.0000001056, 0.0173430108, 0.0058919066, -0.0139766391, -0.0119382655, 0.0002005640, -0.0228827521, 0.0130665563, 0.0320843197, -0.0148140565, -0.0162866507, -0.0003077023, -0.0195803121, -0.0213707667, -0.0495010428, 0.0113409171, 0.0207750443, 0.0445621684, -0.0005159369, -0.0640502721, 0.0332855545, -0.0093105379, -0.0265219361, -0.0239701513, 0.0469348803, -0.0000000055, 0.0101736672, 0.0181482341, -0.0105244350, 0.0127698854, 0.0004492960, 0.0116183180, -0.0180579647, 0.0087899985, 0.0000000688, -0.0118587334, 0.0013720932, -0.0064508957, 0.0016675445, 0.0146192601, 0.0013087365, -0.0129058836, -0.0000000000, 0.0038860361, 0.0232316460, -0.0052662292, 0.0001527994, -0.0036253410, 0.0087511614, 0.0041848030, 0.0037359570, -0.0155111346, -0.0026727649, 0.0030593525, 0.0096589420, -0.0310173575, -0.0166412536, 0.0029356221, 0.0153241735, -0.0203249548, -0.0436681621, 0.0167363565, -0.0067529110, 0.0210916810, 0.0000000022, 0.0466665514, 0.0433720127, -0.0064239423, -0.0345479064, 0.0004816094, 0.0073585967, -0.0040544197, 0.0097807031, -0.0163062327, 0.0112025822, 0.0001833168, 0.0160601866, -0.0369582102, -0.0132712787, -0.0062684417, 0.0143743604, 0.0153667796, 0.0213644877, -0.0020490154, 0.0054176296, -0.0113847610, 0.0421404801, 0.0097092502, 0.0136963632, 0.0000034874, -0.0414595529, 0.0106250150, 0.0342988558, 0.0375661254, -0.0100583676, 0.0091992849, -0.0090178633, -0.0037408422, -0.0000096626, -0.0162591580, 0.0243235640, -0.0222290214, -0.0197456013, 0.0134638315, -0.0050615533, 0.0433504656, 0.0000000002, 0.0072742379, 0.0363036916, 0.0527100340, -0.0010055394, -0.0028343599, -0.0185433161, -0.0197212547, -0.0085352166, 0.0077633848, -0.0233262666, 0.0020080712, -0.0189257134, -0.0009723989, 0.0063402751, 0.0294191651, 0.0056640524, -0.0080506587, -0.0274853688, 0.0085131964, -0.0049368725, -0.0271390937, -0.0000144049, 0.0147264283, 0.0321130939, 0.0238876361, 0.0185168125, -0.0015681233, -0.0183198750, 0.0002511214, -0.0039324686, -0.0136892395, 0.0052074995, -0.0021437618, -0.0012276713, -0.0128608570, 0.0338841304, 0.0006972986, 0.0035285018, 0.0375053212, -0.0020180794, -0.0086690690, 0.0191447306, -0.0125624193, -0.0102371946, -0.0025259356, -0.0041638291, -0.0000000051, 0.0076607047, 0.0024857176, -0.0159777515, -0.0146221127, -0.0128851626, 0.0034261944, -0.0062282132, -0.0193546154, 0.0000000102, 0.0026427540, 0.0216172189, 0.0047912393, 0.0111952899, -0.0069469120, -0.0005208324, -0.0005618340, -0.0000000000, 0.0028830136, -0.0097178612, -0.0100644501, 0.0000528460, 0.0014540433, 0.0001393560, -0.0126969349, 0.0019862363, 0.0067998325, -0.0060469001, -0.0041417973, 0.0015311920, -0.0151444543, -0.0023250778, -0.0058217840, -0.0036809684, -0.0002228562, 0.0233038310, 0.0035076048, -0.0066234376, -0.0011652814, 0.0000000012, -0.0055839769, -0.0088294065, 0.0061757169, -0.0062020323, 0.0001509195, 0.0064540599, -0.0042138794, 0.0013892076, -0.0093007395, 0.0139882918, 0.0000269952, -0.0024495148, 0.0146445772, 0.0046474664, -0.0136929974, -0.0103520900, -0.0082542095, -0.0004274624, 0.0073599969, -0.0136604654, -0.0031619556, -0.0364298113, -0.0324841216, 0.0640805215, 0.0004186741, 0.0041683340, 0.0016831696, 0.0663739443, 0.0029110778, 0.0303395148, 0.0008159814, 0.0279820822, 0.0954557359, -0.0002459685, -0.0063357330, -0.0850658566, -0.0401314683, -0.0657035485, 0.0501040891, 0.0050637834, 0.0071240258, 0.0000001965, 0.0045362348, 0.0639860258, 0.0094575668, 0.0004369228, 0.0044733710, -0.0161489602, -0.0168586783, 0.0089601073, 0.0142421136, -0.0604006685, -0.0009319825, 0.0466504619, -0.0272382628, -0.0240242165, 0.0077187736, 0.0188309457, -0.0403295048, -0.0482612848, 0.0495011620, -0.0222082064, 0.0354722887, 0.0002409812, 0.0046428600, 0.0958265737, 0.0072797961, 0.0037866186, -0.0020039403, -0.0056999242, -0.0130171105, -0.0400291719, 0.0051354733, 0.0153432395, -0.0068838629, 0.0575751849, -0.0378179215, -0.0015676206, -0.0149512179, 0.0035365245, -0.0360143371, -0.0515918955, -0.0144718029, 0.0364279076, 0.0229677893, 0.0228796303, -0.0062808837, -0.0778954625, 0.0000036621, -0.0033694049, 0.0329077691, 0.0562760793, -0.0186346490, 0.0061334777, -0.0217406005, 0.0524397753, 0.0009445040, 0.0000066446, 0.0120619200, -0.0597117171, 0.0108092381, 0.0081313830, -0.0475856625, 0.0008582933, 0.0187297706, 0.0000000171, -0.0188313574, -0.0600994192, -0.0227071997, 0.0008960718, 0.0055416767, 0.0016229139, -0.0329468325, -0.0319062285, 0.0022320850, -0.0069969618, -0.0167644564, -0.0109277917, 0.0405200385, 0.0174540132, 0.0188392214, -0.0530267060, 0.0342491791, 0.0360778570, -0.0455757678, 0.0272641145, -0.0668327585, 0.0000011503, -0.0615295209, -0.0664395690, -0.0030810551, 0.0448066816, 0.0000702562, -0.0259585902, 0.0042919815, 0.0036169556, -0.0226468053, -0.0367484502, -0.0013598026, -0.0336796977, 0.0696117058, 0.0378920585, 0.0095653096, -0.0325632766, 0.0148501415, -0.0025012400, 0.0389080457, -0.0348636843, -0.0291108955, -0.0184862558, 0.0008634499, 0.0417255685, 0.0000403278, -0.0224372186, -0.0053145760, -0.0024471520, 0.0115101486, 0.0339501165, 0.0070577646, -0.0339475945, 0.0105851600, 0.0000100765, 0.0089480206, 0.0101080621, -0.0122284945, -0.0204438623, 0.0341019370, -0.0074003101, 0.0197713673, -0.0000000520, 0.0096243871, 0.0497491360, 0.0475268923, -0.0001389966, -0.0004237505, -0.0149301728, 0.0061639235, -0.0164379198, -0.0046612862, -0.0205955449, 0.0103184870, -0.0082014417, -0.0092312098, -0.0198785588, -0.0057353382, 0.0313182957, 0.0039200331, -0.0346640646, 0.0286103915, 0.0044487114, 0.0010470406, -0.0000009203, 0.0401390493, 0.0633884966, 0.0171893220, 0.0006021175, -0.0003560488, -0.0068825055, -0.0098165162, -0.0112450961, 0.0051132627, 0.0069631762, -0.0010924427, 0.0097504957, -0.0330412723, 0.0039047531, -0.0060042893, 0.0146080162, 0.0161039494, -0.0076413178, -0.0255704559, 0.0275042318, 0.0260680616, 0.0259572808, 0.0330132917, -0.0255243052, -0.0000394949, -0.0106210588, 0.0247957893, -0.0402174518, -0.0234603081, -0.0089455228, -0.0266641788, 0.0136997839, -0.0247060508, -0.0004569347, -0.0167019702, 0.0418509394, 0.0331354253, 0.0409081131, -0.0015045995, -0.0118857482, 0.0079239765, -0.0000000338, -0.0219429769, -0.0275252573, -0.0023293695, -0.0108582228, -0.0205861405, 0.0031534890, -0.0105109867, -0.0129309250, 0.0003909216, 0.0538733304, 0.0124284076, -0.0036713493, 0.0026697477, 0.0483679958, -0.0019031567, 0.0219458230, 0.0062628579, 0.0363527983, -0.0096585630, 0.0153306955, 0.0123712597, -0.0000608989, 0.0024698004, -0.0165471379, 0.0464215502, 0.0194250960, -0.0049019889, -0.0079078451, -0.0002968882, 0.0054111611, -0.0145632271, -0.0003059086, -0.0055658324, -0.0214084852, -0.0438005030, -0.0380938835, 0.0122750634, 0.0407607779, 0.0318063758, 0.0189829823, -0.0008387207, -0.0103136487, -0.0139583498, -0.0103939539, -0.0226858892, -0.0264093149, 0.0000032828, 0.0070606577, 0.0288285371, -0.0243993066, 0.0103605585, 0.0040782811, -0.0173510369, -0.0150351096, -0.0267647225, 0.0000248066, -0.0263500381, 0.0093976669, 0.0565892719, 0.0569711924, 0.0011617520, -0.0022020277, -0.0286889505, 0.0000000000, -0.0027834591, -0.0252687745, -0.0502376482, 0.0005397178, 0.0063689444, -0.0043117027, 0.0181876086, -0.0001320733, -0.0201865174, 0.0053102262, -0.0280998275, -0.0043732170, -0.0167342555, -0.0049909721, -0.0416668802, -0.0285541583, -0.0020395454, 0.0000365742, -0.0074347225, -0.0155391889, -0.0241423212, 0.0000003560, 0.0033771226, -0.0340648964, 0.0005029055, -0.0112096574, 0.0015499943, -0.0094109261, 0.0048337155, -0.0150762089, -0.0118545331, -0.0045405487, -0.0011945635, 0.0136591326, 0.0264525786, -0.0186738558, 0.0233402085, -0.0415759273, 0.0213535447, 0.0301793851, -0.0143271750, -0.0017156119, 0.0135927750, 0.0205951985, 0.0070231878, -0.0555003174, -0.0000411454, -0.0561445057, 0.0038995408, -0.0183657371, 0.0151931206, -0.0064521465, -0.0087715965, 0.0075220899, 0.0036983774, -0.0000054018, 0.0120175006, -0.0393819436, -0.0015164958, 0.0311505366, 0.0133584468, -0.0078995442, 0.0255363304, -0.0000000002, -0.0061920034, -0.0040094531, 0.0006361301, -0.0002903838, 0.0081742946, -0.0061883950, 0.0055188360, 0.0004569059, -0.0145261614, 0.0003850784, -0.0071085272, 0.0072349738, -0.0024638358, 0.0026607388, -0.0170956012, -0.0437386408, -0.0005455285, 0.0404781923, -0.0067224205, -0.0078177368, -0.0255526714, -0.0000488612, 0.0392252356, 0.0049265772, 0.0080842823, 0.0043871435, -0.0031201367, -0.0245552864, 0.0000169154, 0.0211409070, -0.0094904630, 0.0006339023, -0.0004383643, 0.0108932899, -0.0147233279, -0.0051725251, 0.0197165720, -0.0191975050, 0.0528551117, 0.0334128775, -0.0199901480, 0.0336592570, -0.0188377574, 0.0056839162, -0.0023527569, 0.0147266388, 0.0000012097, -0.0074540661, -0.0050943801, -0.0257689934, 0.0080369227, -0.0052617416, -0.0037425356, -0.0182500817, -0.0074553736, 0.0000008267, 0.0068395487, 0.0065165721, 0.0037054149, 0.0132655296, -0.0065724608, 0.0068666739, -0.0099472208, -0.0000000604, 0.0118531315, 0.0105799716, -0.0067676362, -0.0002009403, 0.0071473033, 0.0167661849, -0.0030120963, 0.0144591713, 0.0055689909, 0.0436221659, 0.0205235891, -0.0154982582, -0.0192787629, -0.0040930579, -0.0179725457, 0.0072292071, -0.0098781185, -0.0071123969, 0.0050566760, 0.0044267001, 0.0326620452, 0.0000001285, 0.0080572339, -0.0036878597, -0.0015821174, -0.0278514884, 0.0040796031, 0.0019350217, 0.0024008306, 0.0118669160, -0.0112353936, -0.0060692281, 0.0004112141, 0.0028871321, -0.0401532240, -0.0300231166, -0.0037160914, -0.0018730405, 0.0325419158, 0.0552531965, 0.0010457134, -0.0046104821, -0.0391455553, 0.0370903537, -0.0253797490, -0.0160273891, -0.0001135533, -0.0151947476, -0.0232802108, -0.0062598190, -0.0313798226, 0.0060738758, -0.0195601154, 0.0116469134, -0.0220497288, -0.0000801656, -0.0323981494, -0.0302124806, 0.0045329602, 0.0068402998, 0.0074900151, -0.0067596654, -0.0558421686, -0.0000001966, 0.0034068066, 0.0068375557, 0.0523128919, -0.0005374434, -0.0112207280, 0.0233410317, 0.0108217876, -0.0318372473, -0.0315483660, -0.0310127847, -0.0018043711, 0.0054090424, -0.0171749815, -0.0237328727, -0.0065029282, -0.0579520650, -0.0025733102, -0.0143271787, -0.0165454559, -0.0434930846, 0.0164320562, -0.0000513985, -0.0178867467, -0.0185013060, 0.0048436904, -0.0421217568, -0.0009258787, 0.0270756111, 0.0196102802, 0.0261726044, -0.0153914010, 0.0070785484, 0.0010341653, -0.0129679274, 0.0276453812, 0.0341444314, 0.0127670150, -0.0008990071, 0.0728261098, 0.0193867031, -0.0164798535, 0.0006621665, -0.0150118060, -0.0021098587, -0.0347415544, 0.0100668892, -0.0000010807, 0.0011110298, 0.0068570059, 0.0056945854, 0.0046116016, 0.0001759208, 0.0131301349, -0.0152128525, -0.0146934967, -0.0001582358, -0.0300753117, 0.0358277969, -0.0012947090, 0.0013943650, -0.0107039986, 0.0008464989, -0.0232621375, 0.0000000002, -0.0036298544, 0.0074336841, 0.0375922695, 0.0000332554, 0.0015529918, -0.0057122139, -0.0289750397, -0.0244633872, -0.0212542824, -0.0128362980, 0.0028806808, -0.0054639052, 0.0155866509, 0.0024628351, -0.0000655558, 0.0407214910, 0.0165213235, 0.0029301881, 0.0145275705, -0.0351312608, 0.0090006487, -0.0000005037, -0.0180628262, -0.0376332812, 0.0108965943, -0.0037276375, 0.0010080988, 0.0196693745, 0.0056009772, 0.0081629911, -0.0152143557, 0.0146400807, 0.0009654259, -0.0140751721, 0.0346198268, 0.0270289779, -0.0140146548, 0.0156078460, -0.0138968443, -0.0063734408, 0.0108122695, -0.0157798473, 0.0242756568, 0.0354327448, 0.0550037809, 0.0146228112, 0.0006384819, -0.0529193394, -0.0576436594, 0.0125779910, -0.0204761010, 0.0040213945, -0.0041640680, -0.0513010845, 0.0433943756, -0.0001720172, 0.0322925486, -0.0146702081, -0.0161378831, 0.0205382556, 0.0215289164, -0.0042184247, 0.0737157464, 0.0000000665, -0.0120434277, 0.0074014193, 0.0552537367, -0.0071705617, 0.0323597901, -0.0175375659, 0.0079042269, 0.0086356169, -0.0191508401, 0.0144779989, 0.0003584274, -0.0373149365, 0.0210041255, -0.0167729184, 0.0221758168, -0.0429668538, 0.0402254052, 0.0098712072, 0.0191253591, 0.0288090538, -0.0384099931, 0.0000673456, -0.0039746724, 0.0306368303, -0.0101780118, 0.0071348748, 0.0032948931, -0.0174687374, -0.0258579478, -0.0385172963, 0.0370947644, -0.0276903212, -0.0207155719, -0.0073260022, -0.0410595722, 0.0534355789, -0.0663331747, -0.0269347355, 0.0161406267, 0.0325275175, 0.0462828912, 0.0267008040, -0.0613060705, -0.0345506966, 0.0038913204, 0.0047770506, -0.0002784630, -0.0025254809, 0.0155055933, -0.0251985639, 0.0207484886, -0.0091373352, 0.0056258105, -0.0067893923, 0.0185683388, -0.0000095055, -0.0057027750, 0.0080512566, 0.0178622697, 0.0130679412, 0.0045297965, -0.0006198152, 0.0082220109, 0.0000000036, -0.0044177929, 0.0368160605, -0.0172866043, -0.0017802648, -0.0112753082, 0.0034347218, 0.0058991006, -0.0256221611, -0.0217513312, -0.0057049301, -0.0084541477, 0.0086878091, -0.0315445885, -0.0235604364, 0.0074671335, -0.0154556874, 0.0015207664, 0.0412862487, 0.0234549660, -0.0003328449, 0.0185793564, -0.0000215689, 0.0322024226, -0.0115088075, 0.0014914743, 0.0086660748, -0.0014417383, 0.0221150853, 0.0029712627, -0.0027485495, 0.0090013286, 0.0396798290, -0.0124206925, 0.0547414087, -0.0093790209, 0.0009541137, 0.0065765604, -0.0049920487, -0.0317907184, 0.0104793441, 0.0042666011, 0.0108038923, 0.0101021426, 0.0109658092, 0.0159919094, -0.0230343994, 0.0000975328, -0.0650049150, -0.0247627757, 0.0213501211, 0.0064760442, -0.0065717516, -0.0208997689, 0.0018752008, -0.0046777502, -0.0000597537, 0.0234502032, 0.0130711775, -0.0058783665, 0.0280717723, 0.0134220282, -0.0055023427, 0.0447188430, 0.0000000168, -0.0039778319, -0.0229812078, 0.0102872532, -0.0069209449, -0.0080341911, -0.0063796947, 0.0145319756, -0.0105075147, 0.0025714885, 0.0078789368, 0.0078659384, -0.0102135064, 0.0478581823, 0.0228433721, 0.0240023360, -0.0063638892, 0.0397178158, 0.0179862622, 0.0025036198, -0.0042193085, -0.0294306148, -0.0000234888, -0.0381275155, 0.0013732398, 0.0204882398, 0.0014122982, -0.0013197104, -0.0149327032, 0.0094257807, 0.0098774629, 0.0137829809, -0.0028541279, -0.0071510319, -0.0236933939, 0.0273477677, 0.0076578972, -0.0039010530, 0.0041108774, 0.0114894323, 0.0561436377, 0.0325340554, -0.0100911139, -0.0473772921, 0.0326301567, 0.0101840822, 0.0152761983, -0.0002039450, -0.0067856866, 0.0290423967, -0.0054267831, 0.0121799000, -0.0219498500, 0.0152549753, 0.0198109895, 0.0209719352, -0.0008227009, -0.0156986378, 0.0387069769, 0.0546945669, 0.0002810577, -0.0197027568, -0.0045084790, -0.0107432427, -0.0000003391, 0.0069444505, 0.0084553175, 0.0082377372, -0.0055970568, -0.0117769772, -0.0151759041, -0.0406105034, -0.0258884747, 0.0208136179, -0.0215328168, 0.0017962779, 0.0162277166, 0.0271469187, -0.0385671221, -0.0200754907, -0.0479871333, -0.0011685592, -0.0182711743, -0.0456900671, -0.0111417398, 0.0104694869, -0.0003955865, -0.0451409221, -0.0539266951, -0.0162522346, -0.0230409298, -0.0209166761, 0.0072529926, -0.0032415621, -0.0119828200, 0.0237306543, -0.0030986331, -0.0027122139, -0.0175576992, 0.0051111979, -0.0021478725, 0.0111723682, 0.0081226742, 0.0178562514, 0.0101639936, 0.0060943807, -0.0097387191, -0.0072560986, -0.0006020470, 0.0143281948, -0.0168460216, -0.0002291895, 0.0261783190, -0.0064294082, 0.0064726011, 0.0348790362, 0.0008010713, -0.0226968061, 0.0031733448, 0.0154140238, -0.0004094885, -0.0196607746, -0.0269377064, 0.0520690158, 0.0101485085, 0.0107681984, -0.0065116836, -0.0015544547, -0.0000007217, -0.0081713116, 0.0063690036, -0.0095685562, 0.0009896343, 0.0005982746, 0.0235725194, 0.0443440862, -0.0227666181, -0.0198696088, -0.0151359746, 0.0062988671, 0.0080945520, -0.0084112445, 0.0214762669, -0.0397056788, -0.0026210113, -0.0011772272, -0.0134955058, -0.0060616899, -0.0265337043, 0.0344557092, -0.0000741674, 0.0145801296, -0.0128944740, -0.0280388258, -0.0038990281, -0.0136908870, -0.0040469198, 0.0225854944, 0.0177383125, 0.0069408636, -0.0569439456, 0.0004977204, 0.0043979487, -0.0054331287, -0.0724140331, 0.0545555800, 0.0080641778, 0.0145696225, 0.0430006906, -0.0008185788, 0.0294388290, 0.0106003098, 0.0346915834, -0.0263578668, -0.0038685610, -0.0005455277, -0.0516193993, 0.0077978093, 0.0244580396, 0.0094206166, 0.0325130187, -0.0240920931, 0.0009536847, -0.0128554283, -0.0009602363, -0.0393567681, 0.0062307920, 0.0586187467, 0.0096065020, 0.0110854283, -0.0070624566, -0.0203010123, -0.0000007311, -0.0181685798, 0.0012874848, 0.0694877207, -0.0114499237, -0.0261544064, -0.0134986518, -0.0285259373, -0.0291818958, 0.0338060297, -0.0183360167, 0.0122907814, -0.0524993464, 0.0302759930, -0.0071922545, -0.0109365378, -0.0315656774, 0.0351680368, -0.0346080624, -0.0210227035, -0.0244473442, -0.0139639564, -0.0002890437, -0.0249680318, -0.0300470777, 0.0113396561, -0.0043474277, -0.0016034083, -0.0126215704, 0.0150279365, 0.0073773931, -0.0092693465, -0.0209057182, -0.0008760843, -0.0165762268, 0.0182123911, 0.0409651287, 0.0123977838, 0.0132301152, 0.0729744881, 0.0483400635, -0.0085716490, -0.0145843010, -0.0246953666, 0.0155452779, -0.0174584854, -0.0216572825, -0.0008256602, -0.0206093658, 0.0108605372, -0.0340152420, -0.0009206611, -0.0113091329, -0.0182295553, -0.0043701441, -0.0021750529, -0.0000517243, 0.0045921491, -0.0149964280, -0.0104676709, 0.0324633867, 0.0072455127, -0.0007491577, -0.0342825353, -0.0000000071, -0.0025576216, -0.0156827588, -0.0696747005, -0.0006693064, -0.0121659758, 0.0073579908, -0.0135603435, 0.0130224936, -0.0305074416, 0.0342917927, 0.0012141065, 0.0248546973, 0.0014855646, 0.0108388439, -0.0170593336, -0.0006292381, -0.0127497250, 0.0406745933, -0.0101290056, -0.0075846668, 0.0142811406, -0.0001920607, 0.0225436911, -0.0056393663, 0.0065167057, -0.0116992630, -0.0037148381, -0.0143091725, 0.0112197157, 0.0347480848, -0.0123868212, 0.0259117540, -0.0072618020, 0.0169831049, -0.0145076104, -0.0250004157, -0.0128136529, 0.0067456360, 0.0278624445, 0.0161086507, -0.0374793559, 0.0235721394, -0.0426226854, -0.0216554441, -0.0112174489, -0.0139685972, 0.0000008184, 0.0022496891, -0.0123984506, -0.0129267126, 0.0016195177, -0.0107126255, 0.0027497185, -0.0065029911, -0.0157932322, -0.0000972338, 0.0024637650, -0.0119575206, -0.0047643199, 0.0281552263, 0.0035000660, 0.0051351376, -0.0030090013, 0.0000000084, 0.0141593432, -0.0195814781, -0.0083984016, 0.0002970601, 0.0073441714, 0.0089205103, -0.0038833530, -0.0120319566, 0.0000168127, 0.0217509940, -0.0003309574, -0.0010624380, -0.0148518616, 0.0097292010, -0.0127469525, 0.0179873351, 0.0066686473, -0.0019645253, 0.0042518303, 0.0107308729, -0.0143282181, 0.0000008849, 0.0299976505, 0.0063098865, 0.0047699441, -0.0387802832, 0.0024048060, 0.0056382893, -0.0021535626, 0.0192083884, 0.0080266269, -0.0016278874, -0.0001072619, 0.0073991986, 0.0048302617, -0.0375634171, 0.0192304179, -0.0052431710, 0.0114856251, 0.0271433499, 0.0053739143, -0.0149257742, -0.0350008719, 0.0268704686, -0.0193651337, -0.0222691633, -0.0000018325, 0.0005012353, 0.0084140757, -0.0256194882, 0.0063837543, -0.0018451352, -0.0130440071, -0.0034324648, -0.0200183820, 0.0006233925, 0.0013965928, 0.0111010512, -0.0204636790, 0.0469674170, 0.0151701886, 0.0023059119, -0.0111409314, -0.0000000397, 0.0053195474, -0.0230916180, -0.0496559441, 0.0003406533, 0.0091962945, 0.0255419873, -0.0107965255, 0.0024172578, -0.0084378896, 0.0583308190, 0.0107153654, 0.0067220507, -0.0008953518, 0.0422759876, -0.0328143165, 0.0259293392, 0.0052796006, 0.0199020337, -0.0035436887, -0.0256510284, 0.0308534075, -0.0000102179, -0.0230533089, -0.0333067067, 0.0154536152, -0.0295346901, 0.0019156174, 0.0049427440, 0.0099748094, 0.0236918926, -0.0137373097, 0.0104906280, 0.0009247140, -0.0118353534, 0.0434785113, -0.0414866209, 0.0098109413, 0.0076452033, -0.0021108782, -0.0013266250, 0.0088553866, -0.0312645100, -0.0541794971, 0.0514840111, 0.0019345016, -0.0079957359, -0.0000076373, 0.0065220287, 0.0520735458, -0.0436947495, 0.0569990687, -0.0151339797, -0.0161574818, 0.0075306590, -0.0328515582, 0.0001555730, -0.0313832648, 0.0394873321, 0.0290543456, -0.0054707294, 0.0139591703, 0.0083679669, 0.0180853102, 0.0000001967, -0.0005016092, -0.0123616597, -0.0128300088, 0.0045934860, 0.0211799182, 0.0288044810, -0.0349025093, 0.0040941229, -0.0106609119, 0.0130750528, -0.0297854524, 0.0144877899, 0.0103479680, 0.0117266020, -0.0080314558, -0.0619899705, 0.0351967439, 0.0222942196, -0.0116874054, -0.0198045056, -0.0397644602, -0.0000466959, -0.0311215427, -0.0189415161, -0.0170144271, 0.0163080003, 0.0030117333, -0.0157507546, -0.0081017362, 0.0054595037, 0.0142812906, -0.0095362822, 0.0015334856, -0.0013390898, 0.0324306153, 0.0050209295, -0.0085026100, 0.0022938924, -0.0364704169, -0.0155118722, 0.0104534347, 0.0349901356, -0.0169079546, 0.0351624526, 0.0110061858, -0.0305918157, -0.0000059359, -0.0494779460, -0.0100440513, -0.0317195803, -0.0077393460, -0.0207643770, -0.0095277745, -0.0151570095, 0.0046380307, -0.0001306461, -0.0013492227, -0.0377222523, -0.0240929238, 0.0274391416, -0.0005090217, -0.0000880350, 0.0158675779, -0.0000000050, -0.0018485956, 0.0019794777, -0.0106580127, -0.0013305218, 0.0071538338, 0.0225460231, -0.0384951010, 0.0033514379, -0.0122455368, 0.0357451923, 0.0121356891, 0.0186498258, 0.0057866611, 0.0392894484, -0.0117865428, -0.0276417527, 0.0134032136, 0.0569500513, -0.0173207652, 0.0216258690, -0.0018520820, 0.0000006012, -0.0288519152, -0.0301373899, 0.0326921605, -0.0085376538, 0.0007755990, -0.0173753016, 0.0142732318, 0.0115870051, -0.0186508093, 0.0269453861, -0.0015540173, 0.0040171603, 0.0251197461, -0.0069172629, 0.0093769366, 0.0113337245, 0.0188617371, -0.0116169844, -0.0290566571, -0.0150228608, -0.0525160432, 0.0311579779, -0.0047475956, -0.0110548846, -0.0001151396, -0.0056136465, 0.0074716443, -0.0462201200, 0.0465179309, 0.0007508995, -0.0043273764, -0.0298336800, -0.0381904021, -0.0001661651, -0.0404381976, 0.0255565345, 0.0311716385, 0.0416771211, 0.0076380852, -0.0058676512, 0.0127926422, -0.0000000127, -0.0143866492, -0.0105439490, 0.0089659914, -0.0006627631, 0.0094758887, 0.0125195552, 0.0050846268, -0.0319456905, -0.0408044532, 0.0235400423, 0.0110314004, -0.0261233859, 0.0019568743, 0.0144647900, -0.0080504017, -0.0115623269, 0.0179208256, 0.0167444795, -0.0192074757, 0.0102649555, -0.0027578578, -0.0000424880, -0.0022450541, -0.0566987470, -0.0318878293, -0.0282261688, -0.0029083237, 0.0032439784, 0.0245854463, 0.0175716188, -0.0123500228, -0.0384241901, 0.0001092048, -0.0091095166, 0.0500202551, -0.0387955010, 0.0085535655, 0.0145097170, 0.0105639100, 0.0447178893, -0.0247063804, 0.0297630224, -0.0079914071, -0.0161017198, -0.0173262171, 0.0179337226, 0.0001031195, -0.0024210960, 0.0208494477, -0.0131360628, 0.0067127310, 0.0083094351, 0.0269246195, -0.0365382209, -0.0397740938, 0.0000266221, -0.0483003445, 0.0566560514, 0.0265602693, -0.0040643811, 0.0178978518, -0.0009074367, 0.0019059671, 0.0000002252, 0.0044905911, 0.0274078269, 0.0175306853, 0.0011490812, 0.0006475127, -0.0335882194, -0.0146355322, -0.0059289108, -0.0028907596, -0.0339654423, -0.0213471968, -0.0048035868, -0.0311453026, -0.0356094353, -0.0191420708, 0.0050734580, -0.0008669735, 0.0158767514, 0.0147952447, -0.0388768725, -0.0264366008, -0.0001881461, -0.0323793367, 0.0337811820, 0.0074535669, 0.0067882999, -0.0029599429, 0.0256695896, -0.0042640762, -0.0158637781, -0.0250929929, 0.0370662995, -0.0040181703, 0.0132341301, 0.0241679810, 0.0427958667, -0.0366222523, 0.0215679128, -0.0225309208, -0.0252305381, 0.0123485466, 0.0021546641, 0.0174968671, -0.0021539663, 0.0198332909, -0.0254133306, -0.0002085568, -0.0420353040, -0.0236716028, -0.0126184355, 0.0518468507, 0.0061056279, -0.0194740556, 0.0101055214, 0.0208962299, 0.0001340399, -0.0020205386, -0.0309414752, -0.0145133268, 0.0191841293, 0.0034485783, -0.0016738110, 0.0410038382, 0.0000000344, -0.0193762407, 0.0031170289, 0.0034695896, -0.0030331472, -0.0072187181, 0.0273884404, 0.0074197128, -0.0275475271, -0.0372940004, 0.0102562625, 0.0048851734, -0.0080842096, 0.0049140695, 0.0135915251, -0.0094577624, -0.0295819920, -0.0051431991, 0.0471551158, 0.0034026655, 0.0348725021, -0.0147963651, 0.0000443768, 0.0143645043, 0.0025836136, 0.0126540214, 0.0054507009, -0.0051782206, -0.0207326654, -0.0135518238, 0.0288757812, 0.0093379542, -0.0294535290, -0.0013750439, -0.0146403499, -0.0533342473, -0.0396020748, 0.0044830232, -0.0099487649, 0.0523157902, 0.0249182023, -0.0114844348, 0.0517190360, -0.0027227898, -0.0169925801, -0.0320046954, 0.0027011633, 0.0014607239, -0.0418913253, -0.0166854057, 0.0359202847, 0.0497608371, -0.0239393171, 0.0269597787, -0.0059167673, -0.0307624713, -0.0001526853, -0.0301377736, 0.0139433183, -0.0033475747, 0.0019074462, 0.0461844243, -0.0003523396, 0.0392662287, -0.0000000410, -0.0112274997, 0.0011083682, 0.0182732940, -0.0001000233, 0.0073169535, -0.0128335962, 0.0059979721, -0.0499676466, -0.0052820239, -0.0504126847, -0.0020291824, -0.0148188360, 0.0001762493, -0.0269813221, -0.0519565828, -0.0104545038, -0.0086224740, -0.0449276827, 0.0188853703, -0.0255441777, -0.0458245240, -0.0001937730, -0.0400279686, -0.0051618740, -0.0283999350, -0.0050792424, -0.0016998783, 0.0140026603, 0.0047313944, 0.0236902852, 0.0098297009, -0.0129504716, -0.0089923367, -0.0226495899, 0.0148289502, 0.0233764164, -0.0104952399, 0.0169461444, 0.0172762796, 0.0184741337, 0.0204810258, 0.0396396741, 0.0082029318, -0.0088799642, 0.0253066346, -0.0098514967, -0.0000020476, -0.0334719904, -0.0156786256, 0.0069500245, 0.0010578550, 0.0015248948, 0.0354093313, -0.0154268797, -0.0125373378, -0.0000252256, 0.0020904595, -0.0098093636, -0.0258139111, -0.0147090973, -0.0187360831, 0.0014053991, 0.0351162739, -0.0000000848, 0.0024576692, 0.0112941731, 0.0400783680, 0.0000268135, 0.0023078164, 0.0064358870, -0.0037192192, -0.0315025263, -0.0089547718, -0.0000429636, 0.0205629356, -0.0109495707, -0.0037391130, 0.0093413172, 0.0092945881, 0.0159478821, -0.0082394499, 0.0205557682, 0.0076872031, 0.0469428785, -0.0223023295, 0.0000041751, 0.0150018558, -0.0087146517, -0.0137720359, -0.0046003358, 0.0003566845, 0.0033521717, -0.0041815988, 0.0431590863, -0.0068598120, -0.0026951274, -0.0008687798, -0.0184830334, 0.0005832380, 0.0331503451, -0.0151221994, 0.0026410355, 0.0254687592, -0.0155250449, -0.0078570507, 0.0043770815, -0.0039971853, 0.0324996524, -0.0336189494, -0.0077648563, 0.0000072784, -0.0601536520, -0.0075684721, 0.0000769007, -0.0335351229, 0.0312416982, -0.0046503358, -0.0224622302, -0.0483353622, -0.0005389033, -0.0470198765, 0.0278746206, 0.0214427039, 0.0057870308, 0.0109438980, 0.0020782861, -0.0475205183, -0.0000000164, 0.0042061233, 0.0109308604, -0.0104261991, -0.0103842281, -0.0215724763, -0.0091649154, -0.0377645679, -0.0014819051, 0.0170130394, 0.0118377348, 0.0070810975, -0.0018117091, -0.0042799981, 0.0388977118, -0.0138722276, 0.0273463428, 0.0137657151, 0.0065056402, -0.0216144789, -0.0269929972, 0.0180934016, -0.0001531584, -0.0107448855, -0.0463358164, 0.0061102668, 0.0121177556, 0.0087212613, -0.0084291436, 0.0193678513, -0.0189578272, -0.0187874008, 0.0305628460, -0.0002237811, 0.0151953185, 0.0393387675, 0.0201645102, 0.0112597849, 0.0128064603, 0.0250221938, 0.0014124702, -0.0141295632, -0.0341629535, -0.0179130509, -0.0492578559, 0.0089899870, 0.0047205230, 0.0000008053, 0.0049357852, -0.0266675875, -0.0004622315, -0.0142551586, 0.0027938196, 0.0147325480, -0.0291454885, 0.0187303014, 0.0000004949, 0.0280319490, -0.0100906640, -0.0158786867, -0.0309213530, -0.0045290887, 0.0062799673, 0.0182269681, -0.0000001927, 0.0145915570, 0.0314324275, 0.0428996384, 0.0006418414, 0.0018798084, -0.0211788490, 0.0280506145, -0.0056158113, -0.0094926963, -0.0289471969, -0.0040201009, -0.0072227996, -0.0118592689, -0.0261040889, 0.0201556236, -0.0049046222, -0.0052014850, -0.0161128361, 0.0049089463, 0.0118654352, -0.0454476960, 0.0000006549, 0.0555110537, 0.0063861986, 0.0031166926, 0.0025853850, 0.0017109631, 0.0083368877, 0.0006802165, 0.0170681812, 0.0035487069, 0.0280978438, 0.0002044811, 0.0450171679, -0.0309925694, 0.0296930540, 0.0005418896, -0.0164958350, -0.0227219649, -0.0137784565, -0.0314903595, 0.0087557388, 0.0320416167, -0.0062448187, 0.0167253874, -0.0295089688, 0.0000661813, 0.0054168277, -0.0123777241, 0.0252268314, 0.0006340923, 0.0112484060, -0.0006483030, 0.0340010598, 0.0055853552, -0.0002399800, 0.0092977630, -0.0210791752, 0.0281982906, -0.0059075337, -0.0199402459, -0.0049256468, -0.0134516787, -0.0000000714, -0.0195745286, -0.0122368457, 0.0197788421, -0.0034234461, -0.0010317652, -0.0105312234, 0.0093020974, -0.0197991841, -0.0025277776, -0.0116855633, -0.0155742140, -0.0159634948, 0.0054021110, 0.0059497375, 0.0001054441, -0.0208778083, 0.0266059320, -0.0032678377, -0.0256152134, -0.0032240103, 0.0026631232, 0.0000109904, -0.0022291497, -0.0076414654, 0.0069431555, 0.0183814615, -0.0064859176, -0.0100719566, -0.0005163068, 0.0122400345, -0.0004317528, -0.0322821736, -0.0001767640, -0.0153067410, 0.0063098292, 0.0002211060, 0.0215697680, 0.0135552911, 0.0248895641, 0.0209510475, -0.0209448673, 0.0028361571, 0.0114542888, -0.0163182821, -0.0216676239, 0.0043216823, -0.0000038918, -0.0053691962, -0.0065699243, 0.0014769495, -0.0044570980, -0.0030191687, -0.0182430558, 0.0012168552, -0.0083050290, 0.0000148878, -0.0260854065, 0.0077236635, -0.0079873195, 0.0388843939, 0.0021729062, -0.0021664689, 0.0340272374, -0.0000000341, 0.0045370660, 0.0012246675, -0.0244225208, 0.0000972619, 0.0007715456, 0.0132696275, -0.0152194910, -0.0178467147, -0.0156430472, 0.0298970845, 0.0270281285, -0.0046975180, -0.0303715691, 0.0276511889, -0.0242622513, 0.0639422238, -0.0100972066, -0.0040957425, 0.0232507251, -0.0043566846, 0.0234886203, 0.0000077939, 0.0377455689, 0.0365335234, -0.0017749434, -0.0518573932, 0.0003068659, -0.0221735295, -0.0008649221, 0.0118708657, 0.0093698278, 0.0116701853, -0.0032292972, 0.0091154873, -0.0042938367, -0.0337127000, 0.0148106720, 0.0241940673, -0.0092219813, 0.0140486471, 0.0045708213, -0.0150706694, -0.0453066938, 0.0150954761, -0.0258288570, -0.0020397063, -0.0000496800, -0.0343784951, 0.0120952139, -0.0018208317, 0.0254749190, 0.0176724512, -0.0055257380, 0.0390464067, -0.0361932926, -0.0000629599, -0.0523335822, -0.0003890188, 0.0296702068, 0.0453335121, 0.0090587670, -0.0007961333, -0.0166273788, 0.0000002654, -0.0140016181, -0.0088242199, 0.0364985131, 0.0007957308, 0.0090245111, 0.0304581951, -0.0340893306, 0.0009493366, -0.0129228225, 0.0040578288, -0.0234149285, -0.0369559005, 0.0189412944, 0.0257901456, -0.0155996168, -0.0406789258, -0.0121495724, -0.0103579974, -0.0170696843, 0.0087195514, -0.0098760976, -0.0001426738, -0.0131386211, -0.0164188482, -0.0376050696, 0.0089852149, 0.0036950216, 0.0019125380, 0.0029904891, 0.0330813080, -0.0211360212, -0.0004753284, 0.0007717077, -0.0010325788, 0.0172001179, 0.0356059894, -0.0230705515, -0.0066778087, 0.0431412607, -0.0011104157, 0.0028798492, -0.0033006743, -0.0095204283, 0.0118616894, 0.0041628815, 0.0033275231, -0.0003987013, -0.0095886094, 0.0027004790, -0.0807952657, 0.0053280094, 0.0214133468, 0.0015828076, -0.0414546430, -0.0193582978, -0.0009019977, -0.0000621804, -0.0122832442, 0.0583903752, 0.0051910286, 0.0154312961, -0.0029318205, 0.0195529461, -0.0000020486, -0.0151368091, 0.0261748042, 0.0329348892, -0.0000792507, -0.0237823073, 0.0170109477, 0.0288106594, -0.0225384012, -0.0494913906, 0.0195626840, 0.0110490164, -0.0382336788, -0.0201758277, 0.0053333179, -0.0126385977, -0.0123359561, 0.0258554369, 0.0161781013, -0.0181094185, -0.0044345520, 0.0305634867, 0.0000745606, 0.0479649343, -0.0240044631, -0.0237383302, -0.0024781898, -0.0050710258, -0.0099566309, -0.0019770954, 0.0185412429, 0.0170072783, -0.0592690520, 0.0018135151, -0.0071919244, -0.0334648415, -0.0515847430, -0.0000788192, 0.0208635945, 0.0398103893, 0.0385612696, -0.0777479857, 0.0521529391, 0.0244104899, 0.0577091090, 0.0038586259, -0.0370297693, -0.0000336016, -0.0836683735, -0.0067023495, 0.0066379271, -0.0265068449, 0.0360488258, -0.0157200899, -0.0230181552, 0.0052230721, -0.0001067467, -0.0081267217, -0.0301679578, -0.0220883396, 0.0280247927, 0.0220626984, 0.0038280785, 0.0129287541, 0.0000008250, 0.0117612807, 0.0165569838, 0.0538111217, 0.0025215184, 0.0166283417, -0.0460339449, -0.0130036538, 0.0305760801, -0.0068347803, -0.0232668929, 0.0052347351, 0.0031321349, 0.0237885676, -0.0404554904, -0.0202052165, -0.0494753011, 0.0201810859, 0.0350934975, -0.0179281458, 0.0108428830, -0.0629308969, 0.0000021799, -0.0388363935, 0.0016692346, 0.0294577889, -0.0057023834, 0.0051052980, -0.0102307238, -0.0003890096, 0.0080729211, -0.0119266789, 0.0237136018, 0.0010920563, -0.0002794918, 0.0483355001, 0.0683049858, -0.0371963568, -0.0440995991, 0.0493330620, 0.0001021468, -0.0051222066, 0.0115839075, -0.0186959859, 0.0233547855, -0.0187538248, -0.0094394041, -0.0005653533, -0.0197928101, 0.0038136728, 0.0207634605, 0.0378816016, -0.0047124475, -0.0005880530, 0.0003330600, 0.0123547269, -0.0002530490, -0.0636124164, -0.0187204760, 0.0472071916, 0.0592676662, -0.0005039432, -0.0004563856, 0.0070839236, 0.0000000006, -0.0237889085, 0.0216878410, 0.0108004669, 0.0000254270, 0.0139817344, -0.0070719775, -0.0073512588, -0.0229729004, -0.0126599343, -0.0211009979, -0.0032210227, -0.0318208747, 0.0213992260, 0.0013253700, -0.0789304450, -0.0495397709, -0.0432317965, -0.0022790912, -0.0083558932, 0.0152746253, 0.0021488823, 0.0000052231, -0.0070270551, -0.0659388378, -0.0355739221, -0.0071032150, 0.0028975909, 0.0161295850, 0.0196482055, -0.0007932416, -0.0292058066, 0.0271445233, -0.0012326908, 0.0203804709, 0.0206440669, -0.0044058422, 0.0214182101, -0.0223471820, 0.0182241295, 0.0183587447, -0.0110788178, 0.0177084059, 0.0021452976, -0.0247556195, 0.0399287678, -0.0139994305, 0.0000541582, 0.0180619024, -0.0049347747, 0.0752115324, -0.0226246323, -0.0129896179, -0.0120022753, -0.0150323519, 0.0208059847, -0.0002406905, 0.0387780592, -0.0256988611, -0.0424075276, -0.0194374621, -0.0543786883, -0.0103805065, 0.0147743952, 0.0000005408, -0.0109356306, -0.0659327284, -0.0747004673, -0.0042043203, -0.0081589390, -0.0195966065, 0.0403455608, 0.0220295265, 0.0368169844, -0.0168184098, -0.0146342125, 0.0155285979, 0.0242654458, -0.0091387518, 0.0288654733, 0.0386083722, 0.0218277629, -0.0607081726, 0.0027300678, 0.0321194194, -0.0114643052, 0.0000158475, -0.0108171357, 0.0073069753, -0.0098478319, 0.0048443759, -0.0092904493, -0.0023810342, -0.0067483457, -0.0190029517, 0.0134402858, -0.0279398467, -0.0099658594, -0.0241249315, 0.0314965732, 0.0142795835, 0.0182646345, -0.0071368930, -0.0408290066, -0.0120053161, 0.0411213078, -0.0286475252, 0.0306171067, -0.0055228909, 0.0200260002, -0.0144318780, -0.0002095505, -0.0202244017, 0.0031609193, -0.0273201130, 0.0118545769, -0.0052516786, -0.0139864674, 0.0009710278, -0.0204080436, -0.0001513258, -0.0094432682, -0.0393319950, 0.0121111330, 0.0365953185, -0.0001406650, -0.0044440301, 0.0333191715, 0.0000000256, -0.0087373247, -0.0224314611, -0.0395198390, -0.0025892784, 0.0145218978, 0.0161963478, -0.0036002563, -0.0144676417, -0.0339631326, 0.0464569815, -0.0075525725, 0.0004292118, -0.0076084640, 0.0607594140, 0.0128081879, -0.0136781773, 0.0132049788, 0.0336512029, -0.0014626489, 0.0039334260, -0.0040472792, 0.0001077336, 0.0299085528, -0.0245594922, -0.0170220397, -0.0163544826, 0.0002631066, -0.0241068602, 0.0113012046, 0.0127785383, -0.0078018741, -0.0163794663, -0.0042697038, 0.0335899256, -0.0199279860, -0.0365472883, 0.0230254550, 0.0174857695, 0.0014532056, 0.0757202879, -0.0214327425, 0.0287103076, -0.0576683767, -0.0243537463, -0.0206643101, -0.0201501139, -0.0000851112, -0.0438386202, 0.0216723438, 0.0370268263, 0.0263949987, 0.0014381548, -0.0287704803, -0.0323929116, -0.0273315609, -0.0000352064, -0.0268509202, -0.0334617905, -0.0111462083, 0.0410204269, -0.0117359255, -0.0062349248, 0.0293682050, 0.0000000000, 0.0036364240, -0.0029612875, -0.0351459309, -0.0001987078, -0.0247271415, -0.0053149695, -0.0019584631, 0.0136613818, -0.0241548326, 0.0470563062, 0.0464671254, -0.0051505077, -0.0549907163, -0.0098766219, -0.0217983462, 0.0145724136, -0.0334765501, -0.0028824962, 0.0060051046, 0.0410468541, -0.0402912609, 0.0000046483, 0.0462185964, 0.0408927575, 0.0246366952, -0.0574855730, 0.0000484980, -0.0145317791, -0.0079656243, 0.0366456397, 0.0087285442, 0.0209585819, -0.0079349279, -0.0065999413, -0.0059682177, -0.0267456416, -0.0186798889, 0.0032922137, 0.0329726115, -0.0186187029, 0.0332383625, -0.0079548480, -0.0382690690, 0.0008696229, -0.0010582785, -0.0368843973, 0.0000007246, -0.0144737680, -0.0049959444, -0.0474929623, 0.0025222858, 0.0094780037, -0.0003393411, -0.0063554700, -0.0405284651, 0.0000135406, -0.0093261451, 0.0070012133, 0.0004688188, 0.0147248479, -0.0170071404, 0.0067205820, 0.0081436066, 0.0000000199, 0.0143731823, -0.0052063614, -0.0246479902, 0.0009101242, 0.0150768543, 0.0121602081, 0.0021064286, 0.0111301215, -0.0022417952, 0.0343636870, -0.0019265579, -0.0069724158, -0.0122257741, 0.0063053505, -0.0064935912, -0.0085473210, -0.0129518006, 0.0373698398, -0.0178122949, 0.0378121771, 0.0210583191, 0.0000012837, 0.0036687865, -0.0285224393, 0.0064862957, -0.0113044297, 0.0056959009, -0.0044675516, 0.0032582455, 0.0199032612, -0.0104765762, 0.0009018379, -0.0002068995, -0.0068072993, 0.0204211082, 0.0224380381, 0.0058042272, -0.0186255984, 0.0119209634, 0.0068219709, -0.0190820247, 0.0000731528, -0.0269741025, -0.0149334474, 0.0158575438, -0.0024447208, -0.0000852686, -0.0057698502, -0.0390069000, -0.0214520991, 0.0125283021, -0.0134506524, 0.0279135760, 0.0061797900, 0.0235400368, -0.0003060939, 0.0488759726, -0.0184172131, -0.0187288094, -0.0056951116, 0.0259762723, -0.0066521587, 0.0180896968, 0.0000000416, -0.0011032235, 0.0131314956, -0.0190082360, -0.0068131089, -0.0021089294, 0.0038317787, 0.0543630607, -0.0133874454, -0.0353795253, -0.0178404097, 0.0070421328, 0.0072637433, -0.0092955334, -0.0251856335, -0.0175665505, -0.0358073972, 0.0101186140, 0.0359552838, 0.0115600526, -0.0401347093, -0.0067757433, -0.0000127677, 0.0181371123, 0.0006597362, -0.0076177060, -0.0011546890, -0.0016591536, -0.0135386009, -0.0051318989, -0.0231619067, 0.0083324239, -0.0114667052, -0.0023961058, -0.0004177544, -0.0001159903, -0.0307661127, 0.0043505328, -0.0344429985, -0.0073845438, 0.0034600205, -0.0161007307, 0.0097242035, 0.0382737778, -0.0462368764, -0.0463177450, -0.0092715658, 0.0000014738, 0.0218985751, 0.0762001649, -0.0172072928, 0.0184101295, 0.0305815227, -0.0061334604, 0.0333132744, -0.0640274063, 0.0000099774, -0.0154859684, 0.0117629869, 0.0721235126, -0.0154761840, -0.0104027586, -0.0053211004, -0.0547031537, 0.0000000602, 0.0112311030, 0.0141543066, -0.0443174802, 0.0015267985, -0.0203783009, 0.0236708410, -0.0164193530, -0.0227926057, 0.0037076126, 0.0512899272, 0.0043476676, -0.0461730175, -0.0284697767, 0.0092847571, -0.0000002777, 0.0287098773, 0.0052872943, 0.0384901725, -0.0120784119, 0.0201472603, 0.0247781016, -0.0000014380, 0.0335011035, -0.0141258975, 0.0292435084, -0.0074330387, 0.0043135057, 0.0020115941, -0.0007230627, 0.0107820565, -0.0321850963, 0.0168904234, 0.0021847936, -0.0305793528, 0.0035743404, -0.0327628404, 0.0190448500, 0.0118508013, -0.0014323185, 0.0080376444, -0.0446611717, -0.0134620201, -0.0002807455, 0.0330835655, -0.0191475749, -0.0412786864, -0.0001173331, 0.0064453282, -0.0257735234, -0.0530607589, 0.0108976215, -0.0112864319, -0.0176136885, -0.0039660884, -0.0112524237, -0.0001147844, -0.0352413878, 0.0039043182, -0.0108286953, 0.0483754948, -0.0035500589, 0.0099867480, -0.0021744687, -0.0000000312, -0.0041116616, 0.0126839736, -0.0228657518, 0.0000979145, 0.0070238532, 0.0149720190, -0.0363673568, 0.0219210740, -0.0200673975, 0.0104185455, 0.0089795170, 0.0145396190, -0.0015509496, -0.0137689998, -0.0043794671, -0.0502377637, -0.0460368246, 0.0272627771, -0.0153823020, -0.0004604237, 0.0382598490, -0.0001301415, -0.0086955689, -0.0397705436, -0.0120700039, -0.0231404509, -0.0000995362, 0.0189953111, 0.0170583446, 0.0207397994, -0.0011679865, 0.0464551263, -0.0031513649, 0.0182685405, 0.0299642459, -0.0253419112, 0.0334881656, 0.0111218868, -0.0622649193, -0.0184995402, -0.0090094618, -0.0209347662, -0.0070305802, 0.0206367392, -0.0003741402, 0.0097114854, -0.0000004240, 0.0158590525, 0.0137763014, 0.0265435651, 0.0041604354, 0.0074088625, -0.0075565991, -0.0127918608, -0.0104142372, -0.0000132729, -0.0152695347, -0.0267762151, -0.0100794891, -0.0258915666, -0.0012525541, -0.0011129868, -0.0153656350, -0.0000000425, 0.0000037969, 0.0060217925, -0.0000042115, 0.0061575100, -0.0141651575, 0.0063623358, 0.0135116158, -0.0044030491, 0.0111934524, -0.0246184655, 0.0021161456, 0.0069560590, 0.0170767754, 0.0144633874, 0.0059410017, 0.0065547419, 0.0363740586, -0.0461521558, -0.0210009217, -0.0117711499, -0.0104646916, -0.0000106971, -0.0063386280, -0.0074088355, -0.0448872820, -0.0128011424, -0.0009489374, -0.0037405286, 0.0036410526, 0.0145931188, 0.0094604921, -0.0071356869, -0.0000976083, -0.0144282756, 0.0512329713, 0.0049180086, 0.0063618692, 0.0025601662, -0.0188685879, -0.0166797750, -0.0050738249, 0.0061820121, 0.0238351002, -0.0383619778, 0.0489078499, 0.0124872848, 0.0004055185, 0.0084138364, -0.0035149057, 0.0089672245, -0.0414438806, -0.0079290383, 0.0103310542, -0.0152892740, 0.0631675422, 0.0001280997, 0.0503182299, -0.0091168284, -0.0417151041, -0.0373892784, -0.0392273106, -0.0089214714, 0.0376055539, 0.0000000841, 0.0015011107, 0.0251367819, -0.0021090251, -0.0164821949, 0.0040252674, -0.0126243830, 0.0092604468, 0.0098164398, 0.0047124447, -0.0360622369, -0.0306158103, -0.0053702234, 0.0061909747, -0.0263533872, 0.0362489447, 0.0025349765, 0.0443777740, 0.0138890054, 0.0224936269, -0.0143193332, -0.0179762058, 0.0003736715, 0.0029215361, -0.0088049937, 0.0004157563, 0.0569504946, -0.0069878981, -0.0061531905, -0.0339251943, -0.0288186744, 0.0178513210, 0.0039943005, -0.0016716021, 0.0295813084, -0.0092925560, 0.0422006883, -0.0171127170, -0.0035044102, -0.0405479409, 0.0078554293, 0.0099483961, -0.0059131854, 0.0493831299, -0.0022516304, 0.0156226195, 0.0085136592, 0.0001051349, 0.0084950505, -0.0280641597, 0.0166469384, 0.0064881225, -0.0235454645, 0.0114497282, 0.0144992610, 0.0079396991, -0.0002466587, 0.0210988969, 0.0037726513, -0.0299210306, -0.0357311182, 0.0182156265, 0.0036082079, 0.0141860088, -0.0000002011, -0.0015059401, 0.0182682890, 0.0009479125, -0.0050833873, -0.0237034317, 0.0209448189, -0.0015087614, 0.0188216884, -0.0213396419, -0.0015251394, -0.0110731851, -0.0079683922, -0.0269107334, -0.0216610618, 0.0246767811, 0.0082959421, -0.0332310610, -0.0294828154, 0.0022003583, 0.0029824935, -0.0269142482, 0.0000111444, 0.0115605434, 0.0020769117, -0.0084570115, 0.0198142324, 0.0041069402, 0.0179441031, 0.0043667979, 0.0027836582, -0.0100749778, 0.0249010399, -0.0057778554, -0.0178662464, 0.0411606245, 0.0230501480, -0.0133587811, -0.0095340684, -0.0073932149, -0.0573627204, -0.0393594727, -0.0107798809, -0.0150994742, -0.0143370274, 0.0172534045, 0.0395676903, -0.0000044483, -0.0104105510, -0.0278608222, 0.0092680762, -0.0186624117, 0.0025428964, 0.0028237351, -0.0362035148, 0.0119547816, -0.0019492540, 0.0169779267, 0.0155963395, -0.0292252712, -0.0003294080, 0.0012324228, -0.0076035829, 0.0070705302, -0.0000001342, -0.0118936235, 0.0094607538, 0.0025783128, -0.0025355942, -0.0218357407, -0.0185641963, 0.0157871954, 0.0050859172, 0.0194470808, -0.0311453249, 0.0010858397, 0.0202637985, 0.0123361601, -0.0195530504, 0.0487386733, -0.0022326638, -0.0206539128, -0.0731769949, 0.0189173706, -0.0147784185, -0.0084246434, -0.0000381938, -0.0084246462, 0.0541645288, -0.0255316328, 0.0005865307, -0.0136035187, 0.0193187837, 0.0117673967, -0.0087247482, -0.0023093917, 0.0089143533, -0.0051916009, 0.0035767660, -0.0081337476, -0.0041331449, -0.0144201247, 0.0130156213, -0.0165536422, 0.0150221642, 0.0202517267, -0.0018129211, 0.0132963043, 0.0148331570, -0.0156992581, -0.0310318545, 0.0001198893, 0.0442339107, -0.0024487176, 0.0214283839, 0.0220140927, -0.0162523482, -0.0060470845, 0.0448073111, 0.0093924794, -0.0015975189, -0.0109666530, -0.0240015946, 0.0353353359, -0.0136788208, -0.0125840697, 0.0107892808, 0.0041955216, -0.0000087262, -0.0028461937, -0.0050637517, -0.0084323529, 0.0000681596, 0.0155052356, -0.0069164555, -0.0146616241, 0.0050480808, -0.0112545853, 0.0268771779, 0.0024037370, 0.0001577703, 0.0224021431, 0.0045820358, -0.0193290710, 0.0362237096, -0.0149238687, -0.0305267423, -0.0125702797, -0.0248092394, 0.0127088455, -0.0001338776, 0.0104076928, -0.0357058980, 0.0182982124, -0.0064616627, -0.0041265613, 0.0051972531, 0.0069604432, -0.0114660617, 0.0079601565, 0.0011469829, 0.0035464286, -0.0003102554, 0.0274660271, -0.0332353711, 0.0446529724, -0.0066571864, -0.0334749520, -0.0014118076, -0.0294950064, -0.0183415022, 0.0046715750, 0.0039518378, 0.0058634230, -0.0068810470, -0.0000779139, -0.0147151034, -0.0348740481, -0.0150896907, -0.0013894102, -0.0258315336, 0.0046036434, 0.0074753230, 0.0040323711, 0.0001221353, 0.0165112708, -0.0251755118, -0.0387834311, -0.0081440862, 0.0031531102, -0.0004579325, 0.0083151134, -0.0000000077, -0.0133035257, 0.0077757854, -0.0327386856, -0.0007021601, 0.0161613524, 0.0427658930, 0.0039947839, 0.0140073774, -0.0448509417, 0.0372943655, -0.0020280576, 0.0138949202, -0.0144338384, 0.0139016304, 0.0259394199, -0.0290068109, -0.0297814310, 0.0392089598, 0.0077177142, 0.0107857985, 0.0113906562, 0.0000236789, -0.0045905933, 0.0092819780, 0.0172936693, -0.0003086288, 0.0077543696, 0.0146903051, -0.0024280376, 0.0213941690, 0.0013564894, 0.0263462365, -0.0050663808, -0.0109786950, -0.0012721564, -0.0145251509, 0.0049021938, 0.0121398438, 0.0189929344, -0.0155055551, -0.0207102410, 0.0044507789, -0.0240932144, -0.0052571399, -0.0218956284, -0.0032263699, 0.0001208967, -0.0038409550, 0.0039753686, 0.0096070189, 0.0407844335, -0.0122146895, 0.0045914012, 0.0162428711, -0.0183996446, -0.0005115752, -0.0254186280, 0.0202373676, -0.0025629909, -0.0006038088, 0.0075488430, -0.0042793136, -0.0340407938, -0.0000008271, -0.0168723539, 0.0106862895, -0.0181160662, -0.0001737207, -0.0141418036, 0.0213537943, 0.0300769880, -0.0309811924, -0.0301611256, -0.0157647151, -0.0006502594, 0.0203782693, -0.0214502271, -0.0279490165, 0.0272828694, 0.0015504013, -0.0266056005, 0.0043235510, -0.0138609139, -0.0427420773, 0.0148397190, -0.0000409799, -0.0040523191, -0.0225331057, -0.0136698969, -0.0338005386, -0.0094110174, 0.0277047977, 0.0069996095, 0.0295264814, 0.0125023974, 0.0198402666, -0.0136098061, 0.0091601806, 0.0446347371, -0.0094514126, 0.0365071334, -0.0007270118, -0.0248656888, -0.0043908772, -0.0169924535, 0.0010346879, 0.0157274604, -0.0221226271, -0.0365614146, 0.0254036430, -0.0000556053, -0.0718652979, -0.0535045862, -0.0651726127, -0.0304430500, 0.0164006446, -0.0209795982, -0.0239490774, -0.0153120141, -0.0003385382, 0.0046553430, 0.0303186830, 0.0063869613, 0.0572051518, 0.0167026948, -0.0053033209, -0.0028090444, -0.0000000641, -0.0085117612, 0.0033657099, 0.0207371339, -0.0164294392, -0.0371494703, 0.0057194512, -0.0249842219, -0.0094177723, 0.0225451197, 0.0338806324, 0.0290161874, -0.0129572321, -0.0071061878, -0.0168774873, 0.0104392767, 0.0169166774, -0.0174699798, -0.0026352142, 0.0238283090, 0.0104347253, -0.0038985033, 0.0000119410, 0.0044860588, 0.0369199589, 0.0319722220, -0.0163921583, 0.0024060602, -0.0138332117, -0.0041541564, 0.0304243509, -0.0148077086, 0.0422476567, -0.0031710358, 0.0048998599, -0.0252146032, -0.0040833559, -0.0384327397, 0.0073969201, 0.0411928147, 0.0223611426, -0.0196289867, -0.0250979196, -0.0124025987, 0.0029712296, -0.0326437987, -0.0111442292, 0.0000000671, 0.0057857903, 0.0344336554, 0.0202182941, -0.0077319969, 0.0012544517, -0.0046458552, -0.0055699041, -0.0121728806, 0.0000054506, -0.0221798792, 0.0202417858, 0.0164252352, -0.0484445468, -0.0335792452, 0.0054271687, -0.0388065353, 0.0000002605, 0.0090380302, -0.0096625527, -0.0256223753, 0.0035581063, 0.0040006861, -0.0078989379, -0.0071811858, 0.0132195754, 0.0086753946, -0.0274080578, -0.0090227360, -0.0106604593, 0.0050093345, -0.0107256388, -0.0001595475, -0.0252863094, 0.0494044758, -0.0243895035, -0.0154223870, 0.0060799662, -0.0084524453, -0.0000000286, -0.0035165802, -0.0207766667, 0.0091477120, 0.0011163682, 0.0008508433, 0.0064250366, -0.0052003264, -0.0291754175, -0.0125935497, 0.0092884386, 0.0008758380, 0.0122849960, 0.0458542556, 0.0359146371, -0.0097518861, -0.0233808849, -0.0167253315, -0.0073238197, -0.0035663776, 0.0066129495, 0.0236380324, 0.0254025944, 0.0028617699, 0.0099746576, 0.0000004369, -0.0257216003, -0.0144404573, 0.0051994054, -0.0033075411, -0.0017538047, -0.0020670488, -0.0341790020, -0.0217136107, -0.0000766573, -0.0149620455, 0.0106156562, 0.0075273421, 0.0112965489, 0.0133026522, -0.0024989848, -0.0043976363, -0.0000000018, 0.0060333926, -0.0093744276, -0.0146977985, -0.0009417454, -0.0107595166, 0.0209284984, -0.0197173320, -0.0107446443, 0.0233072508, 0.0273734927, 0.0051319981, -0.0020274946, 0.0081714997, 0.0156311113, -0.0259325001, -0.0142598338, 0.0075500188, -0.0291976165, -0.0081424993, 0.0079644294, -0.0021134932, -0.0000025810, -0.0193985105, -0.0211244617, 0.0059959763, -0.0180969555, 0.0090633640, -0.0088486820, 0.0088796364, -0.0016090419, 0.0010907870, 0.0106260087, 0.0000381375, 0.0154184205, 0.0071219164, 0.0077793123, -0.0125271492, -0.0020722980, -0.0009887159, 0.0108931148, 0.0047800010, -0.0071633100, -0.0546578839, -0.0051799356, -0.0067845252, -0.0150574893, -0.0000128051, 0.0390558168, 0.0347590744, 0.0167600438, 0.0121142901, -0.0006618172, -0.0007762790, 0.0380939841, -0.0023038322, 0.0000799203, 0.0231280588, 0.0267186631, 0.0460960753, -0.0171330068, -0.0143122207, -0.0071037398, -0.0144306077, 0.0000029547, 0.0205237679, -0.0246823151, -0.0196739025, -0.0050955280, 0.0184356514, 0.0264089946, -0.0181817841, 0.0070909713, -0.0164649934, 0.0206943098, -0.0173626728, -0.0131425401, 0.0016228016, 0.0049009286, 0.0213152710, -0.0207767691, 0.0377259813, 0.0334344618, 0.0101422733, 0.0043479325, 0.0336191319, 0.0000295607, 0.0160784479, -0.0390334465, 0.0600358807, 0.0171316098, 0.0027159236, -0.0044669788, -0.0009058077, -0.0118787326, -0.0023948767, 0.0164310727, 0.0002912618, -0.0099736536, 0.0059407507, -0.0292265881, 0.0199839361, -0.0139541877, -0.0077581061, -0.0065027173, -0.0056443480, -0.0266238376, 0.0178450141, 0.0263243262, 0.0314596556, 0.0097386232, 0.0000061901, -0.0657175481, -0.0559100993, -0.0183902364, -0.0207500383, 0.0005298683, -0.0000403801, -0.0674556345, -0.0046118773, -0.0000485673, 0.0138352141, 0.0114216888, -0.0355013162, 0.0433940180, 0.0364259072, -0.0115216561, 0.0557440519, -0.0000004334, -0.0014965906, -0.0048483778, 0.0121756811, -0.0038674367, -0.0199727695, -0.0088261142, -0.0166061688, -0.0046847127, 0.0375989154, 0.0249230377, 0.0219544750, 0.0105696116, 0.0061035706, 0.0246394388, -0.0124350432, 0.0042266580, 0.0149261188, -0.0534295365, 0.0085188188, -0.0171954185, -0.0306970086, -0.0000033623, -0.0042457790, 0.0162984114, -0.0090661040, -0.0204675049, 0.0075033894, -0.0175474267, 0.0111339064, -0.0056251576, 0.0102427658, 0.0203713309, -0.0024602937, -0.0108816093, -0.0095566902, -0.0042848801, -0.0196870677, 0.0072907023, 0.0264125094, 0.0389429778, 0.0272744652, -0.0150326956, -0.0461012125, 0.0004055121, 0.0073573370, -0.0049255835, -0.0000413865, -0.0196244735, -0.0160708409, -0.0611475855, 0.0271948203, -0.0030532491, -0.0229133554, -0.0364158228, 0.0033424117, -0.0009217669, -0.0068865884, 0.0418654196, 0.0431382358, 0.0215557218, 0.0064505069, 0.0003032310, 0.0166008044, -0.0000054987, -0.0183031019, 0.0253330395, -0.0418123789, -0.0021267748, -0.0058741192, -0.0047794841, -0.0237305034, 0.0091259675, 0.0310106408, 0.0091685979, -0.0143815577, 0.0052380408, 0.0131205246, -0.0064011789, 0.0109283132, -0.0160830487, -0.0295339301, 0.0213414505, -0.0018253619, 0.0066982834, 0.0053723599, 0.0000055002, -0.0053575360, -0.0153551903, 0.0147512043, 0.0314248689, -0.0027946774, -0.0178707000, -0.0033147996, 0.0073679183, -0.0087012984, 0.0466954708, -0.0138103021, 0.0370140895, -0.0142362947, 0.0195313171, -0.0151614966, -0.0232348889, 0.0122379046, 0.0001496804, -0.0121887438, 0.0072901961, -0.0078879185, -0.0050398097, -0.0457163602, -0.0025152718, 0.0000591842, -0.0552759543, -0.0285881404, 0.0037650287, 0.0013932158, 0.0213353410, 0.0155575024, 0.0232444443, -0.0098478701, -0.0000035790, -0.0416759215, 0.0110652801, -0.0292912647, 0.0186612699, 0.0123602170, 0.0085868165, -0.0124534993, -0.0000002791, -0.0032868329, 0.0403524563, 0.0722500831, 0.0008225449, 0.0153571665, -0.0113210166, -0.0293738171, 0.0025913415, -0.0079064434, -0.0457281098, 0.0047705583, -0.0304221530, 0.0115177454, -0.0364294723, -0.0228663813, -0.0459555276, -0.0225329697, -0.0115341302, 0.0084824776, -0.0364420936, -0.0446351916, -0.0003194778, -0.0161296837, -0.0100368522, -0.0514463820, -0.0108667444, 0.0020258026, 0.0080356970, 0.0015766111, -0.0123314848, -0.0061835228, 0.0401608609, 0.0091696661, 0.0253165346, 0.0548697039, 0.0662963837, 0.0036831503, -0.0247440636, 0.0027538189, -0.0148705989, -0.0400575250, 0.0124693625, 0.0285005607, 0.0245048255, 0.0487880222, -0.0272088256, -0.0002704051, -0.0140729221, -0.0367944427, -0.0343047120, -0.0198494736, -0.0208412409, -0.0113912020, -0.0221244209, 0.0087856846, -0.0000155742, 0.0344814621, 0.0167920645, 0.0039923461, 0.0178669188, 0.0049749087, -0.0118082492, 0.0343474820, -0.0000000224, -0.0026896049, -0.0209612753, -0.0170314331, -0.0140992524, -0.0145392278, 0.0085718017, -0.0109808324, 0.0221398175, 0.0021732782, 0.0551052801, -0.0264702234, 0.0096276309, 0.0057696016, -0.0096782707, 0.0208326634, -0.0268178508, 0.0027554310, 0.0287004821, 0.0128756082, 0.0233859662, 0.0220291000, 0.0000313264, 0.0010514398, -0.0081460550, 0.0433036089, 0.0219779853, 0.0026012512, 0.0061981473, 0.0051057488, 0.0076243458, 0.0047806315, 0.0297506209, -0.0031222303, 0.0051927338, -0.0241435207, -0.0061045117, -0.0172791928, 0.0019302442, 0.0037056704, 0.0122299409, 0.0185896102, -0.0124430377, -0.0362856984, 0.0050031235, -0.0137415538, 0.0091295866, -0.0001543632, -0.0021347892, -0.0350325480, 0.0375786833, 0.0406429172, -0.0085976347, 0.0085752849, -0.0064072562, -0.0008897317, 0.0002644158, -0.0104871513, 0.0260672811, -0.0344844945, 0.0057920371, 0.0226394944, 0.0109875500, -0.0186124723, -0.0000026367, -0.0061411601, 0.0151614519, -0.0018645135, 0.0001067001, 0.0210886728, 0.0099157160, 0.0408500805, 0.0341250487, -0.0340311825, -0.0146044111, 0.0009723475, 0.0226299185, 0.0062923823, -0.0146972453, -0.0019519175, -0.0276705436, -0.0252489615, -0.0232263673, -0.0187273696, -0.0413709395, 0.0139041012, -0.0004712822, -0.0092148911, 0.0038716462, -0.0533429421, -0.0098862117, 0.0017182285, 0.0135367196, -0.0053530633, 0.0146117974, 0.0122721773, 0.0078708269, 0.0026683346, 0.0132337790, 0.0148562798, 0.0061723813, -0.0157821123, -0.0026076285, -0.0180655811, -0.0054255989, -0.0245732386, 0.0097598927, 0.0042756931, 0.0349073373, 0.0005968961, -0.0098889899, -0.0000066897, -0.0217747837, -0.0352867581, -0.0048234062, -0.0193980969, 0.0043051806, -0.0243928637, -0.0265632737, -0.0101426523, 0.0013551839, 0.0111325085, 0.0187003277, -0.0072032325, 0.0129567636, 0.0191768184, -0.0023067857, 0.0062233922, -0.0000000000, -0.0018110411, -0.0065602143, 0.0161561407, -0.0003808561, -0.0038168887, 0.0120668011, 0.0123641621, -0.0001096082, -0.0030380150, -0.0132611524, 0.0171007328, -0.0202712156, 0.0177031867, 0.0005554538, -0.0097870287, -0.0098160906, 0.0052787559, 0.0057612094, -0.0043679099, 0.0122336419, -0.0075737713, -0.0000033361, -0.0166884847, 0.0067390585, -0.0098635741, -0.0017350407, 0.0032610472, -0.0060741589, 0.0010391313, 0.0251936745, 0.0116279870, -0.0354794972, -0.0005965118, -0.0260772873, -0.0192346312, 0.0180577636, -0.0275607221, -0.0034256019, 0.0483950377, 0.0160467327, 0.0123712355, -0.0053427550, -0.0160308816, 0.0193610173, -0.0149405906, -0.0181862246, -0.0000589243, -0.0547963083, 0.0150261642, 0.0138578666, -0.0265467782, 0.0130441589, -0.0104621695, 0.0033824721, -0.0299985874, 0.0010338963, -0.0031345626, -0.0104100239, -0.0076116552, -0.0174190272, -0.0113325696, -0.0057686181, -0.0365410633, 0.0000001083, 0.0022649425, 0.0018238113, 0.0187449995, 0.0024354139, -0.0151455961, -0.0158003271, -0.0277983155, -0.0540611185, 0.0431869812, 0.0016317465, 0.0030554398, -0.0292296782, 0.0014987860, -0.0293124858, 0.0251876060, -0.0136771733, 0.0245659184, -0.0367682613, -0.0328328758, 0.0223647039, -0.0094284434, -0.0000531639, -0.0207040608, -0.0340964273, 0.0190344304, -0.0198487006, 0.0027131028, 0.0105149848, 0.0307932254, -0.0025912898, 0.0009025186, 0.0155948689, -0.0042617391, -0.0237784404, 0.0194768365, 0.0523791574, -0.0264560767, -0.0044100960, 0.0547332913, 0.0093760174, -0.0027260478, -0.0132754724, -0.0505553409, 0.0141345514, -0.0204154514, 0.0337516703, 0.0000018061, 0.0112791564, 0.0717708915, 0.0016600641, 0.0089419568, 0.0177524611, -0.0211644396, -0.0027268645, -0.0310758520, 0.0000049872, -0.0479524545, 0.0338088050, 0.0066143158, -0.0558803566, -0.0417663194, -0.0041452139, -0.0377071314, 0.0000000219, 0.0084063606, -0.0137315048, 0.0405419767, 0.0037351684, -0.0203210358, 0.0196789838, -0.0097417161, -0.0334849134, -0.0127620585, -0.0169795249, -0.0178152509, -0.0286783967, 0.0055934191, 0.0237723552, 0.0316809379, 0.0194857307, 0.0044759987, 0.0069592460, -0.0151137449, 0.0467276908, 0.0100904331, -0.0000021253, 0.0131664006, -0.0024414584, -0.0240614135, 0.0121076442, 0.0027119047, -0.0130189294, -0.0062886956, 0.0356961936, 0.0025238481, -0.0245554373, 0.0011529879, -0.0228781775, 0.0533429980, 0.0316647403, 0.0016856591, 0.0062622125, -0.0012315140, -0.0159616843, -0.0104873059, 0.0148277143, 0.0059423079, 0.0038023833, -0.0265100840, -0.0010476350, 0.0003931358, -0.0158426780, 0.0370414332, -0.0142223146, -0.0101450989, -0.0060342788, -0.0001973006, 0.0216501299, 0.0047040964, 0.0006043503, 0.0066247671, -0.0007809853, -0.0050025503, -0.0317664929, 0.0056741266, -0.0120847831, -0.0278066695, -0.0000006706, 0.0052915360, -0.0042762500, -0.0304699894, -0.0024510729, -0.0007203210, 0.0126452921, 0.0060186335, -0.0082630003, -0.0224018786, -0.0055219075, 0.0046361461, 0.0290703010, -0.0183351543, -0.0040576821, 0.0197297707, 0.0046598976, 0.0146738049, 0.0418351367, 0.0009485134, -0.0470021889, 0.0300071836, 0.0000979480, -0.0277259666, -0.0071043861, 0.0223009195, -0.0178894773, -0.0006632226, 0.0206562690, -0.0059734345, -0.0029933953, -0.0121543203, 0.0258706529, -0.0016091845, 0.0148729617, 0.0404729284, 0.0215987172, 0.0231441297, 0.0185940005, 0.0008347079, -0.0219302289, -0.0158226378, -0.0201824214, -0.0006692129, -0.0179434102, -0.0060683950, 0.0350268371, -0.0000122765, -0.0664390251, -0.0133434832, 0.0191831551, -0.0242998339, -0.0060165408, 0.0052359500, -0.0358593836, 0.0068928408, -0.0000741705, 0.0076323776, -0.0114313122, -0.0387498140, 0.0003601765, -0.0019157691, -0.0028984533, 0.0264717434, 0.0000000030, 0.0017566617, -0.0162283015, 0.0139674349, -0.0063451095, -0.0092915306, -0.0082481774, -0.0395261943, 0.0149474433, 0.0105263423, 0.0291121993, 0.0069633438, -0.0105728023, -0.0012655980, -0.0003362967, 0.0020743967, 0.0344830975, 0.0255922303, -0.0246880688, 0.0184649825, 0.0058268225, -0.0469489135, 0.0000018867, 0.0129654882, 0.0501385592, 0.0465132147, 0.0093885986, -0.0018396449, -0.0121739041, -0.0093260510, 0.0122946557, 0.0081817461, 0.0266611744, -0.0014233958, -0.0095866090, -0.0192854051, 0.0430589654, -0.0524302460, 0.0011740018, 0.0335928500, 0.0109965168, 0.0422701128, -0.0046095159, -0.0358521603, 0.0028363233, -0.0238083992, -0.0123175234, -0.0003041392, 0.0111072743, 0.0031584585, 0.0368146040, 0.0267715212, -0.0153321465, 0.0128699420, 0.0024316034, 0.0323591828, -0.0003210653, -0.0271859970, 0.0022209389, 0.0686528385, 0.0119479708, -0.0026794479, -0.0072551994, 0.0024957012, -0.0000002699, 0.0022084634, -0.0052219504, 0.0307643097, -0.0046697468, -0.0044162241, -0.0095134648, -0.0166229010, -0.0455031544, 0.0123239579, -0.0029335872, 0.0098329997, -0.0143107967, -0.0026360061, -0.0106592309, -0.0308128875, -0.0416187979, 0.0016040355, -0.0276730768, -0.0140184630, -0.0259781331, -0.0252234507, -0.0000535855, -0.0129575236, -0.0542272702, 0.0116967876, 0.0019863672, -0.0051990938, -0.0111307129, 0.0077271084, -0.0352679715, 0.0318254530, -0.0145365484, -0.0050623822, 0.0089683561, 0.0184714813, -0.0151343634, 0.0329526477, -0.0025542991, -0.0261263847, 0.0343755148, 0.0457466543, 0.0032408112, 0.0043092594, 0.0038704167, 0.0249646995, 0.0278857201, 0.0001877707, -0.0243727453, -0.0756448880, -0.0293901954, 0.0002939140, -0.0183353536, 0.0053967903, -0.0167374332, 0.0242402758, 0.0019618028, 0.0262983833, 0.0456306115, -0.0144246519, -0.0077377381, 0.0075058495, -0.0148819396, 0.0380457379, -0.0000000266, -0.0062851752, 0.0074320887, 0.0303873625, -0.0221849717, 0.0125486059, 0.0078292638, -0.0262140445, -0.0007082978, -0.0266189966, 0.0064520165, -0.0056756558, -0.0058880546, -0.0022365607, 0.0000795835, 0.0471837707, 0.0139322542, -0.0241722371, 0.0424347185, 0.0321486369, 0.0153702376, -0.0080923112, 0.0000843367, 0.0216301065, -0.0136105390, 0.0136772497, -0.0047167460, 0.0127123687, -0.0144727863, -0.0228873845, 0.0026457780, 0.0149336718, 0.0217106920, -0.0138051044, 0.0138944490, -0.0080514736, 0.0294832923, -0.0247400422, 0.0081738019, 0.0024365829, 0.0084727257, 0.0016398866, -0.0193150584, -0.0320584141, 0.0166742466, 0.0042419499, 0.0286812354, 0.0004308744, -0.0008602441, -0.0417590402, 0.0209555253, -0.0124242380, 0.0355703868, -0.0106117986, -0.0521425605, 0.0283500180, -0.0015506035, -0.0049223658, -0.0113561656, -0.0081355302, 0.0358076543, 0.0091514215, -0.0041815434, -0.0008272046, -0.0000005518, -0.0103516504, 0.0197880436, 0.0512588657, 0.0006473809, -0.0182185043, -0.0440357327, 0.0402262025, -0.0116414484, 0.0414967947, -0.0609345958, 0.0210527796, -0.0104011456, 0.0140973972, -0.0347040147, -0.0182558242, -0.0880766809, 0.0363527983, -0.0753261894, -0.0095584262, -0.0254170876, -0.0324082226, -0.0000110371, -0.0080842637, -0.0118185859, -0.0589006543, -0.0413136110, -0.0058951969, -0.0237117708, -0.0011366492, -0.0180852227, -0.0008330621, -0.0063979840, -0.0074320952, 0.0149105201, 0.0806642324, 0.0452419855, -0.0067493953, -0.0247605164, -0.0102992002, 0.0195272956, -0.0204483997, 0.0033282717, 0.0376388654, 0.0586523563, 0.0276468359, 0.0036957171, -0.0001403842, 0.0204163659, -0.0289211906, -0.0292507205, 0.0324360542, 0.0132513056, -0.0355095342, -0.0209245756, 0.0271443091, -0.0011467485, -0.0286784619, -0.0082927756, 0.0191652197, 0.0372056141, 0.0225597974, 0.0051270495, 0.0049379319, 0.0000000542, -0.0120491534, 0.0077496716, 0.0034279388, -0.0014904682, 0.0045683654, 0.0226769466, -0.0362130366, 0.0140578160, 0.0019334923, 0.0434050821, -0.0111419950, 0.0174926035, 0.0163597725, -0.0067911176, -0.0205912776, -0.0608534813, -0.0155863361, -0.0386831909, -0.0140675399, -0.0147682158, 0.0131350588, -0.0001038766, -0.0036414752, -0.0444647744, -0.0369440056, -0.0160858482, 0.0083209127, -0.0143225873, 0.0082442537, -0.0167827960, 0.0156938210, -0.0109306034, -0.0081653111, 0.0197817665, 0.0191306248, -0.0366061851, 0.0178704355, 0.0032644267, -0.0048626154, 0.0340322107, -0.0036287741, -0.0016642377, -0.0874884427, -0.0769519880, -0.0183670726, -0.0377548411, -0.0000565910, 0.0414259434, 0.0400648825, 0.0313059650, 0.0096744662, -0.0117933750, 0.0143687669, 0.0446697772, -0.0530028306, -0.0001967436, -0.0052730874, 0.0028116002, -0.0268182475, -0.0081245983, -0.0651688352, 0.0010911488, 0.0232147072, 0.0000035334, -0.0103019215, -0.0269075576, -0.1008897424, 0.0042189662, 0.0133394282, -0.0223353840, 0.0299956258, -0.0153970579, -0.0103937937, 0.0313303135, 0.0306595415, 0.0394855328, -0.0059900493, 0.0422716662, 0.0001483332, 0.0830034539, -0.0171554387, 0.0411316156, -0.0075871795, 0.0391940661, 0.0452060588, 0.0000022670, 0.0356741101, 0.0729172751, 0.0330821201, -0.0112786749, -0.0387617089, 0.0175207909, -0.0053304615, 0.0404616520, -0.0069040293, -0.0122588808, -0.0007555371, -0.0414995439, -0.0159404930, -0.0380603038, 0.0338951536, 0.0243059564, -0.0197770111, -0.0547948554, 0.0329056121, -0.0053587612, 0.0261861272, 0.0180276223, -0.0129315350, 0.0294275992, -0.0000942952, -0.0750738829, -0.0248521399, 0.0053982134, -0.0132197514, 0.0066032303, -0.0184974261, -0.0531822592, 0.0076248129, -0.0009275138, -0.0029683192, 0.0132921254, -0.0041102236, 0.0198148694, 0.0074567655, -0.0079380553, 0.0008619067, 0.0000000601, -0.0197525956, 0.0134992367, 0.0165250581, -0.0178129300, -0.0067881225, 0.0023514151, -0.0107319299, 0.0135606164, -0.0087678283, 0.0178861171, 0.0067843078, -0.0164977461, 0.0139547940, -0.0091959033, 0.0176063050, -0.0316877253, 0.0101969820, -0.0293689314, 0.0096637346, -0.0200340338, 0.0095136389, -0.0000427911, -0.0009981908, 0.0044705546, -0.0113957953, 0.0125397900, 0.0065840404, -0.0150972046, 0.0053828713, -0.0094941333, 0.0072842184, -0.0117558315, -0.0081440080, -0.0131501229, 0.0177219417, -0.0012292777, -0.0243063420, 0.0086025326, 0.0856928602, 0.0229636803, 0.0092451358, -0.0118082883, -0.0334455222, -0.0045721265, 0.0241343528, 0.0050397734, -0.0000231959, 0.0003857157, 0.0045758374, -0.0093450658, 0.0056238044, -0.0016050922, -0.0020930972, -0.0112624373, -0.0044513722, -0.0000931979, -0.0046862173, 0.0096443100, 0.0259261411, 0.0216544233, 0.0147867417, -0.0030100755, 0.0261564925, -0.0000001729, 0.0033977947, -0.0266479235, -0.0302721746, -0.0040425388, 0.0028854748, 0.0131584490, -0.0081175687, 0.0153385811, 0.0061894800, 0.0178435836, -0.0259187333, -0.0222415049, 0.0057841847, 0.0097378967, -0.0026934992, -0.0149133904, 0.0023975857, -0.0300848745, 0.0170549676, -0.0139210997, -0.0159698129, 0.0000032083, -0.0040608887, -0.0458167568, -0.0229148418, 0.0037734134, 0.0170660987, 0.0063780081, -0.0102889575, -0.0112427939, -0.0020373957, 0.0007237260, -0.0066520395, 0.0376738161, -0.0169730708, 0.0323262475, -0.0137752937, -0.0009424535, -0.0085626980, 0.0413510315, 0.0094920080, -0.0054510930, -0.0263956357, 0.0279073697, 0.0128981061, -0.0365248881, 0.0000104497, -0.0022329204, -0.0123488912, -0.0267464146, -0.0392662510, 0.0034838011, 0.0141397538, -0.0358693376, -0.0250362027, 0.0000114913, 0.0298606716, 0.0748458132, 0.0280589573, 0.0042297882, -0.0220080614, -0.0023188603, -0.0165941268, 0.0000002010, 0.0181685742, -0.0226531792, 0.0208648480, -0.0142397415, 0.0236782730, -0.0124856541, 0.0105237365, 0.0082199872, 0.0081155803, 0.0139463348, -0.0109051717, -0.0456576161, 0.0234721787, -0.0272198282, 0.0229679514, -0.0290971939, 0.0541372411, 0.0194951966, -0.0238487944, -0.0067885905, 0.0152661577, 0.0000083356, -0.0260519125, -0.0423800573, -0.0022065614, 0.0329722762, 0.0109203150, 0.0143303312, -0.0009033941, -0.0071341097, 0.0139913755, -0.0170558766, 0.0021076843, -0.0309537854, 0.0125763929, 0.0451269448, -0.0345553122, -0.0166373476, 0.0342456549, 0.0310148112, 0.0340556204, -0.0231439266, -0.0161862019, -0.0088521410, 0.0311126746, 0.0043238476, 0.0000131119, 0.0222483687, -0.0176663883, 0.0092882328, -0.0334891714, -0.0087214289, 0.0149336103, -0.0049357652, 0.0279936064, -0.0002007624, 0.0337576717, -0.0233797785, -0.0282093305, -0.0452495553, -0.0322764367, -0.0029369555, 0.0217240769, -0.0000006648, -0.0009338699, -0.0081707379, -0.0249601938, -0.0040308121, -0.0025264684, -0.0205089599, -0.0014689579, 0.0008086553, -0.0055047716, -0.0225722622, -0.0053797197, 0.0170745403, 0.0010709118, 0.0104327388, 0.0085591786, -0.0015854860, 0.0155606512, -0.0030581031, -0.0026427400, 0.0332477801, 0.0292436816, 0.0000250068, 0.0047276854, 0.0089808889, 0.0283413474, 0.0290116481, -0.0123468684, 0.0002058110, 0.0002465713, -0.0249204710, -0.0041495063, -0.0039945683, -0.0064092902, 0.0077444301, -0.0034561083, 0.0320238546, 0.0156117436, -0.0011929689, 0.0041192216, -0.0100164507, 0.0060000676, -0.0192669127, 0.0319604278, -0.0086823516, -0.0482893400, 0.0080180587, -0.0000010625, -0.0523544252, 0.0354308672, -0.0669446141, 0.0003870641, -0.0243071858, 0.0349829271, 0.0752123892, -0.0393554792, 0.0002720983, -0.0572384112, 0.0405655727, 0.0300204121, 0.0152231706, 0.0178495124, -0.0088547990, -0.0030866158, 0.0000000720, 0.0243592318, -0.0028701099, -0.0204385445, 0.0012770653, -0.0022771491, -0.0054467027, -0.0781833157, -0.0265512094, -0.0237102620, 0.0327598639, 0.0053927144, 0.0324922763, -0.0135497525, 0.0602082163, -0.0094771385, 0.0072008613, -0.0284002945, 0.0514672510, 0.0117789535, -0.0084597329, -0.0299596451, -0.0000019570, 0.0119841145, 0.0245574061, 0.0579051226, 0.0098015182, 0.0027088090, -0.0102477800, -0.0100323809, 0.0066303909, 0.0059546260, 0.0547124334, 0.0009651906, 0.0070119253, -0.0036241710, -0.0075157182, 0.0065800939, 0.0283674039, 0.0174647924, -0.0121017369, -0.0484481826, -0.0179402363, -0.0006017913, 0.0170653928, 0.0156590119, 0.0111083109, -0.0000637949, -0.0014750051, 0.0032033639, -0.0314960517, -0.0114927758, -0.0112785492, -0.0075054201, -0.0020981643, 0.0133229597, -0.0003358974, -0.0091168843, -0.0002415016, -0.0214765985, 0.0409710072, 0.0085076764, -0.0006079529, -0.0033420909, -0.0000007146, 0.0033586863, -0.0007935944, -0.0155103635, -0.0005756615, -0.0162862651, 0.0182737764, -0.0248699337, 0.0201980099, 0.0164360665, 0.0224685688, 0.0151343197, 0.0231534988, 0.0136810848, -0.0028532518, 0.0176415127, -0.0355326608, -0.0328593068, -0.0433291867, 0.0032455968, 0.0026316752, 0.0094191637, -0.0000060440, -0.0139142750, 0.0027485404, -0.0229466837, 0.0121920761, 0.0039667068, 0.0179785453, 0.0094442153, 0.0213488024, -0.0008689424, 0.0472357832, 0.0010917954, 0.0413405858, -0.0308846794, 0.0243348069, -0.0239330772, 0.0218264870, -0.0552391261, -0.0062040668, 0.0124545982, -0.0202027168, -0.0175122619, -0.0324766561, -0.0056339847, 0.0197908245, 0.0000001852, 0.0400000885, 0.0129867550, 0.0930045024, 0.0117546208, 0.0036459093, 0.0088124638, 0.0382140502, 0.0276139136, -0.0001297974, -0.0098582255, -0.0429854207, -0.0224461760, -0.0222561061, -0.0290572681, 0.0014589954, -0.0005697914, 0.0000000071, -0.0081279576, -0.0141215520, 0.0017392177, 0.0023831790, -0.0200215559, -0.0131946718, 0.0193145070, -0.0170755684, -0.0027405079, -0.0205962732, -0.0086052343, 0.0033653942, 0.0010102835, 0.0013163222, 0.0006063526, 0.0000065506, -0.0386025123, -0.0334197767, 0.0055672373, -0.0080979988, -0.0092259413, -0.0000085401, -0.0106219510, 0.0061598471, -0.0159613788, -0.0092592062, -0.0248475969, -0.0209289547, 0.0014135455, -0.0126683591, 0.0044111907, -0.0430698916, -0.0003341920, -0.0018713149, 0.0620278157, 0.0114074731, 0.0068021361, -0.0092294412, -0.0642913133, -0.0238063615, 0.0264616981, 0.0070401151, 0.0169468001, -0.0037956850, 0.0218483340, -0.0231603179, -0.0001241751, 0.0089691626, -0.0381232947, -0.0388699174, -0.0080928039, -0.0152546596, -0.0213276241, -0.0044963923, 0.0048142360, -0.0003472219, 0.0419860221, -0.0012353680, -0.0295799151, -0.0343459398, -0.0106413579, -0.0011073139, 0.0179487411, -0.0000035015, 0.0201310068, 0.0055240151, 0.0084938100, -0.0032083774, 0.0141010154, 0.0200404990, 0.0450134128, 0.0258947778, 0.0117190331, -0.0033439645, -0.0138023896, 0.0259439796, 0.0048934026, -0.0469310693, 0.0324747302, -0.0248131678, -0.0026332110, 0.0119698197, -0.0021797859, 0.0190980770, 0.0170001183, 0.0000364688, 0.0054509421, 0.0096460693, 0.0018621262, 0.0079635065, 0.0066242926, 0.0253637712, 0.0186530631, -0.0047161635, 0.0003882871, 0.0221868511, -0.0058881389, 0.0266094245, -0.0150432792, 0.0364452749, -0.0164749511, -0.0066698887, 0.0044657346, -0.0019306956, -0.0192447379, 0.0139536653, -0.0105799492, 0.0141989542, 0.0245872736, -0.0136270709, -0.0000228796, 0.0056929383, 0.0060364497, 0.0021214404, -0.0057130908, -0.0035071741, -0.0159688294, 0.0263219178, 0.0114855981, -0.0001958145, 0.0191202834, -0.0257825498, -0.0037621551, -0.0395948961, -0.0050968546, -0.0078140693, 0.0142232114, -0.0000000390, 0.0205049831, -0.0098502524, -0.0195225440, -0.0000700451, 0.0075370502, 0.0265008919, -0.0046923254, 0.0104668476, 0.0441704355, 0.0114041455, 0.0037384462, -0.0141307898, 0.0163583439, 0.0205050129, 0.0176755860, -0.0177158248, 0.0254090596, 0.0059603793, -0.0188361034, 0.0190693773, -0.0029897876, 0.0000010799, -0.0046346285, -0.0185007621, -0.0042736898, 0.0235277060, -0.0100599909, 0.0009302865, 0.0008663603, -0.0184198376, -0.0077095972, -0.0152097028, -0.0004703008, -0.0221090298, -0.0111909900, 0.0150726726, 0.0142148249, -0.0022218050, -0.0063144499, -0.0436132886, -0.0055267997, -0.0086496510, -0.0063375486, -0.0116854571, -0.0042429361, -0.0035839318, -0.0000287666, 0.0365681499, 0.0017023472, 0.0068028565, -0.0112523772, -0.0290737040, -0.0054874681, -0.0053659203, -0.0084840544, -0.0000658678, 0.0073143630, 0.0090763606, -0.0598777756, 0.0030592401, 0.0071784370, 0.0038228086, -0.0024097208, -0.0000006874, -0.0222665817, 0.0047047795, -0.0458290838, -0.0004581999, 0.0103772050, 0.0002677802, 0.0305633303, 0.0204242337, -0.0023106879, -0.0125359166, 0.0039572427, 0.0189050641, -0.0182310864, -0.0182271805, 0.0048478697, 0.0048860135, -0.0246548839, -0.0101715755, 0.0121102436, -0.0118549876, 0.0088462885, -0.0000011703, 0.0339143723, 0.0196779072, 0.0097585041, 0.0006509337, -0.0014737147, 0.0296580754, -0.0002356058, -0.0038134966, 0.0046720793, -0.0135631962, -0.0036036796, 0.0142168822, -0.0199683644, -0.0061990740, 0.0094285710, 0.0079149902, -0.0321097933, -0.0227694083, 0.0083999652, 0.0034657095, 0.0237669554, -0.0138752358, 0.0195643120, -0.0034772928, -0.0000323345, 0.0167995300, -0.0093682176, 0.0073361243, -0.0148161864, 0.0174109787, -0.0048669437, 0.0355552584, 0.0137882950, -0.0000782521, -0.0108895581, -0.0234484430, 0.0183588061, 0.0436534472, -0.0049559753, -0.0145845171, 0.0025821216, 0.0000000165, 0.0106833251, -0.0134628601, -0.0145202633, -0.0000895410, 0.0099854497, 0.0118392333, -0.0201767087, -0.0020919857, 0.0093049649, 0.0130378818, -0.0017175805, 0.0111954603, 0.0167149361, 0.0167769920, -0.0143599017, 0.0036003271, 0.0310843401, -0.0312370304, -0.0042957505, -0.0178640001, 0.0012899399, -0.0000103561, 0.0297950804, -0.0111040501, -0.0064392970, -0.0068887738, -0.0171788950, -0.0024216704, -0.0187422018, -0.0015611486, -0.0027065803, 0.0199833754, 0.0000627163, 0.0262693577, -0.0302801393, -0.0235438291, 0.0342100821, 0.0075925887, -0.0169128962, 0.0391140543, 0.0299803056, -0.0286146943, -0.0072272969, 0.0153514929, 0.0361511968, 0.0355775766, 0.0000793422, -0.0100382753, -0.0171255767, -0.0340333804, -0.0250902120, -0.0160402302, -0.0018959637, -0.0030737086, 0.0308832992, -0.0014439240, 0.0252119098, -0.0101604667, -0.0007229834, 0.0072155176, 0.0288366470, -0.0051862551, 0.0360727236, -0.0000001999, -0.0044562411, 0.0065664593, 0.0101841614, -0.0119877029, -0.0188830625, 0.0239563324, -0.0419449620, 0.0203065909, 0.0034619740, 0.0520244725, 0.0138792647, 0.0137840901, 0.0006290841, 0.0057075229, 0.0023836552, 0.0035630965, -0.0179842282, -0.0228571407, 0.0175182912, -0.0099392086, -0.0026761699, -0.0000073637, 0.0083714090, 0.0151091032, -0.0099299457, 0.0248981658, 0.0017013154, 0.0058856155, -0.0008606899, -0.0095225330, 0.0214049537, 0.0163480751, 0.0004029338, 0.0203140713, -0.0459255651, -0.0326106101, 0.0042223418, 0.0419479012, -0.0077467579, 0.0152826421, 0.0039658123, -0.0195067823, -0.0290271919, 0.0210936479, 0.0159028135, -0.0210281406, -0.0000576258, 0.0524574034, -0.0378562659, 0.0429113731, -0.0043438529, -0.0238610338, -0.0117211603, 0.0324109234, 0.0096392864, 0.0001426567, -0.0171398912, -0.0440531746, -0.0413956158, -0.0182208698, -0.0006750395, -0.0005375796, 0.0018533063, -0.0000025137, -0.0189091787, -0.0051720841, -0.0393818170, -0.0000159155, -0.0016227266, 0.0575775020, 0.0065250699, 0.0157928951, -0.0422282964, 0.0272018723, -0.0083633438, 0.0050779316, -0.0273243859, -0.0100350715, 0.0540967695, -0.0188048333, -0.0443122759, 0.0173977874, -0.0076864217, 0.0165033583, 0.0289091561, -0.0004802792, -0.0003386590, -0.0322289057, -0.0132251224, -0.0131685827, -0.0027640597, 0.0289098751, 0.0147450548, 0.0246618334, -0.0157535058, 0.0127628436, 0.0004676049, -0.0324515440, 0.0517683774, -0.0052109170, 0.0138262948, -0.0024479772, -0.0584243983, -0.0422429703, -0.0071000988, -0.0092006139, -0.0637414083, 0.0195582230, -0.0101593612, 0.0291973017, -0.0001093486, -0.0379038565, 0.0081744306, -0.0491658188, 0.0027287868, -0.0170695782, -0.0031138116, -0.0482684188, -0.0056540873, -0.0001242935, -0.0163750611, 0.0369141810, -0.0145285595, 0.0236196648, 0.0398130752, -0.0051573082, 0.0014599406, 0.0000000049, 0.0103227384, 0.0035857500, -0.0286185872, -0.0001843543, -0.0004409314, -0.0139848394, -0.0375951715, 0.0078252107, 0.0189761687, -0.0191155151, -0.0130438851, 0.0322006866, 0.0111215264, -0.0084004765, -0.0265552234, 0.0042807404, 0.0078382706, -0.0579752959, -0.0000650712, -0.0278900489, -0.0044760741, 0.0000021034, 0.0157597456, 0.0573745444, -0.0128242699, 0.0199475326, 0.0082928743, 0.0070138648, 0.0138735976, -0.0367311314, 0.0052561802, 0.0235619079, -0.0078472495, 0.0492998622, -0.0426501557, -0.0035139937, -0.0179844685, 0.0048172586, 0.0272355173, 0.0259351768, 0.0055754189, 0.0009000404, 0.0179200824, -0.0166830607, -0.0320636220, -0.0086761219, 0.0000003402, 0.0053243698, 0.0474289991, 0.0542697757, -0.0272877775, 0.0192178711, 0.0091043804, -0.0122659281, -0.0236299597, 0.0000049542, -0.0071276850, -0.0135585004, -0.0018083105, -0.0810649171, -0.0907977298, 0.0048994105, -0.0564318635, 0.0000000003, 0.0021205223, -0.0174689963, -0.0092221582, 0.0000590239, -0.0044400473, -0.0371840931, 0.0131779956, -0.0335075408, -0.0015366067, -0.0289919097, -0.0035500752, -0.0043375562, 0.0103272013, -0.0049371207, 0.0443626083, 0.0280588437, 0.0468980335, 0.0185928158, -0.0353923142, 0.0187071171, 0.0187145323, -0.0000010892, -0.0153983822, -0.0233552828, 0.0214171261, 0.0122512747, -0.0003154410, -0.0211211629, -0.0055151344, 0.0149193099, 0.0010498479, -0.0036691544, 0.0004865102, -0.0560174137, 0.0991114154, 0.0340641551, -0.0227780323, -0.0043454426, -0.0243135616, -0.0482750349, 0.0339885764, -0.0205071140, 0.0548216291, 0.0241970178, 0.0044012065, -0.0013238459, 0.0000016085, 0.0168050863, 0.0275875628, 0.0286058672, -0.0166030880, 0.0027255297, 0.0131998612, -0.0325959437, -0.0163744260, 0.0000376664, -0.0073751560, 0.0203685760, 0.0120507721, -0.0189847406, -0.0388459153, 0.0058544069, -0.0154930884, 0.0000002871, 0.0013918759, -0.0048829932, -0.0293165669, 0.0008207993, -0.0022376024, -0.0431133956, -0.0065923552, -0.0232335348, 0.0166152660, -0.0153313950, 0.0041367491, -0.0046476349, 0.0059660706, 0.0053138533, 0.0033741505, 0.0178074725, 0.0262588318, -0.0292210095, -0.0168561488, 0.0008506525, 0.0278369933, -0.0000016373, 0.0063201268, -0.0077981236, 0.0409017280, 0.0399757326, -0.0004889035, -0.0041335006, -0.0093977107, -0.0172779895, -0.0074647525, -0.0085221604, 0.0008893512, 0.0042397878, 0.0603452101, 0.0281073749, -0.0148228714, -0.0061311824, -0.0354023986, -0.0095583685, 0.0481575727, -0.0031476873, 0.0415787436, -0.0251003038, -0.0100333979, -0.0176007710, 0.0000128244, 0.0143563226, -0.0302274134, 0.0035796426, -0.0249672681, 0.0205798186, 0.0286633130, 0.0025429856, -0.0371355973, 0.0000709868, -0.0231593288, 0.0174233988, 0.0529561155, -0.0016895679, -0.0465646461, -0.0051105702, -0.0104288496, 0.0000003762, -0.0130132167, -0.0229197834, -0.0020071021, 0.0008395439, -0.0006589250, -0.0165975783, 0.0040809549, -0.0221063662, -0.0351630226, -0.0042750337, -0.0159370843, -0.0447487533, -0.0140667642, -0.0045079254, 0.0101042874, 0.0098298043, -0.0005341407, -0.0060942536, -0.0178497843, 0.0323489942, -0.0028390121, 0.0000059888, 0.0160285197, -0.0051455875, 0.0397611447, 0.0396973267, -0.0030482286, -0.0023441617, -0.0034673009, 0.0243032090, -0.0078341877, -0.0176578965, -0.0002961668, 0.0038115557, 0.0201281346, 0.0363321342, 0.0217764769, -0.0040686443, 0.0170057137, -0.0098472843, 0.0201165769, -0.0292435996, 0.0545102619, 0.0200606268, 0.0299984440, 0.0241776239, -0.0000011460, 0.0057225893, 0.0207820684, 0.0121603468, -0.0083324788, -0.0144332871, 0.0038406907, -0.0551548451, -0.0071954723, 0.0002702578, -0.0075804372, 0.0133861639, -0.0258606132, 0.0116647054, -0.0029612014, 0.0025572211, 0.0287596174, -0.0000016122, 0.0010842577, -0.0002086518, -0.0229353849, 0.0030280959, 0.0064650914, -0.0225591511, 0.0015238936, 0.0043608248, 0.0300073996, -0.0285702832, 0.0083473334, -0.0027454910, 0.0153615093, -0.0185758881, -0.0136883501, 0.0194650702, 0.0121555962, -0.0432294160, 0.0073711528, -0.0156171257, -0.0019664033, -0.0000022710, 0.0156475641, 0.0219230764, 0.0127750449, 0.0159920715, -0.0057892026, 0.0069503384, 0.0151005462, -0.0337897316, -0.0137545913, -0.0130811315, -0.0002488454, 0.0203230008, -0.0015572296, 0.0286900252, -0.0165994558, -0.0079754591, -0.0203835182, 0.0404984616, 0.0289222430, 0.0001228560, 0.0135842590, 0.0078454986, 0.0350276791, 0.0085897893, 0.0000200597, 0.0229733922, 0.0058026691, 0.0216547772, -0.0113529172, -0.0254726484, 0.0170482919, 0.0189502724, 0.0158616435, -0.0001484928, 0.0180417243, -0.0082973149, -0.0068193963, 0.0120369764, 0.0079978388, -0.0045892932, 0.0297950953, 0.0000000266, 0.0168885011, -0.0022373842, -0.0477082953, -0.0023711827, 0.0057852375, 0.0127129573, 0.0054804939, 0.0340827964, -0.0034095361, 0.0238263998, -0.0086654779, 0.0187770911, 0.0058445544, -0.0121125709, 0.0055604260, 0.0115522873, 0.0084035816, -0.0046171551, 0.0013182360, 0.0079990523, 0.0202663653, 0.0000005379, 0.0078892307, 0.0154934507, 0.0117738200, 0.0162005667, 0.0012428400, 0.0178682134, -0.0044489913, -0.0189044122, 0.0187379438, -0.0049252161, -0.0085764322, 0.0287149046, -0.0205451716, -0.0105758831, -0.0035972060, 0.0042492915, 0.0055335993, 0.0019812800, 0.0351921394, -0.0096116057, -0.0037012997, -0.0068192016, -0.0031747280, -0.0392652676, 0.0000127088, -0.0105181132, -0.0166129712, 0.0120523777, -0.0028139637, 0.0174331330, -0.0213081408, 0.0398899950, 0.0187850296, -0.0000057077, -0.0018019322, -0.0358331501, -0.0094312718, -0.0186697338, -0.0338786654, -0.0060272706, -0.0209991690, -0.0000000762, 0.0215356238, 0.0100601884, -0.0007346966, 0.0000400428, -0.0100566000, 0.0024145662, 0.0051227841, 0.0070520286, 0.0177463368, -0.0089161135, 0.0174517445, 0.0014897399, 0.0187803414, -0.0226483233, 0.0060085114, -0.0245074537, 0.0238134433, 0.0109303463, -0.0347718894, 0.0044125160, 0.0172315128, -0.0000256974, 0.0059690233, 0.0026370813, -0.0162905790, -0.0018568663, -0.0043547493, -0.0053175483, 0.0187729597, 0.0230761636, -0.0012959007, 0.0369967818, -0.0026094685, 0.0101696765, 0.0143312933, 0.0503559113, -0.0055990815, -0.0085407179, -0.0330639109, -0.0411769450, -0.0184273049, -0.0021918067, 0.0362964272, 0.0344513729, 0.0180992242, -0.0256779622, 0.0000061232, -0.0026158316, -0.0165341310, -0.0727098435, -0.0216198992, -0.0135318600, 0.0038367733, -0.0271189362, -0.0153223658, -0.0010665358, 0.0308933612, 0.0299356189, -0.0248103142, -0.0186046902, 0.0107102133, 0.0024675382, -0.0029310170, -0.0000001213, 0.0102449935, 0.0192211308, -0.0568808392, -0.0022617739, -0.0010168424, -0.0044850162, 0.0179659203, 0.0565929823, 0.0111872051, -0.0110601550, -0.0104771415, 0.0377829596, 0.0068652309, -0.0175379533, -0.0090844315, -0.0272225160, -0.0145643568, -0.0317014195, -0.0094755655, 0.0043889256, 0.0020985205, -0.0000361979, -0.0200742483, 0.0334145576, -0.0111697884, 0.0389851369, 0.0012535595, 0.0116022797, 0.0113366758, -0.0139339007, -0.0135129644, 0.0452824049, -0.0098661566, 0.0263826139, -0.0155357299, 0.0251554046, -0.0021420214, -0.0282207243, 0.0033418979, -0.0310030933, -0.0248457026, 0.0119261816, 0.0515718535, -0.0241017602, -0.0261656176, -0.0120367538, -0.0000013781, -0.0086081997, 0.0058426079, 0.0415946431, -0.0099691981, 0.0002418209, -0.0030132274, 0.0796360746, 0.0106105804, -0.0000033143, -0.0042888066, -0.0403991044, -0.0050151865, -0.0250802636, -0.0070829936, -0.0012558199, -0.0111527927, 0.0000000212, 0.0311033092, -0.0162272882, -0.0032435544, 0.0000378998, 0.0079398500, 0.0167590231, -0.0162292738, 0.0006212745, 0.0016359542, -0.0082273632, -0.0060466486, 0.0124410223, 0.0019790248, 0.0078504961, -0.0035806505, 0.0054476452, -0.0173993502, -0.0112766856, 0.0036706906, -0.0280157756, 0.0109703727, 0.0000024792, -0.0061230077, 0.0204601530, -0.0142190065, -0.0066624796, -0.0077752364, -0.0061019231, 0.0034341896, 0.0104350271, -0.0085733440, 0.0056614759, -0.0004208172, -0.0143944994, -0.0067761354, 0.0138465101, 0.0124719348, 0.0105636874, -0.0003229871, -0.0417898707, -0.0213571545, -0.0196197107, 0.0027558417, -0.0180797186, 0.0234828051, -0.0050262134, 0.0000018308, -0.0039815502, 0.0014936449, 0.0265525877, 0.0307496600, 0.0112140896, 0.0007283100, -0.0203710552, 0.0133505221, -0.0004446273, 0.0155292442, -0.0113654193, -0.0258407742, -0.0139867645, -0.0245417915, -0.0046987603, 0.0060163834, 0.0000000039, -0.0054125651, -0.0047118058, 0.0151507407, -0.0002917169, -0.0106437346, -0.0080807060, 0.0321405008, -0.0002349734, 0.0014604050, -0.0261228047, -0.0129666077, 0.0016939655, 0.0135458382, 0.0041147829, -0.0164397787, -0.0142445136, 0.0103616416, -0.0322047770, -0.0115777375, 0.0083738640, -0.0270664208, -0.0000178413, -0.0173066668, -0.0213625468, -0.0122298105, 0.0004145165, -0.0093786335, -0.0176716186, 0.0135356728, 0.0016306259, 0.0180250406, -0.0166802444, -0.0008149642, -0.0145671135, 0.0292363856, 0.0099192802, 0.0050005177, -0.0179478303, -0.0177756418, -0.0031075405, 0.0100532053, 0.0025034649, 0.0248862654, 0.0433487482, -0.0007113360, -0.0073472145, -0.0000065619, 0.0486719199, -0.0250065196, -0.0245134477, 0.0118488483, 0.0072029950, 0.0108408993, -0.0112918345, 0.0036295950, 0.0001512082, -0.0343397558, 0.0001438074, 0.0474208742, 0.0054398207, 0.0285080094, 0.0010116070, -0.0140030021, -0.0000014964, -0.0262408480, 0.0121007999, 0.0137326233, -0.0035812694, 0.0199878607, 0.0230185837, 0.0094426889, -0.0081689777, -0.0325720496, -0.0029476697, 0.0041079177, 0.0053095254, 0.0143974144, -0.0066579608, 0.0053037158, -0.0056303567, -0.0455016494, 0.0265481472, -0.0009222943, -0.0154358782, 0.0455640703, -0.0000030264, 0.0054697176, -0.0607093200, -0.0059578815, -0.0025792532, -0.0021524029, 0.0188360978, -0.0048328810, -0.0069036069, 0.0031333414, -0.0259661935, 0.0102978405, -0.0091257952, -0.0231579170, -0.0579814427, 0.0468092188, 0.0046044835, -0.0062596509, 0.0026846600, -0.0399968959, 0.0075155408, 0.0306946486, -0.0247936323, -0.0169246700, 0.0011724260, 0.0000004170, 0.0402603894, 0.0447270907, 0.0291044805, 0.0507293753, 0.0054425807, 0.0094878944, 0.0367391296, 0.0149153918, 0.0000329699, -0.0145355072, 0.0035830364, 0.0248537324, -0.0638426170, -0.0509247370, -0.0011793592, -0.0173566490, 0.0000000184, 0.0031637116, -0.0240290649, -0.0151904179, 0.0035273207, -0.0143404510, 0.0170922931, 0.0212511998, -0.0314731449, -0.0202224888, -0.0136005431, -0.0259267483, -0.0119611789, -0.0011123538, -0.0032095870, 0.0290977657, -0.0134339342, 0.0107918931, 0.0284310374, -0.0020648867, 0.0334767960, -0.0054466254, -0.0000002130, -0.0253218133, -0.0450883768, 0.0130959554, 0.0144601362, -0.0097114677, -0.0289537814, 0.0104590505, 0.0060871542, 0.0153676160, -0.0245831888, 0.0008981220, -0.0235612746, 0.0234512333, 0.0060810475, 0.0054346165, 0.0006388739, -0.0323662721, -0.0150301242, 0.0199805293, 0.0163403116, -0.0031854983, 0.0287398063, 0.0368011408, -0.0255677849, -0.0000622082, 0.0071765962, -0.0414891653, 0.0081417598, 0.0074378876, -0.0198732372, 0.0136826206, -0.0030657980, -0.0006601214, -0.0000421996, -0.0118490644, -0.0077251527, -0.0129762003, -0.0002941784, -0.0121766608, -0.0036250716, 0.0187578704, -0.0000011873, -0.0043582791, 0.0034346706, -0.0171443094, -0.0003250475, -0.0065770806, 0.0308449306, -0.0086643323, 0.0117507204, -0.0416901223, 0.0294459630, -0.0013575843, 0.0082646105, -0.0015461363, 0.0194967613, 0.0370604508, 0.0029414531, -0.0306350216, 0.0155271851, 0.0032874199, 0.0387281850, 0.0259023272, -0.0000598219, -0.0256624240, -0.0376525372, -0.0039935182, 0.0156215467, 0.0004911150, 0.0136083374, 0.0092285322, 0.0071700909, -0.0244082697, 0.0135677736, 0.0020270145, 0.0010087460, 0.0117587624, -0.0179524757, 0.0362341814, 0.0068978393, -0.0219530333, -0.0309465583, -0.0105785765, -0.0072829402, -0.0124447206, 0.0086375549, 0.0004906685, 0.0299689751, 0.0000036029, 0.0151087847, 0.0255746786, -0.0113157593, -0.0135683976, 0.0005208586, 0.0144864693, -0.0394442528, -0.0246475507, -0.0000485217, 0.0105144717, 0.0441401452, -0.0108800512, -0.0155284032, -0.0196434855, -0.0086856065, -0.0020220703, -0.0000033010, -0.0002053553, 0.0108309770, 0.0161049552, -0.0005536400, -0.0113181043, -0.0031933528, 0.0050058649, -0.0126237832, 0.0104337903, -0.0159618128, 0.0185677055, -0.0116184140, 0.0038577025, 0.0229376312, 0.0068084286, 0.0512428433, 0.0216707867, -0.0248718634, -0.0119251516, 0.0013139769, 0.0230999421, -0.0000031501, 0.0066043423, 0.0177225247, -0.0011160002, 0.0170666501, 0.0013809444, 0.0017900150, -0.0041546659, -0.0189154688, -0.0025116650, -0.0228596982, -0.0001539522, -0.0155070564, 0.0473803096, 0.0125087136, 0.0001313941, 0.0178063978, -0.0110327527, -0.0046081315, -0.0019758346, -0.0200570691, 0.0453546159, 0.0432723351, 0.0202717297, -0.0333793499, 0.0000773737, 0.0303220209, -0.0218771715, -0.0116655203, 0.0114386044, -0.0097525259, 0.0006611797, 0.0037938065, 0.0179730095, 0.0003641629, 0.0107178427, -0.0008222851, 0.0288133100, 0.0008229088, -0.0125492187, -0.0002386936, -0.0313247815, -0.0000026164, -0.0115426946, -0.0174333453, -0.0401892737, -0.0061787982, 0.0020716011, 0.0004503246, 0.0182985775, 0.0419987217, -0.0277560018, 0.0236037541, -0.0293370895, 0.0060968641, 0.0103338715, -0.0145011200, -0.0076857423, -0.0422415026, -0.0367752723, 0.0041943407, -0.0171503238, -0.0017385521, 0.0631542057, -0.0000176491, -0.0134041877, -0.0656126067, 0.0091263968, 0.0276384354, -0.0004643066, 0.0117837582, 0.0153318830, -0.0092365211, -0.0155409044, 0.0018065746, -0.0018753698, 0.0186915006, 0.0249203816, -0.0060956660, 0.0327981859, -0.0175300613, -0.0161608234, 0.0077865003, -0.0025005799, -0.0032400019, 0.0242864862, -0.0055321706, 0.0313151665, 0.0129249524, -0.0000433699, 0.0171368606, -0.0005796969, -0.0028893822, 0.0065318155, -0.0227829758, 0.0028298018, -0.0010727732, 0.0290077068, -0.0000152572, 0.0323961005, -0.0136436233, -0.0464576147, -0.0217930581, 0.0148553923, -0.0066097965, 0.0239125472, 0.0000000894, 0.0158144366, 0.0029751919, -0.0210897662, -0.0034831357, 0.0049541332, 0.0107638380, 0.0159541741, 0.0309588723, 0.0027871432, 0.0059538363, -0.0049114279, 0.0143363671, 0.0173217896, 0.0033778478, 0.0115567781, 0.0054260641, 0.0393729843, -0.0542028882, -0.0063430346, -0.0052438644, -0.0034038215, 0.0000101765, -0.0039347960, -0.0046935230, -0.0145300999, 0.0358475447, 0.0069099432, 0.0021702461, 0.0272970479, -0.0382725708, 0.0049537225, -0.0155066093, -0.0072071096, 0.0086488621, -0.0366527624, -0.0250193682, 0.0233972222, -0.0143517843, 0.0261365492, -0.0065445006, -0.0131443227, 0.0090616457, 0.0056889290, 0.0267548002, 0.0197837669, -0.0073510171, 0.0001387016, 0.0222399589, 0.0036510513, 0.0166177191, -0.0142578026, -0.0139049916, -0.0011227435, 0.0011013161, -0.0206238385, -0.0000100351, 0.0000882492, 0.0065542026, -0.0140169133, -0.0087095490, -0.0414567813, 0.0099799857, -0.0057765557, -0.0000188051, -0.0003114527, -0.0125923287, -0.0159163363, 0.0023401012, 0.0266734753, -0.0276627522, -0.0022327434, 0.0101740602, 0.0061339382, -0.0173140075, -0.0158953387, -0.0000808664, 0.0186143685, -0.0313577838, 0.0039623459, 0.0087862993, -0.0050669853, 0.0069514802, -0.0155480327, -0.0016831136, 0.0287286248, -0.0000737616, -0.0184400436, -0.0209237412, 0.0142742712, 0.0045503448, -0.0068153241, 0.0126483832, 0.0069775004, -0.0047588525, -0.0250919536, -0.0046953592, -0.0052801589, 0.0086897872, 0.0445382036, 0.0338926949, -0.0130353812, 0.0103945155, -0.0243197922, -0.0018861196, 0.0346850120, -0.0256678164, -0.0058749537, 0.0553143956, 0.0506428070, -0.0194061641, -0.0000241779, 0.0060968595, -0.0205719750, -0.0273876358, 0.0016921198, -0.0082792910, -0.0006559334, 0.0051756939, 0.0049524494, 0.0000263130, 0.0002802195, 0.0285667405, 0.0212521031, 0.0491265431, 0.0229872670, -0.0084713819, -0.0159868188, 0.0000003041, 0.0283971075, 0.0030966084, -0.0350056849, 0.0006501156, 0.0257869065, 0.0230969377, -0.0067224083, 0.0338580906, 0.0153516149, 0.0330726169, -0.0166340023, 0.0163221769, 0.0233555045, -0.0377418362, -0.0392141677, -0.0509737954, -0.0165275410, -0.0416724570, -0.0175841898, -0.0255378466, 0.0388045460, -0.0000409586, -0.0088764653, -0.0667656660, -0.0224551912, -0.0023671649, 0.0032693513, 0.0078461077, 0.0077457614, -0.0158272032, 0.0138884503, 0.0256440844, 0.0038901092, 0.0430179611, -0.0081575029, -0.0120177213, -0.0023918862, -0.0004607524, -0.0063155140, 0.0439357720, 0.0122793736, -0.0098462505, -0.0482579879, -0.0838719830, -0.0584837049, 0.0181245226, -0.0000162223, 0.0061384575, 0.0391937159, 0.0327954106, -0.0205340609, 0.0067044841, 0.0224949978, 0.0384273157, -0.0381487198, 0.0001109243, -0.0248703621, -0.0057859393, -0.0105583360, 0.0013755962, -0.0199116152, -0.0054568979, 0.0029235580, -0.0000000254, -0.0082739517, -0.0176655594, -0.0250047408, 0.0017443454, -0.0028271279, -0.0290345512, -0.0135474866, -0.0358211063, -0.0137153482, 0.0065328991, 0.0383798964, 0.0014791709, -0.0310542770, 0.0330812111, 0.0138967857, 0.0727383196, -0.0330119804, 0.0332489833, 0.0180412028, 0.0150300572, -0.0149685545, 0.0000423739, 0.0272663385, 0.0548760779, 0.0469646081, -0.0421692394, -0.0034247183, 0.0085135018, -0.0370276086, 0.0487202741, -0.0255159289, 0.0279006418, 0.0008823087, -0.0342168026, 0.0185590740, 0.0120457299, -0.0138883544, -0.0013759976, -0.0094774030, -0.0470042899, 0.0282701943, -0.0318265446, 0.0133047942, 0.0113125388, 0.0366297401, 0.0009382576, -0.0002702002, -0.0160172824, 0.0127293877, -0.0150419502, 0.0290556289, -0.0286229458, 0.0075400532, -0.0018308653, 0.0185252856, -0.0000251308, 0.0002684310, 0.0298765544, -0.0030263639, 0.0222303793, 0.0211679097, -0.0146322185, 0.0196380857, 0.0000000243, 0.0098081855, 0.0022700366, -0.0266955253, -0.0005292369, 0.0109894015, 0.0196772311, 0.0048943642, 0.0194993038, 0.0052080904, 0.0012965698, -0.0197533816, 0.0072021917, -0.0017533432, -0.0035305573, -0.0166754797, -0.0314877927, 0.0009969904, -0.0090424316, 0.0052687074, 0.0125421472, 0.0256007239, -0.0000617971, 0.0079577258, -0.0042791581, -0.0071201464, 0.0357984081, 0.0092184469, 0.0069897561, 0.0051270085, -0.0429134220, -0.0027404018, -0.0220844485, -0.0140797477, 0.0490538292, -0.0607090518, -0.0342090018, 0.0121241687, -0.0049266750, 0.0312139485, 0.0438628942, 0.0121382028, 0.0136416638, 0.0026307772, -0.0028532138, 0.0205721613, 0.0005696143, -0.0000064969, 0.0055619543, 0.0277901664, -0.0117102498, -0.0167440046, 0.0028958684, -0.0142172761, -0.0244656522, -0.0020123357, 0.0000383016, 0.0081659602, 0.0090754442, 0.0372298397, -0.0031129611, -0.0173063818, 0.0034100639, 0.0067391582, -0.0000008769, 0.0026080883, 0.0056055319, -0.0213469230, 0.0047084671, -0.0016324717, -0.0097742155, 0.0129083470, 0.0184300691, 0.0039288220, -0.0128739299, 0.0025557675, -0.0108897695, -0.0001698977, -0.0063948636, -0.0022691062, -0.0092223184, 0.0171677675, 0.0038208982, -0.0090775844, 0.0039269822, 0.0116632869, 0.0000000191, 0.0222933553, 0.0099060303, -0.0020633494, 0.0021285152, -0.0002015771, -0.0036800213, 0.0055717248, -0.0105049359, -0.0157281328, -0.0110959169, 0.0006423476, 0.0223417562, 0.0097861858, 0.0214886442, -0.0174918696, -0.0148636857, -0.0126624433, 0.0195739791, 0.0138559034, -0.0146762393, 0.0321238339, 0.0074807131, -0.0048114620, -0.0367612280, 0.0000163476, -0.0090798624, 0.0098115811, -0.0405770987, 0.0098800426, 0.0192797855, 0.0098213665, -0.0102592492, -0.0377505831, 0.0000242848, 0.0053133783, 0.0181892719, 0.0309478398, -0.0178414211, -0.0420629047, -0.0009450221, -0.0383543409, 0.0000002957, 0.0085662706, -0.0104960836, -0.0183082633, 0.0019882694, 0.0112481015, 0.0197273232, 0.0097435126, -0.0181115009, -0.0121121211, -0.0134746581, -0.0295124911, -0.0234059356, 0.0413897857, -0.0270615797, -0.0090049906, 0.0066107665, 0.0145764127, 0.0692736655, -0.0299051777, 0.0143075399, 0.0216753073, -0.0000004925, -0.0383736901, -0.0838510692, 0.0313564278, 0.0080854483, 0.0015662671, -0.0014017589, 0.0131468512, 0.0163222197, -0.0100896321, -0.0054930914, 0.0005705504, -0.0042680716, 0.0106550995, 0.0177087095, 0.0304324552, -0.0206339341, 0.0000499290, -0.0035129576, 0.0046502333, -0.0042433077, 0.0280302297, -0.0005791757, 0.0045619947, 0.0297712591, 0.0000520861, -0.0205386598, -0.0012078068, 0.0295565818, -0.0056839054, -0.0098442240, -0.0081090340, -0.0080438238, -0.0022417086, 0.0005286652, 0.0281251725, -0.0240164921, -0.0240159258, -0.0294620413, -0.0045767012, -0.0108067766, 0.0412495993, 0.0000007038, 0.0059693940, -0.0068860175, -0.0074127475, -0.0012801903, 0.0036840762, 0.0117145414, -0.0129815191, -0.0126289902, 0.0232556108, 0.0104232477, 0.0053228443, 0.0124837663, -0.0057160417, 0.0277125761, 0.0232108925, 0.0482589379, 0.0303953309, 0.0074184691, -0.0089764930, 0.0097541250, 0.0072547924, 0.0000005939, 0.0304288138, 0.0364865847, 0.0438164510, 0.0154341059, 0.0020569491, -0.0043302514, 0.0010583431, 0.0130227488, 0.0157401953, -0.0061265398, -0.0008994894, -0.0221801735, -0.0433886126, 0.0127103645, 0.0149682909, 0.0148235206, 0.0412372202, -0.0157282166, 0.0033376815, -0.0023697717, 0.0038987258, 0.0132273873, -0.0196742993, 0.0094752163, 0.0000025080, 0.0156011684, -0.0015162296, -0.0106755206, -0.0286511350, 0.0029639388, 0.0329348743, -0.0372144692, 0.0051330556, 0.0001197523, -0.0039420375, 0.0369165689, 0.0928322971, 0.0379372239, -0.0008070079, -0.0058435248, 0.0107012903, 0.0000001256, -0.0260350481, -0.0242892373, 0.0400372073, 0.0008105700, -0.0100503666, -0.0609077215, -0.0571356751, 0.0044824127, -0.0346062779, 0.0067570554, -0.0137676280, -0.0080630751, 0.0256909933, 0.0219858550, 0.0203795824, 0.0200629774, 0.0077451584, -0.0690335184, 0.0035417511, 0.0222182162, 0.0604074225, -0.0000065500, 0.0306570400, 0.0097099319, 0.0609556586, 0.0626604185, 0.0071805264, 0.0279398151, -0.0209220219, 0.0053160847, -0.0167658310, 0.0067936671, 0.0107464064, 0.0027870385, -0.0492282547, -0.0129196597, 0.0028918693, 0.0331236087, 0.0260130595, 0.0118022487, -0.0113475993, -0.0338926278, 0.0524214134, -0.0042919083, 0.0228477661, -0.0083137713, 0.0000016398, -0.0053092446, -0.0024132601, -0.0414388962, -0.0161456596, -0.0017669022, -0.0050762771, -0.0101828929, -0.0024738638, -0.0000115114, -0.0043173223, 0.0170845520, -0.0120271333, 0.0106606521, -0.0019481564, -0.0037593530, 0.0108670974, 0.0000000695, 0.0147925140, 0.0156641621, -0.0057749837, -0.0039861002, 0.0018112842, -0.0075111268, -0.0017843280, -0.0037940086, 0.0106770713, 0.0070020189, 0.0034942154, 0.0001257985, 0.0080878437, -0.0014764075, 0.0016895786, -0.0035348411, -0.0183979608, -0.0455411077, 0.0045334618, -0.0012824365, -0.0131369699, 0.0000001015, 0.0094943242, 0.0057170540, -0.0000881293, 0.0254586972, -0.0044881203, 0.0030686222, -0.0060732071, -0.0041117757, -0.0049491562, -0.0049619251, 0.0012503826, 0.0279928688, -0.0261223633, 0.0211768057, -0.0129844835, 0.0023696118, -0.0211707335, 0.0124150617, -0.0043696933, -0.0070368527, 0.0253265649, -0.0258334670, 0.0124512417, 0.0267582387, 0.0000021239, 0.0607230552, 0.0120581063, 0.0776523352, 0.0141000804, -0.0137583138, 0.0069868970, 0.0458302535, 0.0431438796, -0.0000058285, 0.0139405429, -0.0586997159, -0.0067129661, -0.0168745462, -0.0191846471, 0.0008000852, 0.0195421334, -0.0000621027, -0.0075340034, -0.0143899182, -0.0034905153, 0.0012994226, 0.0206020921, -0.0097837402, 0.0229410734, -0.0148973530, -0.0047237575, 0.0076925168, -0.0060338858, 0.0104348781, 0.0051094196, -0.0188245550, 0.0017511360, 0.0295862984, -0.0006108445, -0.0069041448, 0.0080770021, -0.0121071944, 0.0086057140, 0.0000000474, 0.0338830799, -0.0066311983, -0.0017158968, -0.0135167697, -0.0003868405, 0.0071909796, -0.0036212357, -0.0154590718, 0.0177665409, -0.0248870980, -0.0003976705, 0.0045628627, 0.0034067249, -0.0057057072, 0.0202190205, 0.0096085025, -0.0537702218, 0.0161769614, 0.0306820702, -0.0038293365, 0.0015466630, -0.0142861130, 0.0011041004, -0.0277547780, -0.0003285082, -0.0295603964, -0.0421918966, -0.0345320478, -0.0176233947, 0.0133453161, -0.0051925061, 0.0062165838, -0.0066998894, -0.0000131835, 0.0066446518, -0.0136396782, -0.0004637407, -0.0346977003, -0.0184162240, -0.0151159503, 0.0045183469, -0.0000034317, 0.0080935871, 0.0350383446, 0.0119892983, -0.0000840265, -0.0049685589, 0.0172796063, 0.0244560186, 0.0087862546, 0.0007486683, -0.0048379516, 0.0017547650, -0.0172104295, -0.0032783283, -0.0046146731, 0.0291611850, -0.0231580436, 0.0258800425, 0.0195527337, -0.0153109767, 0.0128459595, -0.0230637211, -0.0000004988, -0.0054445774, -0.0252331775, -0.0092874086, 0.0207618643, 0.0002803644, -0.0131879468, 0.0099309161, -0.0084254928, -0.0032285966, 0.0160739180, -0.0041050874, -0.0305710174, -0.0193996318, 0.0218108054, 0.0090747336, -0.0000299235, 0.0339736156, 0.0157764982, -0.0463627130, 0.0047396985, 0.0046308441, -0.0127891973, 0.0151822036, -0.0154846432, -0.0000005999, -0.0009728494, -0.0216364115, 0.0046269181, 0.0052109109, 0.0075587947, -0.0043094005, 0.0013046975, 0.0182971787, -0.0000000192, 0.0107325735, -0.0048184311, 0.0022352363, -0.0317472257, -0.0081231734, 0.0012073106, 0.0268128775, 0.0000000016, 0.0110114850, -0.0001617909, 0.0320374481, -0.0020834464, -0.0045998595, 0.0038709999, 0.0184324943, 0.0025279371, 0.0046461844, -0.0012967179, -0.0163114332, -0.0292762145, -0.0139607396, 0.0030889160, -0.0009814778, -0.0219580717, -0.0012852509, 0.0019040368, -0.0023459664, 0.0181781705, -0.0192555021, -0.0000001271, -0.0163719207, -0.0174480956, 0.0123606222, 0.0297188815, -0.0123470183, -0.0082137296, 0.0118132764, -0.0153014446, -0.0120351408, -0.0281557702, -0.0066934023, -0.0255418718, -0.0094813490, 0.0094250329, -0.0046442328, -0.0091981879, 0.0115352031, 0.0022854973, 0.0015943418, 0.0074137901, -0.0024082069, -0.0471696816, -0.0062367502, 0.0158078782, -0.0000185239, 0.0017815211, -0.0055288421, 0.0152206775, 0.0073379856, -0.0108895898, -0.0050006849, 0.0259389784, 0.0263488218, 0.0000001685, 0.0286857598, -0.0322089754, -0.0286599454, 0.0027800349, 0.0242276546, 0.0000720180, 0.0250004102, -0.0000439984, 0.0128789432, 0.0082663335, -0.0126475217, -0.0000632373, -0.0037985391, 0.0276848264, 0.0119626522, 0.0045113601, -0.0015966529, 0.0351185687, 0.0196935628, 0.0197461490, -0.0056145778, 0.0006803788, 0.0164968558, 0.0005775795, -0.0241774563, 0.0074795717, 0.0181141905, 0.0194129739, -0.0185208917, 0.0000012625, 0.0135735702, 0.0318431780, -0.0246011112, -0.0148835238, 0.0006314686, 0.0189533196, -0.0070931558, 0.0278559458, 0.0110856090, 0.0100139715, -0.0004566388, -0.0178074129, -0.0553797446, 0.0088644242, -0.0186405554, 0.0124743311, -0.0006298613, -0.0316926092, -0.0003766979, -0.0013730377, -0.0323887579, 0.0054949736, 0.0087083988, -0.0214727167, -0.0000009147, 0.0025487931, -0.0106320875, -0.0422258675, -0.0410957597, 0.0034927120, 0.0091020055, -0.0010154474, -0.0126574133, 0.0000007871, -0.0035128854, 0.0123712244, 0.0000481092, 0.0239132233, -0.0098420205, -0.0067694830, -0.0163105316, 0.0000000117, 0.0022446557, 0.0111614419, 0.0168255381, -0.0005288514, -0.0031229223, -0.0097276466, -0.0037519538, 0.0248754490, -0.0147205722, 0.0077614007, 0.0189057942, -0.0075842063, -0.0151987653, -0.0017410861, -0.0265685953, 0.0414145105, -0.0035013421, -0.0227716044, 0.0004099259, -0.0010631023, -0.0116160875, -0.0000002023, 0.0132674202, 0.0162473936, 0.0112135457, -0.0032513856, -0.0117246117, -0.0125662545, 0.0075739827, 0.0176866408, -0.0142254336, -0.0011306882, -0.0073017967, 0.0203829370, 0.0201175883, -0.0011668477, 0.0244388971, -0.0039925124, -0.0028256103, 0.0038733254, 0.0027419636, -0.0086456966, 0.0271361582, -0.0000567878, 0.0152956210, 0.0022705370, 0.0000036093, -0.0058064121, 0.0007484340, -0.0068028863, -0.0086000366, -0.0097571732, -0.0147520928, 0.0023232056, 0.0221619587, -0.0000189447, 0.0110486476, -0.0208801795, -0.0444096774, -0.0018522420, 0.0110490536, -0.0054339226, 0.0166194253, -0.0000000003, 0.0108272191, 0.0160476360, 0.0035018120, -0.0012326770, 0.0026195773, 0.0247554388, -0.0224266145, -0.0032912686, 0.0258453321, 0.0081936242, 0.0022589292, 0.0089029102, 0.0025231149, 0.0088369539, 0.0029465933, -0.0059159319, -0.0123073719, -0.0302446000, 0.0050199507, -0.0064180177, -0.0233109500, -0.0000053816, 0.0057383096, -0.0032512404, -0.0079613002, -0.0094600050, -0.0006874911, -0.0006547172, 0.0100784050, -0.0323189609, -0.0053231288, 0.0122872284, -0.0099667218, 0.0391015857, -0.0175999291, 0.0131909717, 0.0084289350, 0.0064329663, 0.0004012106, 0.0054497868, -0.0095778266, 0.0001085832, -0.0024799479, -0.0416978411, 0.0110522080, -0.0077401344, -0.0000163171, -0.0086897649, -0.0041404422, 0.0127030360, -0.0116271693, -0.0086913640, -0.0131136924, 0.0452831276, 0.0266294796, -0.0000764387, 0.0133275501, -0.0151531715, -0.0191669185, 0.0089157792, 0.0093806097, -0.0064844391, 0.0174822286, -0.0000007475, 0.0220267139, -0.0166065451, -0.0383438878, -0.0000921751, -0.0129013350, 0.0263782684, -0.0126568470, 0.0042124274, 0.0063383798, 0.0347598195, 0.0045068283, 0.0101434067, 0.0148192961, 0.0012809897, 0.0236015804, -0.0075010057, -0.0304281171, -0.0145634552, 0.0119079286, 0.0164853968, -0.0124968626, 0.0000052945, 0.0100106616, 0.0192030072, -0.0133315427, 0.0080634058, -0.0108866924, 0.0204961691, -0.0133875497, 0.0307401251, 0.0096525727, 0.0115879104, -0.0006632160, 0.0002805851, -0.0524071269, 0.0107871192, -0.0273061953, 0.0095543629, -0.0144645991, -0.0136721889, 0.0131672202, -0.0091535775, -0.0181301683, 0.0338039473, 0.0073351408, 0.0185703244, -0.0000643343, 0.0001691947, 0.0130960168, 0.0245519467, -0.0141531825, -0.0118635856, -0.0048400927, -0.0548688881, -0.0108405910, 0.0000020277, 0.0016930794, -0.0075490479, -0.0316809788, -0.0169975907, 0.0083675869, 0.0036639019, 0.0079742558, 0.0000001202, -0.0035306134, 0.0093668988, -0.0030318731, -0.0066474173, -0.0040030107, -0.0098017287, 0.0047620451, 0.0160347018, 0.0204221793, 0.0105658751, 0.0146300700, 0.0113686696, -0.0162073225, 0.0096497489, 0.0157070272, 0.0036697846, 0.0402213782, -0.0208545756, -0.0076021450, -0.0141399475, 0.0070377565, -0.0000011557, 0.0071992045, 0.0257120598, 0.0112381624, 0.0109800724, -0.0017878560, 0.0119776726, 0.0077764038, -0.0090566175, -0.0318276063, 0.0012434366, -0.0003726415, -0.0004276211, -0.0080316458, 0.0322013833, -0.0126755172, -0.0013181736, 0.0015647997, -0.0136005925, 0.0223776717, -0.0051951595, 0.0087221190, -0.0367176421, -0.0035373380, -0.0038741217, 0.0000005577, 0.0497450307, 0.0300372671, 0.0176796895, -0.0190143529, 0.0112092001, 0.0021794408, 0.0020972814, -0.0031858445, -0.0001941486, 0.0156458504, 0.0001842444, 0.0336817838, -0.0333839133, -0.0460974351, -0.0023905593, -0.0271865409, 0.0000000093, -0.0060481708, -0.0245221127, 0.0095709506, 0.0010047631, 0.0009730458, 0.0015688549, 0.0314846784, -0.0310153328, 0.0060546552, -0.0262004342, -0.0402397662, -0.0289534461, -0.0117705744, -0.0411642045, 0.0434779450, 0.0066219568, 0.0150539633, 0.0415489078, -0.0057569235, 0.0252195578, -0.0350565016, -0.0000000307, 0.0090622306, -0.0436723903, 0.0332911387, -0.0046718526, -0.0013564707, 0.0129876221, 0.0039689941, 0.0067291316, -0.0023569181, -0.0008591737, 0.0001881650, -0.0146432109, 0.0301304776, 0.0070740404, 0.0134838866, -0.0023709952, -0.0458232090, 0.0088701649, -0.0132108405, -0.0141807208, -0.0173159782, -0.0024853798, 0.0053357305, 0.0262548570, 0.0000005162, 0.0235401746, 0.0596260838, 0.0318234749, 0.0258550514, -0.0017001776, 0.0278925691, -0.0119514503, -0.0070100091, -0.0000016294, 0.0053556110, 0.0124895126, 0.0196552891, -0.0214607716, -0.0101518715, -0.0003571239, -0.0222534016, -0.0000408954, -0.0204181839, -0.0209415760, 0.0049426304, 0.0012510839, 0.0073820273, -0.0145332804, 0.0308642853, -0.0123954434, -0.0051920926, -0.0110779712, -0.0068562198, 0.0080766324, -0.0082819182, -0.0148892794, 0.0165363979, 0.0396448411, 0.0032229461, 0.0034579802, 0.0079086851, 0.0034622124, -0.0070058615, -0.0000001194, -0.0029534404, -0.0073696435, 0.0063547492, -0.0002030600, -0.0012550812, 0.0036552330, -0.0105690220, -0.0101156216, -0.0100013046, -0.0044643115, -0.0003411624, -0.0066715726, 0.0277494397, -0.0066156746, 0.0004319071, 0.0155074503, -0.0216133632, -0.0182877481, 0.0073057427, 0.0056347512, 0.0150050055, -0.0265220255, 0.0069677616, -0.0280102361, -0.0000286977, -0.0509049557, -0.0384794436, -0.1100344211, -0.0222688802, 0.0310762208, 0.0100573180, -0.0174689163, -0.0567310750, -0.0000039040, -0.0157589130, 0.0489501655, 0.0597557351, 0.0300635118, -0.0213984884, 0.0036202106, -0.0017565510, 0.0000001324, 0.0087692160, 0.0186965335, 0.0341820493, 0.0003526911, -0.0026429489, -0.0056049372, -0.0023491059, -0.0280259755, -0.0022240416, -0.0300580896, -0.0072359941, -0.0342311822, 0.0092860311, 0.0024011855, 0.0017764547, 0.0030505811, -0.0017818027, 0.0420029871, -0.0093220118, 0.0053379629, -0.0395845883, 0.0000016247, 0.0174958128, -0.0051737684, 0.0081965029, 0.0170502067, -0.0005253963, -0.0212488249, -0.0190802086, 0.0267284736, -0.0293044709, 0.0123035433, 0.0041716341, 0.0258741248, -0.0037309835, 0.0095393928, 0.0224265549, 0.0076994244, 0.0260873381, 0.0816718042, -0.0412505902, 0.0005637571, 0.0445184968, -0.0154355532, -0.0024270848, 0.0238159746, 0.0000169734, 0.0271425489, 0.0105681634, 0.0296436958, 0.0273369569, -0.0116878347, -0.0009721027, 0.0107198497, 0.0176441520, 0.0000140236, 0.0181733146, -0.0130270403, -0.0311315656, -0.0195093174, 0.0044465140, 0.0009873107, -0.0005270120, -0.0001034550, -0.0101993391, -0.0039591957, -0.0039219325, -0.0022060391, 0.0083982041, 0.0005363570, 0.0261109378, 0.0202516969, 0.0005351762, -0.0040119234, 0.0075493432, 0.0218326505, 0.0007072318, -0.0042103040, 0.0109138656, 0.0029996298, -0.0044324016, -0.0012353279, -0.0023665298, -0.0084136138, 0.0133001180, 0.0000000255, -0.0018889939, 0.0102285184, -0.0091387685, 0.0079082530, 0.0006648487, 0.0097661037, -0.0018157799, -0.0087699946, 0.0079957442, -0.0042043435, 0.0000190716, -0.0040335828, 0.0064955293, 0.0168268699, -0.0016939007, -0.0028074034, -0.0386944227, -0.0175058413, -0.0005102026, -0.0019266834, 0.0091030216, 0.0187164973, 0.0100935549, -0.0035103727, 0.0000211324, 0.0121259186, -0.0250417627, -0.0195653569, 0.0016139469, -0.0088778026, -0.0044839652, -0.0182087142, 0.0179291908, 0.0000000252, 0.0226486642, -0.0269495454, 0.0087996330, 0.0105402973, 0.0379464626, -0.0057114493, 0.0064245290, -0.0000037459, -0.0077354833, 0.0157698784, 0.0059937630, -0.0008910851, 0.0061106910, 0.0133905383, 0.0063544409, 0.0145103373, 0.0099994317, 0.0363055952, -0.0001425926, 0.0019051684, -0.0007659777, -0.0028183211, 0.0106242271, -0.0089787710, -0.0000835187, -0.0099199768, 0.0133406529, -0.0351939946, 0.0071643195, 0.0000030301, -0.0102950316, 0.0000419809, 0.0043602977, 0.0171369351, -0.0010599041, -0.0001917511, 0.0160556026, -0.0207117647, -0.0121651543, 0.0017623126, -0.0127504207, 0.0027774705, -0.0564847328, -0.0138824144, 0.0162709188, 0.0069578444, 0.0249174125, 0.0074797664, -0.0089145545, 0.0119291367, -0.0107091749, 0.0080637531, 0.0092678033, -0.0154051855, -0.0000008743, -0.0080085453, -0.0280267671, -0.0570899621, 0.0105642155, 0.0130208535, -0.0005167887, -0.0051354342, 0.0027549136, -0.0000132658, 0.0275547709, 0.0229624007, -0.0065812650, -0.0291865021, 0.0116840163, -0.0027868866, -0.0114421267, 0.0000000526, 0.0112975137, 0.0073054065, 0.0097157685, -0.0072851651, 0.0047338456, 0.0303093772, 0.0280582588, 0.0121219037, 0.0116696423, 0.0002213055, -0.0102860937, -0.0203218106, 0.0003993361, -0.0207985658, 0.0084048528, -0.0417086706, 0.0099431360, 0.0197453070, -0.0032898816, 0.0004188116, -0.0161575004, -0.0000019590, -0.0332337320, -0.0405070931, 0.0270364657, 0.0043336283, 0.0167216435, -0.0042567556, 0.0155115416, -0.0031147297, 0.0014157153, -0.0093710506, -0.0055392287, -0.0323521979, -0.0158145651, -0.0004685273, -0.0283330716, -0.0125390552, 0.0142138787, 0.0129850134, -0.0393952802, -0.0022876321, -0.0223372933, 0.0046359044, -0.0107643250, 0.0177330635, 0.0000027379, -0.0122221252, 0.0138646066, -0.0135152750, 0.0033870980, -0.0149787879, -0.0025306789, -0.0255386494, -0.0027504808, 0.0000030961, 0.0173544586, 0.0238387734, -0.0390306748, -0.0099801850, 0.0228512343, -0.0026085619, -0.0068048760, -0.0000010678, 0.0075101824, 0.0045820707, -0.0185873155, -0.0015100356, 0.0013500638, 0.0025143465, 0.0028476126, 0.0278897509, 0.0249747485, 0.0011493640, 0.0084902290, -0.0010205798, 0.0049700667, 0.0065046647, 0.0064579002, 0.0248148125, 0.0239220057, -0.0326528586, 0.0068560857, -0.0069371574, 0.0098273866, 0.0000005193, -0.0171275605, 0.0248240773, 0.0130358664, 0.0207252186, -0.0014688028, 0.0160489902, -0.0037641556, -0.0186072849, -0.0033025290, -0.0016727520, -0.0032554080, 0.0046625333, -0.0235775877, 0.0138006350, -0.0259440765, -0.0025853286, 0.0229086913, -0.0242271349, -0.0037717863, 0.0029665553, 0.0259472225, -0.0192354266, 0.0102824261, -0.0098104766, -0.0000022732, -0.0081861168, -0.0189646631, -0.0157749690, 0.0002495073, -0.0033555692, 0.0002744409, 0.0141133927, 0.0077371551, -0.0000000234, 0.0216193460, -0.0148367481, -0.0268642586, 0.0020657815, 0.0068363110, -0.0094640935, 0.0071102981, 0.0000000049, -0.0035121518, -0.0075325016, -0.0128615638, -0.0031169394, 0.0017659419, -0.0103425225, 0.0269404054, 0.0247141086, -0.0137413861, -0.0006838895, -0.0050322143, -0.0057902047, -0.0326705612, -0.0033831296, 0.0021877505, 0.0074931267, -0.0415223464, -0.0111385779, 0.0092125423, 0.0113016469, 0.0077489680, 0.0000011272, -0.0204725508, -0.0158308819, -0.0022624938, 0.0042397762, -0.0000138391, -0.0004378791, -0.0030679028, 0.0218419023, 0.0004834579, -0.0211505443, -0.0034312822, -0.0190214477, -0.0135828238, -0.0059598759, -0.0214319807, -0.0068194778, 0.0321348347, -0.0102632968, -0.0071348068, 0.0005140550, 0.0045032236, 0.0035421452, -0.0020010672, 0.0131310839, 0.0000096152, 0.0530026369, 0.0207045786, 0.0122003332, 0.0188325718, -0.0125835817, 0.0023912946, 0.0008967042, 0.0082566515, -0.0001172684, 0.0031100523, 0.0215932019, -0.0203500744, -0.0164071340, -0.0179056060, 0.0068332413, 0.0067189788, -0.0000106747, -0.0120718339, -0.0244971700, -0.0213898011, 0.0016163877, 0.0042269146, -0.0208084043, 0.0329357721, 0.0114048989, -0.0071964175, -0.0228827372, -0.0161619615, 0.0069216145, 0.0078115212, -0.0177854095, 0.0075952839, -0.0011007211, 0.0070257392, -0.0182957724, 0.0021127441, -0.0057401699, 0.0180020593, -0.0000010707, -0.0009070272, 0.0086574033, 0.0082282126, 0.0096423449, 0.0008886088, 0.0070700338, -0.0006056105, -0.0228122063, 0.0169045199, -0.0180010721, 0.0001894434, 0.0039070952, 0.0203398485, 0.0171920471, 0.0035827602, -0.0005476063, -0.0436015353, -0.0034693549, 0.0171175394, 0.0091464771, 0.0105464114, -0.0224094167, 0.0100421570, -0.0392822623, -0.0000007393, 0.0228179712, -0.0261690468, 0.0199542753, -0.0043024877, -0.0183489043, 0.0061880434, 0.0392560251, 0.0527039953, 0.0000266634, 0.0172568206, -0.0256615542, -0.0005583982, 0.0376605988, 0.0127817597, -0.0057619386, -0.0099324640, -0.0000010721, -0.0328593776, 0.0070160329, -0.0036868444, 0.0001033426, -0.0001102457, 0.0070654578, 0.0076493574, -0.0017057873, -0.0106770219, -0.0073299184, 0.0116948206, 0.0082547180, 0.0088472283, -0.0242939238, -0.0049358746, -0.0345358029, 0.0010705857, -0.0229627676, 0.0004789359, -0.0161276851, 0.0006480340, 0.0000002973, 0.0020865833, -0.0354130007, 0.0073777596, 0.0145233562, 0.0010039085, 0.0188377611, -0.0001180102, -0.0386602953, 0.0204841010, 0.0030996096, 0.0021894581, 0.0277227405, -0.0260050297, -0.0329374596, -0.0016209139, -0.0371885002, -0.0323935226, 0.0017726494, 0.0104689654, -0.0044311900, 0.0246916078, -0.0070539084, -0.0074440395, -0.0156485587, 0.0000006844, 0.0265611485, 0.0203492567, 0.0613892116, 0.0368938260, 0.0035990684, 0.0220271721, 0.0316016264, 0.0268625356, 0.0000148359, -0.0029183172, 0.0015683915, 0.0421921685, -0.0274006166, -0.0344556011, -0.0014930794, 0.0137791857, 0.0000000162, -0.0169665981, -0.0202571992, 0.0135234129, 0.0005891057, 0.0000601774, -0.0319097601, -0.0046981885, -0.0238464195, -0.0047379541, -0.0071156514, -0.0314941779, -0.0134603735, 0.0079214182, -0.0140308077, 0.0298864841, -0.0059278896, 0.0067661754, -0.0135228280, -0.0054967678, 0.0278031528, 0.0252142455, -0.0000002642, -0.0068219835, -0.0224213228, 0.0303539243, 0.0494398102, -0.0005424604, -0.0019149290, -0.0169947203, -0.0076806117, 0.0032755211, -0.0127469469, -0.0004256438, -0.0067214393, -0.0317714438, 0.0086787855, -0.0076463427, -0.0026311127, -0.0243323799, 0.0182327516, 0.0315680318, 0.0183518268, 0.0072346586, -0.0000555355, 0.0042841942, 0.0067994492, -0.0001318653, -0.0157210417, -0.0110469200, -0.0146411331, -0.0403413922, -0.0042600627, -0.0046248934, 0.0034988672, 0.0044571948, -0.0000088260, 0.0007703721, 0.0003423983, -0.0446883701, 0.0242147706, 0.0204605423, -0.0070206011, 0.0027680951, -0.0000002747, 0.0029549720, 0.0159404688, -0.0072901631, 0.0002107697, -0.0120971389, 0.0122913690, -0.0177201144, 0.0157485250, 0.0143755078, 0.0073486432, 0.0272241142, -0.0001024763, -0.0133970762, 0.0089302985, -0.0098617524, 0.0155497855, 0.0046299133, -0.0319287404, 0.0101745864, -0.0103963856, -0.0231166948, -0.0000058026, 0.0177209973, 0.0349208377, 0.0021234711, 0.0004986734, 0.0002034512, 0.0041542854, -0.0068058381, 0.0087807020, -0.0243754871, 0.0277704913, -0.0008472965, 0.0028062372, -0.0406909138, 0.0267639980, -0.0175185073, 0.0003960230, 0.0113057327, -0.0109114461, -0.0017230837, -0.0120168328, 0.0180009883, -0.0094640618, -0.0073002735, 0.0432688370, 0.0000011429, 0.0319534242, 0.0434788726, 0.0397328548, 0.0221692845, -0.0011408002, 0.0029764320, -0.0046651294, 0.0161574073, -0.0000239159, -0.0086582880, -0.0091716629, -0.0068971678, -0.0256919805, -0.0120091876, -0.0024589777, 0.0138220768, -0.0000241635, -0.0101035731, -0.0065188436, 0.0133683309, 0.0013821218, -0.0069595743, 0.0164380092, 0.0004671838, -0.0182585046, -0.0133147268, -0.0061566588, -0.0042339689, 0.0065216348, -0.0195790511, 0.0093311016, 0.0300093945, 0.0262748748, -0.0123496121, 0.0071090055, 0.0071027018, 0.0102422442, -0.0083673056, -0.0000006405, -0.0068589533, -0.0056607425, -0.0064401105, 0.0003106438, 0.0002054997, -0.0017758472, -0.0020046961, -0.0257692877, -0.0009531938, -0.0161138270, -0.0039098845, 0.0115394341, 0.0064534936, -0.0026946182, 0.0102722216, 0.0172943473, -0.0270738006, -0.0128005613, -0.0049964995, 0.0135108968, -0.0085896375, 0.0095729725, 0.0410929620, -0.0056018555, 0.0000022187, 0.0200060308, -0.0177973676, 0.0039110845, -0.0005277181, -0.0076904935, 0.0099007497, 0.0077325804, 0.0392263085, -0.0000075720, 0.0211706273, -0.0067068092, -0.0183064006, 0.0103642438, 0.0152500197, -0.0000095615, 0.0003029098, -0.0000022814, -0.0108093042, -0.0039718463, 0.0016773831, 0.0005621861, 0.0019596166, 0.0044278731, 0.0229099691, 0.0292199124, -0.0034661426, -0.0034480186, 0.0151800113, -0.0060410695, -0.0082859732, -0.0222184174, 0.0003176891, -0.0090737324, -0.0030512619, -0.0363127589, 0.0072185071, 0.0065543903, -0.0010102768, -0.0000010951, -0.0164232124, -0.0149044478, -0.0056143324, 0.0212918874, 0.0003177343, 0.0045999740, -0.0042130705, -0.0061151637, -0.0130091654, -0.0087805409, -0.0008727083, 0.0275995713, -0.0459334143, 0.0184551869, -0.0135874487, -0.0122225117, -0.0138642322, 0.0104254661, 0.0148580857, 0.0057687722, 0.0283649880, 0.0096970499, 0.0004895045, 0.0034418374, -0.0001548111, 0.0141759692, -0.0116208689, 0.0259286426, -0.0110506555, 0.0055364724, 0.0000500745, -0.0111483261, 0.0029320903, -0.0000006671, 0.0096487561, -0.0298660118, -0.0221404824, -0.0108569004, 0.0034634229, 0.0009558464, -0.0037033190, 0.0000000077, 0.0014596866, 0.0061199823, -0.0120034516, -0.0003961626, -0.0031325144, 0.0050015645, 0.0138601270, 0.0088951159, -0.0004209509, 0.0165208485, 0.0105576543, -0.0093165543, -0.0248741992, 0.0133323660, 0.0017980041, -0.0139316591, -0.0167079605, -0.0385930799, -0.0088949930, -0.0095575294, 0.0050270194, -0.0000089025, 0.0102731194, 0.0202555098, -0.0121670039, 0.0111421794, -0.0058477405, -0.0038158468, -0.0011855017, -0.0231252722, -0.0208495446, -0.0209109895, -0.0027103233, -0.0154039487, -0.0128934458, 0.0015332634, 0.0123115648, -0.0064816759, 0.0292064790, -0.0072961459, -0.0047705416, 0.0081737619, -0.0016886180, -0.0000032696, 0.0060224407, -0.0120102037, -0.0000037288, 0.0104845930, -0.0154337548, 0.0042559272, 0.0514293052, 0.0022171095, 0.0179290399, 0.0418067388, 0.0091519598, -0.0000011349, -0.0076944814, -0.0289298985, -0.0195420608, 0.0415306091, 0.0374406017, -0.0030473080, -0.0013040608, -0.0000003334, 0.0130105671, -0.0055133104, -0.0170866419, -0.0067530484, 0.0100481668, 0.0389302596, 0.0328224190, 0.0145036029, -0.0121225519, 0.0158230159, 0.0080765113, 0.0091251163, 0.0067430222, -0.0007782447, -0.0247566290, -0.0326440036, -0.0179307591, 0.0010061371, -0.0022108890, -0.0090842759, 0.0155127840, 0.0000003268, -0.0095874509, -0.0485437177, -0.0434069633, -0.0019638722, 0.0064960541, 0.0179524310, 0.0121425744, 0.0113359196, 0.0180952568, -0.0112279467, 0.0021727062, -0.0015139672, -0.0310760085, 0.0103702052, 0.0209762435, -0.0057853940, -0.0189065523, 0.0121432682, -0.0082162675, 0.0165115632, -0.0040493277, 0.0290750712, 0.0018840519, -0.0172865968, 0.0000031626, 0.0282552540, -0.0164696593, -0.0164205749, 0.0275712870, 0.0016039493, 0.0012148404, -0.0038498007, 0.0115940440, 0.0000009741, 0.0140588675, -0.0016140717, -0.0087325126, 0.0408167429, 0.0203386508, -0.0003207493, -0.0345536582, 0.0000000106, -0.0252083279, -0.0112791900, -0.0015962755, -0.0124231428, 0.0166949611, -0.0077697369, 0.0142732309, 0.0383233167, -0.0196563695, 0.0192687251, -0.0231518224, 0.0036640351, 0.0091171125, -0.0250931177, -0.0440571681, -0.0176647939, -0.0009261597, -0.0418725349, 0.0072624753, -0.0356386602, 0.0407170877, -0.0000143245, -0.0224373806, -0.0178586710, 0.0020115403, 0.0145027153, 0.0037817019, -0.0048611779, 0.0355790369, -0.0016920702, -0.0043084691, -0.0036567135, -0.0067138094, 0.0357248224, -0.0114980815, -0.0083546601, 0.0258620623, -0.0038595835, -0.0094175860, 0.0127361640, 0.0288791135, 0.0009719299, 0.0083814086, -0.0465921052, -0.0265176687, 0.0452704430, -0.0000375346, -0.0012935174, 0.0208498631, 0.0211621635, -0.0471147224, 0.0167489517, 0.0049194964, -0.0239521265, -0.0128091928, -0.0000115511, -0.0013452248, 0.0203453526, -0.0109011214, 0.0134693347, -0.0067175827, -0.0119242454, -0.0148756653, -0.0000003315, -0.0069794413, 0.0062978435, -0.0059070699, 0.0019447310, -0.0093550142, -0.0196002498, -0.0264071617, -0.0162756145, -0.0226342492, -0.0058213701, 0.0182382520, 0.0144686466, -0.0157285351, 0.0188368578, -0.0082727438, 0.1001333073, 0.0168838669, -0.0019753256, 0.0158949066, -0.0026302417, -0.0098374104, -0.0000074465, 0.0369071774, 0.0373131707, 0.0111873196, -0.0522782095, -0.0031915910, 0.0021433425, -0.0135150179, 0.0160168875, -0.0102252308, 0.0274336208, -0.0046860618, -0.0115314107, 0.0239884704, -0.0224778447, 0.0178995673, 0.0226581171, 0.0035768184, -0.0325274207, 0.0284817144, -0.0309365429, 0.0209744330, 0.0367709696, 0.0027600992, -0.0108147664, -0.0000442582, 0.0227507893, -0.0264427681, 0.0042534238, 0.0129394690, -0.0049301647, 0.0022525571, 0.0097912000, 0.0132374354, -0.0000009253, -0.0158681124, -0.0124394493, 0.0076007424, -0.0101625528, -0.0011502820, -0.0089315865, 0.0122242607, 0.0000001314, 0.0027976427, 0.0057464270, 0.0102001745, -0.0038431701, -0.0001487562, 0.0230988227, -0.0022620391, 0.0079660332, 0.0091388486, 0.0226373654, 0.0053706700, -0.0151164746, -0.0050817211, 0.0066807801, 0.0191009603, -0.0137287090, -0.0029689970, 0.0074851038, -0.0023041989, -0.0085293725, 0.0284650214, -0.0000023539, -0.0195955820, -0.0363448448, 0.0094703306, 0.0337690748, 0.0015917022, 0.0070153549, 0.0182008687, -0.0242217518, -0.0225905143, 0.0081482958, -0.0037103621, -0.0142253600, -0.0122997211, 0.0185782984, 0.0155140711, 0.0000947602, -0.0199234523, 0.0056085717, -0.0014101770, 0.0173978843, -0.0169286989, 0.0079367319, 0.0328432992, -0.0521630123, 0.0000062421, 0.0047869342, -0.0068322090, -0.0393133573, -0.0141185001, 0.0024527044, -0.0074886549, -0.0303544980, 0.0109563880, 0.0000007586, 0.0250992551, 0.0096817613, 0.0194469169, -0.0214661509, -0.0114804888, 0.0045496793, 0.0116783697, -0.0003091795, -0.0016256514, -0.0107455673, 0.0024338302, 0.0000042017, 0.0041309092, -0.0322352983, 0.0496097766, 0.0029337446, 0.0079991752, -0.0201748051, -0.0063683367, 0.0071949563, 0.0106411716, -0.0368681215, 0.0195390582, -0.0365107767, 0.0444530956, -0.0043143434, -0.0134474412, 0.0272658076, -0.0080778850, 0.0000000035, -0.0076141017, 0.0002384570, -0.0004868009, 0.0414072871, -0.0002608732, -0.0034088099, 0.0093437070, -0.0065075699, 0.0122898780, -0.0307121500, 0.0005224183, 0.0106055839, -0.0549573824, 0.0084093474, -0.0045754635, -0.0028700342, -0.0027659091, 0.0435769856, -0.0175843518, 0.0090166656, 0.0431435108, 0.0085955625, 0.0094413627, -0.0213649478, 0.0003091174, 0.0203694720, -0.0067885411, -0.0209039599, -0.0075737149, 0.0138354879, 0.0101412237, 0.0020310224, -0.0088832146, 0.0000002045, -0.0157101899, 0.0145963309, 0.0330518112, -0.0117168287, -0.0288198851, -0.0041036527, 0.0057657356, 0.0000000687, -0.0083567128, -0.0224827006, 0.0092002144, 0.0007070148, -0.0041658366, -0.0141707938, 0.0231315903, -0.0073875538, -0.0109109348, -0.0095424913, 0.0026502493, -0.0196096767, 0.0187680703, -0.0108797038, 0.0225578528, -0.0156424679, 0.0113288183, 0.0670777336, -0.0225319993, 0.0209411029, -0.0105216596, -0.0000023940, -0.0208691489, -0.0394345000, 0.0240324531, 0.0264452770, 0.0024549761, -0.0157669708, -0.0023384709, -0.0071809213, 0.0138017600, -0.0011114264, 0.0023254759, -0.0190140102, 0.0187222548, 0.0005001930, 0.0204650722, 0.0001969623, -0.0055654650, 0.0267042555, -0.0200987086, 0.0201597344, -0.0078363884, -0.0479802564, -0.0043194834, 0.0081438860, -0.0000006673, -0.0059363190, -0.0094388993, -0.0035443916, -0.0118644163, 0.0087162284, 0.0098385289, -0.0162082575, -0.0105049657, 0.0000001222, 0.0098307068, 0.0077044214, -0.0110092331, -0.0344526470, -0.0154109634, -0.0026515420, 0.0075068441, -0.0000234502, 0.0065367334, 0.0222306345, 0.0097742658, 0.0001888735, -0.0014507447, -0.0074725170, 0.0275114663, -0.0009958257, 0.0071467957, -0.0213270951, 0.0065085399, -0.0024831970, -0.0150382137, 0.0146945687, 0.0111934403, 0.0188527741, 0.0311028492, -0.0149913933, 0.0076845614, 0.0184407067, -0.0114063071, -0.0000001353, 0.0208087135, 0.0212090965, -0.0012669928, 0.0140383253, -0.0112541001, -0.0184062365, -0.0002790138, -0.0032462871, -0.0163416211, 0.0004888897, -0.0037751088, -0.0151217347, -0.0162849855, 0.0118832244, 0.0181814954, 0.0098773018, 0.0159276668, -0.0034336762, -0.0236100182, 0.0070451945, 0.0333853848, -0.0241305623, 0.0075597861, 0.0274362192, -0.0000048080, -0.0162577629, 0.0006185264, -0.0293237343, -0.0086233253, 0.0073704319, 0.0132783633, -0.0479382351, -0.0115182661, -0.0000054749, -0.0107669085, 0.0588090979, 0.0348271839, 0.0271211546, 0.0089806588, 0.0077227624, -0.0370427296, -0.0000001973, -0.0208520181, 0.0108053610, 0.0291453004, 0.0002472544, -0.0151798408, -0.0449609309, 0.0009881231, -0.0115104550, -0.0143701443, -0.0446323454, 0.0149474023, 0.0052626478, 0.0047144135, -0.0129232686, -0.0140054813, 0.0068365862, 0.0070109786, -0.0688768402, 0.0135209989, 0.0288866907, 0.0066560563, -0.0000131498, 0.0292200688, 0.0380363204, -0.0079299891, 0.0220517498, -0.0037952343, 0.0019906745, -0.0325351246, 0.0116757900, -0.0280298106, 0.0182238333, 0.0036148827, 0.0554722622, -0.0380976424, -0.0086737750, -0.0152296834, 0.0135815851, 0.0276017357, 0.0099533163, -0.0131817628, -0.0070457999, 0.0691087767, 0.0090022432, 0.0117333382, 0.0038377279, 0.0000008810, 0.0064749205, 0.0092766797, -0.0199852865, 0.0024050320, 0.0020887526, -0.0028762419, -0.0274934880, -0.0014690487, 0.0000000742, 0.0235487483, -0.0108045982, -0.0034131948, 0.0086233532, 0.0146510545, 0.0034361985, -0.0101640737, -0.0000392357, 0.0114064803, 0.0039900457, -0.0045319656, -0.0065746922, -0.0007319585, -0.0068678809, 0.0330599248, 0.0114846863, -0.0090753119, -0.0013882139, -0.0013686495, -0.0040848064, -0.0123967668, -0.0269552115, -0.0001489892, -0.0169247072, 0.0108015491, 0.0089354925, 0.0047241487, 0.0014092576, -0.0001619642, 0.0000000102, 0.0023580375, -0.0035690279, -0.0087685324, -0.0095982263, 0.0001818598, 0.0062767938, -0.0012866551, 0.0105959522, -0.0146133117, -0.0057445373, -0.0003468841, -0.0021858143, -0.0048677088, -0.0036566101, -0.0223742425, -0.0058723139, 0.0145853190, 0.0016103594, -0.0028214250, 0.0100075314, 0.0007081184, -0.0214938223, -0.0151396217, 0.0006007361, 0.0000000025, 0.0109844822, 0.0144655807, 0.0620045662, 0.0097545721, -0.0034551781, -0.0050364351, 0.0428064130, 0.0315352604, 0.0000003607, 0.0057666851, -0.0914482400, 0.0130371070, -0.0008549051, 0.0000273004, 0.0002975664, 0.0087294783, 0.0000042490, -0.0016366820, -0.0103968596, -0.0058237948, 0.0000115494, 0.0047615664, 0.0039182659, -0.0030137966, -0.0172489621, 0.0099613946, 0.0211685784, -0.0008125288, 0.0060228212, 0.0000647471, 0.0025222497, 0.0214879084, -0.0174606815, -0.0245094653, 0.0016666020, 0.0047599445, -0.0009632303, 0.0002664376, 0.0000000001, 0.0064171087, -0.0115343425, -0.0296196211, -0.0014577979, -0.0003676185, -0.0007322396, 0.0101824319, -0.0104915351, 0.0089361807, -0.0131393559, 0.0000425807, 0.0135834115, -0.0224703085, 0.0007537841, 0.0221579634, 0.0199922193, -0.0206221715, -0.0011310519, 0.0107104816, -0.0039130743, -0.0098329978, 0.0041348590, 0.0242944192, -0.0340477154, 0.0000000523, -0.0084244357, -0.0127725201, -0.0356139094, -0.0142385866, 0.0116128214, 0.0086900070, -0.0156644247, -0.0233320855, 0.0000138046, 0.0088814544, 0.0520375930, 0.0036346160, -0.0202022977, -0.0132038100, 0.0032656868, -0.0005659185, -0.0000000459, -0.0032522825, 0.0067726793, 0.0121926479, 0.0003670267, -0.0063672685, -0.0171629842, 0.0146631682, 0.0230213609, 0.0136628589, -0.0081036091, -0.0122511536, -0.0278515518, 0.0027035768, -0.0028214608, 0.0051563014, -0.0174946040, 0.0059093875, -0.0005643078, -0.0365233719, 0.0270817783, 0.0154388770, -0.0000004425, -0.0148717342, -0.0180231519, 0.0120741595, 0.0354807004, 0.0002828018, 0.0077133956, -0.0009412502, 0.0056414576, -0.0176656581, -0.0058630034, -0.0041176951, -0.0087754810, -0.0037471130, 0.0286995042, 0.0001681568, -0.0281959996, 0.0022926491, -0.0117530394, -0.0090077380, -0.0138373803, 0.0023781392, 0.0043318523, 0.0144049618, -0.0051162662, 0.0000000730, -0.0005412081, -0.0090391887, -0.0225305036, 0.0005303465, 0.0032085008, 0.0070856190, -0.0180472229, -0.0108308159, -0.0000003076, -0.0076898057, 0.0302854534, 0.0049287272, 0.0043968344, -0.0060029300, 0.0000859110, 0.0150979664, -0.0000000380, 0.0009656489, -0.0099928286, 0.0245818384, -0.0022248561, -0.0082811769, -0.0098870769, 0.0188998058, 0.0053734952, -0.0038926597, -0.0125288442, -0.0063533271, -0.0120952623, 0.0019579737, 0.0039349310, -0.0006533829, -0.0281014629, 0.0114871142, -0.0028155898, -0.0094526028, 0.0241950247, -0.0026894493, 0.0000000236, 0.0002552814, -0.0066683847, 0.0067893262, 0.0186612271, 0.0000835857, 0.0054655918, -0.0103695178, 0.0112098595, -0.0150894737, -0.0034558533, 0.0001680206, -0.0044509652, -0.0289843939, 0.0083947163, -0.0109825376, -0.0113905547, 0.0066529890, 0.0211502761, -0.0126634790, 0.0097757857, 0.0140326740, -0.0149888834, 0.0067132893, -0.0042904937, 0.0000000326, -0.0106395409, -0.0135033904, 0.0120853903, -0.0104582915, -0.0043917550, -0.0063113370, 0.0043924595, 0.0167252310, 0.0000000165, 0.0097945472, -0.0109080495, -0.0043246644, -0.0046704803, 0.0164428726, -0.0029569231, 0.0237575136, -0.0000000117, 0.0163486693, 0.0008588234, -0.0190080907, -0.0049837166, 0.0000458632, 0.0109976484, -0.0070408932, -0.0103637818, 0.0160569903, 0.0174677894, -0.0045924457, -0.0114350514, 0.0025421812, 0.0003646784, 0.0103598274, 0.0008963319, -0.0111649381, -0.0150281088, 0.0051123621, 0.0109878387, -0.0157280844, 0.0000011331, 0.0016087684, 0.0025033769, -0.0055320701, 0.0001894953, -0.0052730078, 0.0073191570, -0.0053653517, -0.0121948943, -0.0000189707, 0.0023533260, -0.0034158886, 0.0101309875, -0.0221018996, -0.0027781532, -0.0177644864, -0.0012111602, -0.0016364510, -0.0072268466, 0.0086544063, -0.0003733170, -0.0244145580, -0.0045942762, -0.0208461359, -0.0055811666, -0.0000000027, -0.0095202522, 0.0277776718, -0.0208416693, -0.0068653920, -0.0012758448, -0.0066246539, 0.0049179881, -0.0043172594, -0.0000001019, -0.0324294828, 0.0189982094, 0.0028101485, 0.0120255295, -0.0353181586, 0.0008231310, -0.0024494808, -0.0000000249, 0.0100971246, -0.0019510229, 0.0040490255, 0.0003102242, -0.0136187440, -0.0281021446, -0.0234318599, -0.0186686255, -0.0163684562, -0.0132440887, 0.0208714381, 0.0004664409, 0.0017624535, -0.0042378665, -0.0048603807, 0.0028357711, 0.0275148973, -0.0142822424, -0.0121420911, -0.0042989044, 0.0103017185, -0.0000000141, 0.0170948170, 0.0244576856, 0.0047787190, -0.0052339546, -0.0035167774, -0.0021247480, -0.0170853119, 0.0037884316, -0.0016181023, 0.0072930274, 0.0006209066, -0.0036762578, -0.0090210475, 0.0016286394, 0.0092151156, -0.0007239127, -0.0018330775, -0.0124693206, -0.0069519007, 0.0043326276, 0.0358110033, 0.0089791808, -0.0095099695, 0.0215983540, -0.0000127768, -0.0127268312, 0.0053524692, -0.0240088403, 0.0030517532, -0.0013561373, 0.0036879466, -0.0273637585, 0.0025841398, 0.0000000660, -0.0024428880, 0.0198788531, -0.0132756894, 0.0101039559, 0.0074426956, -0.0007463762, 0.0109171001, -0.0000001610, 0.0043557291, 0.0174037404, 0.0113334181, -0.0043740617, -0.0164965782, -0.0031922290, -0.0083877835, 0.0050418708, 0.0020751136, 0.0018590650, 0.0148154311, -0.0108464900, -0.0115743708, 0.0016315578, -0.0021934169, 0.0096483221, 0.0075900713, 0.0022534786, 0.0087510962, 0.0011940474, 0.0057931440, 0.0000000597, -0.0071323183, 0.0147468653, 0.0097937929, 0.0070543555, -0.0003778173, 0.0005685913, 0.0042215348, 0.0056387619, -0.0105432933, -0.0025911990, -0.0002393489, -0.0087620784, -0.0217841733, 0.0109170619, -0.0272659753, 0.0057254042, 0.0273246579, -0.0007279047, 0.0066392361, 0.0075579626, 0.0020778193, -0.0381397903, 0.0000340327, 0.0044225478, 0.0000001774, 0.0006152751, -0.0107697900, 0.0010048235, -0.0050045969, -0.0055806004, -0.0093714884, 0.0004130867, 0.0236335862, -0.0000000003, 0.0127743753, -0.0048671532, -0.0205472261, -0.0097518219, 0.0035522534, -0.0009794909, 0.0256677140, -0.0000000001, 0.0123755261, 0.0090210978, -0.0017250003, -0.0133728152, -0.0020101191, -0.0089712925, 0.0001651792, -0.0006448189, 0.0033939169, -0.0050551640, -0.0150745884, 0.0011028193, -0.0036829910, 0.0018646119, 0.0099520041, 0.0023068814, -0.0064766714, -0.0499711111, 0.0101481443, 0.0126836533, -0.0141853821, 0.0000004082, 0.0248095188, 0.0252357591, -0.0209929608, 0.0159370210, -0.0143770827, 0.0139100747, -0.0009418112, -0.0015662009, -0.0011853230, -0.0122762034, -0.0105143506, 0.0089251595, -0.0243183710, 0.0102652414, -0.0144177908, 0.0055986647, -0.0029078503, -0.0013672159, 0.0013960938, 0.0087513132, 0.0210712664, -0.0005887240, -0.0019928042, 0.0019703570, 0.0000000053, 0.0020434589, 0.0088854674, -0.0055279080, -0.0059160236, -0.0016050587, 0.0064519383, -0.0151708582, 0.0029700422, 0.0000008547, 0.0035700083, 0.0180350915, -0.0022082583, -0.0043896027, 0.0126268053, -0.0015748136, 0.0025157605, -0.0000000003, -0.0146301184, 0.0006924516, -0.0159844123, -0.0003005278, 0.0004554780, 0.0026175915, -0.0025413935, 0.0019897034, 0.0260059889, 0.0051636072, 0.0031119571, -0.0011553731, -0.0091501530, 0.0019792530, -0.0074107903, 0.0062391269, 0.0001746066, 0.0077325357, 0.0047587426, 0.0027579188, 0.0015685637, 0.0000000232, -0.0084303888, -0.0021159828, 0.0127692847, 0.0171569213, 0.0000618972, 0.0044498458, -0.0026844523, -0.0153050944, -0.0169674084, 0.0049519041, -0.0000537750, 0.0116090057, 0.0067517511, 0.0050531472, -0.0180450194, -0.0054434538, -0.0029565741, -0.0127417184, 0.0019043711, 0.0071623521, -0.0082317656, 0.0230557770, 0.0126720583, -0.0109334812, 0.0000003937, -0.0003709506, -0.0117023988, -0.0110886088, 0.0254712347, -0.0036462522, 0.0063844342, 0.0151787680, 0.0045764982, -0.0000015970, -0.0244749039, 0.0217239223, 0.0363287218, -0.0055140555, -0.0027757613, 0.0026370219, 0.0146013610, 0.0000001894, -0.0010275443, -0.0069014071, -0.0058342027, 0.0007023664, 0.0080830846, 0.0000141436, -0.0119197983, -0.0104818065, 0.0103859510, -0.0029284118, -0.0040344102, -0.0135533689, -0.0100605311, 0.0131760649, 0.0140669150, -0.0036624044, -0.0118694706, 0.0134404050, -0.0017606926, -0.0044713267, 0.0068812533, 0.0000000077, -0.0177111346, -0.0375657305, 0.0199662540, 0.0443850905, 0.0013670357, -0.0171266571, -0.0031264219, -0.0411400534, -0.0037017425, -0.0154151693, 0.0011155434, 0.0026435119, -0.0256010052, -0.0133329732, 0.0059532844, -0.0031029971, 0.0042538801, 0.0420642681, 0.0071587889, 0.0207336899, 0.0129386401, 0.0045863772, -0.0196487736, 0.0178272836, 0.0000124089, 0.0041820295, 0.0062170196, 0.0135955084, 0.0219389014, -0.0074354792, 0.0042584916, 0.0123956669, 0.0270774476, 0.0000023459, 0.0027137077, -0.0175766107, 0.0014909653, -0.0078708520, 0.0168266241, 0.0000144215, 0.0053983792, 0.0000001661, 0.0049249558, 0.0018018746, 0.0072800848, 0.0002125749, 0.0001667774, 0.0006788870, -0.0152518163, -0.0059079994, 0.0063130134, -0.0062705856, 0.0073199337, 0.0047342661, -0.0009929899, -0.0071360413, -0.0066919331, -0.0014287155, -0.0307115857, 0.0082837362, 0.0053617833, -0.0299820155, 0.0063480022, -0.0000074682, -0.0053365086, 0.0071996031, -0.0006224625, 0.0075439732, -0.0003665576, -0.0051913410, -0.0018570365, -0.0324156918, 0.0133912498, 0.0025280553, 0.0001678878, 0.0007588041, -0.0089361575, -0.0052330885, 0.0027579807, 0.0043322369, 0.0049332893, -0.0041335421, 0.0118622566, 0.0117326658, 0.0013861163, -0.0051675118, 0.0141151482, -0.0186320320, -0.0000000849, -0.0253035221, -0.0162776597, -0.0360843502, -0.0323296934, 0.0033841189, -0.0008288187, -0.0190102961, -0.0151300589, -0.0000084326, 0.0028027033, 0.0460108370, 0.0196963958, 0.0093575092, -0.0128484331, -0.0033445111, -0.0231871828, 0.0000000630, -0.0062446315, 0.0121702859, 0.0430744514, 0.0001564063, -0.0030011551, -0.0197281819, -0.0112084262, 0.0079104677, 0.0064891074, -0.0236692466, -0.0004910851, -0.0351515971, -0.0144292880, -0.0074206712, -0.0022005015, 0.0028019871, 0.0095132720, -0.0140698897, -0.0133785233, 0.0042080232, -0.0063712723, -0.0000001727, 0.0129323918, -0.0020646695, 0.0151384510, 0.0179241337, 0.0008510384, 0.0059021087, -0.0035244026, -0.0089980699, -0.0070920521, -0.0161482487, 0.0000269832, 0.0197612382, -0.0046619545, 0.0099368766, 0.0110109765, -0.0189373326, 0.0223721899, 0.0325240642, -0.0187588800, -0.0073699383, 0.0635792688, -0.0047028628, 0.0005834789, -0.0035669177, 0.0000000002, 0.0055401092, 0.0029351530, 0.0141299935, -0.0109111313, -0.0012857107, -0.0011773639, 0.0120353401, 0.0087020025, 0.0000001779, 0.0067855739, -0.0264251158, -0.0014103506, -0.0075670783, -0.0047783945, 0.0000294024, 0.0110080112, 0.0000000120, -0.0067689065, -0.0060490360, -0.0096547632, 0.0000037438, 0.0005366533, 0.0065000560, 0.0056037926, 0.0022580405, 0.0134551423, 0.0115553048, 0.0017317061, 0.0025135037, 0.0031929540, 0.0019807799, 0.0070211943, -0.0071600424, -0.0081225866, -0.0000659121, -0.0007071774, 0.0026748010, -0.0064752311, 0.0000000015, -0.0114117945, -0.0049025379, -0.0033814770, 0.0068383678, 0.0000618242, 0.0009174605, -0.0022651413, -0.0073225512, 0.0004385311, -0.0043788683, 0.0000129057, -0.0061965222, -0.0071255281, -0.0089895250, 0.0019457232, -0.0005764884, -0.0064296685, -0.0160545930, -0.0035483118, -0.0100682341, -0.0166597124, 0.0051426198, 0.0117058400, -0.0210464429, 0.0000000008, 0.0003402326, 0.0190198962, -0.0409662202, -0.0118994052, -0.0002814654, -0.0021965613, -0.0246576183, -0.0050297626, 0.0000042347, 0.0119211916, 0.0200923085, 0.0062757642, 0.0073660696, -0.0086286133, -0.0051936028, -0.0138165159, -0.0000000168, -0.0014112283, 0.0009403802, -0.0138542745, 0.0005262857, 0.0000918066, -0.0062880786, 0.0029490350, 0.0068512061, 0.0196648017, 0.0010479775, 0.0028377918, -0.0201975945, -0.0008261445, -0.0134212449, 0.0031960534, -0.0021672098, 0.0259269048, -0.0013702379, -0.0121323457, 0.0114586568, 0.0136625608, 0.0000000616, -0.0007500476, -0.0201852787, 0.0192926265, 0.0124390582, 0.0000924615, 0.0111751854, 0.0009910120, 0.0049257823, 0.0066597322, 0.0023905914, 0.0002484598, 0.0148823131, -0.0030814554, 0.0011974499, -0.0177837256, -0.0046908385, 0.0180714224, -0.0046400642, -0.0111879269, 0.0023518372, -0.0073538944, 0.0117586283, 0.0450496450, -0.0432202294, 0.0000000200, 0.0265436452, -0.0200501550, -0.0403750055, 0.0028132610, 0.0037203454, 0.0043929061, 0.0131880902, -0.0169563442, -0.0000002887, 0.0046286127, -0.0041074948, 0.0424504280, 0.0039280262, -0.0371619612, 0.0011196324, 0.0094739338, -0.0000008769, -0.0016779497, -0.0027591949, 0.0120601095, -0.0023250389, -0.0072820131, 0.0111851478, 0.0556012355, 0.0063164458, -0.0322840624, -0.0036804506, -0.0028396547, -0.0306833461, 0.0124066742, -0.0067573274, 0.0269568395, -0.0281215832, 0.0278501436, 0.0142512377, -0.0245868452, 0.0460915826, 0.0151846223, -0.0000000339, -0.0118401702, -0.0653942004, 0.0033878114, 0.0299864318, 0.0018339244, 0.0058424640, -0.0043052458, 0.0416082516, -0.0010152337, -0.0307439864, 0.0012176007, -0.0116488468, -0.0043584062, 0.0114360489, -0.0097860536, -0.0135164615, 0.0240112934, 0.0327310152, -0.0184730496, 0.0187138058, 0.0007166966, 0.0008186063, 0.0023102083, -0.0052747102, 0.0000000292, 0.0053324611, 0.0034378872, -0.0002992102, -0.0023177741, -0.0063634166, 0.0033348568, -0.0242321603, -0.0002449438, 0.0000002889, 0.0151809081, -0.0074594412, -0.0261426084, -0.0313910283, 0.0030157522, 0.0008985846, 0.0217844881, -0.0000000007, -0.0031095294, 0.0082194712, 0.0010804895, -0.0002053663, 0.0009091150, -0.0068006194, 0.0076266793, 0.0130544249, 0.0029172648, 0.0015601206, 0.0076100263, -0.0005254745, -0.0025041937, 0.0152655328, 0.0136178955, 0.0144776013, 0.0093217539, -0.0104922047, -0.0012069616, 0.0208473168, -0.0100566996, 0.0000005858, -0.0072574713, 0.0119465888, -0.0050823949, 0.0108089307, -0.0035066714, -0.0001517414, 0.0053584273, -0.0122613059, -0.0094645116, -0.0143800387, -0.0090444004, -0.0053017186, -0.0069686589, 0.0095060719, -0.0070665651, 0.0040403726, 0.0049603237, -0.0221508816, 0.0148592312, 0.0064094793, 0.0071883854, 0.0060086190, -0.0076166955, -0.0003517708, 0.0000000023, 0.0001415242, 0.0115246065, -0.0089536533, -0.0016505588, 0.0091794245, -0.0013284438, -0.0136968456, -0.0082922811, -0.0000015430, -0.0104612261, -0.0008796904, -0.0056014895, 0.0106190508, -0.0028270972, 0.0011939044, -0.0093423091, -0.0000000032, -0.0011052185, -0.0056525501, 0.0089794360, -0.0004442268, -0.0278072469, -0.0111690387, 0.0005442305, -0.0081926771, -0.0102066174, -0.0035185264, 0.0045796274, -0.0115339542, 0.0010662433, -0.0120625459, 0.0063376790, -0.0086740488, -0.0033317434, 0.0002608411, -0.0029748669, -0.0000761183, -0.0037242929, 0.0000000112, -0.0011517848, -0.0046366602, -0.0009146233, -0.0070587816, 0.0000090056, 0.0051487223, -0.0021188587, 0.0090405652, -0.0085964305, 0.0042493576, 0.0000295455, 0.0010862004, 0.0015222939, 0.0124980863, -0.0122826602, -0.0041621723, 0.0114317490, 0.0076898462, -0.0024329405, -0.0021236185, -0.0011850012, -0.0144335888, 0.0147854928, 0.0115857897, 0.0000018699, 0.0122214323, 0.0159394015, 0.0341426432, 0.0265280101, -0.0112436125, 0.0122235809, 0.0165480878, 0.0177679509, -0.0000029050, 0.0026914640, -0.0151197426, 0.0161667671, -0.0057085864, -0.0201537795, 0.0015844144, 0.0277498383, 0.0000061236, -0.0067367214, -0.0110634901, 0.0038196493, 0.0000954665, 0.0106830811, -0.0125719113, 0.0081634084, -0.0079841129, 0.0023373452, 0.0087019866, 0.0045208912, 0.0043064719, 0.0040728278, -0.0041985386, 0.0167978145, -0.0065067196, -0.0062294677, -0.0071666366, -0.0040142583, 0.0241781864, 0.0017140650, 0.0000000154, 0.0081300121, 0.0127706164, -0.0081295958, 0.0229041036, 0.0009808121, 0.0005861541, -0.0042983475, -0.0001513287, 0.0082450015, -0.0240235422, 0.0002931157, -0.0062404643, -0.0295823682, 0.0027683673, -0.0021328114, 0.0111043509, -0.0206617024, 0.0130564524, 0.0242307335, 0.0006245639, 0.0144632868, 0.0024588422, -0.0047338004, 0.0182756484, -0.0000000020, -0.0251477323, -0.0224356763, -0.0004128895, -0.0255414601, -0.0094788745, -0.0078015816, -0.0020145311, 0.0365077816, -0.0000003210, -0.0124549121, -0.0346744508, -0.0230101719, 0.0146519830, 0.0132718133, 0.0025966677, 0.0120791234, 0.0000001099, 0.0086634308, -0.0017080625, -0.0034133398, -0.0002793425, 0.0015713975, -0.0085950308, -0.0427031368, -0.0132263489, 0.0264190808, 0.0070531471, 0.0047763931, 0.0341912657, 0.0280308872, 0.0089342101, 0.0017493812, -0.0130487876, 0.0122043481, -0.0361622013, 0.0076147076, -0.0240272582, 0.0050023827, -0.0000000110, -0.0004257599, 0.0271488335, -0.0088455211, -0.0008417082, -0.0010309509, -0.0095979422, -0.0000111508, -0.0185821727, 0.0023503688, 0.0198463239, 0.0014343541, 0.0306260698, -0.0175615363, 0.0068915994, -0.0107534006, 0.0088038761, -0.0058709658, -0.0028126880, 0.0070198951, -0.0179834608, -0.0270519704, -0.0388178192, -0.0036190206, -0.0151325837, 0.0000000036, 0.0099261412, -0.0109781912, 0.0363346525, 0.0284076817, -0.0083037950, 0.0147284605, 0.0605134405, 0.0224626865, -0.0000167195, -0.0103257569, -0.0271116178, 0.0276951529, 0.0001835837, -0.0183395743, 0.0027972963, 0.0149633726, 0.0000000025, -0.0166172218, -0.0120707331, 0.0103512956, 0.0003796125, 0.0102419294, -0.0184198972, -0.0010187667, -0.0283767451, 0.0168785919, 0.0020672362, -0.0194290280, -0.0176037531, 0.0096382434, -0.0157348439, 0.0036468760, -0.0130929183, -0.0060544047, -0.0043819780, 0.0122505808, 0.0223140065, -0.0007868583, 0.0000000036, -0.0092625264, -0.0151018063, 0.0029736846, 0.0273767803, 0.0004113079, 0.0035377908, -0.0067830235, -0.0125043178, 0.0208684858, -0.0272716843, 0.0002687632, 0.0136716887, -0.0267027486, -0.0136230271, -0.0021933839, 0.0106341662, -0.0342947431, 0.0266981050, 0.0174597185, 0.0098871766, 0.0223624688, -0.0071232533, 0.0099898307, 0.0153318010, -0.0000000826, -0.0194297303, -0.0024748053, -0.0300758462, -0.0171969011, -0.0043004835, -0.0078239003, -0.0245830920, 0.0005373948, -0.0000015164, 0.0204200745, 0.0278019551, -0.0328706130, -0.0025034344, 0.0215450544, -0.0056921709, 0.0185749717, 0.0000000010, 0.0054917797, 0.0168993305, 0.0099074086, -0.0025210886, -0.0059229801, -0.0003793985, -0.0008691196, 0.0093344366, 0.0122454381, 0.0035222715, -0.0062206327, -0.0004432919, -0.0079811756, 0.0132889124, 0.0143157458, 0.0073704119, 0.0001593962, -0.0430201180, 0.0097201457, -0.0002117167, -0.0187807735, 0.0000002613, 0.0135879591, 0.0378111564, -0.0127982264, 0.0121086463, -0.0025228350, 0.0088478588, 0.0087696211, 0.0017720795, -0.0204921644, -0.0082794446, -0.0093286503, 0.0004189218, -0.0256817117, 0.0239239149, -0.0172228701, 0.0047982479, 0.0315800346, -0.0038513136, -0.0011320139, 0.0022952808, 0.0208579265, 0.0191859305, -0.0134968031, 0.0214525554, -0.0000119296, -0.0140517345, -0.0001316524, 0.0078618405, 0.0301178358, -0.0082634157, 0.0058809966, -0.0121207349, 0.0128787681, -0.0000003689, -0.0117508508, 0.0185498167, 0.0000031376, 0.0102066668, 0.0284267478, -0.0002852338, 0.0152422655, 0.0000002400, 0.0041941404, 0.0005035832, 0.0009204147, -0.0001724570, -0.0040619741, -0.0003571642, -0.0118394224, -0.0023134327, 0.0187079143, 0.0184541345, 0.0128332293, -0.0071026222, 0.0019641211, -0.0135460356, -0.0096293166, 0.0070067709, -0.0082510626, 0.0051958431, 0.0036056251, -0.0084409928, 0.0216855556, -0.0000066165, -0.0170239750, 0.0075757704, 0.0031427564, 0.0098998519, 0.0003086270, -0.0022944633, -0.0003943752, -0.0215027612, 0.0034881569, -0.0017669008, 0.0002070301, -0.0060262140, -0.0333487727, -0.0112920273, -0.0223054942, 0.0027044895, 0.0229886491, 0.0022739368, 0.0205537118, 0.0168672968, -0.0215084162, -0.0106783770, -0.0006954728, 0.0104309497, -0.0000067898, 0.0004948030, -0.0106626274, -0.0026317544, -0.0220752936, 0.0008855810, -0.0115277274, -0.0085048107, -0.0038644343, -0.0000000051, 0.0027699338, -0.0036985152, -0.0171492435, -0.0126187466, -0.0089951549, -0.0057657985, 0.0047665727, 0.0000001604, 0.0047613480, 0.0095532322, 0.0141295344, 0.0002149850, 0.0044510663, -0.0150630493, -0.0083843125, 0.0024951545, 0.0127474703, -0.0079324227, 0.0020612122, 0.0032935466, -0.0050517526, -0.0004860158, 0.0126790879, -0.0026260102, -0.0187118575, -0.0425346717, -0.0016274820, -0.0108627398, -0.0051535601, 0.0000000823, 0.0121236723, 0.0325219296, -0.0166185386, -0.0020672854, -0.0094993673, -0.0029462699, -0.0045781177, -0.0063348096, -0.0123051275, -0.0079836855, -0.0046677520, 0.0037281830, -0.0053082951, 0.0219167676, 0.0107116597, 0.0053459429, -0.0011077763, 0.0087611508, 0.0133096799, -0.0178504176, 0.0250683408, -0.0162723809, -0.0051154299, -0.0052385535, 0.0000000736, 0.0029719551, 0.0196874104, -0.0278476011, 0.0101381307, 0.0008523929, 0.0129801370, -0.0064490600, 0.0065706717, 0.0000018726, 0.0157369524, 0.0183313172, 0.0117211323, -0.0043139202, 0.0029631974, -0.0008255946, 0.0023461641, -0.0000006718, -0.0112652639, 0.0009439118, 0.0127114542, 0.0002440874, -0.0069291592, -0.0266061742, 0.0142370285, 0.0059219413, 0.0183569975, -0.0134576438, 0.0034130176, -0.0065973494, -0.0059264335, -0.0064800740, -0.0077704894, 0.0027955971, 0.0097009335, 0.0071101687, -0.0037410753, 0.0273448601, 0.0071510687, 0.0000014384, -0.0016664224, 0.0003672422, 0.0088547394, 0.0286974441, 0.0001927143, 0.0105455862, -0.0087682381, -0.0043756054, -0.0079566566, -0.0053843441, -0.0051520565, 0.0004218789, -0.0232768226, 0.0097278636, -0.0187479146, -0.0168895032, 0.0118900659, -0.0179990716, -0.0011877320, 0.0074348249, 0.0295919254, 0.0030843199, 0.0046310918, -0.0164156947, 0.0000000144, 0.0154785085, -0.0105913430, -0.0090555828, -0.0533667281, 0.0069819828, -0.0017962102, 0.0122513734, -0.0086912150, -0.0000020697, 0.0144986855, -0.0245051850, -0.0104489448, -0.0410666578, -0.0079981070, -0.0039414437, -0.0206088983, 0.0000000063, -0.0065276935, 0.0119589008, -0.0019659905, 0.0001113189, 0.0002979422, 0.0188557580, -0.0000846304, 0.0151638128, 0.0037265848, 0.0045092665, -0.0027872948, -0.0021287384, -0.0069613275, 0.0170492567, 0.0286424011, -0.0106402589, 0.0168902166, -0.0204472449, -0.0154949939, -0.0319115035, -0.0014150713, 0.0000000023, -0.0298170913, -0.0269951820, -0.0114537803, 0.0031349678, 0.0008429816, -0.0026470372, -0.0047882348, -0.0120617589, 0.0074551436, -0.0077937576, -0.0005715747, -0.0006696081, 0.0372318737, 0.0214264989, 0.0204084478, 0.0061566560, -0.0100861648, -0.0242847893, -0.0200766474, -0.0196075961, -0.0062521035, -0.0038187145, 0.0057374374, -0.0063177235, -0.0000000011, 0.0173936728, 0.0077085886, -0.0122672049, -0.0195516068, 0.0022814902, 0.0031420588, 0.0064857691, 0.0047556981, -0.0000003466, -0.0036848013, -0.0006541850, 0.0205913074, -0.0012517121, -0.0269157030, 0.0019846400, -0.0077577247, -0.0000002854, -0.0109883137, -0.0044889580, -0.0095122503, 0.0011909687, -0.0088479128, -0.0144367162, -0.0084540853, 0.0010986007, -0.0098659806, 0.0069736377, 0.0265249759, -0.0099374726, 0.0174703207, 0.0046344269, -0.0014022207, -0.0105077550, 0.0143929096, -0.0114337290, -0.0069821612, -0.0067079905, 0.0073504648, -0.0000000221, -0.0120759979, -0.0134486165, 0.0008931933, -0.0051592002, 0.0011235480, -0.0044617322, -0.0123963673, -0.0145731643, 0.0234815981, -0.0075090784, 0.0007889633, 0.0072445134, 0.0166280735, -0.0217393320, 0.0047634807, 0.0131368740, 0.0011776402, -0.0270422082, -0.0161305182, 0.0029347409, -0.0049308208, -0.0009567472, -0.0319868438, 0.0417081527, -0.0000088200, -0.0337916687, 0.0074147526, 0.0001035886, -0.0330888033, -0.0049633430, -0.0150180236, -0.0122040873, 0.0065711210, -0.0000105036, -0.0211532470, 0.0111145824, -0.0328527689, 0.0096320137, 0.0051869974, -0.0011219676, -0.0029650177, -0.0000000387, 0.0031873849, 0.0016363364, -0.0061552371, 0.0003361350, -0.0203653108, -0.0059392145, -0.0432561561, -0.0023139669, -0.0084949657, -0.0291120131, 0.0030663386, 0.0473164357, -0.0046864613, 0.0137675209, -0.0244570673, 0.0328470170, -0.0007157916, 0.0122279339, 0.0130838836, -0.0536223426, -0.0075927624, -0.0000124720, 0.0279632173, 0.0659961030, 0.0214397870, -0.0112637235, -0.0149939694, -0.0094291335, 0.0022744741, -0.0074845422, 0.0005607008, 0.0402610302, 0.0020961573, 0.0039186291, 0.0008948588, 0.0029989979, 0.0152182672, 0.0161987059, 0.0144065181, -0.0168846287, 0.0041806735, -0.0187404547, 0.0345086753, 0.0011151335, 0.0203629006, -0.0241537727, 0.0000000242, -0.0118693337, -0.0055849259, -0.0430175476, -0.0079326890, -0.0007607030, 0.0021310858, -0.0097580897, -0.0180724282, 0.0000000198, 0.0107196011, 0.0444214828, 0.0197276026, -0.0027151972, 0.0172256827, -0.0046355459, 0.0044158623, -0.0000000113, -0.0062936991, 0.0022086920, -0.0098949494, -0.0000387774, 0.0030328485, 0.0098665273, 0.0171809979, -0.0064258776, 0.0260969903, 0.0311380867, 0.0043317247, -0.0429630056, -0.0054335664, 0.0057990639, 0.0122384969, -0.0058582197, 0.0066437279, -0.0015094157, -0.0135908555, 0.0255759191, -0.0067352536, 0.0000000699, -0.0136080673, -0.0303866863, 0.0002394655, 0.0090776235, 0.0008118304, 0.0110874576, -0.0109043848, 0.0040003657, 0.0003772854, -0.0145205231, 0.0001735675, 0.0006559279, 0.0008603815, -0.0114264414, -0.0136611303, -0.0073851990, 0.0141818365, 0.0047894907, -0.0227433927, 0.0078271525, -0.0355845354, -0.0139130633, 0.0336894803, -0.0370815210, 0.0000000000, 0.0227694064, -0.0235594753, -0.0193315949, -0.0133026512, 0.0077210795, -0.0006345421, -0.0127933426, -0.0077734636, 0.0000010566, 0.0166743249, -0.0150855631, 0.0217473954, -0.0146411043, -0.0383494943, 0.0031261679, -0.0091280499, -0.0000002301, -0.0047260774, 0.0086417943, 0.0227530710, 0.0000048861, 0.0013276925, -0.0101304613, 0.0375886261, 0.0106984898, 0.0104297707, -0.0258641466, -0.0090709208, -0.0141211264, 0.0121839512, -0.0362107493, 0.0072628795, -0.0178259443, 0.0107611176, 0.0001129396, -0.0151128257, 0.0371116772, 0.0014122867, -0.0000194862, -0.0056920731, -0.0214999057, 0.0056952331, 0.0336010531, -0.0001942226, 0.0133983744, 0.0039633750, 0.0296824612, -0.0197231956, -0.0056106034, 0.0000086828, 0.0011855462, -0.0118237175, 0.0386966877, -0.0075951419, -0.0154455872, 0.0009007500, 0.0044223247, -0.0123068364, -0.0058153211, 0.0453591794, -0.0101696076, 0.0282177106, -0.0348963402, -0.0000000002, -0.0002985168, -0.0250629187, -0.0111561120, 0.0223631766, 0.0092716292, 0.0175301004, 0.0159915388, -0.0060421433, 0.0000006898, -0.0125331180, 0.0402053036, 0.0503138192, -0.0251502227, -0.0339768752, 0.0005426336, 0.0068878531, 0.0000009706, -0.0170847047, 0.0022716071, 0.0247629154, 0.0002491967, 0.0113035673, -0.0055322517, -0.0019457553, -0.0005080913, -0.0000927023, -0.0157392249, -0.0153129539, -0.0401059948, 0.0210667923, 0.0015512535, 0.0078410292, -0.0006761951, -0.0279569458, 0.0097174896, -0.0180941597, 0.0227396581, 0.0018614577, -0.0000001072, -0.0297583286, -0.0664074346, 0.0270006824, 0.0603655167, 0.0001665508, -0.0024046618, -0.0177345201, -0.0165161137, -0.0007485655, -0.0290882904, 0.0014906026, 0.0038653612, 0.0163303129, 0.0194776151, 0.0140967937, -0.0178069305, -0.0276622921, 0.0278255008, -0.0009829061, 0.0051052631, 0.0509009063, 0.0115605043, -0.0158328768, -0.0042295721, 0.0000000305, -0.0071010636, 0.0085112723, -0.0379550308, -0.0035855684, 0.0050992756, 0.0049203685, -0.0180384163, -0.0189642031, -0.0000000119, -0.0146061163, 0.0524210446, -0.0141297365, -0.0067360671, -0.0219680164, -0.0060532806, -0.0192442257, -0.0000001391, -0.0015525991, 0.0163448248, 0.0264194570, 0.0002712370, -0.0149198910, -0.0309303179, -0.0024306667, 0.0052000335, 0.0010879156, -0.0345140323, 0.0017454913, -0.0026252288, -0.0088606533, -0.0184248276, -0.0053056660, 0.0010067765, 0.0195076223, 0.0041671582, -0.0146353673, -0.0174610876, 0.0102009540, 0.0000130021, 0.0029903369, 0.0117409816, 0.0172719657, 0.0038029719, 0.0002031142, 0.0110598067, -0.0032889389, -0.0014719988, -0.0154862646, 0.0189524218, 0.0000870491, -0.0099199573, -0.0026448914, 0.0188433602, 0.0029975306, -0.0181693174, 0.0033651036, -0.0055305455, -0.0036083527, 0.0010530609, 0.0328522772, -0.0309548546, -0.0295797195, 0.0354094915, -0.0000016408, 0.0120559670, 0.0124925692, -0.0149651216, 0.0034386495, -0.0080243656, -0.0137567492, -0.0190283060, 0.0179839805, -0.0000110516, -0.0295327436, 0.0455303751, -0.0436447412, -0.0300151799, -0.0207275916, -0.0107031520, 0.0065523982, 0.0000001089, 0.0087446971, 0.0286276154, 0.0463574454, 0.0009532218, -0.0106932726, -0.0442213416, -0.0281559099, 0.0015998853, -0.0072603375, -0.0659725815, 0.0138640180, 0.0211261455, -0.0087307980, -0.0009956546, -0.0157241281, 0.0263286717, 0.0004139846, -0.0368439667, 0.0280390866, -0.0540598482, -0.0000814068, -0.0000006582, 0.0389788374, 0.0758243725, -0.0036002477, 0.0176682994, -0.0088825766, -0.0047085956, -0.0114707826, -0.0361296795, -0.0146951647, 0.0037362739, 0.0013116141, 0.0199864730, 0.0120727262, 0.0215155650, 0.0109408582, 0.0103278020, -0.0100579727, -0.0111439358, 0.0168802012, -0.0009107180, 0.1299220920, 0.0019911730, 0.0132490378, 0.0019540892, 0.0000000001, 0.0091953427, 0.0032190806, -0.0150670810, 0.0008640039, -0.0000688319, -0.0017529094, -0.0079479190, -0.0011896404, 0.0000000307, -0.0042199590, 0.0005940029, 0.0013033029, 0.0033153135, 0.0007544612, 0.0008756636, 0.0002848220, 0.0000000006, -0.0008093931, -0.0032324102, -0.0186356399, 0.0001659660, -0.0001111636, -0.0004932545, 0.0120013105, 0.0074314768, -0.0144143524, 0.0072927908, -0.0003687526, -0.0025779766, 0.0004323203, -0.0046187998, -0.0081606274, -0.0116659598, -0.0027931174, 0.0017963353, 0.0004336672, 0.0055380338, -0.0031362190, 0.0000000328, -0.0008392554, -0.0034400867, 0.0008007574, -0.0010756730, -0.0000379280, -0.0036919855, -0.0020944993, 0.0036721053, -0.0026235946, 0.0010161201, 0.0000276651, 0.0147043522, -0.0073697167, 0.0019019850, -0.0051789610, 0.0011790702, -0.0078433501, 0.0020530275, 0.0060420181, 0.0031188454, -0.0043377005, -0.0085046273, -0.0137617514, -0.0009435804, 0.0000000000, 0.0007855271, -0.0031591731, 0.0156948026, -0.0042437236, 0.0002848104, -0.0007643282, 0.0259655621, 0.0155440262, 0.0000000201, 0.0014278836, -0.0254261978, 0.0005677372, -0.0018839111, -0.0005772968, 0.0012388618, -0.0040572621, 0.0000001082, 0.0059821820, -0.0070175515, 0.0025933105, 0.0000020643, -0.0000105054, 0.0006742018, 0.0091382945, -0.0052485000, -0.0055612233, 0.0007700929, -0.0025584945, 0.0005047419, 0.0051119365, -0.0028006311, 0.0090089887, -0.0136601357, -0.0086076828, 0.0030958452, -0.0004845512, -0.0101039894, -0.0028580632, 0.0000000000, -0.0096258270, -0.0069845668, -0.0104508912, -0.0044351132, -0.0001820504, 0.0025667616, -0.0030306273, 0.0008987802, 0.0080940593, -0.0065995143, 0.0000420695, 0.0114001604, -0.0005866642, -0.0010105607, -0.0010457478, 0.0033795680, -0.0089590205, -0.0050030863, 0.0001036221, -0.0078565450, -0.0078489790, 0.0134928431, -0.0058789067, -0.0088862935, 0.0000000014, -0.0110851694, -0.0401274636, -0.0193293076, -0.0062470459, 0.0014326258, 0.0048073437, 0.0126749622, -0.0070225326, -0.0000000787, 0.0183878671, 0.0118219750, -0.0043465095, 0.0272845905, 0.0040966342, 0.0011108271, -0.0200542752, -0.0000791436, -0.0196038671, 0.0132402498, 0.0161488298, -0.0019941060, -0.0035632316, 0.0018389967, 0.0162203386, -0.0083575798, 0.0075671086, 0.0032219626, 0.0041740299, -0.0290372968, -0.0135804657, -0.0140713211, 0.0219297651, -0.0033741298, -0.0024537242, -0.0018009503, -0.0118254190, 0.0112632131, -0.0117804948, -0.0000530826, 0.0017112666, -0.0272609964, 0.0058691120, -0.0143845836, 0.0003798464, 0.0268470515, -0.0014989900, 0.0201416258, -0.0001096333, 0.0003831368, 0.0001726628, -0.0158475935, -0.0048173992, -0.0247153696, 0.0092323897, -0.0147610782, 0.0370658971, 0.0182287041, -0.0152651733, 0.0125840260, -0.0189650767, -0.0105101727, 0.0039240406, -0.0079790624, 0.0000000001, -0.0001868223, -0.0100110909, -0.0016718947, 0.0015574733, 0.0030840337, -0.0000656530, 0.0126115037, -0.0025634898, -0.0000000252, 0.0001433112, 0.0021835491, 0.0042852042, 0.0199800134, -0.0092860665, 0.0014095757, -0.0029109113, -0.0000000996, -0.0071814088, -0.0014157521, -0.0093205227, 0.0000856035, 0.0006586739, -0.0111343060, 0.0062503712, -0.0047395299, 0.0079224026, -0.0002334256, -0.0101044290, -0.0187571254, 0.0007672460, -0.0050299033, 0.0059911297, -0.0120346388, -0.0120373955, -0.0051955041, -0.0030395105, 0.0157055873, -0.0103205387, 0.0000000000, 0.0052102343, 0.0001838934, 0.0032554751, 0.0046463786, -0.0000419954, 0.0009170719, -0.0032842802, 0.0048851059, -0.0014355173, -0.0052040671, -0.0000798924, 0.0058272779, -0.0132139996, 0.0061165732, 0.0006653089, -0.0047299685, -0.0058181216, 0.0212026462, -0.0035416419, -0.0085732425, 0.0087198801, -0.0055881976, 0.0026918249, 0.0103687756, 0.0000000001, 0.0102801761, 0.0013632567, -0.0272696055, 0.0000409913, -0.0039598495, -0.0062786625, -0.0062213670, 0.0146533092, 0.0000000033, 0.0124626812, 0.0108998297, -0.0016450096, 0.0031039075, 0.0062877089, 0.0017099157, -0.0002076356, -0.0000010023, 0.0125818448, 0.0107205333, -0.0304140951, -0.0024782154, -0.0085854335, -0.0002726799, 0.0284801330, 0.0122047132, -0.0086427443, 0.0094681093, -0.0015603171, -0.0035331019, -0.0047747786, -0.0151015325, 0.0004170731, -0.0053904597, 0.0081150131, 0.0059229685, 0.0029323243, 0.0140641443, 0.0031255749, 0.0000000100, 0.0031621358, -0.0049728635, 0.0030566489, -0.0032923103, -0.0014368709, 0.0199541245, -0.0020541945, 0.0093860738, 0.0012390396, 0.0029507498, -0.0001364223, 0.0136731146, -0.0199578684, -0.0139686763, -0.0138989640, -0.0065520224, -0.0065444424, -0.0011656274, -0.0041556014, 0.0167596526, -0.0092735272, 0.0155552728, 0.0094466666, 0.0026563052, -0.0000000000, 0.0093237078, 0.0024113350, 0.0066051860, 0.0057539670, -0.0001602956, 0.0010485880, -0.0229906887, 0.0063977269, -0.0000001888, -0.0245211869, -0.0016283626, -0.0044383220, 0.0171009097, 0.0087493965, -0.0022245655, 0.0089715645, 0.0000000109, -0.0078026257, 0.0068457373, 0.0163543653, -0.0042814431, 0.0021498636, 0.0049994397, -0.0122661591, 0.0077695837, 0.0008415476, -0.0047842497, -0.0083749145, 0.0086424090, 0.0052284733, 0.0069070654, -0.0177486185, 0.0079358388, -0.0148748662, -0.0021337285, 0.0074176444, -0.0193559378, -0.0190950669, -0.0000000000, 0.0048992769, 0.0065452214, 0.0026407414, 0.0031100491, -0.0032216136, 0.0012115870, 0.0033757144, -0.0049988246, -0.0033108611, 0.0110437442, -0.0000275152, 0.0169503111, 0.0067330678, 0.0167046115, -0.0113146333, 0.0057821162, -0.0150850862, 0.0115039572, 0.0216819551, -0.0034081566, 0.0131725455, 0.0055443337, 0.0124308243, -0.0043913443, 0.0000000001, -0.0055161370, 0.0005266155, -0.0033208625, -0.0032271917, -0.0011282406, -0.0000570335, -0.0171311069, -0.0045863856, 0.0000005067, 0.0096823042, 0.0065133772, -0.0057310737, -0.0104098888, 0.0050355252, 0.0016470974, 0.0176285040, 0.0000000001, -0.0019913374, -0.0048348228, -0.0137690818, 0.0002462230, -0.0014379562, -0.0086655188, 0.0097822016, 0.0139679136, 0.0144478045, 0.0048300968, -0.0005727210, -0.0022146869, -0.0005379546, 0.0014998133, 0.0022847091, -0.0061093662, -0.0035800394, -0.0035508382, -0.0010172125, 0.0159159936, -0.0072125741, 0.0000000018, -0.0012623871, 0.0106207179, 0.0009270032, 0.0113965794, -0.0000609448, -0.0024052565, -0.0029779829, -0.0066647748, -0.0097907018, -0.0043250914, -0.0004883349, 0.0003589077, -0.0075451806, -0.0006156006, -0.0154305669, -0.0070658382, 0.0003953455, -0.0121698529, 0.0010278258, -0.0000023919, -0.0103464229, 0.0007399530, 0.0131168710, 0.0007807623, 0.0000000003, 0.0066763982, 0.0140912263, -0.0261607245, 0.0041433419, -0.0000715093, -0.0041988613, -0.0303526949, -0.0046525155, -0.0000006198, -0.0037480390, 0.0053191488, -0.0058645583, 0.0065197716, 0.0087387236, 0.0024733949, 0.0040753693, -0.0000000420, 0.0117991706, -0.0032642058, -0.0199103057, -0.0030087498, -0.0153440721, -0.0080690365, 0.0187992118, -0.0013703981, -0.0153722633, -0.0046389103, -0.0029274460, -0.0005418014, -0.0004518244, -0.0056536463, -0.0045410856, -0.0095472969, 0.0096725700, 0.0073676612, -0.0003744174, 0.0050807041, -0.0201995876, 0.0000000016, 0.0085022962, -0.0005193098, 0.0033077393, -0.0009665094, -0.0004653388, 0.0139658311, -0.0053372360, 0.0012509994, -0.0092483433, 0.0130760521, -0.0000095128, 0.0234151464, -0.0187945701, 0.0117263515, -0.0226172060, -0.0059187356, -0.0157465991, 0.0048278398, 0.0046331892, 0.0057518687, 0.0071994737, 0.0111328047, -0.0009919649, -0.0012649011, 0.0000000000, -0.0139707485, -0.0188300293, -0.0130980378, -0.0023301793, -0.0026770942, -0.0023689352, -0.0163296312, -0.0086582294, 0.0000000156, 0.0206572600, 0.0111907087, -0.0061876057, -0.0009492977, 0.0135510601, 0.0013970881, -0.0062657180, 0.0000002271, -0.0109490938, -0.0065150741, -0.0083829742, -0.0000605088, -0.0000440538, -0.0133666731, 0.0043998905, 0.0077626212, 0.0188158024, -0.0087716272, -0.0077223480, 0.0060696034, -0.0000324985, -0.0098909028, 0.0035019689, -0.0024361704, 0.0052056364, 0.0040145805, -0.0023464640, -0.0019891185, -0.0031844447, -0.0000082500, -0.0026151524, 0.0243830010, 0.0009799753, 0.0040454683, -0.0000847065, 0.0035235563, 0.0040464522, -0.0016563317, -0.0080131507, 0.0080125136, -0.0005040247, 0.0057580918, -0.0123704849, -0.0118507892, -0.0021125914, -0.0079589821, 0.0243449342, -0.0042375927, -0.0042308364, 0.0101460991, 0.0033422993, 0.0014416266, 0.0047390764, -0.0049095131, 0.0000000009, -0.0028754473, -0.0043779076, 0.0135943582, -0.0066422597, 0.0017111903, -0.0004070687, -0.0053350604, 0.0161754321, 0.0000001360, -0.0007232339, 0.0112428414, 0.0126692606, 0.0007412750, -0.0233895555, 0.0003889156, 0.0023460886, 0.0000000589, -0.0081246803, -0.0147057083, -0.0079241032, 0.0002711234, 0.0043057101, -0.0210595690, -0.0100723524, -0.0008134157, 0.0232038908, -0.0232818685, -0.0151040675, -0.0004777420, 0.0197851453, -0.0112422640, 0.0146358050, -0.0149064539, 0.0048884745, 0.0129206749, -0.0019908627, 0.0054031960, 0.0007126440, 0.0000000001, -0.0079402784, 0.0000467166, 0.0045688725, 0.0312166680, 0.0016345911, -0.0105518997, -0.0067603774, -0.0036688924, -0.0042326609, 0.0053291391, -0.0008268630, 0.0055207266, -0.0144982021, 0.0186839830, 0.0139960032, -0.0063433358, -0.0119523620, -0.0005788387, -0.0028006348, -0.0020711180, 0.0353999697, 0.0063497215, -0.0087034544, -0.0023309542, 0.0000000000, 0.0042184750, 0.0019984979, 0.0250079893, -0.0021003885, 0.0010063249, 0.0121898456, 0.0218123589, 0.0183059964, 0.0000005299, -0.0071469280, -0.0164933931, -0.0022955374, -0.0075939312, -0.0070176185, -0.0009481750, 0.0034792088, 0.0000004591, -0.0074634622, 0.0003997147, 0.0114034358, 0.0000351859, -0.0022935446, 0.0035578003, -0.0108356485, -0.0009971771, 0.0061144037, -0.0011573766, 0.0043593082, 0.0031776931, 0.0041182321, 0.0081949476, -0.0028385269, 0.0059213866, -0.0042578033, 0.0057977689, 0.0069526173, -0.0128780920, -0.0194746330, 0.0000000000, -0.0084746359, 0.0005679431, -0.0077956524, 0.0137719475, 0.0000050719, -0.0125278607, -0.0002111307, -0.0141740451, 0.0034852910, -0.0004180976, -0.0002498167, 0.0089314040, 0.0104800481, 0.0107983137, 0.0107356086, 0.0002503656, -0.0111972624, -0.0162815060, -0.0032597641, 0.0114531731, 0.0094075324, 0.0172755886, -0.0109272599, -0.0054813726, -0.0000000008, -0.0110930679, 0.0098327026, -0.0061499570, 0.0121280719, 0.0121536423, 0.0083503239, -0.0251255296, -0.0137272840, 0.0000026795, -0.0291811880, 0.0345744826, 0.0056953384, 0.0203973819, -0.0142631521, 0.0012606826, -0.0226959046, 0.0000000061, 0.0039755814, -0.0036805556, 0.0334356129, 0.0004166848, -0.0176915787, -0.0139220636, -0.0195457991, -0.0172682982, -0.0210550521, -0.0436276570, 0.0001389449, -0.0186642800, 0.0054699355, -0.0153701100, -0.0049580350, 0.0006460898, -0.0059652054, 0.0081574693, -0.0047300062, 0.0085214544, -0.0205287021, -0.0000000040, -0.0078827366, -0.0180985183, 0.0127144968, 0.0018766746, -0.0002735778, 0.0031282208, -0.0052027591, -0.0070956619, -0.0118498476, 0.0068298839, -0.0010470094, -0.0027430290, 0.0077525326, 0.0247097574, -0.0090076718, -0.0053751864, 0.0033229419, 0.0161062758, 0.0071076648, -0.0042729801, 0.0450515784, 0.0059897099, -0.0071257176, 0.0015473498, 0.0000000000, -0.0097509027, -0.0223600399, -0.0078859990, -0.0018931754, -0.0009109763, -0.0009732632, 0.0066083143, 0.0057322448, 0.0000000009, 0.0071693566, 0.0046637086, 0.0014018879, 0.0058417148, 0.0079581011, 0.0003693525, -0.0040180231, -0.0000008722, 0.0024798014, 0.0089167682, 0.0013031363, 0.0000033741, -0.0004475469, 0.0092116296, -0.0065224757, -0.0024611091, 0.0018360737, 0.0034775320, 0.0007866073, -0.0121903913, 0.0024169111, -0.0160576627, 0.0083675729, -0.0031950304, 0.0041275294, 0.0022886726, -0.0015524954, -0.0053287987, -0.0005057681, 0.0000003413, -0.0121056773, -0.0014183342, -0.0018839075, -0.0032803293, -0.0000665435, 0.0074327928, 0.0028865596, -0.0017369483, -0.0032566108, 0.0055029825, 0.0000158504, 0.0037617430, -0.0025098466, -0.0177790578, -0.0084303720, -0.0007766770, 0.0083101066, -0.0021748689, -0.0045621865, 0.0132467393, -0.0114397267, 0.0033925823, -0.0142931379, -0.0039019536, 0.0000000001, 0.0012664014, -0.0038346152, -0.0029770625, 0.0035447618, -0.0027488503, 0.0015289536, -0.0121286148, 0.0093201231, -0.0000003295, 0.0103197787, -0.0028105699, -0.0146520464, 0.0018986549, -0.0018720600, 0.0022600826, -0.0125669297, -0.0000028741, -0.0138409045, 0.0128610888, 0.0008778236, -0.0008027329, 0.0011970517, -0.0180660468, 0.0139258448, 0.0195839740, -0.0091741290, -0.0085774884, 0.0023523117, 0.0068829274, 0.0021138738, -0.0204543266, -0.0187195074, -0.0046829130, -0.0064667980, 0.0076977522, 0.0050504715, 0.0084869927, -0.0135706328, -0.0000076113, -0.0044640382, 0.0130991396, 0.0082371589, 0.0013336433, -0.0003294561, 0.0186868645, -0.0022067984, 0.0010894476, -0.0066090925, -0.0017572439, -0.0005098486, -0.0068810387, 0.0013852759, -0.0095227901, -0.0057443278, -0.0187852588, 0.0169470944, -0.0093012070, 0.0035580446, 0.0122515699, 0.0192286484, 0.0003473667, 0.0298079755, -0.0177695695, 0.0000000000, 0.0040012635, -0.0156484712, -0.0075578359, -0.0059407060, 0.0044321949, -0.0002102580, -0.0139691681, -0.0095615853, -0.0000072020, -0.0031335480, 0.0296001639, 0.0200523883, 0.0126344571, -0.0141498642, 0.0017022134, -0.0005734100, 0.0000000000, -0.0031315291, 0.0126257520, 0.0050850571, 0.0002423978, 0.0053889337, -0.0136793377, 0.0070882589, -0.0108022140, 0.0129524861, -0.0078209303, -0.0176464301, -0.0208634343, 0.0017169514, -0.0080463523, 0.0195506513, -0.0242619589, -0.0048985742, -0.0250559747, -0.0165689159, 0.0097214626, 0.0025150569, 0.0000000000, 0.0034567877, -0.0240928493, -0.0069257682, 0.0153774759, 0.0006436611, 0.0026243993, 0.0005998019, 0.0034409601, -0.0082031852, -0.0070992950, -0.0013624855, 0.0176960621, -0.0041180961, 0.0129511589, 0.0010320428, 0.0112361135, -0.0166636072, 0.0412955247, -0.0070901979, -0.0042761746, 0.0066582630, 0.0147999208, 0.0023569528, -0.0016111074, 0.0000000019, -0.0151948426, -0.0197680239, -0.0151569452, -0.0028405690, 0.0004398562, -0.0013813087, 0.0064438833, -0.0074198577, 0.0000002030, 0.0147061935, 0.0002052229, -0.0041140458, 0.0038339922, 0.0192915220, 0.0017070402, -0.0029070505, 0.0000000006, -0.0045437901, -0.0058306232, 0.0021791428, -0.0011512417, -0.0015746759, 0.0095734224, 0.0002867808, -0.0042748060, 0.0223040488, 0.0023369752, -0.0079812696, -0.0147220427, -0.0168855824, 0.0050517591, 0.0131528433, -0.0002782622, -0.0016912615, 0.0001789702, -0.0030206293, -0.0026690795, 0.0007784438, -0.0000177426, -0.0065368041, -0.0017728475, -0.0046935584, 0.0029852225, -0.0000844230, 0.0051034936, 0.0017664607, -0.0083922911, -0.0046757581, 0.0057604979, 0.0000416345, 0.0047778916, -0.0046482477, -0.0181287620, -0.0182357337, 0.0033987102, 0.0189932585, 0.0025357334, -0.0062993350, 0.0140007120, -0.0197986197, -0.0063000401, -0.0033573662, 0.0010172321, 0.0000000001, 0.0009852675, -0.0031417992, 0.0061064670, 0.0002593026, -0.0001656773, 0.0029316323, -0.0036306290, 0.0001397039, -0.0000000901, 0.0005691716, 0.0051756622, 0.0011540570, 0.0092048058, 0.0010656130, 0.0005416141, -0.0028172713, 0.0000002469, -0.0003087019, -0.0031608471, -0.0067461380, -0.0022386701, 0.0000219778, -0.0032780229, -0.0022942310, -0.0055136094, 0.0039390563, -0.0027037770, -0.0023989216, -0.0034553942, -0.0005042057, -0.0058782073, -0.0004106978, -0.0026645456, -0.0017071156, 0.0020395331, -0.0014515753, 0.0024076931, 0.0011437926, 0.0000000000, 0.0013525725, -0.0001304331, 0.0091504678, 0.0002439757, -0.0000784651, 0.0071755191, -0.0021503202, -0.0003604173, -0.0019132242, 0.0056672883, 0.0000208710, 0.0038051913, -0.0057089245, 0.0029858425, -0.0071566361, -0.0014209271, -0.0105263414, 0.0102276281, 0.0060275923, -0.0018174142, 0.0023031391, -0.0096329749, -0.0163043644, -0.0064866715, 0.0000000002, -0.0055790339, -0.0075998167, 0.0176275782, 0.0011432626, 0.0038733559, -0.0038859041, 0.0187753998, 0.0116581237, 0.0000000053, -0.0006350200, -0.0270827692, 0.0021658631, 0.0057054157, 0.0117095718, 0.0011374532, 0.0011802758, 0.0000000261, 0.0101828612, -0.0105083492, -0.0010751832, 0.0000136372, 0.0021830152, 0.0001518210, -0.0016915845, -0.0172027200, 0.0167344604, 0.0064435923, -0.0045525399, -0.0065048723, 0.0015795265, -0.0036957166, 0.0010127404, -0.0145028876, -0.0098977182, -0.0022544891, -0.0008697936, -0.0028548916, -0.0033072305, 0.0000000014, -0.0001088341, -0.0017388529, -0.0113720931, -0.0017535494, -0.0000670400, 0.0005521644, 0.0013952894, -0.0020319060, 0.0032262132, -0.0029513657, -0.0001271179, 0.0141321095, -0.0071016941, -0.0051488373, 0.0032336505, -0.0008208626, -0.0065232497, 0.0039614844, -0.0019675766, -0.0012708877, -0.0108651174, 0.0209048744, 0.0228244532, -0.0127457296, -0.0000000000, 0.0110319266, -0.0054217274, -0.0046449490, 0.0054886388, -0.0061770976, 0.0077732038, -0.0007106383, 0.0116588864, 0.0000004135, -0.0299294218, -0.0159029197, -0.0093611032, 0.0151948938, 0.0041604144, -0.0004754857, 0.0110209957, 0.0000004676, 0.0090698935, 0.0030653863, 0.0085103121, -0.0028861102, 0.0018588756, 0.0026648138, -0.0147188772, 0.0090799425, -0.0050917324, -0.0114356847, -0.0000419074, 0.0046815141, 0.0102207940, 0.0026933542, -0.0280127879, -0.0032197908, 0.0061074737, 0.0073983585, 0.0068573272, -0.0105574504, -0.0452264696, -0.0000000003, -0.0038874908, -0.0111885089, -0.0019886382, 0.0114822397, -0.0003764993, -0.0161846317, -0.0109707071, -0.0114582516, -0.0092638480, 0.0165698994, 0.0012103326, 0.0369146839, 0.0120947817, 0.0229783207, -0.0027656222, -0.0045393514, -0.0266220607, -0.0005070753, 0.0176431239, 0.0055997218, 0.0208268501, -0.0016967860, -0.0217846241, -0.0043867510, 0.0000000001, -0.0018045156, -0.0065484797, -0.0016384193, 0.0259006042, 0.0086573903, -0.0017852839, 0.0022625295, 0.0062061613, 0.0000000061, -0.0182560235, 0.0019690455, 0.0026321339, 0.0319568291, 0.0087637631, 0.0034802435, -0.0233720988, -0.0000000001, 0.0087693762, -0.0140370103, -0.0034983414, 0.0005394358, 0.0023101263, -0.0225373134, 0.0197680704, -0.0260691028, -0.0054248958, -0.0243239235, -0.0097364243, -0.0014411118, 0.0000184848, -0.0144132804, -0.0105095981, -0.0152560696, -0.0189171545, 0.0016215567, -0.0012522785, -0.0174696743, -0.0095894681, 0.0000000000, 0.0051677721, 0.0008541016, -0.0212521665, -0.0033518872, 0.0004395870, 0.0118185123, 0.0002938993, 0.0087323766, 0.0000133103, -0.0069305305, 0.0010035976, 0.0272863880, -0.0029377334, 0.0013352425, 0.0095169023, -0.0061693350, -0.0075581446, 0.0327809528, -0.0021044244, 0.0054608532, 0.0342223831, 0.0070285625, 0.0053721629, 0.0064976090, 0.0000000000, -0.0035583428, 0.0042194901, -0.0283333678, 0.0035148934, -0.0047771777, -0.0077102012, -0.0296716820, -0.0071172290, 0.0000000374, 0.0186584704, 0.0118928486, -0.0083119590, 0.0084524304, 0.0197091922, 0.0001462786, 0.0042845383, -0.0000060259, 0.0045061340, 0.0012880267, -0.0174610149, -0.0041800928, -0.0075259553, -0.0037710345, 0.0160579067, 0.0052682343, -0.0034031551, -0.0025355555, -0.0018686284, 0.0101177730, -0.0095170857, -0.0041258074, -0.0047214418, 0.0030611984, 0.0235155821, 0.0079994863, 0.0038490556, 0.0053371969, -0.0115592135, -0.0000000153, 0.0163448639, 0.0165133551, 0.0109602269, -0.0086136861, -0.0013684494, 0.0112370532, 0.0022371851, 0.0121477097, -0.0092387395, 0.0185871869, -0.0030990001, 0.0021715751, -0.0177484844, -0.0058802278, -0.0297816806, -0.0070020356, 0.0115212183, -0.0069459062, -0.0004551998, 0.0052399351, -0.0116215711, -0.0053011496, -0.0039154002, -0.0025310908, 0.0000000002, 0.0060204142, -0.0085953614, 0.0268964656, -0.0008696817, -0.0016201522, -0.0013132914, 0.0151048545, 0.0200049672, 0.0000004945, 0.0023981296, -0.0256498698, -0.0109422505, -0.0078781825, 0.0016242884, 0.0003019822, 0.0155229047, -0.0000011628, -0.0166627411, -0.0017821379, -0.0224546902, 0.0000031342, 0.0008813368, -0.0038993789, 0.0071502100, 0.0021284665, 0.0118578924, 0.0091595957, -0.0023038192, -0.0056483094, 0.0010084417, 0.0003487614, 0.0098055713, -0.0004749867, -0.0141294785, 0.0095252134, 0.0010682398, 0.0098585030, -0.0167351961, 0.0000000000, -0.0057109515, 0.0097702667, -0.0038942213, 0.0087289121, -0.0000336706, 0.0022404024, -0.0036822408, -0.0053556315, -0.0024744815, -0.0023136432, -0.0028519284, 0.0033278957, -0.0098675927, -0.0039955550, 0.0032661855, -0.0112326527, -0.0195620283, -0.0136710098, 0.0030392706, 0.0062805088, -0.0080189565, -0.0099264048, -0.0100468546, 0.0042832321, 0.0000000008, 0.0127362162, 0.0154349338, -0.0141220661, 0.0104493266, 0.0017800361, 0.0005545029, -0.0032398927, 0.0130492719, 0.0000011541, -0.0098419851, 0.0046829418, 0.0084432457, 0.0121399527, -0.0073638475, -0.0001489792, -0.0007135726, -0.0000000931, 0.0030865364, 0.0027877069, 0.0221784618, -0.0013540135, -0.0138906520, -0.0160104670, -0.0073610703, -0.0132930148, 0.0045890468, -0.0305881221, -0.0109213768, 0.0068552853, 0.0009316246, -0.0038514638, -0.0072485311, 0.0048821331, 0.0181655977, 0.0031230971, 0.0017282388, 0.0020137434, -0.0267156903, 0.0000000032, 0.0088673476, 0.0124875242, -0.0028700831, 0.0123946089, -0.0001890397, 0.0032978524, 0.0064923959, 0.0029245273, -0.0065551857, 0.0162722860, 0.0000321179, 0.0268496051, -0.0132177258, 0.0312560573, -0.0180595685, 0.0007317443, -0.0180316102, -0.0102474391, -0.0065974076, 0.0047878823, 0.0399850421, 0.0042997729, -0.0163480788, -0.0023571809, 0.0000000003, -0.0056293635, -0.0109467115, -0.0043879026, 0.0105500137, -0.0006673362, -0.0001779654, 0.0069198138, 0.0008780318, 0.0000015725, 0.0155966859, -0.0079368763, -0.0086582070, 0.0114557771, 0.0110194841, 0.0035869195, -0.0100753391, -0.0000001256, 0.0020966881, 0.0008579699, -0.0129691334, 0.0000434920, -0.0004372165, -0.0172947794, 0.0122413402, 0.0048002247, -0.0026152804, -0.0012828427, 0.0026013420, 0.0058386032, -0.0029300430, -0.0132952863, -0.0063313204, -0.0195740052, -0.0154860960, 0.0035719564, -0.0020842054, 0.0067287325, 0.0013331290, -0.0002438789, 0.0002447606, 0.0121563952, -0.0046396703, -0.0054947319, -0.0000757375, 0.0120578809, 0.0010977762, 0.0091916276, 0.0002338968, 0.0043808245, -0.0006736926, -0.0005003584, -0.0084213605, -0.0269186310, -0.0098440908, -0.0150556127, 0.0201395396, -0.0152958799, -0.0035611072, 0.0074512032, -0.0079530245, -0.0018452010, -0.0103462664, 0.0030556619, 0.0000000001, -0.0015487819, -0.0146391345, -0.0141328126, -0.0082831001, 0.0048589562, 0.0029965686, 0.0083744274, -0.0008111577, 0.0000000426, 0.0044901897, 0.0216593258, 0.0046590092, 0.0143951653, -0.0003618775, -0.0015700207, -0.0252331942, 0.0000000002, 0.0010822321, 0.0017711967, 0.0142330276, -0.0000308505, -0.0080914944, -0.0127030918, -0.0103649944, -0.0098901801, 0.0106489677, -0.0237401258, -0.0115764979, -0.0069296835, 0.0010307438, -0.0262681860, 0.0102718519, 0.0071069831, 0.0112248501, 0.0055804872, -0.0001824098, 0.0021164531, -0.0080096908, -0.0000050205, 0.0059850449, 0.0013171559, 0.0109280199, -0.0068959245, -0.0000460820, 0.0061363266, 0.0085325278, 0.0001513412, -0.0043379664, 0.0206043199, -0.0056671677, -0.0013732488, -0.0020891950, 0.0094987545, -0.0094919903, -0.0059894831, 0.0122301551, 0.0107342331, -0.0032292353, 0.0002165570, -0.0104561737, 0.0057428796, 0.0054128901, -0.0061682649, -0.0000000000, 0.0075542112, -0.0126487734, 0.0088649932, 0.0173434690, 0.0031278001, 0.0039417231, -0.0113734473, -0.0002824977, -0.0000000333, -0.0233331230, -0.0017147757, -0.0020272504, 0.0091354428, 0.0054406989, 0.0000841777, -0.0030870645, 0.0000000006, -0.0196600202, -0.0036307345, 0.0080527710, -0.0010930399, 0.0061575463, -0.0001788045, -0.0150957759, 0.0044262875, -0.0098890048, -0.0096907048, -0.0040771784, 0.0114187365, 0.0114507824, 0.0095762350, -0.0249142610, 0.0092977956, -0.0184090268, -0.0002529052, 0.0049841129, -0.0215534531, -0.0230349153, -0.0000000000, -0.0229420736, -0.0057088272, 0.0015538706, 0.0049759294, 0.0001816384, -0.0020266303, -0.0025297576, -0.0114318151, -0.0031889970, -0.0073486040, 0.0001092532, -0.0043853810, 0.0189161543, 0.0025535782, 0.0058024228, -0.0009324566, -0.0091496538, 0.0102128349, 0.0068898918, -0.0070958352, 0.0282704439, -0.0089423135, -0.0194016304, 0.0156788044, -0.0000029208, 0.0205338988, 0.0254192688, 0.0188750625, -0.0136231640, 0.0003243760, -0.0066245459, 0.0047970801, 0.0195104089, -0.0000079469, -0.0271898545, -0.0005344925, -0.0055389861, -0.0000450130, -0.0174377263, -0.0163778551, 0.0114163626, -0.0000104973, -0.0178871937, 0.0150004355, 0.0095452163, 0.0001370436, -0.0087502515, 0.0238493197, -0.0286290925, -0.0000569135, -0.0121109663, 0.0001759043, 0.0171188619, 0.0183632858, -0.0012066020, 0.0120652858, -0.0179945771, 0.0351106413, -0.0002951320, -0.0017641201, 0.0136988359, -0.0109737851, 0.0003930003, -0.0000012547, 0.0059567164, 0.0108462004, 0.0101336148, 0.0101979934, -0.0106443549, -0.0006207754, 0.0092215678, 0.0048591006, -0.0009281773, 0.0203295387, 0.0004461374, -0.0025734988, 0.0192134473, 0.0155734019, 0.0222721007, 0.0173559673, -0.0164825581, -0.0175570175, 0.0091393283, 0.0005308387, 0.0387529768, 0.0244249105, 0.0060591847, -0.0090912301, 0.0000000005, -0.0203929357, -0.0280350428, -0.0241391696, 0.0046154079, -0.0008107531, -0.0033860686, -0.0312457848, -0.0141237695, 0.0000000536, 0.0225383881, 0.0198644977, -0.0143162617, 0.0040028999, 0.0109213283, 0.0030451948, -0.0198415667, 0.0001621853, -0.0117791174, 0.0017594972, -0.0082063423, -0.0026253345, 0.0020709415, -0.0143767111, 0.0263972282, 0.0156190014, 0.0130254524, -0.0087541249, -0.0029367115, -0.0044115135, -0.0107000247, -0.0204373337, 0.0028602351, -0.0082021886, -0.0097621074, -0.0003292384, -0.0049302243, 0.0080990558, -0.0046301871, -0.0000694614, -0.0093868673, 0.0057335170, 0.0083702700, 0.0062133702, -0.0000593531, 0.0152318357, 0.0057053971, 0.0056920988, -0.0155499587, 0.0090004103, -0.0043518059, -0.0018882146, 0.0034238591, -0.0050057219, -0.0220706202, -0.0194573719, 0.0272524413, -0.0057138703, -0.0003388627, 0.0129052857, -0.0019837315, -0.0127281379, 0.0175054539, -0.0078189019, 0.0000000000, -0.0115153212, -0.0167216919, -0.0263064671, -0.0098394826, 0.0044299071, -0.0060281903, -0.0016894223, -0.0193811860, 0.0000000000, -0.0039546588, 0.0408982672, 0.0077467323, 0.0257477872, -0.0179706216, 0.0016915337, -0.0052240491, -0.0000045176, -0.0068615964, -0.0061410526, -0.0055488045, 0.0000004474, -0.0002461766, -0.0256131981, 0.0094028711, -0.0200259611, 0.0106577929, 0.0063707624, -0.0073939133, -0.0288437344, -0.0058137625, -0.0076398826, 0.0175801758, -0.0162759963, 0.0043102819, 0.0002814784, -0.0153446319, 0.0294767730, -0.0104087368, -0.0000024028, 0.0042450232, -0.0075815627, 0.0041867206, 0.0034001807, -0.0002697316, 0.0050814096, -0.0035022162, 0.0161513053, 0.0057362495, 0.0019070707, 0.0000556691, 0.0032210844, -0.0049692653, 0.0074505969, -0.0049267337, 0.0013051833, 0.0072524697, 0.0313048176, 0.0000465530, 0.0008620646, 0.0016192269, -0.0157074053, 0.0036971744, -0.0080738990, -0.0000000000, 0.0106205000, -0.0071912864, 0.0047969501, 0.0051443707, 0.0003375739, 0.0078160763, 0.0152003989, -0.0006649367, 0.0000000324, -0.0052968208, 0.0182445720, 0.0141418464, 0.0028038779, -0.0220242497, 0.0007724793, -0.0100416122, 0.0000000105, 0.0109796906, 0.0022570712, 0.0177008454, 0.0003144220, 0.0063627232, -0.0099754250, -0.0023058334, -0.0152531033, 0.0024911999, -0.0260001179, -0.0176597983, -0.0155615546, 0.0046700868, -0.0157701131, 0.0208741874, -0.0232114438, -0.0213191640, -0.0051065208, -0.0116553009, 0.0096611278, -0.0026939518, -0.0000000001, 0.0072033876, -0.0114874011, -0.0052971016, 0.0131537253, 0.0004727525, 0.0054516080, 0.0071934978, -0.0006077441, 0.0079128463, -0.0047300463, -0.0003723495, 0.0085468479, 0.0018116644, -0.0006752284, 0.0214748029, 0.0005432704, -0.0108771911, 0.0230631419, -0.0104469387, 0.0027883793, 0.0637147278, 0.0117186680, -0.0123896357, 0.0102938097, 0.0000000000, -0.0200067610, -0.0085126702, -0.0187571514, -0.0062051355, 0.0067106253, 0.0015464758, 0.0042768535, 0.0036366084, -0.0000000086, -0.0039897561, 0.0229548719, 0.0088892030, 0.0234970003, -0.0062547163, -0.0006154699, -0.0093350727, 0.0000091754, -0.0108708320, -0.0003782045, 0.0200669281, -0.0000199129, -0.0159660466, -0.0002726857, -0.0076673445, -0.0165549051, 0.0038785082, -0.0057609831, -0.0037127044, -0.0127597097, -0.0061383308, -0.0057430384, 0.0122545250, 0.0031254508, 0.0064067366, -0.0006146056, 0.0008775683, 0.0094474340, -0.0055684461, 0.0000000000, 0.0144176418, -0.0050739162, 0.0098421760, 0.0030840107, 0.0000258666, 0.0129444161, 0.0025379208, 0.0195449851, 0.0038986821, 0.0091530718, -0.0006971441, -0.0113993268, -0.0168050863, 0.0072252131, -0.0057477634, 0.0048754299, 0.0196831077, 0.0177566912, -0.0102053424, 0.0103339972, -0.0048604053, -0.0016338248, -0.0042331163, 0.0196578503, -0.0000000265, 0.0178140961, 0.0475245379, 0.0141273094, 0.0074159796, 0.0009575569, 0.0023437361, -0.0291173439, 0.0122869350, 0.0000013312, -0.0410784036, 0.0160392597, -0.0021015650, -0.0017836225, -0.0221088640, -0.0095478771, 0.0224239808, 0.0000000007, 0.0024357622, 0.0047370987, 0.0360457636, 0.0017512055, -0.0323585831, -0.0106875133, -0.0240173191, -0.0308312401, -0.0180118047, -0.0239880532, 0.0022714825, 0.0138687864, 0.0128517877, 0.0065486771, -0.0143387681, 0.0330876410, 0.0334654935, 0.0133930603, 0.0203932412, 0.0132649774, -0.0257262923, -0.0000000299, 0.0143896900, 0.0267563779, 0.0013714110, 0.0263729393, -0.0006223446, -0.0074017476, 0.0067466311, -0.0004874620, -0.0137045030, 0.0286403578, -0.0011938778, 0.0326419398, 0.0051993602, 0.0665855855, -0.0174277853, 0.0106288837, -0.0506714955, -0.0214363448, 0.0105806403, 0.0014340157, 0.0700834468, 0.0009034102, 0.0123002250, -0.0068468982, 0.0000000000, 0.0020485888, 0.0010553309, -0.0141495904, -0.0012747066, -0.0084635932, -0.0012872751, -0.0006877892, -0.0008261462, 0.0000000001, 0.0120116975, 0.0019627314, 0.0007378212, 0.0011064949, 0.0068274154, 0.0004040142, 0.0144405374, -0.0000003343, -0.0018248255, -0.0024433576, -0.0012402495, 0.0000496411, -0.0005244144, -0.0035025957, 0.0015216197, 0.0070870649, -0.0009294855, 0.0054012351, -0.0006865221, 0.0059910947, -0.0031384416, 0.0135439057, -0.0013088391, -0.0035228997, 0.0030792931, 0.0013737134, -0.0005800282, -0.0000671564, -0.0018915728, 0.0000000000, -0.0013662337, 0.0102102337, 0.0020788896, 0.0013103978, -0.0000526184, -0.0006153506, -0.0003508149, -0.0069926786, 0.0079504577, -0.0003379321, 0.0000143462, 0.0012693438, -0.0200422537, -0.0126008196, -0.0027984930, -0.0005088115, 0.0022886570, 0.0017550387, -0.0077543156, -0.0001413556, -0.0002265835, -0.0085278079, -0.0085974392, 0.0017920899, 0.0000000000, 0.0000710682, -0.0024495462, 0.0075614136, -0.0047157989, 0.0017760983, -0.0013209223, 0.0084078638, 0.0062361197, 0.0000000005, 0.0002265681, -0.0049155657, -0.0046974611, -0.0029243552, -0.0034765597, 0.0005485206, -0.0050242268, 0.0000000066, 0.0043960880, -0.0003113159, 0.0011869839, 0.0000020396, -0.0045787767, -0.0043821149, 0.0030104471, 0.0022418161, -0.0106455563, 0.0017153489, 0.0013090962, -0.0056262305, -0.0050461898, -0.0059414385, 0.0076006977, -0.0055375532, -0.0018401793, 0.0043166196, -0.0008644252, 0.0022032550, -0.0035905230, 0.0000000000, -0.0097761983, -0.0088582644, -0.0021942554, 0.0024701622, -0.0000571603, 0.0074375579, -0.0062112315, -0.0013464814, 0.0019981898, -0.0004635490, 0.0000238215, 0.0020237833, 0.0045493604, -0.0021330360, -0.0042124917, -0.0024881901, -0.0033230884, -0.0007822490, -0.0013402535, -0.0015974869, -0.0028886346, 0.0060986150, 0.0042142509, 0.0006774694, 0.0000000000, -0.0022145512, -0.0104914922, -0.0124393422, 0.0064432146, 0.0006362438, -0.0029272202, -0.0194682740, -0.0158142168, 0.0000000087, -0.0006902621, 0.0049328888, 0.0049955393, 0.0094887316, 0.0070866430, 0.0014318904, -0.0089021558, -0.0000000000, -0.0040237214, -0.0097305048, 0.0146875521, -0.0000825250, 0.0016504773, -0.0020596823, 0.0017487125, -0.0057346569, 0.0129945753, -0.0230791438, -0.0123657193, 0.0056015048, -0.0078533096, 0.0129519505, 0.0050823647, -0.0088026244, -0.0013431828, -0.0040691555, -0.0079928180, -0.0147674372, 0.0065223975, 0.0000000000, 0.0125903413, 0.0159614086, -0.0019238705, -0.0006484676, -0.0001187141, -0.0003606466, 0.0045747315, 0.0013256049, -0.0043245307, 0.0084511247, 0.0000869301, 0.0152340317, -0.0116416505, -0.0048737857, 0.0100716352, 0.0055407649, -0.0078204600, 0.0154854124, -0.0049297260, -0.0065163388, 0.0312882960, 0.0058726352, 0.0014162029, -0.0032995346, 0.0000000000, -0.0051328889, -0.0142536880, -0.0117594358, 0.0149147091, -0.0008020546, -0.0021591720, -0.0057249097, -0.0046224482, 0.0000000000, 0.0070324601, 0.0043320381, 0.0056740800, 0.0107314875, 0.0136489207, 0.0014248310, 0.0010000750, -0.0000000346, -0.0043677166, -0.0025201619, 0.0094255395, 0.0000047394, -0.0005608465, -0.0002842708, 0.0080033522, -0.0034466758, 0.0034435778, -0.0034918778, -0.0065209987, -0.0066151987, -0.0037952308, 0.0053331270, 0.0010908735, -0.0071249874, -0.0138948895, 0.0018379209, -0.0034709144, -0.0060385698, -0.0077665113, 0.0000000075, -0.0057569845, 0.0044427584, -0.0052190479, -0.0056033111, -0.0000483243, 0.0027832927, 0.0025570320, 0.0009881069, 0.0010890956, -0.0011164419, 0.0000330765, 0.0047530998, -0.0174210779, -0.0060151001, -0.0092138760, 0.0005288804, 0.0085551525, 0.0090273200, -0.0034953225, 0.0015786894, 0.0022720529, -0.0056752404, 0.0045241755, -0.0010883380, 0.0000000000, 0.0038729818, 0.0061509116, -0.0180861223, -0.0015215501, -0.0032502483, -0.0035164095, -0.0081265029, 0.0074537294, 0.0000000000, 0.0094240652, 0.0053407541, -0.0003425895, 0.0066869771, -0.0009527269, 0.0010741336, 0.0065847039, -0.0000000020, -0.0010156783, 0.0051731621, -0.0220774040, 0.0000661131, -0.0004502255, -0.0036069017, 0.0203930214, 0.0133844595, -0.0111917909, 0.0103725893, 0.0082106525, -0.0010383361, -0.0089160278, -0.0028878874, -0.0040423367, -0.0046471953, -0.0005495887, 0.0037380860, -0.0001254701, 0.0120034646, 0.0104492484, 0.0000000000, 0.0000376490, 0.0042048264, 0.0031411473, -0.0049906727, -0.0000954015, 0.0103221349, -0.0002370680, 0.0080668665, 0.0037201133, -0.0086311186, -0.0000242049, -0.0045740041, -0.0163939297, -0.0135588488, -0.0050890185, -0.0070088054, 0.0037160679, 0.0017467657, -0.0051549915, 0.0043041226, -0.0147572532, 0.0047956700, 0.0087194098, -0.0035837407, 0.0000000000, 0.0097810403, 0.0108879954, 0.0024226718, 0.0012034293, -0.0084101269, 0.0052951640, -0.0028028407, -0.0044527100, -0.0000000000, -0.0041816565, 0.0117767332, -0.0089038191, -0.0091896942, 0.0043609035, -0.0006222525, 0.0191044323, -0.0000028648, 0.0008914840, 0.0029720243, -0.0015639641, 0.0002866350, 0.0012597698, -0.0014947421, 0.0005954996, -0.0029963637, -0.0089642107, -0.0035039552, 0.0068939379, 0.0016451885, -0.0060638431, 0.0001803584, -0.0143635273, 0.0066928454, -0.0092201559, 0.0082730819, 0.0093407612, 0.0054249913, -0.0080351839, -0.0000000000, 0.0039389674, 0.0176828988, 0.0105978083, 0.0108185103, -0.0022509298, -0.0028830376, -0.0070541697, -0.0089762490, -0.0077518746, 0.0078163706, -0.0001269733, 0.0053738370, -0.0140268281, 0.0034877376, 0.0008151433, -0.0045346282, -0.0117475828, -0.0051627574, 0.0110611860, 0.0045150877, 0.0011088899, 0.0058195139, -0.0039766100, -0.0011761882, 0.0000000000, -0.0063290303, -0.0133138616, -0.0062769856, 0.0051490790, -0.0025736098, -0.0004836036, -0.0013269287, 0.0086098593, -0.0000000000, 0.0107997553, -0.0007117821, 0.0008547936, 0.0108031398, 0.0088818492, 0.0005863195, -0.0025483896, -0.0000026830, -0.0038889598, 0.0095207253, -0.0066649402, -0.0005245476, -0.0001450356, 0.0028700575, 0.0143286726, 0.0003738454, -0.0007051443, 0.0043184813, 0.0013394587, -0.0090963794, -0.0065638167, -0.0109550525, 0.0003806364, -0.0033124287, -0.0137656629, 0.0038537881, -0.0005838093, -0.0011753646, -0.0022809659, 0.0000000431, -0.0046011657, -0.0039395234, 0.0019629276, -0.0069803521, -0.0000716601, 0.0138807213, -0.0000683727, 0.0060669165, -0.0005453680, 0.0010465260, 0.0000317023, -0.0048512183, -0.0180584602, -0.0157420989, -0.0024057843, -0.0063539497, 0.0144393891, 0.0033803862, -0.0048294473, 0.0090315696, -0.0179803986, -0.0025977201, 0.0114017753, 0.0026792821, 0.0000000000, 0.0041580964, 0.0011494508, -0.0175505728, -0.0008104568, 0.0000791360, -0.0097509846, -0.0062969145, -0.0078905541, 0.0000000008, 0.0138221523, 0.0019281851, -0.0015315978, 0.0040574619, 0.0029578435, 0.0013204598, -0.0079317810, 0.0000000042, -0.0007142383, -0.0109075280, -0.0441284068, -0.0000219226, -0.0002800965, 0.0066747512, 0.0260152016, 0.0147789037, -0.0077922242, 0.0228848215, -0.0035297172, -0.0090776430, -0.0127913132, -0.0028401385, -0.0027524955, -0.0074314675, -0.0052053221, -0.0048476718, -0.0050536692, 0.0216741636, 0.0277152639, 0.0000000000, -0.0019254083, -0.0094051398, -0.0067495555, -0.0074402890, -0.0000597679, 0.0006951994, -0.0052193720, 0.0262260176, -0.0018910770, -0.0127062714, -0.0001411624, -0.0054114778, -0.0034030008, -0.0106628500, -0.0139049534, 0.0036490480, 0.0121547850, 0.0021002246, 0.0011558977, 0.0000708717, -0.0293024164, 0.0027914261, -0.0064791702, 0.0000881281, 0.0000000000, 0.0015130431, -0.0010089611, -0.0116052916, -0.0026022699, -0.0002600840, -0.0007015095, -0.0130154798, 0.0116728460, 0.0000000001, -0.0017714334, -0.0001478285, 0.0014319723, 0.0090117110, -0.0086984625, 0.0004798202, -0.0031310823, -0.0000067681, -0.0030264566, 0.0059959800, -0.0081117256, -0.0002170447, -0.0004424513, 0.0002525508, 0.0122624757, 0.0061484356, -0.0049861479, 0.0003712864, 0.0092016719, -0.0033063493, -0.0020231141, -0.0036475097, 0.0001383232, -0.0026387665, -0.0029681646, 0.0067743664, -0.0011156470, 0.0013384254, -0.0049939202, 0.0000000000, -0.0015694958, -0.0062944791, 0.0015392343, 0.0060775410, -0.0000895076, 0.0133963460, 0.0031500622, 0.0063892193, -0.0051210788, 0.0006820592, 0.0000430264, -0.0018317760, -0.0052360301, 0.0030942902, 0.0026075186, -0.0074589639, -0.0047450718, 0.0019082695, -0.0032047587, 0.0154851461, 0.0038925018, 0.0085021323, -0.0198086202, -0.0098492736, 0.0000000013, 0.0099957921, -0.0040849880, -0.0046873074, 0.0048101945, 0.0041995323, -0.0052741887, -0.0038651903, 0.0139190210, 0.0000001845, -0.0039408929, -0.0037016284, 0.0098445071, 0.0246485993, -0.0119189527, 0.0012663535, -0.0141173247, -0.0000000124, -0.0159613881, 0.0143441223, 0.0134140812, 0.0002575859, -0.0055277818, -0.0181245431, 0.0044390620, 0.0003947873, -0.0162819456, -0.0125665916, 0.0025163975, -0.0106781768, -0.0030266333, -0.0348837711, -0.0017368559, -0.0123276319, -0.0194299333, 0.0092464024, -0.0036297154, 0.0011249036, -0.0230363887, 0.0000000000, -0.0055323076, -0.0072116391, 0.0064975820, -0.0108054038, -0.0000076178, 0.0161691178, -0.0055672363, 0.0035408491, -0.0070620473, 0.0071262922, 0.0001084505, 0.0044821152, -0.0139290597, -0.0031514624, 0.0067058420, -0.0164510664, 0.0050711869, 0.0124502741, 0.0003223150, 0.0072813979, 0.0240534525, -0.0009163258, -0.0088152420, -0.0044140210, 0.0000000000, 0.0047729644, 0.0030811820, 0.0038128402, 0.0017977707, 0.0007549824, 0.0048969644, 0.0088127730, 0.0139228618, -0.0000000023, -0.0013874234, 0.0001798400, -0.0066697989, 0.0025373658, -0.0032042426, -0.0009483851, -0.0043774960, -0.0000041709, -0.0045331786, 0.0105297016, -0.0048514456, 0.0000258578, -0.0002714552, -0.0012665322, 0.0067703892, 0.0000954416, -0.0090720523, -0.0034820728, -0.0019706362, 0.0005516823, 0.0029549601, -0.0151964622, -0.0037609139, 0.0048427708, -0.0201060008, 0.0073514068, -0.0011673917, -0.0065571740, -0.0125741260, -0.0000056482, -0.0070032934, -0.0062474553, 0.0053287754, 0.0062119798, -0.0000048719, 0.0171345472, -0.0005496037, -0.0008923978, 0.0020338201, 0.0128441164, 0.0000251169, 0.0036766161, -0.0015234470, -0.0078852186, 0.0061193169, -0.0061524883, -0.0143029364, -0.0041077943, 0.0002704655, 0.0128351776, 0.0084204664, 0.0017335437, 0.0048299530, 0.0067442944, -0.0000000001, -0.0084015848, 0.0076964390, -0.0049050525, 0.0073867003, 0.0013548548, -0.0011272709, -0.0335418247, -0.0098270709, -0.0000000134, 0.0018175660, 0.0094903512, 0.0120843388, 0.0007416090, 0.0116301430, 0.0010174089, 0.0019868629, 0.0000000391, 0.0051372685, 0.0020122018, 0.0031232534, -0.0000196780, 0.0009869006, 0.0048778327, -0.0025966212, -0.0058655180, -0.0044624871, -0.0251414813, -0.0175052341, 0.0172207877, 0.0052378322, 0.0033211866, -0.0042847334, 0.0013070123, -0.0099061597, -0.0034017686, -0.0030942566, -0.0018657804, 0.0085557196, -0.0000000000, 0.0182469115, 0.0145477783, -0.0088558104, 0.0014780298, -0.0011882359, -0.0009107846, -0.0059815431, 0.0046572485, -0.0034245527, 0.0133990776, 0.0000079433, 0.0156239700, -0.0042621619, -0.0041930657, 0.0126948971, 0.0105926748, -0.0157217328, 0.0169723835, -0.0028710538, -0.0014189027, 0.0237563811, -0.0015824507, -0.0050334511, -0.0001845878, 0.0000000000, -0.0008424035, -0.0001474735, -0.0045005763, -0.0012082522, -0.0011371985, -0.0012047149, -0.0066243052, 0.0054333070, 0.0000000001, 0.0030659090, 0.0009781659, 0.0010116033, 0.0037930452, -0.0018290720, 0.0003833971, 0.0031135050, -0.0000005876, 0.0003059242, 0.0090949526, -0.0016640428, 0.0000002892, -0.0008677626, -0.0024915352, 0.0024512198, 0.0025334849, -0.0067445235, 0.0005806421, 0.0063166809, -0.0015187175, 0.0000293049, -0.0059633697, -0.0003031412, -0.0020257367, 0.0022380305, 0.0037690517, -0.0010585987, 0.0043155346, -0.0028201421, 0.0000000000, -0.0019483317, 0.0011573677, 0.0022439992, -0.0022728047, -0.0000894520, 0.0059599490, 0.0004107163, 0.0004824896, 0.0015547110, -0.0017772361, 0.0000162493, -0.0019862629, -0.0092181191, -0.0074356929, -0.0024883803, -0.0041520069, 0.0012267344, 0.0020804480, -0.0037217606, 0.0032002956, -0.0003442263, 0.0035324835, 0.0032831598, 0.0036539645, 0.0000000000, -0.0046343305, 0.0053959438, -0.0036083683, 0.0073929271, -0.0036577906, 0.0071168821, -0.0139452415, 0.0036602062, 0.0000000001, -0.0057236552, 0.0014249149, -0.0104779201, -0.0009413720, -0.0033068606, -0.0000911146, 0.0127917770, -0.0000000001, 0.0042296504, 0.0093418388, 0.0136967245, 0.0001593339, -0.0010489293, -0.0063443603, -0.0012248576, 0.0022868156, -0.0116508799, -0.0152598964, 0.0076484885, 0.0099715870, -0.0002540764, -0.0009290050, -0.0057499078, 0.0047779125, -0.0105065657, 0.0148827098, 0.0073857624, 0.0008173793, -0.0180347264, 0.0000000000, 0.0081438553, 0.0140777668, 0.0061743842, 0.0040513291, 0.0000974622, 0.0085604629, 0.0079123098, -0.0041183066, -0.0055993288, 0.0041185440, -0.0000035941, -0.0007767900, -0.0120758340, 0.0083489530, 0.0046180827, -0.0108235646, -0.0082134595, 0.0014787994, 0.0024813409, 0.0039804983, 0.0058415392, 0.0061267819, 0.0055514933, -0.0154702701, -0.0000000000, 0.0079871016, -0.0023494358, -0.0042857323, 0.0092524774, -0.0036086058, 0.0009959395, -0.0032327278, -0.0051044305, -0.0000000000, 0.0006879349, 0.0081787659, 0.0185973365, 0.0145721184, 0.0025472948, 0.0013667420, -0.0089194048, 0.0000001395, -0.0099112000, -0.0089474227, 0.0180285722, -0.0014423621, 0.0030385186, -0.0173397437, 0.0062241978, -0.0027903793, 0.0059937756, -0.0345614292, -0.0061783977, 0.0034886727, -0.0010597294, -0.0051198537, -0.0111403931, -0.0036381546, -0.0041380669, 0.0029675753, -0.0065981210, -0.0104457792, -0.0208212789, -0.0000000000, -0.0069053546, 0.0055165542, 0.0103341704, 0.0037230684, 0.0001722554, -0.0055868812, -0.0081420252, -0.0182944164, -0.0003249760, -0.0007522506, -0.0000055130, 0.0076904520, -0.0201972425, 0.0060626324, 0.0058535351, -0.0054157334, -0.0094939843, 0.0165799297, 0.0059408122, -0.0054843226, 0.0540732034, 0.0008822269, -0.0096807396, 0.0041413549, 0.0000000000, -0.0027464172, -0.0066289082, -0.0050937496, -0.0032474541, -0.0010564416, -0.0003878690, -0.0035646439, 0.0026129347, -0.0000000001, 0.0045224465, 0.0061803977, 0.0036158429, 0.0070200539, 0.0022160895, 0.0009385800, -0.0070960405, -0.0000066975, -0.0005542575, 0.0093897972, -0.0005910798, -0.0000720547, -0.0005051593, 0.0004645456, 0.0021138065, 0.0015429144, -0.0031004180, 0.0001050421, -0.0022654564, -0.0029048198, -0.0020170980, -0.0109983310, 0.0016203576, -0.0048189736, 0.0070773079, 0.0030210856, 0.0013456568, -0.0092707900, -0.0030956790, 0.0000000709, 0.0029325853, 0.0050312867, 0.0049621584, -0.0058043096, -0.0001222753, 0.0068224189, 0.0000147748, -0.0022017364, -0.0001746594, 0.0066428748, 0.0000699089, 0.0014565107, -0.0124812005, -0.0103816511, -0.0024209179, -0.0014994895, 0.0008750572, 0.0063813138, -0.0031678353, 0.0071939137, -0.0076367129, 0.0016355388, 0.0157382656, -0.0102509195, 0.0000000000, 0.0003556916, 0.0002768792, -0.0171697959, -0.0016819615, -0.0133584598, -0.0012888795, -0.0035062546, 0.0001012326, 0.0000000000, 0.0157893654, 0.0035891626, 0.0000419821, 0.0011981984, 0.0105598448, -0.0015173365, 0.0177197941, 0.0000000000, -0.0022606736, -0.0019097708, 0.0014335642, 0.0001000875, -0.0003407999, -0.0010706816, 0.0019025875, 0.0078050857, 0.0015427729, 0.0064455550, 0.0003997824, 0.0081898430, -0.0072762589, 0.0150223700, 0.0035365853, -0.0036399292, 0.0003263942, 0.0048070718, -0.0013922844, 0.0005307996, 0.0000368001, -0.0000000000, 0.0006157341, 0.0165184829, 0.0045045349, 0.0012352008, -0.0000878155, -0.0012908565, -0.0012447482, -0.0097765028, 0.0101656830, 0.0017706919, 0.0000265281, 0.0008724200, -0.0209016744, -0.0165976528, -0.0043548583, -0.0003811345, 0.0035689778, 0.0013076798, -0.0102349157, 0.0020931757, 0.0018522638, -0.0028607342, -0.0131892934, -0.0006537448, 0.0000000000, 0.0018292071, -0.0039839512, -0.0023410418, -0.0007195004, 0.0005692887, -0.0009533926, 0.0137890717, 0.0093556689, 0.0000000018, 0.0027602054, -0.0004044755, 0.0003756456, 0.0094362926, -0.0043648556, 0.0013105875, -0.0083573749, -0.0000003084, -0.0026625986, 0.0097982781, -0.0036058719, 0.0000141053, -0.0042043347, -0.0066342321, 0.0088220891, 0.0033289071, -0.0082333749, 0.0011894937, 0.0054043499, -0.0056110048, -0.0003509347, -0.0139329601, 0.0041158525, -0.0042577838, 0.0016091439, 0.0085865008, -0.0004327968, -0.0017880276, -0.0107007353, 0.0000000006, -0.0049708788, -0.0068523949, 0.0020086551, -0.0043826634, -0.0000644941, 0.0096290326, -0.0037503003, 0.0046042907, -0.0015562132, 0.0006530330, 0.0000883077, -0.0018117467, -0.0066863066, -0.0071200971, 0.0004519973, -0.0103761982, -0.0017595908, 0.0004191371, -0.0055690263, 0.0032957117, -0.0040941993, 0.0085420636, 0.0216552354, -0.0022666892, -0.0000000000, 0.0052057202, -0.0009046908, -0.0180156715, -0.0040516113, -0.0051295999, -0.0048077242, -0.0140587427, -0.0123053687, -0.0000000001, -0.0047112620, -0.0099543408, -0.0026836160, -0.0094655575, 0.0064290208, -0.0000043153, 0.0065407516, -0.0000000000, 0.0045651644, -0.0001269376, -0.0314087532, 0.0000670178, 0.0008994242, 0.0164745860, 0.0097742854, 0.0004270374, -0.0066300374, 0.0327674299, 0.0029438441, -0.0018184122, 0.0082429219, 0.0024002537, -0.0144234179, -0.0016751223, -0.0133497659, 0.0006071866, 0.0018670290, 0.0229907036, 0.0101540228, -0.0000000000, -0.0049609295, -0.0208956767, -0.0043777078, -0.0002106636, -0.0017365793, 0.0059838654, -0.0059187664, 0.0084183207, -0.0059942966, 0.0081361122, 0.0000441507, 0.0151973870, -0.0037480798, -0.0015264751, -0.0003678148, 0.0075669093, -0.0157377589, 0.0089178793, 0.0058433632, -0.0016639677, -0.0307073966, 0.0054999273, -0.0172877833, -0.0069836313, 0.0000000000, 0.0058736368, -0.0064899754, -0.0017713561, 0.0049749366, 0.0037804686, -0.0015987024, 0.0020068337, 0.0004814341, 0.0000000001, -0.0023288960, 0.0013048443, 0.0031353873, 0.0055276705, -0.0046524196, 0.0033753084, -0.0210667439, -0.0000003417, 0.0074689649, 0.0030836705, 0.0162236113, 0.0003752850, -0.0026605288, -0.0130565008, 0.0079538859, 0.0076984270, -0.0121388808, -0.0106152399, 0.0054366272, -0.0094587971, -0.0042656111, -0.0121563058, 0.0079998858, -0.0055799508, 0.0042562797, 0.0053824731, -0.0007503131, -0.0167190302, 0.0044065560, 0.0000000000, -0.0112337349, -0.0055773552, -0.0102741653, -0.0056432015, 0.0013719462, 0.0075901737, -0.0041095535, -0.0049581779, -0.0112853516, -0.0108064944, 0.0002871859, 0.0065593282, 0.0036742615, -0.0060170982, 0.0018945893, -0.0097715836, -0.0114290854, 0.0001029560, -0.0096494099, -0.0019160806, 0.0152509175, 0.0026717458, 0.0079530319, 0.0057516582, 0.0000000000, 0.0004129615, -0.0044185370, -0.0198671967, -0.0023522524, -0.0022492402, -0.0104260175, -0.0075278007, -0.0039676046, -0.0000000002, 0.0099751540, 0.0064107343, -0.0038462966, 0.0069815707, 0.0096996529, 0.0018040441, -0.0003281081, -0.0000009265, -0.0037044331, -0.0049899197, -0.0331864096, -0.0000658475, 0.0002032705, 0.0086173713, 0.0230706297, 0.0103413835, -0.0050178501, 0.0214855615, -0.0023737974, -0.0023060143, -0.0113310693, 0.0038634120, -0.0022899604, -0.0059794686, -0.0050280979, 0.0002982201, -0.0028869107, 0.0147295650, 0.0071794954, 0.0000000000, 0.0025260393, -0.0067485836, 0.0008413906, -0.0003000410, -0.0007322271, 0.0122878803, -0.0068455003, 0.0164384637, 0.0011385708, 0.0045088506, -0.0000834603, 0.0046659987, -0.0035336760, -0.0130084613, -0.0111013269, 0.0055686720, 0.0010304549, -0.0002856061, 0.0009621115, 0.0107125482, -0.0306076370, 0.0031874964, -0.0116246371, -0.0001739471, 0.0000000001, 0.0049174074, -0.0126566039, 0.0002559943, 0.0072494778, 0.0004236090, -0.0012671991, 0.0121873394, 0.0120326858, 0.0000000048, 0.0043786042, -0.0114853177, -0.0033407693, 0.0146170603, 0.0058188294, 0.0010511500, -0.0138422064, -0.0001073326, -0.0060925414, 0.0071399454, -0.0050608278, -0.0000047708, -0.0016538530, 0.0060747094, 0.0174206328, -0.0040554330, -0.0059156525, 0.0044391137, -0.0013264868, -0.0074937684, -0.0086483005, -0.0178182442, 0.0055749589, -0.0072898832, -0.0235137437, 0.0075504086, -0.0036473332, -0.0056997477, -0.0035090155, -0.0000274999, -0.0044837161, -0.0103990389, -0.0044716340, -0.0040670368, -0.0001415663, 0.0184725784, 0.0036464923, 0.0091770692, 0.0021566772, 0.0067611989, 0.0002692426, 0.0042002932, -0.0042429464, -0.0116999066, 0.0025631322, -0.0045130602, 0.0027128169, 0.0039974209, -0.0016755905, 0.0151762255, -0.0171039607, 0.0011278364, 0.0011007596, 0.0038780302, 0.0000000001, -0.0011434521, -0.0014112857, -0.0213068221, 0.0032433313, -0.0012535687, -0.0048066298, -0.0060714362, -0.0030515275, -0.0000000446, 0.0055700084, 0.0066279969, -0.0006845500, 0.0066848490, 0.0108994562, 0.0027179273, -0.0049897088, -0.0000123595, 0.0037275103, 0.0027405603, -0.0189828016, -0.0003108445, -0.0008793349, -0.0011016924, 0.0117089441, 0.0083438447, -0.0142090200, 0.0042455578, -0.0034587497, 0.0065020653, -0.0001985644, -0.0058626523, -0.0045812642, -0.0062988051, -0.0076373043, 0.0011296136, -0.0029113521, 0.0008033226, 0.0063911751, 0.0000000362, 0.0035303028, -0.0019087506, -0.0006786059, 0.0025857682, -0.0001818815, 0.0154257212, -0.0069362316, 0.0063101072, -0.0017745383, 0.0120173665, -0.0000556900, 0.0137403719, -0.0074257613, -0.0200726055, -0.0032839582, 0.0012903726, -0.0134561388, 0.0031518196, -0.0045205723, 0.0089339307, -0.0005372999, 0.0011673879, -0.0057988986, -0.0004478563, 0.0000000000, -0.0014865412, -0.0043496294, -0.0083487323, -0.0037297760, 0.0002580638, -0.0000063914, -0.0055704978, 0.0106462743, 0.0000000004, -0.0010828098, 0.0046013300, 0.0023724027, 0.0054154065, -0.0021754892, 0.0006604461, -0.0013333043, 0.0000405376, -0.0044418271, 0.0032546404, -0.0085921930, -0.0017103065, -0.0006382272, 0.0026344554, 0.0156710893, 0.0005104382, -0.0007059005, -0.0045682932, 0.0068411403, -0.0034691659, -0.0096154511, 0.0028622821, 0.0049083848, 0.0016724083, -0.0005600112, 0.0075186458, -0.0014401214, -0.0021895121, -0.0064447359, 0.0000000000, 0.0012185636, -0.0036139532, -0.0000357132, 0.0073995194, -0.0001003170, 0.0115608042, -0.0010506867, 0.0044971714, -0.0043250863, 0.0044410904, 0.0000970440, 0.0034665873, -0.0024629938, 0.0018538529, 0.0023251316, -0.0038450724, -0.0103758071, 0.0011876076, -0.0053460118, 0.0134346755, 0.0028055524, 0.0108269108, 0.0072590117, 0.0018489824, 0.0000000000, 0.0016261628, 0.0012652229, -0.0199359916, 0.0034071333, 0.0011780049, 0.0002636301, -0.0278279111, 0.0012468778, -0.0000000009, 0.0063686613, 0.0009092494, 0.0083797919, 0.0109800836, 0.0042968411, 0.0010903715, 0.0013284751, 0.0000000001, 0.0004848532, 0.0047259289, 0.0024404309, 0.0000330328, -0.0009894945, -0.0042900178, 0.0049904939, 0.0081342272, -0.0039822017, -0.0121708848, 0.0000766184, 0.0109547246, 0.0027796531, -0.0046552001, -0.0007525850, -0.0083194356, -0.0031494771, 0.0065499870, -0.0033751091, -0.0016098977, -0.0223844945, 0.0000000000, 0.0000684893, -0.0093142744, 0.0039065899, 0.0029721663, -0.0000488216, 0.0066568046, 0.0009104960, -0.0032900458, 0.0006946595, 0.0072922441, -0.0000412117, 0.0095217498, -0.0055955332, -0.0075559067, 0.0008961522, -0.0029384051, -0.0130214663, 0.0089696227, 0.0031307151, 0.0136054344, 0.0150004420, 0.0241824202, 0.0156341419, 0.0017346049, 0.0000000000, -0.0086079696, 0.0044215317, -0.0099500325, 0.0091557838, -0.0040431316, 0.0117380423, -0.0221738853, -0.0145041617, 0.0000000000, -0.0010648699, 0.0231137574, 0.0055887531, -0.0014584283, 0.0070286524, -0.0001236940, 0.0117000649, 0.0000004514, 0.0075884140, 0.0095375078, 0.0301853102, 0.0001873228, 0.0005573115, -0.0033249645, -0.0124019645, -0.0051173614, -0.0125937657, 0.0009075755, 0.0075017903, 0.0026070422, -0.0029286144, 0.0067890212, -0.0115686972, 0.0119187105, -0.0090942364, 0.0164492466, 0.0124872848, 0.0033382783, -0.0250559635, -0.0000000000, -0.0078929104, -0.0019850782, 0.0011964358, 0.0102614760, 0.0005611905, -0.0007803289, 0.0019524014, -0.0158521328, -0.0124580134, 0.0053046304, 0.0000385343, 0.0023848373, -0.0172221363, 0.0032710680, -0.0017368837, -0.0058921017, 0.0009086545, 0.0092241559, 0.0012760116, 0.0006579086, 0.0033453677, 0.0013772277, 0.0244204998, -0.0048553967, -0.0000016174, 0.0122849038, 0.0097330203, 0.0113499174, -0.0124575971, -0.0097932760, -0.0016924167, 0.0124839656, 0.0097289886, -0.0000247746, 0.0045882901, -0.0039239125, -0.0028807868, -0.0024042649, 0.0040328708, -0.0109366551, 0.0286182631, 0.0000000791, -0.0041022236, -0.0054597920, -0.0105295861, -0.0006894719, -0.0021059497, 0.0148594994, -0.0053805788, -0.0006508763, 0.0140779745, 0.0246029552, 0.0075023412, 0.0051100031, -0.0020220149, 0.0147197703, -0.0065589631, 0.0165442191, -0.0083398828, -0.0047584097, 0.0008143004, 0.0059690741, 0.0012908200, -0.0000005631, 0.0047270451, -0.0007980400, 0.0154851060, 0.0060817078, -0.0086033819, 0.0018680448, -0.0085358173, -0.0014608554, 0.0041369949, 0.0129528148, -0.0040715211, -0.0100847138, -0.0089710429, -0.0073347990, 0.0066029113, 0.0046265563, 0.0113595864, -0.0097375866, 0.0149609596, -0.0053328075, -0.0184496157, 0.0122686792, 0.0072993734, 0.0024761634, 0.0000000000, 0.0000047650, -0.0058689164, -0.0225977842, 0.0004963295, -0.0003105734, -0.0014435264, -0.0243750792, -0.0051008598, 0.0000000004, -0.0009367646, 0.0138988923, 0.0017763899, 0.0094321119, 0.0045333938, 0.0016002089, 0.0003907725, -0.0000020751, -0.0033844213, 0.0007680194, -0.0007101244, -0.0000701847, -0.0026909423, -0.0001831220, 0.0159924962, 0.0056287083, -0.0089829080, -0.0092264256, 0.0006689983, -0.0000893688, -0.0116961300, 0.0070925588, 0.0048167049, -0.0046007205, -0.0033604186, 0.0099266153, -0.0014904051, -0.0020415131, -0.0097754607, 0.0000000000, -0.0016135008, -0.0011609301, -0.0084801037, 0.0075660180, -0.0001241758, 0.0074063879, 0.0090500396, 0.0040354393, -0.0068632392, 0.0012908953, 0.0002824607, 0.0082529401, -0.0097502321, 0.0056366022, -0.0057900869, 0.0018110950, -0.0129637280, 0.0084067089, -0.0050133448, 0.0197314844, 0.0036400596, 0.0137851071, -0.0130572915, -0.0024378872, -0.0000000000, -0.0003058678, -0.0027120369, -0.0122317057, 0.0048039490, -0.0000635162, -0.0024595885, -0.0168409515, -0.0039381688, 0.0000000000, 0.0003824216, 0.0146122295, 0.0046050684, 0.0097450521, -0.0012946865, 0.0015193941, -0.0159491934, 0.0000000000, 0.0050773034, 0.0081861923, 0.0071311328, -0.0053510084, -0.0004196154, -0.0126528842, 0.0052641267, 0.0109869298, -0.0050453972, -0.0172511060, 0.0070479196, -0.0036774366, 0.0012342896, -0.0178312268, -0.0003970675, -0.0077400440, 0.0117383581, 0.0068972125, -0.0037734183, -0.0058962028, -0.0095536215, 0.0000000000, -0.0043560960, -0.0078627905, 0.0052725170, -0.0114909913, -0.0002972678, 0.0010307562, -0.0025027026, -0.0023910357, -0.0084386794, -0.0017387324, 0.0000406874, -0.0006141785, -0.0067769247, -0.0010544377, 0.0004088840, -0.0106713846, 0.0003494237, 0.0047765104, 0.0004910810, 0.0015426346, 0.0191023834, 0.0027725445, -0.0216031820, -0.0023159094, -0.0000000000, 0.0035848883, 0.0004639000, -0.0082589667, 0.0078697633, 0.0025767738, 0.0066848919, -0.0165421125, 0.0124996798, -0.0000000030, -0.0057324823, 0.0111234477, 0.0074288175, 0.0105458284, -0.0139019266, 0.0023706369, -0.0134287514, -0.0000083886, -0.0056832833, 0.0098777134, 0.0092170369, -0.0000388242, -0.0017162985, -0.0146100391, 0.0093948413, 0.0022455137, -0.0013125304, -0.0372005180, 0.0040037311, 0.0035535770, -0.0039079515, -0.0133179929, 0.0031630073, -0.0128236329, -0.0021877587, 0.0059664962, -0.0051287678, -0.0053850487, -0.0269003473, -0.0000000000, 0.0078686140, 0.0057914061, 0.0063779661, 0.0003493915, -0.0001999789, 0.0133001385, -0.0018303319, 0.0012832992, -0.0083397143, 0.0055317194, 0.0001051515, 0.0052221301, 0.0003725791, 0.0044495603, 0.0130843818, -0.0131666884, -0.0147890775, 0.0002200862, 0.0043579885, 0.0110917185, 0.0444460064, 0.0040086797, 0.0075425911, 0.0019971060, 0.0000000000, -0.0073498427, -0.0166764259, -0.0077610584, 0.0108327037, -0.0020413618, -0.0014622286, -0.0055176252, 0.0069049723, -0.0000000002, 0.0122825503, 0.0016585261, -0.0006704422, 0.0084774680, 0.0116099855, 0.0000987898, 0.0060457676, -0.0000076074, -0.0044251489, 0.0027000061, -0.0004208630, 0.0000132325, 0.0010696647, 0.0047462848, 0.0059496686, -0.0045247455, 0.0064854156, -0.0108476188, -0.0051723784, -0.0006512436, -0.0039872103, 0.0027345037, -0.0015710499, 0.0021876555, -0.0071256328, -0.0013371826, -0.0030855734, -0.0087690977, -0.0066044959, 0.0000000000, 0.0050800401, 0.0112045417, 0.0022550651, 0.0003979978, -0.0000077337, 0.0055396338, -0.0005290586, 0.0075618103, 0.0037817440, 0.0053826636, -0.0000490026, 0.0045744996, -0.0131495753, -0.0157344714, -0.0021240788, 0.0037677269, 0.0100616720, 0.0017708672, -0.0060307658, 0.0069257133, 0.0015449720, 0.0122869676, 0.0232882723, 0.0008826562, -0.0000000015, 0.0013466884, -0.0038950632, -0.0054522413, -0.0006330602, -0.0016711046, -0.0001768792, -0.0020663054, -0.0063684504, -0.0000003735, 0.0106081255, 0.0003149706, -0.0159953032, -0.0064757206, 0.0208798666, 0.0001430261, 0.0012089881, -0.0000000033, -0.0130372476, -0.0070836842, -0.0201378018, -0.0023308871, 0.0007000266, 0.0146114156, 0.0117165251, 0.0079202140, 0.0067870957, 0.0156806316, -0.0175995287, 0.0048445244, -0.0045780670, -0.0025126841, 0.0033426539, 0.0112590957, -0.0217694044, -0.0040394315, 0.0046183914, -0.0082855662, -0.0014506672, -0.0000023452, 0.0053798337, -0.0041499226, 0.0053292597, 0.0129019935, -0.0009834528, 0.0175586045, -0.0007879132, -0.0028309987, -0.0018102904, 0.0305605922, -0.0006683387, 0.0132595170, 0.0010954684, -0.0053605833, -0.0134954629, 0.0104116565, -0.0068841064, -0.0127381654, 0.0142182112, 0.0117760934, -0.0228753798, -0.0013217316, -0.0009629120, 0.0007436792, 0.0000000000, 0.0000446961, -0.0001471973, -0.0015619259, -0.0014174939, 0.0001595406, -0.0013689789, -0.0017793373, -0.0005171345, 0.0000000000, 0.0023264959, 0.0016581473, 0.0009014211, 0.0011951945, 0.0008320631, 0.0003039782, -0.0020198436, -0.0000000000, -0.0006250992, -0.0017741622, -0.0007987835, 0.0000007704, -0.0007551453, -0.0010608664, 0.0008226551, 0.0013764940, 0.0003995836, 0.0006601198, 0.0000284441, -0.0010315208, -0.0006149366, -0.0002377250, 0.0001636275, -0.0019176548, 0.0018890784, 0.0019710388, -0.0007248803, 0.0017147994, -0.0025406375, -0.0000000000, -0.0014704602, -0.0002064607, 0.0002321118, 0.0014384306, -0.0000768337, -0.0010505809, -0.0005218966, -0.0007218610, 0.0011359625, 0.0008072504, 0.0000152963, 0.0006599367, -0.0005399956, -0.0008914233, -0.0042347847, 0.0002612324, -0.0005795091, 0.0024375129, -0.0022004812, 0.0011143378, 0.0004896173, -0.0035359226, -0.0019164125, 0.0002232567, 0.0000000000, 0.0002320530, -0.0008251061, -0.0040217433, -0.0025524823, -0.0000657375, -0.0015440363, -0.0012762253, 0.0012504793, 0.0000000000, 0.0030342836, -0.0004430432, 0.0004347389, 0.0008529255, -0.0015557383, 0.0005908780, -0.0037257064, 0.0000000000, 0.0080757309, -0.0019307863, -0.0007194324, 0.0000006529, -0.0013081357, -0.0014832134, 0.0002201714, 0.0011156462, 0.0000479212, -0.0004942317, -0.0004888867, 0.0006240872, -0.0020426121, -0.0010200398, 0.0049929474, -0.0033044529, 0.0030026317, 0.0034077512, -0.0012236832, 0.0005925260, -0.0020463539, 0.0000000000, -0.0022382136, -0.0028940907, 0.0000031514, 0.0013654346, -0.0000597580, 0.0022219948, -0.0011207741, -0.0028725199, -0.0000550130, 0.0017096547, 0.0000234225, 0.0056891935, -0.0003546763, -0.0025412580, -0.0046910527, 0.0012326698, -0.0030856810, 0.0037616577, -0.0020047657, 0.0003641589, -0.0005504877, 0.0058688018, -0.0034596799, 0.0019059887, 0.0000000000, 0.0027594559, 0.0012570394, 0.0056436146, -0.0017057328, 0.0016822481, -0.0075358972, -0.0094574206, -0.0108738355, 0.0000000001, -0.0008241465, 0.0060019307, 0.0066045048, 0.0030363842, 0.0027366271, 0.0014603209, -0.0071563781, -0.0000000000, -0.0020322117, -0.0073783533, 0.0095714973, 0.0000127919, 0.0004084501, 0.0006623771, 0.0028220639, -0.0009369755, -0.0050743385, -0.0045262566, -0.0016933196, -0.0050408938, -0.0066377800, 0.0015246483, 0.0064840885, -0.0062534576, 0.0036520602, 0.0025933348, -0.0044445796, -0.0048552696, 0.0162083115, 0.0000000000, 0.0002511816, 0.0058350801, -0.0081091225, -0.0005148937, -0.0001265228, -0.0065337494, -0.0048182309, -0.0015732896, -0.0013579456, 0.0044954219, 0.0000425729, 0.0119524207, 0.0002090238, -0.0033255785, 0.0042129275, 0.0037394091, -0.0086640799, 0.0068365596, 0.0037959921, 0.0006522505, 0.0175133236, 0.0005485340, 0.0016316434, 0.0012472690, 0.0000000000, -0.0004020169, -0.0007195158, -0.0044031488, -0.0031100421, 0.0019620187, -0.0051461817, -0.0036046915, -0.0058936519, 0.0000000000, 0.0025606868, 0.0038622962, 0.0096145235, 0.0062830518, 0.0026932524, 0.0011081040, -0.0055870218, 0.0000000000, -0.0015454768, -0.0047924523, 0.0053452938, 0.0000003253, -0.0015255164, -0.0029606221, 0.0026845429, 0.0043528881, -0.0011901245, -0.0005634004, -0.0000652563, -0.0042803697, 0.0001436330, 0.0024805574, 0.0050849696, -0.0041908035, 0.0063931020, 0.0043666260, -0.0024408984, 0.0001399845, 0.0037200756, 0.0000000000, -0.0010405814, -0.0025847245, -0.0071196803, 0.0029712592, -0.0002532703, -0.0032460666, -0.0023266724, -0.0028667008, 0.0012380281, -0.0010243179, 0.0000354152, 0.0064530508, -0.0018982799, -0.0101585072, -0.0016393018, 0.0027024085, -0.0062708487, 0.0099193007, -0.0050612777, 0.0013715182, 0.0060532093, -0.0055332263, 0.0062033283, -0.0031318136, 0.0000000000, 0.0026576817, 0.0038043959, -0.0111528952, -0.0020932266, -0.0030741359, -0.0023192612, 0.0004667723, 0.0019447958, 0.0000000000, 0.0106098782, 0.0028466193, 0.0010327317, 0.0037056068, 0.0001355579, 0.0008604508, 0.0073416983, 0.0000000002, -0.0007416973, -0.0041559087, -0.0091391057, -0.0000331901, -0.0009786321, -0.0051286654, 0.0088327499, 0.0084684491, -0.0001875737, 0.0036450867, -0.0006562816, 0.0001388529, -0.0051578828, 0.0046092933, 0.0004940402, -0.0034777278, 0.0011272558, 0.0027206335, -0.0002275193, 0.0074761491, -0.0021870078, -0.0000000000, -0.0010674732, 0.0070723309, 0.0017053417, 0.0009036424, -0.0001866761, -0.0031897363, -0.0017679551, 0.0012819793, 0.0045445026, -0.0062841699, 0.0000275803, -0.0059009711, -0.0143022072, -0.0085838940, -0.0095395437, -0.0014992187, 0.0072922874, 0.0029111300, -0.0059256228, 0.0009084727, -0.0056149876, 0.0055570030, -0.0036447421, -0.0048693540, -0.0000000000, -0.0048665875, -0.0001535305, 0.0077823438, -0.0019128486, -0.0041809990, 0.0076947161, 0.0014385461, 0.0011688663, -0.0000000000, -0.0072716405, -0.0093886992, -0.0032168247, -0.0022209331, -0.0028557861, -0.0005595046, -0.0023061179, -0.0000000000, 0.0023722001, 0.0041581960, -0.0045123240, -0.0003814443, 0.0021049157, 0.0027579549, -0.0015887507, -0.0000859622, 0.0110772802, -0.0046690437, 0.0045005986, -0.0039457525, 0.0005579593, -0.0006318348, -0.0017573837, 0.0023461943, -0.0020317999, -0.0018296601, 0.0001365232, 0.0018745575, -0.0023778100, -0.0000000000, 0.0023009474, 0.0051951772, 0.0087141097, -0.0027431310, -0.0001639933, -0.0012809867, 0.0038751448, 0.0013189325, -0.0043929829, -0.0008184348, -0.0000226059, -0.0003125739, 0.0011524600, 0.0085422629, 0.0047966000, -0.0058541163, 0.0064551183, -0.0023685563, 0.0087714782, -0.0013339656, -0.0028777269, 0.0003667160, 0.0064552315, -0.0040662326, -0.0000000000, -0.0007811850, 0.0003236315, -0.0106309289, -0.0022529084, -0.0046218620, -0.0015334818, -0.0004826033, -0.0027062094, 0.0000000000, 0.0081569273, 0.0039350362, 0.0027644339, 0.0020718111, 0.0043641860, 0.0004736376, 0.0087117571, -0.0000000000, -0.0008951792, -0.0012650009, -0.0005277122, 0.0000214998, -0.0007941326, -0.0024259884, 0.0011556823, 0.0035377010, -0.0009223252, 0.0014892153, 0.0002231616, 0.0041521643, -0.0017385238, 0.0078381533, 0.0009342052, -0.0022937891, 0.0054620579, 0.0016622540, -0.0005206233, -0.0003909570, -0.0031674143, 0.0000000000, -0.0013176312, 0.0070432760, 0.0001012366, 0.0015398766, -0.0000754015, -0.0013941574, -0.0006832959, -0.0039071860, 0.0046334071, 0.0001597278, 0.0000154685, 0.0009208464, -0.0178278480, -0.0099659236, -0.0031021079, 0.0000319695, 0.0004787567, 0.0024902767, -0.0058663092, 0.0010082376, 0.0003992194, 0.0003551808, 0.0169800632, -0.0106123202, -0.0000000000, 0.0003237721, 0.0033168485, -0.0189137608, -0.0021297652, -0.0113097997, -0.0019662688, 0.0014710856, 0.0016621640, 0.0000000000, 0.0184888933, 0.0028027853, -0.0005444910, 0.0044199927, 0.0102073783, 0.0002610441, 0.0161154419, 0.0000000004, -0.0008098799, -0.0056400187, -0.0140377292, -0.0000027102, -0.0010528147, -0.0002038647, 0.0106792888, 0.0135505628, 0.0027866545, 0.0151072796, -0.0011809207, 0.0067684785, -0.0094591025, 0.0169010982, 0.0026332047, -0.0034519911, -0.0013535732, 0.0033668331, 0.0012784631, 0.0109213851, -0.0013569931, 0.0000000000, -0.0038904180, 0.0142717874, 0.0007497767, -0.0016219477, -0.0000732129, -0.0038192507, -0.0016745399, -0.0046291095, 0.0103051225, -0.0112294536, 0.0000240072, -0.0090071885, -0.0224247687, -0.0168862343, -0.0112163685, -0.0011534197, 0.0164946765, 0.0025642498, -0.0087959971, 0.0009028293, -0.0146651035, -0.0021252763, -0.0008949460, 0.0007682284, 0.0000000000, 0.0011425898, 0.0004564333, -0.0004292301, -0.0009795332, 0.0005150407, -0.0023674716, -0.0014447946, -0.0008658204, 0.0000000000, 0.0007972211, 0.0009508700, 0.0012572485, 0.0011220914, 0.0006824858, 0.0004165580, -0.0025218481, -0.0000000000, -0.0002283988, -0.0020881288, -0.0015762089, 0.0000004667, -0.0009133155, -0.0003556644, 0.0018699776, 0.0006468729, -0.0005304490, -0.0003181415, -0.0006279506, -0.0008151373, -0.0016376610, 0.0002048074, 0.0006491259, -0.0017923191, 0.0011064949, 0.0011487637, -0.0011428582, 0.0007359616, 0.0011107975, 0.0000000000, 0.0001407081, -0.0006179452, -0.0010013630, 0.0008855881, -0.0000816324, -0.0006079748, -0.0007282041, 0.0000270492, 0.0002700927, 0.0004379574, 0.0000126605, 0.0012341830, 0.0000425847, -0.0017566660, -0.0032359306, 0.0009989482, -0.0008637967, 0.0018638544, -0.0018422940, 0.0011686517, 0.0017673856, 0.0042718351, -0.0029467973, -0.0002464302, 0.0000000012, -0.0010658554, -0.0050863735, -0.0078888172, -0.0058869375, 0.0021177579, -0.0126669938, -0.0044704131, -0.0074057356, 0.0000003336, 0.0032726410, 0.0022054764, 0.0136890030, 0.0045231259, -0.0001006693, 0.0009763091, -0.0109758694, 0.0000000007, -0.0062779500, -0.0093995472, -0.0031191830, 0.0000667379, -0.0021662326, -0.0019083638, 0.0010912573, -0.0000067084, -0.0068122917, 0.0026956403, -0.0027927475, -0.0026214784, -0.0054687178, 0.0036920873, 0.0116675673, -0.0092837913, -0.0061045927, 0.0022593695, -0.0045629865, -0.0044504451, 0.0140786273, 0.0000000000, -0.0043350244, -0.0049469150, -0.0077406839, 0.0003773819, -0.0000720898, -0.0049536279, -0.0048211971, 0.0008341970, -0.0037351383, 0.0079036485, 0.0000809560, 0.0085582193, -0.0040526143, -0.0106351012, -0.0019318815, 0.0052654329, -0.0081763044, 0.0032379008, -0.0040294589, -0.0030422164, 0.0082679139, -0.0009670578, 0.0000504207, -0.0020623535, 0.0000000000, 0.0014900923, 0.0000269605, -0.0018438604, 0.0001774523, -0.0010046125, 0.0021075297, 0.0063680904, 0.0007564111, 0.0000000000, 0.0015695058, -0.0046714726, -0.0033371483, -0.0059291157, -0.0040040351, -0.0005687137, -0.0018095701, -0.0000000000, 0.0022832479, 0.0037382680, -0.0072862748, -0.0000000282, 0.0003108807, 0.0018440678, -0.0013034414, -0.0005583209, -0.0003144776, 0.0004041538, 0.0001779266, 0.0028244490, 0.0011785689, 0.0002340935, -0.0037898717, 0.0045833406, -0.0003870348, -0.0023436968, -0.0010808439, -0.0009402562, 0.0038085708, 0.0000000000, -0.0015020620, -0.0042722779, 0.0021537836, -0.0028201460, 0.0000322885, 0.0018872435, -0.0003888319, 0.0021717672, -0.0021128585, 0.0032084468, -0.0000077951, 0.0003385930, -0.0000638451, -0.0002841408, 0.0038275679, -0.0003761865, -0.0046288148, -0.0043672016, 0.0023682541, -0.0036031900, 0.0003598573, -0.0062364833, -0.0042095874, -0.0031827665, -0.0000000000, 0.0036314295, 0.0026265397, 0.0034814798, 0.0058001513, 0.0011261378, -0.0086551905, -0.0055306023, -0.0042191809, -0.0000000040, -0.0005211680, 0.0004178812, 0.0054550129, 0.0009253439, -0.0010713523, 0.0012004345, -0.0011666077, 0.0000000000, 0.0006804618, -0.0058118729, -0.0066868761, -0.0000126670, -0.0003936381, 0.0033132483, 0.0063168448, 0.0039939526, 0.0023245867, 0.0060890233, -0.0050105858, -0.0037775277, -0.0087694246, 0.0075753029, -0.0036997315, -0.0028825817, -0.0056787445, -0.0060258284, -0.0056860116, 0.0089848265, 0.0205304772, -0.0000000000, 0.0012251890, 0.0162383672, -0.0100150201, -0.0005958358, -0.0003170779, -0.0071590086, -0.0079928255, 0.0113376360, -0.0019162068, 0.0022828132, 0.0000299468, 0.0084131900, -0.0054967632, -0.0105375517, 0.0077280882, 0.0043773232, -0.0025688931, 0.0049433145, 0.0018470809, -0.0003930819, 0.0058638444, -0.0017739485, -0.0011579765, 0.0005747683, 0.0000000000, 0.0002292019, 0.0003758052, -0.0003362414, -0.0016197315, 0.0004233776, -0.0014578725, -0.0027313193, -0.0001571286, 0.0000000000, 0.0017916763, 0.0019801771, 0.0009983398, 0.0013208598, 0.0009660260, 0.0004054476, -0.0020549907, 0.0000000000, -0.0005604367, -0.0018100697, -0.0011252937, 0.0000000449, -0.0010744778, -0.0012893953, 0.0013317207, 0.0012227256, 0.0005327988, -0.0013180022, -0.0003205663, -0.0003887290, -0.0009175496, -0.0006864212, -0.0000779425, -0.0016948367, 0.0024622846, 0.0021821698, -0.0010070876, 0.0024106007, -0.0030389898, 0.0000000000, -0.0015814197, -0.0003713270, 0.0007483024, 0.0014358112, -0.0000975602, -0.0011395446, -0.0009025979, -0.0012663786, 0.0013222304, 0.0007335234, 0.0000174934, 0.0005188822, 0.0003863981, -0.0006905593, -0.0045249723, 0.0000777670, -0.0007085560, 0.0021454906, -0.0016784962, 0.0011632860, 0.0017873826, -0.0017365117, -0.0072784135, 0.0056162081, 0.0000000000, 0.0029719549, -0.0024375839, -0.0026102928, 0.0033301413, -0.0001868753, -0.0079161972, -0.0066722059, -0.0070400625, 0.0000000000, -0.0014790838, -0.0025678119, -0.0072452445, -0.0002968595, 0.0004991767, 0.0000280509, -0.0064247525, 0.0000000000, 0.0026765827, -0.0010949807, -0.0079793902, 0.0000001669, 0.0005902891, 0.0096136434, 0.0090821795, -0.0018391702, 0.0037360096, 0.0031877575, -0.0046080681, -0.0015837317, 0.0042092567, 0.0051927934, 0.0023961638, 0.0034472193, 0.0025503356, -0.0101110898, -0.0021549859, 0.0052299504, 0.0219617728, 0.0000000000, 0.0072874972, 0.0169469733, -0.0077214194, -0.0087011093, 0.0000930173, 0.0009967011, 0.0049062045, 0.0168960150, -0.0026920291, -0.0020416183, -0.0000005836, 0.0004838622, -0.0020525795, -0.0019770344, 0.0061719101, 0.0060570068, 0.0069416286, -0.0017014571, -0.0074320268, -0.0013799255, -0.0011604435, 0.0077659483, 0.0015108951, -0.0036692270, 0.0000000000, -0.0017782482, -0.0016171404, -0.0015734213, -0.0039042977, 0.0022841955, -0.0105803562, -0.0082802800, -0.0113271074, -0.0000000000, -0.0021187635, 0.0055394191, 0.0143270036, 0.0038721256, 0.0096821943, 0.0016519957, -0.0034080218, -0.0000000000, -0.0029855194, -0.0078992033, 0.0015643308, 0.0000045835, -0.0012192844, -0.0030481322, 0.0048672138, 0.0020043422, -0.0107347276, -0.0044145030, 0.0006052899, -0.0019014194, -0.0013150334, 0.0074563464, 0.0054545305, -0.0054954449, -0.0084176371, 0.0028247365, -0.0048133247, -0.0009870967, 0.0093980366, -0.0000000000, -0.0035527716, -0.0002469194, -0.0161817018, 0.0063568065, -0.0003562530, -0.0091472911, -0.0021398452, -0.0027158363, -0.0010998325, 0.0000247606, 0.0000479841, 0.0116677443, 0.0015423342, -0.0077579981, 0.0011844450, 0.0051522502, -0.0151892472, 0.0081650373, 0.0027811939, 0.0021413036, 0.0180672575, -0.0014595410, 0.0041547441, -0.0025126811, 0.0000000000, -0.0045999279, -0.0001298055, -0.0054181353, -0.0021274518, -0.0031097562, -0.0011559771, -0.0024306667, -0.0006448283, 0.0000000007, 0.0091814762, 0.0021146073, 0.0010522780, 0.0004624648, 0.0040563392, 0.0007588359, 0.0062941913, 0.0000000002, -0.0005225427, -0.0023612978, -0.0024280860, 0.0000163931, -0.0011121696, -0.0011741905, 0.0054479698, 0.0019612114, 0.0010840719, -0.0014994900, -0.0022334245, 0.0011665961, -0.0022752585, 0.0023401205, -0.0005027860, -0.0023868892, 0.0017805818, 0.0018205859, -0.0010764014, 0.0036933729, -0.0012993368, 0.0000000000, -0.0016586378, 0.0082315877, 0.0005469755, 0.0009755734, -0.0000777195, -0.0013299981, -0.0026582247, -0.0015904463, 0.0046947808, 0.0007864597, 0.0000248300, -0.0003436514, -0.0138929645, -0.0072173965, -0.0068162787, 0.0005252391, 0.0033706441, 0.0023494074, -0.0048603690, 0.0003549740, -0.0000054546, -0.0016202036, -0.0022566721, 0.0017297746, 0.0000000000, 0.0009968404, 0.0006106434, -0.0007014307, -0.0019636841, 0.0002401693, -0.0012700015, -0.0032176583, 0.0002385954, 0.0000000000, 0.0034392125, 0.0002689733, -0.0000703079, 0.0010678363, 0.0005800001, 0.0002095453, -0.0038999962, -0.0000000000, -0.0006765946, -0.0016534383, -0.0018354341, 0.0000001375, -0.0004906656, -0.0010920160, 0.0026682727, 0.0005231433, 0.0017650188, -0.0028671387, 0.0007441808, -0.0001092737, -0.0042320420, -0.0003514765, 0.0030163657, -0.0036088151, 0.0017066692, 0.0035939163, -0.0013563551, 0.0016545479, -0.0000302656, -0.0000000000, 0.0009049805, 0.0013459889, 0.0036651716, 0.0010086637, -0.0001205869, -0.0011516986, -0.0009233046, -0.0017032137, 0.0024968041, 0.0020373908, 0.0000279982, 0.0021961071, -0.0001837313, -0.0020172307, -0.0041851639, 0.0001092628, -0.0020216918, 0.0013202194, 0.0001587734, 0.0013903700, 0.0028205593, -0.0050445828, -0.0037504514, 0.0012272447, 0.0000000000, -0.0017510406, -0.0019207885, -0.0023195064, -0.0019009485, 0.0015274353, -0.0018731928, 0.0005442965, -0.0005489513, 0.0000000003, 0.0026689975, -0.0011409428, -0.0012288280, -0.0001969172, -0.0008442145, 0.0011330465, -0.0049839253, 0.0000000000, 0.0065855943, -0.0035099147, 0.0009047647, 0.0000119510, -0.0004940500, -0.0046592620, 0.0013231823, 0.0032010190, -0.0037577313, -0.0001904402, -0.0006352672, -0.0030303427, -0.0011839535, -0.0014685441, 0.0050720540, -0.0044674873, 0.0024856816, 0.0041470793, -0.0013443183, 0.0023899884, -0.0023096791, 0.0000000000, -0.0048986003, -0.0038623400, -0.0029294835, 0.0028323249, -0.0000435400, -0.0000069707, -0.0038717543, -0.0018164155, 0.0030539194, 0.0000987845, 0.0000419067, 0.0031401811, 0.0017805774, -0.0015267404, -0.0079334704, 0.0001621581, -0.0045074299, 0.0038956695, -0.0044810171, 0.0003012266, 0.0000723703, 0.0095135216, 0.0085989814, -0.0139484294, -0.0000000000, -0.0221681185, -0.0100294715, -0.0019348139, -0.0037170534, -0.0038678132, 0.0164743960, 0.0007323178, 0.0052844598, -0.0000000000, 0.0138096977, -0.0046652486, -0.0066076322, -0.0029462245, 0.0068171425, -0.0008383258, 0.0047515747, -0.0000000000, 0.0020824776, 0.0051114373, -0.0123010073, -0.0002810226, 0.0007819547, 0.0044746548, 0.0053200796, 0.0075285584, 0.0117776012, 0.0143720098, 0.0035800103, -0.0114760660, -0.0008920492, -0.0018934727, -0.0008974768, -0.0015611746, -0.0039175856, 0.0055899578, 0.0013082720, 0.0169021338, -0.0302076973, -0.0000000000, -0.0168703757, -0.0043829270, 0.0108872643, -0.0050268122, 0.0000067161, -0.0038163301, 0.0026602666, 0.0043847924, -0.0054023964, -0.0088442927, -0.0000109792, -0.0171732437, -0.0108671915, 0.0019313096, -0.0146054616, -0.0109961359, 0.0364309363, -0.0065224646, 0.0003870596, -0.0036767330, -0.0325944461, -0.0059918487, -0.0032342516, -0.0035204350, 0.0000000000, -0.0053977994, -0.0052725584, -0.0027157194, 0.0054840101, 0.0038756479, -0.0009528159, 0.0002166458, -0.0001519657, 0.0000000000, -0.0024963841, 0.0005919505, 0.0065115476, 0.0021853270, 0.0021681914, 0.0024250313, -0.0039029217, -0.0000000000, 0.0149133597, -0.0069868453, 0.0022431281, 0.0000003150, 0.0036683865, -0.0103843817, -0.0052327574, 0.0046338225, -0.0121409018, -0.0014604263, -0.0035713245, -0.0064652469, -0.0015785443, 0.0009240763, 0.0046142098, -0.0063333567, -0.0058271661, 0.0011015728, -0.0005105234, 0.0007466933, -0.0022097263, 0.0000000000, -0.0104798442, -0.0074201203, -0.0133755784, 0.0042794705, -0.0000884377, 0.0009082264, -0.0105933575, -0.0079747122, -0.0013071018, -0.0006086827, 0.0001512320, 0.0151176238, 0.0073827296, -0.0092276903, -0.0053550173, 0.0011618490, -0.0193276256, 0.0109419832, -0.0090920571, 0.0011634948, 0.0026903150, -0.0043019899, 0.0113532925, -0.0068744519, 0.0000000000, 0.0001597533, -0.0007630732, -0.0133754155, -0.0011318857, -0.0098372633, -0.0104761133, 0.0021068370, 0.0006528029, 0.0000000000, 0.0155313853, -0.0001422532, -0.0001108956, 0.0054710251, 0.0109573454, 0.0000501569, 0.0142340194, -0.0000000000, -0.0013065692, -0.0075563774, -0.0214333348, -0.0007114270, -0.0000257190, 0.0053811600, 0.0190264434, 0.0095490785, 0.0044243596, 0.0140894307, -0.0032503793, 0.0024931550, -0.0117273899, 0.0164460614, -0.0008681678, -0.0001483301, 0.0012355887, -0.0025820718, -0.0037217299, 0.0137206307, 0.0262990221, -0.0000000000, 0.0032258017, 0.0197273046, -0.0022123384, -0.0021627741, -0.0001139671, -0.0072581619, -0.0028034898, 0.0070025716, 0.0065366370, -0.0131578045, 0.0000151501, -0.0091012465, -0.0227063373, -0.0168687906, -0.0061319908, 0.0025452140, 0.0186930746, 0.0018431601, -0.0088065639, 0.0051811892, -0.0147480322, -0.0032539952, -0.0036610705, 0.0008696251, 0.0000000000, 0.0004751145, -0.0020298492, 0.0004055602, -0.0049384604, 0.0007704482, -0.0020981880, 0.0067647831, -0.0026296759, 0.0000000003, 0.0026627441, 0.0015654467, 0.0023539516, 0.0014426284, -0.0023227420, 0.0006970781, -0.0065929303, -0.0000000000, 0.0054018698, -0.0039551780, 0.0004332255, 0.0000003799, -0.0011988181, -0.0035725981, 0.0021847915, 0.0022331767, -0.0022909625, -0.0008774559, -0.0007560390, -0.0019260473, -0.0016363716, -0.0011381970, 0.0043269340, -0.0048642484, 0.0076253102, 0.0023915528, -0.0019960441, -0.0018482286, -0.0020050500, 0.0000000000, -0.0030962361, -0.0043287799, -0.0022360194, 0.0032046344, -0.0001481542, -0.0032647615, -0.0023581134, -0.0043396153, 0.0023991473, 0.0019247525, 0.0000304202, 0.0020676390, -0.0003279912, -0.0011173085, -0.0057319026, 0.0003273820, -0.0025069830, 0.0018915138, -0.0032203714, 0.0001221980, 0.0026666536, -0.0026757452, 0.0062430301, -0.0052207834, 0.0000000000, -0.0004705918, -0.0019973887, -0.0091886166, 0.0008544974, -0.0048516528, -0.0052639781, 0.0033828646, 0.0001815581, 0.0000000001, 0.0127647901, 0.0007984010, 0.0019444420, 0.0050775940, 0.0056781378, 0.0006864770, 0.0063802032, 0.0000000000, -0.0010093512, -0.0080782520, -0.0182604771, -0.0004204696, -0.0011524798, 0.0042021186, 0.0150068868, 0.0068734996, 0.0043466506, 0.0091419742, -0.0042049615, -0.0023532950, -0.0099601280, 0.0068479171, -0.0013867071, -0.0017300913, -0.0009207329, -0.0014066430, -0.0033002258, 0.0091926511, 0.0169747956, 0.0000000000, -0.0017364885, 0.0096784625, -0.0018142697, -0.0020654558, -0.0001729519, -0.0052196882, -0.0049294331, 0.0086153774, 0.0022959807, -0.0079183970, 0.0000224988, -0.0078116991, -0.0157715902, -0.0135223810, -0.0068480801, 0.0010949221, 0.0118915290, 0.0039317296, -0.0067656613, 0.0034378229, -0.0114189666, -0.0027468139, -0.0013004020, 0.0008091085, 0.0000000000, -0.0001890995, 0.0006934276, 0.0005115193, -0.0020119022, 0.0006178643, -0.0018331113, -0.0020981890, -0.0006101303, 0.0000000000, 0.0006689916, 0.0009685321, 0.0013901979, 0.0001870859, 0.0002841293, 0.0004377994, -0.0027108470, 0.0000000000, -0.0022427491, -0.0019482279, -0.0011765359, 0.0000005159, -0.0008565449, -0.0016948399, 0.0007965224, 0.0012424348, 0.0000845988, -0.0004374048, 0.0005064152, -0.0012085071, -0.0025489836, -0.0001393921, 0.0021493409, -0.0026866435, 0.0019313854, 0.0017560951, -0.0010986360, 0.0013946870, -0.0025051360, -0.0000000000, -0.0008186572, 0.0007277268, -0.0001813773, 0.0021511503, -0.0001160347, -0.0008481919, -0.0017068280, -0.0013537249, 0.0004141541, 0.0013348521, 0.0000192099, 0.0015305838, 0.0007421088, -0.0010697755, -0.0048459913, 0.0006293355, -0.0011165956, 0.0019669218, -0.0016404532, 0.0011446585, 0.0023057980, -0.0051310714, -0.0001777115, 0.0034769459, 0.0000000000, 0.0065829097, 0.0008600238, -0.0080538969, 0.0000479273, 0.0003579141, -0.0138839148, -0.0116449073, -0.0065725748, 0.0000000000, 0.0060482593, 0.0021099406, 0.0058079567, 0.0050361818, 0.0018718366, 0.0005466976, -0.0048453398, 0.0000000000, -0.0006393181, -0.0086961268, -0.0118749449, -0.0000286963, 0.0001195596, 0.0075068302, 0.0124435080, -0.0018279831, 0.0082788048, 0.0053654225, -0.0084929178, -0.0006104368, -0.0058724773, 0.0037315730, -0.0006451846, -0.0025031236, 0.0027931069, -0.0018072281, -0.0082001043, 0.0092041828, 0.0270420350, -0.0000000000, 0.0057276208, 0.0084841643, -0.0086448612, -0.0015030892, -0.0001232849, -0.0044753626, -0.0038632837, 0.0166200977, -0.0005770444, 0.0030853234, 0.0000379019, 0.0040156171, -0.0030802903, -0.0115423072, -0.0000635129, 0.0080726603, -0.0018404040, 0.0044809221, 0.0008457612, 0.0032083967, 0.0012510485, 0.0030861255, 0.0003478375, 0.0041785394, -0.0000000000, -0.0167977847, -0.0123471599, -0.0012907840, 0.0098321121, 0.0022439279, 0.0061692265, -0.0079948092, -0.0016195409, -0.0000000000, 0.0040500229, 0.0045529748, 0.0000797395, 0.0010581602, 0.0011215545, -0.0003533910, -0.0017184431, -0.0000000000, 0.0039605587, 0.0089951549, 0.0076905075, -0.0000000899, 0.0011076767, 0.0012493816, -0.0129049653, -0.0009564474, 0.0071481909, 0.0064895037, 0.0003154222, -0.0030722881, 0.0068448139, -0.0019181210, -0.0045217760, 0.0071127140, 0.0000859064, -0.0052266289, 0.0014235405, 0.0058341250, -0.0124277640, 0.0000000000, -0.0033543282, -0.0006137994, -0.0000558857, -0.0050149788, 0.0002281774, 0.0019436190, 0.0063816570, 0.0071464642, -0.0054518394, 0.0002362861, -0.0000381159, -0.0040144147, 0.0014202890, 0.0060080597, -0.0047160350, -0.0002626254, 0.0128224166, -0.0045899828, -0.0050665718, -0.0045300834, -0.0125702024, 0.0136845177, -0.0000089223, 0.0065418468, -0.0000014611, -0.0001161922, 0.0021334887, 0.0215380397, -0.0068616844, 0.0002069711, -0.0004224179, 0.0063329251, 0.0049654231, -0.0000199170, -0.0073070498, -0.0023389466, -0.0057464140, -0.0035118901, 0.0030179736, -0.0096331900, 0.0033612563, -0.0000000801, -0.0149069345, 0.0053004711, 0.0050145998, -0.0027805481, -0.0032887103, 0.0081993146, -0.0048821978, -0.0114970021, 0.0071786805, 0.0038650662, 0.0075191227, -0.0007304810, 0.0005336549, 0.0020254545, -0.0024092505, 0.0179515518, -0.0058581340, -0.0062353751, 0.0037011162, -0.0063529238, -0.0103339143, -0.0000002904, -0.0005875695, -0.0012614829, 0.0095543228, -0.0004874914, -0.0071774344, 0.0020394006, 0.0026660722, 0.0080444505, -0.0070832069, 0.0074619669, -0.0049799541, -0.0180543717, 0.0124569694, 0.0127439490, 0.0073072147, 0.0078818807, 0.0156830065, -0.0163602103, 0.0174809564, -0.0007863480, -0.0134290010, -0.0113410782, -0.0040584817, 0.0037513673, 0.0000000000, 0.0012207852, 0.0003287084, -0.0017496611, -0.0016910597, 0.0019605800, -0.0081831962, -0.0046360521, -0.0049362737, 0.0000000000, 0.0013173330, 0.0017408368, 0.0006072389, -0.0007424572, 0.0000381001, 0.0011546081, -0.0059057996, 0.0000000000, -0.0003851117, -0.0052222363, -0.0068465783, 0.0000009874, -0.0021337988, -0.0002079629, 0.0066737202, 0.0028303550, -0.0009451929, 0.0010606864, -0.0056916270, -0.0024557796, -0.0053000418, 0.0025066519, 0.0028605545, -0.0032507004, 0.0021932304, -0.0019299641, -0.0032923545, 0.0061617107, 0.0172496885, 0.0000000000, 0.0037642343, 0.0081584910, -0.0068158936, -0.0009036393, -0.0002084046, -0.0028644032, -0.0033790811, 0.0072453092, 0.0013287462, 0.0013475782, 0.0000426659, 0.0051616509, 0.0018070191, -0.0028497369, -0.0021662160, 0.0047575687, -0.0044661998, 0.0050842003, -0.0052580317, 0.0012727602, 0.0037093312, -0.0038715485, -0.0008940485, 0.0010587226, -0.0000000000, -0.0033950114, 0.0008649118, 0.0004479300, -0.0041419761, 0.0026448397, -0.0043727076, -0.0028332991, -0.0023934522, 0.0000000000, 0.0020878974, 0.0030350010, 0.0050597037, 0.0007095832, 0.0035175662, 0.0012980595, -0.0013521247, -0.0000000000, -0.0023269148, -0.0048936578, 0.0013707031, 0.0000000236, -0.0008164831, -0.0060692858, 0.0012575727, 0.0043177614, -0.0036792096, -0.0047637094, -0.0025330510, -0.0029470453, -0.0009799586, 0.0015761061, 0.0044143870, -0.0053666197, 0.0046955538, 0.0048424965, -0.0026500716, 0.0028117136, -0.0045942417, -0.0000000000, -0.0039402242, 0.0003394015, -0.0067798523, 0.0050078868, -0.0003228793, -0.0042051352, -0.0041208360, -0.0056482954, 0.0029208297, -0.0014448649, 0.0000435481, 0.0055009257, 0.0013649761, -0.0013099613, -0.0051392727, 0.0007050519, -0.0084743546, 0.0072643268, -0.0027577558, 0.0017471244, 0.0108826021, -0.0050265049, -0.0021194734, 0.0000578505, -0.0000000000, 0.0008988614, 0.0010182826, 0.0117726140, -0.0012190118, 0.0023750579, -0.0086769024, -0.0056693098, -0.0070968866, -0.0000000000, 0.0041673416, -0.0004279664, 0.0117119122, 0.0017853115, 0.0009453827, 0.0005055787, -0.0022387349, -0.0000000000, -0.0041197143, -0.0114080701, 0.0000288473, 0.0000000054, -0.0040916819, -0.0028114428, 0.0017524374, 0.0004350762, -0.0076997518, -0.0061807940, -0.0095577026, -0.0067290664, -0.0100245262, 0.0039433711, 0.0089593194, -0.0120768826, -0.0137706269, -0.0001425116, -0.0078330524, 0.0025872588, 0.0119521450, -0.0000000000, 0.0005166042, 0.0110438494, -0.0103947939, 0.0024804715, -0.0002548341, -0.0117268339, -0.0127699208, -0.0002068203, -0.0022683719, 0.0105010476, 0.0000630916, 0.0110493312, -0.0046589333, -0.0059019201, 0.0036926037, 0.0039057978, -0.0121075623, 0.0106467288, 0.0080718286, 0.0001636867, 0.0208242182, 0.0041050026, 0.0017336679, 0.0024568480, 0.0000000000, 0.0060581565, -0.0014358839, 0.0018691667, 0.0035436514, 0.0011797367, -0.0056797680, -0.0011490925, -0.0053807236, 0.0000000000, -0.0030824104, 0.0014090167, 0.0039658663, 0.0021408263, 0.0005397038, 0.0000082090, -0.0042399503, 0.0000000000, -0.0014315044, 0.0002782393, 0.0002518371, -0.0000048733, 0.0005380304, 0.0008724782, 0.0093696425, -0.0044395416, -0.0022866086, -0.0094242869, -0.0007951315, 0.0002925821, -0.0031468601, -0.0001207123, -0.0059747486, 0.0044785361, 0.0064461576, -0.0035342430, -0.0018795948, -0.0041123349, 0.0216116942, 0.0000000000, 0.0059282449, 0.0013434262, -0.0022529308, 0.0021990081, 0.0000078811, -0.0010902025, -0.0040660328, 0.0052676843, 0.0002303954, 0.0031677450, -0.0000055640, 0.0037674699, 0.0036812960, -0.0039345603, 0.0076309494, 0.0014549317, -0.0069913967, 0.0006823639, 0.0015484547, 0.0004836845, 0.0057176570, 0.0163203720, 0.0136964200, -0.0119547918, -0.0000000005, -0.0112129040, -0.0072382512, -0.0054320078, 0.0008593116, -0.0145331025, 0.0015227395, 0.0040774788, 0.0033237939, -0.0000000370, 0.0214111432, 0.0023604233, -0.0094129946, -0.0038107086, 0.0197403189, -0.0075881109, 0.0233151708, 0.0000000000, -0.0074171592, 0.0048146048, -0.0204242133, -0.0046805036, 0.0034339172, 0.0144894328, 0.0086229276, 0.0052159526, 0.0086079845, 0.0232376903, 0.0015301709, 0.0065418519, -0.0113334395, 0.0197238848, -0.0021311860, 0.0102858469, -0.0008471329, -0.0088039041, 0.0051248246, 0.0013124804, 0.0055995733, -0.0000000000, -0.0011510797, 0.0209049117, 0.0046518827, -0.0071995044, -0.0005170543, -0.0000188461, 0.0022858237, 0.0013395960, 0.0063023875, -0.0043276194, -0.0001469439, -0.0219733045, -0.0182313286, -0.0176809300, -0.0031278811, 0.0013073627, 0.0293544494, -0.0153288320, -0.0074800639, -0.0022521878, -0.0342927203, 0.0006151802, -0.0017650400, 0.0007907840, 0.0000000000, 0.0001896851, 0.0002938022, -0.0039264509, 0.0073674028, 0.0005184342, -0.0009888195, -0.0019699964, -0.0027937456, 0.0000000000, -0.0015610395, 0.0059679020, 0.0028797337, 0.0015703450, 0.0026786807, 0.0004207500, 0.0002736331, 0.0000000000, -0.0006267186, -0.0022183461, -0.0007721054, 0.0000000863, -0.0008584454, -0.0017290680, 0.0027961135, 0.0006663015, -0.0043726396, -0.0001635433, 0.0000194005, 0.0004127057, 0.0001831149, -0.0007255945, -0.0113652078, 0.0005078928, 0.0066101821, 0.0033275364, -0.0003965335, 0.0017426778, -0.0037841543, 0.0000000000, -0.0029632859, -0.0004429867, -0.0018433338, 0.0024412214, -0.0000823373, -0.0008543519, -0.0011029796, 0.0030836086, 0.0024062861, -0.0031111347, 0.0000153844, 0.0006223343, -0.0009619192, -0.0033720376, -0.0060904929, -0.0001059525, -0.0019724695, 0.0007637276, -0.0009462449, 0.0053476272, 0.0028197104, -0.0035929279, -0.0015385651, 0.0003640450, 0.0000000000, 0.0002535596, -0.0005434707, -0.0042857006, -0.0015497189, -0.0004755116, -0.0014720005, 0.0021177717, 0.0010680036, 0.0000000000, 0.0035769562, -0.0003169433, 0.0001570492, 0.0012881084, 0.0009543729, 0.0007214067, -0.0030751012, 0.0000000000, 0.0080354437, -0.0020310620, -0.0012218562, 0.0000005811, -0.0010472502, -0.0023628639, 0.0006526159, 0.0011413069, 0.0004585053, -0.0009831344, -0.0009326221, 0.0004072395, -0.0010251722, -0.0011042231, 0.0004575214, -0.0033125228, 0.0035825379, 0.0032564620, -0.0015073544, 0.0000943377, -0.0029535133, -0.0000000000, -0.0010190363, -0.0022073039, 0.0003403329, 0.0012398058, -0.0000572030, 0.0002818509, -0.0008689447, -0.0029962149, 0.0012203162, 0.0019524680, 0.0000235712, 0.0035852755, -0.0002304287, -0.0038901821, -0.0049234689, 0.0004962106, -0.0030524633, 0.0034177820, -0.0042057680, 0.0014057346, -0.0001534257, 0.0067974348, 0.0101998830, 0.0058808504, 0.0000000000, -0.0023631470, 0.0205532778, -0.0024986872, -0.0026076483, -0.0056930650, -0.0085490933, 0.0009280198, 0.0019405845, -0.0000000001, -0.0040435866, -0.0034189487, 0.0062508313, -0.0024435651, -0.0037325514, 0.0009111067, -0.0062641427, -0.0000000000, -0.0008061931, -0.0058807787, 0.0098595740, 0.0000215544, -0.0028826834, -0.0055690114, -0.0002598469, -0.0000026984, 0.0010235142, 0.0073644039, -0.0019236858, 0.0081815515, -0.0111168753, -0.0130133955, 0.0186850373, -0.0107820220, 0.0159307271, -0.0009419196, -0.0090469625, 0.0042875279, -0.0071422099, 0.0000000000, 0.0124896718, 0.0085351504, -0.0037030675, -0.0082621193, 0.0006639604, 0.0069379560, -0.0017373924, -0.0026189892, -0.0145729650, 0.0137819061, 0.0000440737, 0.0064634923, -0.0168673452, 0.0001658764, 0.0106578954, 0.0126350243, -0.0023070979, 0.0037518919, 0.0026588563, -0.0015747857, -0.0014715516, 0.0049157632, 0.0154820066, 0.0116673782, -0.0000000000, 0.0099179922, 0.0257945620, -0.0090755159, -0.0051313480, -0.0052856570, -0.0091352807, 0.0147240758, 0.0069346433, -0.0000106020, -0.0062296353, -0.0089776022, 0.0005634282, -0.0038825758, -0.0094525488, 0.0010446641, -0.0044890656, 0.0000000000, -0.0005756804, -0.0075738435, 0.0136653921, -0.0002535932, -0.0052366792, -0.0027030120, 0.0018400757, -0.0069846446, 0.0020841958, 0.0128495796, -0.0032560788, 0.0137155969, -0.0090577016, -0.0154422056, 0.0227278527, -0.0063307052, 0.0172277577, 0.0024622218, -0.0106539894, 0.0059364429, -0.0071107298, 0.0000000000, 0.0136891156, 0.0025922789, -0.0091036372, -0.0173419435, 0.0004475326, 0.0093029635, 0.0003312200, 0.0016740408, -0.0182821974, 0.0147808101, 0.0000764811, -0.0065618064, -0.0172177088, -0.0011889228, 0.0170135535, 0.0150873056, -0.0086349323, 0.0009974703, -0.0023991838, -0.0005111663, -0.0108948676, -0.0036413225, 0.0055842227, -0.0051241415, 0.0000000000, 0.0015973174, 0.0015775078, -0.0073477798, -0.0080777891, -0.0020396844, -0.0022547117, 0.0091947457, 0.0036191905, -0.0000000000, 0.0038937021, -0.0087010292, 0.0019454656, -0.0130689973, -0.0049265567, 0.0006291125, -0.0060941307, 0.0000000000, -0.0005448976, -0.0025690396, -0.0025530816, 0.0000010354, -0.0008837270, -0.0069705453, 0.0065428857, 0.0032170515, -0.0050635105, 0.0035202000, -0.0011371153, 0.0026785131, -0.0082469108, -0.0082836365, 0.0076763486, -0.0053638034, 0.0224032216, -0.0023011647, -0.0016197257, -0.0011450812, -0.0044580000, -0.0000000000, 0.0081814481, 0.0016805938, 0.0017862972, -0.0056426818, 0.0001089701, 0.0063232258, -0.0030913313, -0.0102840709, -0.0075706146, 0.0096010594, 0.0000273769, 0.0073106168, -0.0062222877, -0.0067859800, 0.0050498708, -0.0005592518, -0.0056880307, 0.0099018225, -0.0053463588, -0.0003041893, 0.0042616692, 0.0103965262, 0.0163627863, 0.0050617517, -0.0000000000, 0.0156911165, 0.0220658854, -0.0061135548, -0.0298525263, -0.0062380498, -0.0062577268, 0.0108817723, 0.0028120962, -0.0000722501, -0.0007819573, -0.0283327810, -0.0138647854, -0.0047481605, -0.0146610253, -0.0032847899, -0.0098444158, -0.0000000000, -0.0091745621, -0.0140058128, 0.0234488957, -0.0014252753, -0.0128284656, 0.0099544572, -0.0004196690, -0.0169113092, 0.0053194528, 0.0157157890, -0.0007759578, -0.0004293860, -0.0009945722, -0.0274016000, 0.0338567384, -0.0134532284, 0.0046300166, 0.0094759166, -0.0131298164, 0.0049440325, -0.0072452161, -0.0000000000, 0.0132495901, -0.0091780685, 0.0062556798, -0.0103935916, -0.0009700797, 0.0092670126, 0.0060455082, 0.0107951146, -0.0457647592, 0.0273583643, -0.0002978517, -0.0160676204, -0.0218121056, 0.0380580314, 0.0137204072, 0.0027800759, 0.0206491556, -0.0027907668, 0.0072033340, -0.0209449567, -0.0179866608, -0.0041488800, 0.0004662925, 0.0003408841, 0.0000000000, -0.0028062873, -0.0000555162, -0.0030841196, -0.0094858129, 0.0001671270, -0.0020000194, -0.0021409725, 0.0014396368, 0.0000000000, 0.0012638983, -0.0020754589, 0.0012649866, -0.0026658266, -0.0047213463, 0.0002589599, -0.0015925718, 0.0000000000, -0.0005135412, -0.0014289184, -0.0010575970, 0.0000000036, -0.0008394512, -0.0025402878, -0.0033589511, 0.0012338610, 0.0026608938, 0.0010898607, 0.0003267565, -0.0011938532, -0.0023230519, -0.0014022336, 0.0087354248, -0.0017110945, 0.0066694161, 0.0017802380, -0.0001832543, 0.0021306435, -0.0027438549, 0.0000000000, 0.0020715545, 0.0008766687, 0.0066397972, 0.0001581135, -0.0000367413, -0.0009397687, -0.0007630727, -0.0049412567, -0.0023425194, 0.0054941340, 0.0000142827, 0.0011858997, -0.0021822855, -0.0002442855, -0.0005599769, 0.0007622468, -0.0009907262, 0.0046808021, -0.0016514806, -0.0047808583, 0.0010256509, -0.0027559097, -0.0020077273, 0.0002381597, -0.0000000000, 0.0005631763, 0.0025859647, -0.0018956440, -0.0017902509, 0.0000715342, -0.0024314984, -0.0033804805, -0.0001948812, 0.0000000000, 0.0014152449, 0.0017727745, 0.0008248725, 0.0013284874, -0.0004127152, 0.0004376117, -0.0021970908, -0.0000000000, -0.0006791627, -0.0024970083, -0.0008078515, 0.0000000814, -0.0013490192, -0.0032153961, 0.0014920357, 0.0021253484, 0.0007854871, -0.0024194221, -0.0001839644, -0.0005975217, -0.0011745982, 0.0001179786, -0.0001787104, -0.0025898179, 0.0029404128, 0.0029553298, -0.0018638872, 0.0035044521, -0.0031633675, 0.0000000000, -0.0016539358, 0.0022050967, -0.0000153745, 0.0021343352, -0.0001164240, -0.0016813324, -0.0016584413, -0.0016178271, 0.0010461286, 0.0006572647, 0.0000262914, 0.0033157514, -0.0031239453, -0.0009217471, -0.0048791943, -0.0003214209, -0.0018306552, 0.0037999393, -0.0023288827, 0.0013814255, 0.0039327792, -0.0011367569, -0.0013273207, 0.0006232242, 0.0000000000, -0.0009777407, 0.0001125214, 0.0013020241, -0.0009447137, 0.0003191780, -0.0016039757, -0.0034072397, -0.0004622587, 0.0000000001, 0.0010551646, 0.0008953816, 0.0005176516, 0.0016678397, 0.0003798341, 0.0004204890, -0.0025332393, 0.0000000000, -0.0003326019, -0.0017493325, -0.0006542519, 0.0000000110, -0.0006804917, -0.0011325092, 0.0010805314, 0.0010556555, 0.0001266763, -0.0013303598, -0.0005762458, -0.0006136989, -0.0007884431, -0.0011972775, 0.0000171280, -0.0017682285, 0.0017927469, 0.0011996413, -0.0007974681, 0.0012164627, -0.0020989724, 0.0000000000, -0.0007897993, -0.0004873620, 0.0004991434, 0.0008418480, -0.0000746902, -0.0006589185, -0.0008252508, -0.0005422161, 0.0005139908, 0.0006576112, 0.0000131655, 0.0007549673, 0.0005392771, 0.0002447756, -0.0032917787, -0.0000416554, -0.0007742182, 0.0015870371, -0.0008815939, 0.0010772286, 0.0018985430, 0.0108566042, 0.0051409318, 0.0056834402, 0.0000000017, 0.0136182532, -0.0019562596, -0.0172643028, 0.0084546842, -0.0009283240, -0.0142652811, -0.0034156051, 0.0039659576, 0.0000000792, 0.0178342462, -0.0021782112, -0.0057411296, -0.0110857654, 0.0161873717, 0.0008459850, -0.0129143661, 0.0000000000, 0.0035875801, 0.0019092420, -0.0141756488, 0.0000553204, -0.0023162924, 0.0016331695, -0.0027755501, 0.0103469305, -0.0006063533, 0.0096735004, -0.0010515810, 0.0022352587, -0.0095597943, -0.0030854968, -0.0028314616, -0.0160751715, 0.0284904819, -0.0157313049, -0.0060697920, -0.0290715992, 0.0030419331, 0.0000000000, 0.0011815787, 0.0102834273, -0.0048554637, -0.0019706977, -0.0001103048, 0.0069589461, -0.0033621283, -0.0095281852, 0.0011476600, 0.0159659218, 0.0002192551, 0.0231615491, 0.0053518745, -0.0260616280, 0.0058850623, 0.0067005823, 0.0020373282, 0.0125644235, -0.0031488389, -0.0052722618, -0.0029680305, 0.0149322757, -0.0018897296, -0.0082042404, 0.0000000000, 0.0191463232, 0.0046559428, -0.0194301140, 0.0117405336, -0.0019207874, -0.0036962661, 0.0033269746, 0.0049368162, 0.0000000000, 0.0045453445, -0.0025745737, 0.0002421242, -0.0117155770, 0.0056443368, -0.0008389527, -0.0164707862, -0.0000000000, 0.0041558580, 0.0067755785, -0.0172444358, -0.0000000856, 0.0005623610, 0.0114939027, 0.0019892633, 0.0059508658, -0.0011618624, 0.0056925714, 0.0005324491, 0.0029536150, 0.0003330030, -0.0044850502, -0.0205150302, -0.0046355277, -0.0051200376, -0.0116111841, -0.0039571053, -0.0167366304, 0.0157829933, 0.0000000000, -0.0087231128, -0.0062844865, -0.0065825242, -0.0038633482, 0.0000376658, 0.0081321774, 0.0019002219, -0.0003215392, -0.0043799537, 0.0045638261, -0.0000087077, 0.0110823801, -0.0081109796, -0.0252244938, 0.0159610268, 0.0035448561, -0.0045885788, -0.0042921659, -0.0033151975, 0.0022281413, 0.0028486133, -0.0025058186, 0.0016258599, -0.0033006920, -0.0000000204, -0.0125443367, 0.0119887833, 0.0057486594, 0.0134277707, -0.0047486653, 0.0086819110, -0.0030126960, -0.0051330198, -0.0000036326, -0.0074149389, 0.0007481551, 0.0043143975, -0.0005237391, 0.0053432966, 0.0003140627, 0.0127420947, -0.0000000019, 0.0004685177, 0.0019943884, -0.0024992020, -0.0000210651, 0.0026157654, 0.0077842241, -0.0088670719, 0.0044955309, 0.0002450282, -0.0124988882, -0.0048987153, -0.0072099110, -0.0047478909, 0.0164871980, 0.0052570789, -0.0018534912, -0.0165531598, 0.0002558908, 0.0036994955, 0.0051436326, -0.0154743064, -0.0000000001, -0.0175093301, -0.0024596937, 0.0027026071, 0.0184589662, -0.0003725325, -0.0094743054, -0.0110164499, -0.0108583476, -0.0051361145, -0.0008137234, -0.0000982326, -0.0059009437, 0.0037459724, 0.0078400429, -0.0084949136, -0.0020712297, -0.0000303935, -0.0101174312, 0.0040215179, 0.0028872194, 0.0094358716, -0.0019507137, 0.0090340925, -0.0022963169, 0.0000000000, 0.0033963460, 0.0008353253, -0.0085270684, -0.0158562008, -0.0025801547, -0.0019068574, 0.0061043818, 0.0074300612, 0.0000000000, 0.0088886749, -0.0112258429, -0.0070012040, -0.0148700681, -0.0059645963, 0.0004597439, -0.0082002543, 0.0000000000, 0.0000169196, -0.0018287043, 0.0053036790, 0.0000002134, -0.0008806102, -0.0051950230, 0.0032939916, 0.0017885953, -0.0015607419, 0.0056729638, 0.0006369475, -0.0028564979, -0.0130627071, -0.0102568632, 0.0221687388, -0.0085677905, 0.0216001254, -0.0113955038, -0.0013300851, -0.0028910921, -0.0017029208, -0.0000000000, 0.0107393395, 0.0060052453, -0.0016114943, -0.0069576446, 0.0002562853, 0.0062777176, -0.0048279199, -0.0159638058, -0.0162956659, 0.0148285385, 0.0000161354, 0.0063148001, -0.0078761755, 0.0045509888, 0.0091077760, 0.0007163499, 0.0003530805, 0.0109189730, -0.0062113707, -0.0087800939, 0.0033457652, 0.0151809929, -0.0052966289, -0.0050790138, 0.0000000000, 0.0109756049, 0.0163385402, -0.0093270801, 0.0108817117, -0.0013699570, 0.0020470999, -0.0021021462, 0.0086393123, -0.0000010846, -0.0075526293, -0.0110235075, -0.0111263618, -0.0130823534, 0.0046870871, -0.0005516103, -0.0190397408, -0.0000000000, -0.0039085578, 0.0117589068, -0.0018974658, -0.0001177758, -0.0164697822, 0.0100817233, -0.0004812829, 0.0098678917, -0.0048158574, 0.0051055322, 0.0044725738, -0.0023289958, -0.0081921639, -0.0096547697, -0.0041096434, -0.0123672886, -0.0063924007, -0.0094689382, 0.0049010823, -0.0001328995, 0.0088385707, 0.0000000000, -0.0098469853, 0.0009021935, -0.0007652868, -0.0041715368, 0.0000771824, 0.0112422211, 0.0083831893, -0.0055104038, -0.0158835053, 0.0011759659, -0.0000236615, 0.0062251752, -0.0112272752, -0.0061924644, 0.0082673877, 0.0021465505, 0.0027872981, -0.0093709053, -0.0007554514, 0.0100595560, 0.0073837568, 0.0058480753, 0.0004516420, 0.0013680890, -0.0000000000, 0.0011047641, -0.0006187372, 0.0004053671, 0.0079998914, 0.0018136081, -0.0078928359, -0.0015686302, -0.0026359130, -0.0000006531, -0.0073720617, 0.0125967693, 0.0059296549, 0.0019594196, 0.0024298963, 0.0011106069, -0.0004582895, 0.0000000000, -0.0006733270, -0.0139713110, 0.0106470715, 0.0000164491, -0.0010629080, -0.0041712546, 0.0063627386, -0.0026642610, -0.0074850498, 0.0068466533, -0.0042261621, -0.0005310799, -0.0073102191, -0.0035659792, 0.0007851658, -0.0087490529, 0.0035531509, 0.0059671309, -0.0098806266, 0.0095076263, -0.0022400746, -0.0000000000, -0.0053769676, -0.0018704355, -0.0154247032, 0.0077183577, 0.0000018255, 0.0004423197, -0.0118222926, 0.0024301212, -0.0027661689, 0.0001223680, 0.0000423138, 0.0112089682, -0.0030602708, -0.0019824235, 0.0003742402, 0.0007128295, -0.0031534634, 0.0046864664, 0.0013970323, 0.0027280492, 0.0033108643, -0.0037016398, 0.0049794638, 0.0043973206, 0.0000000000, -0.0012184728, 0.0068948795, -0.0033574740, -0.0141612608, -0.0012830567, -0.0034522228, 0.0109580234, 0.0056466707, -0.0000000039, 0.0020939242, -0.0132167926, -0.0007289479, -0.0086544035, -0.0073883925, 0.0009076091, -0.0072516403, -0.0000000000, -0.0001974507, -0.0011233028, 0.0037881681, 0.0000194380, -0.0005927645, -0.0014846617, -0.0021885810, -0.0003188787, -0.0005454553, 0.0076080700, -0.0009502487, -0.0000666089, -0.0100135086, -0.0057226857, 0.0154730976, -0.0057104477, 0.0081630535, -0.0022180208, -0.0017691628, 0.0024212508, -0.0046951431, 0.0000000000, 0.0059717228, 0.0004400451, 0.0019094637, -0.0099838208, 0.0002968806, 0.0065897550, -0.0023931698, -0.0106458189, -0.0147258155, 0.0104906093, 0.0000255018, 0.0056927474, -0.0085978694, 0.0034615379, 0.0087021133, 0.0045198034, -0.0038781643, 0.0069415518, -0.0030272345, -0.0071185073, -0.0023876633, -0.0044954112, 0.0294014756, 0.0093412669, 0.0000000008, 0.0275123864, 0.0406532958, -0.0084282085, -0.0045344541, -0.0162565298, -0.0142267719, 0.0413051620, 0.0183545165, -0.0001458951, -0.0006633445, -0.0194689259, -0.0016339817, -0.0106674135, -0.0101527767, -0.0003978403, 0.0037928931, 0.0000000000, -0.0027139124, -0.0052656643, 0.0070047718, -0.0019785962, -0.0011015021, 0.0093339523, 0.0051364931, -0.0067768199, 0.0025857145, 0.0263387207, 0.0004851186, 0.0228653718, -0.0166680608, -0.0127126975, 0.0363141187, -0.0007440386, 0.0213254392, -0.0069433199, -0.0119234333, 0.0089020198, -0.0107189212, 0.0000000003, 0.0181393400, 0.0100833839, -0.0105997697, -0.0364473350, -0.0014325796, 0.0152492076, -0.0040579708, 0.0059875492, -0.0158916879, 0.0314017124, -0.0000621293, -0.0079742689, -0.0387483574, -0.0060885064, 0.0400659814, 0.0224877167, -0.0119376108, -0.0123946127, -0.0054872609, 0.0018345771, -0.0218520667, -0.0045700502, -0.0052285837, 0.0016780940, 0.0000000000, -0.0010376170, -0.0010483772, -0.0011166709, -0.0010103545, 0.0013353331, -0.0018887131, -0.0030275150, 0.0004266969, 0.0000000001, 0.0038660597, 0.0023191231, -0.0029669804, 0.0005824231, 0.0004415987, 0.0010997445, -0.0042067617, 0.0000000000, 0.0060327980, -0.0050318842, 0.0018945490, 0.0000039496, -0.0009440867, -0.0039700842, 0.0018281444, 0.0023923775, -0.0044336421, 0.0002851832, -0.0009966723, -0.0028325852, -0.0032947885, -0.0006283752, 0.0028177614, -0.0033144602, 0.0016549350, 0.0034391200, -0.0011981903, 0.0041636326, -0.0025264688, 0.0000000000, -0.0044776471, -0.0009936406, -0.0023045286, 0.0037028331, -0.0000600365, -0.0004137589, -0.0044921883, -0.0012490475, 0.0005941410, 0.0013373255, 0.0000412022, 0.0026704120, 0.0006403678, 0.0016713226, -0.0070209457, -0.0013950072, -0.0018230197, 0.0043071839, -0.0033147938, 0.0005501292, -0.0005338173, 0.0157921072, -0.0051090182, -0.0131470356, -0.0000000020, 0.0125215789, 0.0070966138, -0.0129668666, 0.0106960209, -0.0073151505, 0.0000940733, 0.0023345524, 0.0116500612, -0.0000000000, -0.0055907746, -0.0004297555, -0.0064948872, -0.0139091993, 0.0090707568, -0.0011930502, -0.0076619093, -0.0000000000, -0.0027954229, 0.0205235407, -0.0138242105, -0.0000037453, -0.0029228765, 0.0119471690, -0.0058626393, 0.0118255159, 0.0025778343, 0.0153491404, 0.0091530420, 0.0015000249, 0.0003141690, 0.0002399372, -0.0184177887, -0.0091779670, -0.0040292321, -0.0120534115, 0.0001490847, -0.0025514835, 0.0053127315, -0.0000000046, -0.0119974511, -0.0029258113, 0.0019941437, -0.0001059311, -0.0000193595, 0.0061315792, 0.0091256341, -0.0107962452, -0.0071760868, 0.0052534053, -0.0000754890, 0.0098470859, -0.0100944266, -0.0164615232, 0.0071270741, 0.0005075104, 0.0009359305, -0.0108515853, 0.0033680396, 0.0067770272, -0.0060029081, -0.0040489687, -0.0233031344, -0.0086372700, 0.0000000768, -0.0189615283, 0.0085916957, 0.0071613588, 0.0250945911, -0.0007427770, 0.0070911637, -0.0030816458, -0.0128340982, -0.0000002462, -0.0070541836, 0.0039708395, -0.0102731073, -0.0124027422, 0.0091861375, 0.0017765713, 0.0118220374, -0.0000000000, 0.0028691969, 0.0183038022, 0.0054658004, -0.0000183366, -0.0177729446, 0.0047413935, -0.0248899404, 0.0091595557, -0.0110791381, 0.0006044721, 0.0108347861, -0.0250319336, -0.0147926826, 0.0192188937, -0.0036769472, 0.0063452772, -0.0128970258, 0.0043712328, 0.0074087847, 0.0004718157, -0.0122581851, -0.0000001324, -0.0238465071, -0.0085600168, 0.0176853556, 0.0240838230, 0.0001449736, 0.0039217663, 0.0028981448, -0.0169587526, -0.0248422921, 0.0005836271, 0.0001042005, -0.0100777466, 0.0077158259, 0.0046206652, -0.0071666939, -0.0013769421, 0.0093431491, 0.0000305324, -0.0102666086, 0.0123947458, 0.0109511064, -0.0022568670, 0.0040323096, 0.0014813693, 0.0000000000, -0.0037858274, 0.0042989454, -0.0001288154, 0.0034888298, -0.0036001366, 0.0018766668, -0.0021922784, 0.0042474703, 0.0000000000, -0.0004055101, -0.0064378441, -0.0022441619, 0.0032751278, 0.0054776878, 0.0002110359, 0.0088200187, 0.0000000000, -0.0004611641, 0.0011508145, 0.0027834368, -0.0000000270, -0.0006485574, 0.0009012806, 0.0039266837, 0.0027924164, -0.0003408841, -0.0063059474, -0.0015070400, -0.0006540811, -0.0014090396, 0.0075065275, -0.0001937770, -0.0032326020, -0.0040181652, -0.0018603463, 0.0026205704, 0.0006200346, -0.0083202282, -0.0000000000, -0.0003698753, 0.0049255523, 0.0021592635, 0.0025805950, -0.0001546141, -0.0023349198, -0.0039105900, -0.0056396048, 0.0022013166, 0.0004139471, 0.0000109722, 0.0002932931, -0.0102712009, -0.0011789523, -0.0057526277, -0.0016952049, 0.0000414369, 0.0036195449, -0.0015309353, 0.0055915825, 0.0005233387, -0.0028621340, 0.0090033067, -0.0033245867, 0.0000000000, -0.0003514443, -0.0009038409, -0.0100201759, -0.0081840483, -0.0009687383, -0.0022013884, 0.0004834288, 0.0033596449, 0.0000000001, 0.0123264622, -0.0071798977, -0.0017908722, -0.0032990891, -0.0011078879, 0.0009032700, -0.0041788900, 0.0000000000, 0.0015946095, -0.0028324567, -0.0000715417, 0.0000004677, -0.0031822179, -0.0053719971, 0.0029197268, 0.0046672402, 0.0012437275, 0.0006661739, -0.0008245734, 0.0000661459, -0.0030164840, -0.0050994209, 0.0148567874, -0.0086597018, 0.0183089897, -0.0063541951, -0.0021915704, 0.0008976309, -0.0043856790, 0.0000000000, 0.0089375060, 0.0059754183, -0.0018620633, 0.0002745775, -0.0000949678, 0.0018677134, -0.0033758613, -0.0084929056, -0.0052517769, 0.0101043507, 0.0000305095, 0.0060187918, -0.0057741613, -0.0012010229, 0.0022516132, 0.0002927607, -0.0002776643, 0.0128552355, -0.0066367593, -0.0037426648, 0.0064428747, 0.0192305669, -0.0111058680, -0.0107753491, 0.0000000000, 0.0168205705, 0.0062448718, -0.0222121086, 0.0191655289, -0.0039548143, -0.0015024178, -0.0043561519, 0.0094304336, 0.0000000000, -0.0019583649, -0.0056023723, -0.0062574018, -0.0107495971, 0.0097919889, 0.0006801010, -0.0174491126, -0.0000000000, 0.0030287439, 0.0127303572, -0.0058851233, 0.0000000956, -0.0010723827, 0.0066965367, -0.0026591797, 0.0127162775, -0.0036237400, 0.0057700058, 0.0102196736, -0.0004744329, -0.0082697477, -0.0041435710, -0.0289073996, -0.0112447608, -0.0120087285, -0.0095712235, -0.0034983910, -0.0077373297, 0.0101461923, 0.0000000000, -0.0111716315, -0.0008524668, -0.0020102058, 0.0030807308, -0.0001551806, 0.0123824487, 0.0054217945, -0.0052944445, -0.0054347645, -0.0024609074, 0.0000260000, 0.0110348901, -0.0179271996, -0.0273273960, 0.0101656653, 0.0017461276, 0.0038944581, -0.0034415959, -0.0157180857, 0.0131176785, 0.0114763621, -0.0015134204, -0.0072568171, 0.0008324975, 0.0000000000, -0.0001285482, 0.0006067991, 0.0120736072, -0.0006957912, 0.0036362966, -0.0020311743, -0.0044867382, -0.0012506717, 0.0000000000, 0.0012142542, 0.0017168069, -0.0046518450, -0.0037916892, 0.0003553797, 0.0003745849, -0.0045928592, 0.0000000000, -0.0006450145, -0.0061247409, 0.0046906318, 0.0000000239, -0.0077778450, -0.0036248055, 0.0043822899, 0.0013136779, -0.0091851102, -0.0010023920, 0.0000880536, -0.0045443089, -0.0115450285, -0.0009528160, 0.0019677465, -0.0023691822, 0.0011547380, 0.0004934137, -0.0009302159, 0.0052863630, -0.0023360811, -0.0000000000, -0.0060692867, 0.0002988116, -0.0044485531, 0.0029862348, -0.0001171413, -0.0014280782, -0.0072730607, 0.0006352959, -0.0007206430, 0.0023456495, 0.0000192668, 0.0007245720, 0.0071675805, 0.0051909685, -0.0038665412, -0.0031600958, -0.0001168362, 0.0022601339, 0.0014254330, 0.0018348815, 0.0004895242, -0.0013746327, -0.0003805697, -0.0001162459, 0.0000000000, 0.0041417503, 0.0023414255, 0.0025996298, -0.0033030675, 0.0005859034, -0.0031807076, -0.0046426267, -0.0004293706, 0.0000000000, 0.0062893429, 0.0015975047, 0.0040195384, 0.0048319213, 0.0049603381, 0.0004885984, -0.0007373762, 0.0000000000, -0.0006243276, -0.0064986325, 0.0003205178, 0.0000000003, 0.0000446972, 0.0027500747, 0.0057977345, 0.0003750606, 0.0023021041, 0.0017572544, -0.0013732807, -0.0027865088, -0.0071944906, 0.0022147703, 0.0023068069, -0.0085385330, -0.0041154441, 0.0054426962, -0.0034446132, 0.0033154478, -0.0021536397, 0.0000000000, -0.0060533481, -0.0003516071, -0.0038522296, 0.0034990073, -0.0001529717, -0.0035390947, -0.0058072647, -0.0065506031, 0.0044322573, 0.0009905987, 0.0000405088, 0.0045442679, -0.0072275233, -0.0116959037, -0.0030567870, 0.0010218213, -0.0043042293, 0.0082736900, 0.0022173144, 0.0060021691, 0.0027520892, 0.0080710044, 0.0198409148, 0.0158275999, -0.0000000000, 0.0183096677, 0.0291148294, -0.0063756728, -0.0165573433, -0.0060335277, -0.0124101089, 0.0250143297, 0.0071818349, -0.0000877517, -0.0003626428, -0.0170247257, -0.0095069408, -0.0067978827, -0.0166800097, -0.0012564259, -0.0107843392, -0.0000000000, -0.0044931085, -0.0089902161, 0.0180819184, -0.0014925333, -0.0037486148, 0.0054144673, 0.0024453192, -0.0152238049, 0.0077776685, 0.0214694291, -0.0042457148, 0.0149866249, -0.0082276445, -0.0222365502, 0.0377171040, -0.0076957978, 0.0111628165, 0.0008156943, -0.0167382788, 0.0051534395, -0.0091865240, -0.0000000000, 0.0136358859, -0.0067749191, -0.0057228273, -0.0237349719, -0.0007845131, 0.0127918655, 0.0043980912, 0.0114774946, -0.0335091464, 0.0266065374, -0.0003005982, -0.0175501704, -0.0146686183, 0.0176142436, 0.0246498007, 0.0180946589, 0.0024332651, -0.0096005928, -0.0050023673, -0.0132882558, -0.0238581598, 0.0353678837, 0.0283155739, 0.0153010171, -0.0000047887, 0.0394424833, 0.0126841385, -0.0234365445, -0.0117309280, -0.0062915981, -0.0246165544, 0.0117607331, 0.0312613398, -0.0001494498, 0.0034861236, -0.0304702185, -0.0246929061, -0.0193003770, 0.0153533323, -0.0137473205, -0.0260509718, -0.0000002490, -0.0202741958, 0.0089275641, 0.0064262771, -0.0044413563, -0.0260074083, 0.0283605102, 0.0097681060, 0.0068671335, -0.0083001349, 0.0188897401, -0.0011571894, 0.0238781590, -0.0075908434, -0.0160483029, 0.0161169544, -0.0183027331, 0.0100655062, -0.0236013085, -0.0150605189, -0.0237642005, 0.0149093485, -0.0000015770, 0.0082630021, 0.0006605643, -0.0128437933, -0.0252823085, -0.0101492042, 0.0150560709, 0.0082393400, 0.0078952573, -0.0159764066, 0.0309808943, -0.0052308729, 0.0137771582, -0.0278923698, -0.0103051532, 0.0372820087, 0.0221646875, 0.0232081786, -0.0173185542, -0.0158401374, 0.0025083192, -0.0205920823, -0.0075859684, -0.0041738697, 0.0003942455, 0.0000000000, -0.0045461934, 0.0008201071, 0.0063856053, -0.0073917173, 0.0018919467, -0.0011401146, -0.0158305243, -0.0012790689, 0.0000000027, 0.0038023461, -0.0036146471, -0.0020848364, -0.0024077024, -0.0038956448, 0.0010363793, -0.0103628151, -0.0000000000, -0.0001884215, -0.0082542896, 0.0074637425, 0.0000018094, -0.0137037020, -0.0063264128, 0.0042362818, 0.0020517115, -0.0049077249, -0.0023713082, -0.0002988190, -0.0077088862, -0.0061812312, -0.0069082109, 0.0134866368, -0.0026538866, 0.0030902904, 0.0055113733, -0.0006383792, 0.0076705259, -0.0090603717, 0.0000000000, 0.0020924369, 0.0031207078, 0.0040685465, 0.0025340959, -0.0000022951, 0.0020963068, -0.0062290933, -0.0008677900, -0.0113622062, 0.0073050703, 0.0000426723, -0.0031601069, -0.0061609042, 0.0126870777, -0.0052299104, -0.0049978304, 0.0051674019, 0.0144045278, 0.0004388847, -0.0039506280, 0.0033250307, -0.0024454370, -0.0000078816, -0.0005559613, 0.0000000000, -0.0023118309, 0.0008037461, -0.0078314971, -0.0027939240, 0.0011461213, -0.0054292781, -0.0094655640, 0.0008684768, 0.0000000000, 0.0032563002, 0.0025367625, 0.0024648483, 0.0026179985, -0.0005785230, 0.0010908651, -0.0064250352, -0.0000000000, -0.0009397045, -0.0039961888, 0.0017660332, 0.0000002288, -0.0016181560, -0.0056410721, 0.0025619138, 0.0057596117, 0.0009964273, -0.0006954849, -0.0037424020, -0.0035523446, -0.0014636740, -0.0063998704, 0.0031058749, -0.0065417541, 0.0041708210, 0.0074959276, -0.0037175454, 0.0027068811, -0.0028842171, -0.0000000000, -0.0023340110, 0.0019676629, -0.0028365997, 0.0024921033, -0.0003022529, -0.0011193661, -0.0035242178, -0.0007477753, 0.0009957062, 0.0035633531, 0.0000443039, 0.0097338948, -0.0002117809, -0.0001878582, -0.0076202448, -0.0002086706, -0.0035268737, 0.0067669093, -0.0026668161, 0.0002475990, 0.0037146611, -0.0055038622, -0.0096817529, -0.0046321056, -0.0000000000, -0.0134916203, 0.0153337633, 0.0116094723, 0.0136998547, -0.0048861662, 0.0126710031, -0.0054331110, -0.0093548298, -0.0000000000, -0.0139466217, -0.0015918200, 0.0048585902, -0.0008484598, 0.0031939656, -0.0003077580, 0.0136081008, -0.0000000000, -0.0026718462, 0.0062995558, 0.0047083693, -0.0000000194, 0.0039303377, 0.0041432884, -0.0195530877, 0.0054121041, 0.0019370208, -0.0136090275, 0.0000277847, -0.0159249976, -0.0164318718, 0.0107041821, 0.0025106624, 0.0043587987, -0.0316778757, 0.0055353278, 0.0054757372, 0.0004204321, -0.0231531318, -0.0000000000, -0.0207615886, -0.0009843664, 0.0142084956, 0.0146066537, -0.0002227067, -0.0113466764, -0.0090296846, -0.0147875911, -0.0073042912, 0.0031712034, -0.0000030046, -0.0134808607, 0.0100351172, 0.0112401322, -0.0133189894, -0.0074645830, -0.0021196434, -0.0199741498, 0.0127858296, 0.0069618588, 0.0192214418, 0.0250145737, -0.0081035933, 0.0036780413, 0.0000000009, 0.0229201671, 0.0022783419, -0.0223103110, 0.0184646565, 0.0042957473, -0.0161014162, -0.0137645593, 0.0181108210, 0.0000000000, 0.0049131913, -0.0107391896, -0.0117314421, -0.0170512404, 0.0159460474, -0.0009136132, -0.0404696465, 0.0000000000, -0.0063724932, 0.0161824934, -0.0038327861, -0.0000229936, -0.0200409517, 0.0130321681, 0.0027789287, 0.0168143883, -0.0100380387, 0.0115397321, 0.0016465686, -0.0026967733, -0.0069738966, -0.0174012445, -0.0191502087, -0.0227044262, 0.0060102935, -0.0230927877, -0.0071754651, -0.0210497603, 0.0250648521, 0.0000000000, -0.0019270359, -0.0033314633, -0.0096760662, -0.0046660849, -0.0000550990, 0.0178241748, 0.0119255167, -0.0011838608, -0.0147431148, 0.0071562803, -0.0000421448, 0.0316196159, -0.0116741415, -0.0179922972, 0.0107695144, 0.0044587301, 0.0183782950, 0.0057026353, -0.0184984300, 0.0131550459, 0.0013492646, 0.0094204284, 0.0141961379, -0.0057423199, -0.0000000041, 0.0013943041, 0.0023995645, -0.0097199576, 0.0067179641, -0.0081047611, 0.0035911554, 0.0116321268, 0.0020793728, -0.0000000696, -0.0010332706, 0.0049752905, -0.0036523489, -0.0013415405, 0.0097129187, -0.0040448974, 0.0233561415, -0.0000000001, -0.0034324522, 0.0074045858, -0.0011780849, -0.0002512876, 0.0018688515, 0.0120602194, -0.0026280941, -0.0014441245, -0.0014186569, 0.0106695509, 0.0014841683, 0.0025692938, 0.0006496047, 0.0224082693, 0.0011362272, 0.0054214112, -0.0114489449, -0.0031510820, 0.0092398087, -0.0083837761, -0.0007591259, -0.0000000002, -0.0026132239, 0.0000996708, 0.0022816325, 0.0017734705, 0.0003512089, 0.0005691006, 0.0048322836, -0.0059800395, -0.0004287435, -0.0006012567, -0.0002799783, -0.0083782366, -0.0125355851, -0.0124523593, 0.0137477228, 0.0031763755, 0.0030276142, -0.0138521828, -0.0048521692, 0.0001895578, -0.0090680625, -0.0177335497, 0.0080666654, 0.0081566516, 0.0000000059, -0.0112443408, 0.0001697711, 0.0019386777, 0.0037963181, 0.0045820838, 0.0039553051, 0.0205671564, 0.0058033699, -0.0000060964, -0.0012815773, 0.0178078059, 0.0097560799, -0.0010935380, 0.0057620355, 0.0005494402, -0.0082598384, 0.0000000000, 0.0006369893, 0.0054510403, 0.0008964760, -0.0003041871, 0.0023639414, -0.0058651231, 0.0065804659, -0.0022062880, -0.0025049429, 0.0063352096, -0.0067268414, 0.0041321535, -0.0130909877, -0.0135686481, 0.0149514340, -0.0019628177, -0.0137071200, -0.0009527641, 0.0054382021, -0.0273356196, -0.0018401573, 0.0000000000, -0.0072803968, -0.0190061014, 0.0044980422, -0.0175207835, 0.0010520770, 0.0137066590, -0.0043885950, -0.0216415040, -0.0033764618, 0.0223422311, 0.0000616136, 0.0078192223, -0.0006807537, 0.0103833275, 0.0058235177, 0.0084146028, -0.0245949756, -0.0023003197, -0.0157938339, -0.0064433240, 0.0114460364, 0.0216508228, -0.0351186059, -0.0162935629, 0.0000002216, 0.0106470985, -0.0041833655, 0.0078084725, 0.0276329685, -0.0068510021, -0.0120914346, -0.0129872393, 0.0105290301, 0.0000000039, -0.0065270732, -0.0072099878, -0.0065876348, -0.0044349865, -0.0160768367, 0.0002586744, -0.0083380714, -0.0000000029, 0.0049928809, 0.0192906410, -0.0059887208, 0.0000203392, -0.0011674658, 0.0059617660, -0.0337269418, -0.0025080838, -0.0016676784, 0.0115876589, 0.0287519172, -0.0093886461, -0.0061570271, 0.0097827520, -0.0160141699, -0.0002216705, -0.0074162167, -0.0066303089, -0.0036891298, 0.0038091482, 0.0102832494, -0.0000001579, -0.0158700794, 0.0028459085, 0.0053183152, -0.0306067280, -0.0000964465, 0.0039796145, 0.0308513809, -0.0059136734, -0.0081434362, -0.0064376621, 0.0008468963, -0.0142686507, -0.0047618146, -0.0372750498, 0.0244926438, 0.0173190292, 0.0163903553, -0.0303216781, -0.0071425652, 0.0055587688, 0.0068048444, 0.0098532205, 0.0488078818, 0.0007991721, -0.0000007089, 0.0112460256, 0.0261247531, 0.0145440092, -0.0165311825, 0.0222165119, -0.0167272463, -0.0235459674, 0.0094376933, -0.0000075644, -0.0040636393, -0.0283719599, -0.0085402196, 0.0007924960, -0.0216116980, -0.0053392984, 0.0018060440, -0.0000000482, -0.0018211257, -0.0229972266, -0.0135575840, 0.0032107753, -0.0358489864, -0.0091428235, 0.0123312585, 0.0346623473, -0.0164753385, 0.0036313124, 0.0072362027, 0.0147236316, -0.0144640598, 0.0011109991, -0.0084530078, 0.0204263330, -0.0039308197, -0.0003906713, -0.0233963076, 0.0242653359, -0.0380581915, -0.0000062067, 0.0191315822, 0.0449098945, 0.0059972834, -0.0135358628, -0.0003967605, 0.0002508415, -0.0070444713, 0.0234181285, 0.0022004289, 0.0169330705, -0.0009985672, 0.0055814669, 0.0220542960, 0.0221683867, 0.0063136793, 0.0043640835, -0.0012268838, -0.0216741767, 0.0254277959, -0.0324511416, -0.0230234005, -0.0091343848, 0.0267607067, -0.0139087914, 0.0000076110, 0.0343266279, -0.0028829838, 0.0182493869, -0.0087086838, 0.0174044166, 0.0097396914, -0.0368911996, 0.0136006931, 0.0000096973, 0.0151899289, -0.0108407130, -0.0078253634, -0.0203400813, 0.0038832200, -0.0011642401, -0.0081006410, 0.0000000687, -0.0048765880, 0.0014998948, -0.0090058353, 0.0001580405, -0.0232534166, -0.0269188359, 0.0207777433, 0.0187285580, -0.0297868066, -0.0130289877, 0.0148634193, 0.0161010511, -0.0370594300, -0.0105556855, -0.0001469766, 0.0132401343, -0.0107905436, 0.0137711028, -0.0003679655, -0.0035559661, 0.0158024374, -0.0000009079, 0.0170568805, 0.0093541453, 0.0055346712, 0.0018853272, 0.0013694540, 0.0043773097, -0.0115364185, 0.0045226561, 0.0155841205, 0.0092385486, -0.0018923173, 0.0244897231, 0.0057373354, 0.0024735525, 0.0008695330, -0.0000595459, -0.0147666270, 0.0054181144, -0.0007763280, 0.0030060103, 0.0287677348, 0.0128972251, 0.0134455347, 0.0192250125, -0.0000004277, 0.0128529500, 0.0056404942, -0.0356113985, 0.0257359408, 0.0122489240, -0.0022412434, -0.0044150911, 0.0152340224, -0.0000642312, -0.0074818898, 0.0107567273, -0.0057026334, -0.0188842192, 0.0189363994, -0.0013799472, -0.0184182525, 0.0000000092, -0.0078472933, 0.0214487761, -0.0037725063, 0.0003304264, -0.0137841357, -0.0011439204, 0.0167107098, 0.0272051431, -0.0049320986, 0.0024316872, 0.0067619937, 0.0143733565, -0.0239578895, -0.0164985657, -0.0088241678, -0.0062310598, 0.0259491540, -0.0219505094, 0.0003518075, -0.0325516164, -0.0016163257, -0.0000125002, 0.0065784394, 0.0163884163, -0.0153353559, -0.0099274414, -0.0029654708, 0.0004710548, 0.0016406402, -0.0100216344, 0.0091936188, 0.0179169867, -0.0000369736, 0.0408348367, -0.0064764069, -0.0064474656, 0.0002953262, 0.0157231800, -0.0069389939, -0.0206424315, -0.0183583293, -0.0058065285, 0.0135715045, 0.0190882850, 0.0014026924, 0.0160349775, 0.0000250468, 0.0235445965, 0.0359882340, -0.0393050276, 0.0250901505, -0.0039326493, 0.0242846552, -0.0426317789, 0.0133241462, -0.0004534955, -0.0146766296, 0.0470059849, 0.0148408683, 0.0141269406, 0.0461161621, -0.0055090683, -0.0005529408, 0.0000002201, -0.0118394680, 0.0165102985, 0.0218799189, -0.0017242301, -0.0165265948, 0.0086006774, 0.0184648782, -0.0166333579, -0.0221518353, -0.0107954806, 0.0201362260, 0.0169508345, -0.0066662412, -0.0198553130, -0.0286966488, -0.0112578869, 0.0146049680, 0.0063301036, 0.0260414258, -0.0074594012, 0.0521672443, -0.0000065250, 0.0209881477, 0.0141959768, 0.0077764979, 0.0049383128, 0.0012444973, 0.0007577814, -0.0054298909, 0.0124988807, 0.0021624402, 0.0011111341, -0.0018964151, 0.0018227316, -0.0421011299, -0.0156766325, -0.0071361577, 0.0044399165, 0.0186512694, -0.0069460934, 0.0082159834, 0.0351229161, 0.0215307195, -0.0052940738, 0.0266591497, -0.0168257616, 0.0000003446, -0.0103980610, -0.0072507886, -0.0023978739, -0.0088830432, -0.0170773640, -0.0133060236, 0.0068168775, -0.0026592785, -0.0000466372, 0.0059659011, 0.0053577721, 0.0090262182, -0.0007415921, -0.0028490887, -0.0004895501, 0.0061327326, 0.0000000169, 0.0015521127, -0.0149339978, -0.0329641253, -0.0004234691, 0.0013974551, -0.0072190277, 0.0178071614, -0.0009914162, -0.0031958320, 0.0117935752, -0.0011571599, 0.0120398980, -0.0016128661, -0.0152114863, -0.0024727522, -0.0044224341, -0.0072948318, 0.0124316104, -0.0117596565, 0.0038591682, 0.0183922444, 0.0000000023, 0.0045789308, -0.0066107754, -0.0038283169, -0.0096126003, 0.0007527085, 0.0038590266, -0.0035901207, 0.0095240595, 0.0096100289, 0.0077736625, 0.0001188618, -0.0075551360, -0.0158732701, -0.0114488136, 0.0067467708, 0.0088464925, -0.0085968515, 0.0020430251, -0.0027922348, 0.0000426347, 0.0008504314, -0.0036226925, 0.0056525823, -0.0022004812, 0.0000000037, 0.0125534069, 0.0267896838, -0.0094604120, -0.0078555550, -0.0098934267, -0.0086968588, 0.0269409548, 0.0154873664, -0.0000880536, -0.0018020689, -0.0339685380, -0.0047705877, -0.0056898254, -0.0065443623, 0.0004874334, -0.0030734576, -0.0000000000, -0.0018395720, -0.0048846509, 0.0072689522, -0.0006562714, 0.0008062773, 0.0076976516, 0.0016525402, -0.0072485278, -0.0044034980, 0.0187874492, 0.0010442602, 0.0163367093, -0.0081590163, -0.0112901768, 0.0088004582, -0.0016510690, -0.0007030572, 0.0012205533, -0.0065394384, 0.0028243770, -0.0039785607, 0.0000000008, 0.0108875483, 0.0100450870, -0.0147396633, -0.0187303368, -0.0006249822, 0.0047884141, -0.0022920473, 0.0075551770, -0.0171329565, 0.0120995175, 0.0001081542, -0.0043318477, -0.0257748645, -0.0075337733, 0.0251329616, 0.0091031194, -0.0020185215, -0.0006897992, 0.0099712396, 0.0026020790, -0.0104866717, -0.0201607328, 0.0203254800, 0.0135789439, 0.0000017616, 0.0148676578, -0.0168338660, -0.0047258483, 0.0131445862, -0.0033024978, -0.0000334203, 0.0000028099, 0.0186098851, -0.0000343452, 0.0173286237, -0.0050723497, -0.0321244225, -0.0243063010, 0.0242958125, 0.0016043441, 0.0074942992, 0.0000000270, 0.0027952564, 0.0180877093, -0.0065198392, -0.0008111002, -0.0071362173, -0.0032202534, 0.0134166721, 0.0185814854, 0.0001068189, 0.0051406142, -0.0073745516, 0.0136541016, -0.0071880152, 0.0087461062, 0.0196587462, -0.0131772123, 0.0440382212, -0.0140291685, 0.0173061546, -0.0225058403, -0.0230035763, 0.0000001757, 0.0044924412, 0.0227741227, 0.0061430861, 0.0090975547, 0.0001315747, 0.0084181856, -0.0146649079, -0.0232375748, -0.0018807305, 0.0254784916, -0.0004349636, 0.0389023647, 0.0213689208, -0.0004979637, 0.0080656903, 0.0071545583, -0.0359533019, 0.0177386776, -0.0055670431, 0.0149356984, -0.0000182086, 0.0074974662, 0.0122427633, -0.0393750668, 0.0000010654, -0.0203567185, -0.0179800205, -0.0111345593, -0.0660788044, 0.0081741093, -0.0145552019, 0.0283532590, -0.0098829195, 0.0000050777, 0.0358104259, -0.0312411580, 0.0093674101, -0.0276534855, -0.0183798112, 0.0095438985, 0.0210440252, 0.0000000095, -0.0009090313, -0.0029122753, -0.0172925983, -0.0022500544, 0.0091591459, -0.0138441110, -0.0215146206, 0.0369088016, -0.0028933324, -0.0009845146, -0.0226910356, 0.0076910788, 0.0101114865, 0.0505407043, 0.0077822213, -0.0126514761, 0.0199548211, 0.0100606289, 0.0035339671, 0.0077971062, -0.0349162407, -0.0000025306, -0.0188660473, 0.0118827969, -0.0061164643, 0.0372118838, -0.0034498787, -0.0357656851, -0.0015076231, -0.0296105053, 0.0165694654, 0.0017643553, -0.0015414462, 0.0186127946, 0.0377383716, 0.0535972752, -0.0018835256, -0.0103325713, -0.0320350155, -0.0105117513, 0.0002121969, -0.0268599074, 0.0123874731, 0.0152015500, 0.0058182720, -0.0173631161, -0.0000004945, 0.0118187135, -0.0081972247, 0.0076441346, -0.0150225852, 0.0044693979, -0.0119432509, 0.0193037763, 0.0077562099, -0.0001787016, 0.0302040800, -0.0386704728, 0.0039128824, -0.0422043018, -0.0179871656, -0.0018024850, 0.0114078335, -0.0000000261, 0.0049696038, 0.0066303541, -0.0223209634, -0.0006567979, -0.0038656413, 0.0030141613, -0.0117636472, 0.0315127298, 0.0101468023, 0.0208334867, 0.0005761807, 0.0182331130, -0.0063124369, 0.0209213644, 0.0055534006, -0.0006555108, 0.0292859785, 0.0090904944, -0.0018042012, 0.0204414204, -0.0027085545, -0.0000104056, 0.0068082386, 0.0215441957, 0.0038438542, -0.0075470284, -0.0033294735, -0.0235857721, 0.0192490742, -0.0193468370, 0.0013896718, 0.0177715197, -0.0012601117, 0.0210042559, 0.0121702421, -0.0160387531, 0.0195304658, 0.0121292109, -0.0088770669, -0.0284700878, 0.0040332866, -0.0145302759, -0.0174717121, -0.0492202751, -0.0485904440, -0.0312053282, -0.0000012770, -0.0160528179, -0.0048543117, 0.0326429605, -0.0031563470, 0.0023060185, 0.0075472975, 0.0044505997, -0.0298284367, 0.0000039537, 0.0044265208, -0.0288992431, 0.0175193306, 0.0010955813, -0.0401970856, -0.0000276231, 0.0292721447, -0.0000001469, -0.0021373674, 0.0063068056, 0.0335839763, -0.0011423695, -0.0089957789, -0.0309661161, -0.0264988020, -0.0335576423, 0.0220397711, -0.0174023621, 0.0166323427, -0.0362390205, 0.0067281267, -0.0203727875, 0.0025167626, 0.0155298440, -0.0225880183, 0.0422115177, 0.0133642219, 0.0383854546, -0.0873187557, 0.0000009780, 0.0048137684, -0.0067717833, 0.0581855066, 0.0288757961, -0.0042698169, -0.0055845533, -0.0081045609, 0.0052754437, -0.0481613874, 0.0117410086, -0.0027535760, -0.0515566617, 0.0162062775, 0.0386482738, -0.0110986484, -0.0405777991, -0.0067529879, 0.0105372705, 0.0338462926, 0.0018968573, 0.0269063171, 0.0092204819, -0.0096922815, -0.0109213572, -0.0000002898, -0.0024471229, -0.0087524243, -0.0393070392, 0.0118182069, 0.0147279482, -0.0111338086, 0.0055408897, -0.0068138130, -0.0000010086, 0.0217602197, -0.0145423934, -0.0054545198, -0.0179124828, -0.0015473755, -0.0023126476, -0.0218359623, -0.0000000539, -0.0071261842, 0.0167156197, -0.0048094611, -0.0009405364, -0.0211963598, 0.0075312117, -0.0029981968, 0.0371950828, -0.0168014988, 0.0185058583, 0.0109048607, 0.0154934898, -0.0083443103, -0.0093793701, 0.0051532127, -0.0304445308, 0.0126287695, 0.0285395253, -0.0104316957, -0.0061029484, 0.0138962269, -0.0000057313, -0.0143834231, 0.0154505149, 0.0084818657, -0.0056759748, -0.0002669956, -0.0138400579, 0.0220677573, 0.0233836640, 0.0003525621, 0.0319069251, 0.0003911057, 0.0200009681, 0.0045061125, 0.0062279673, -0.0082474928, 0.0124208461, 0.0191347208, -0.0237369742, -0.0196380410, -0.0107190209, 0.0131013226, -0.0095613478, 0.0203213599, 0.0094071990, -0.0000631221, 0.0170217007, -0.0119974781, -0.0060321684, 0.0108577097, -0.0105858417, 0.0071828444, -0.0291265659, -0.0083495285, -0.0003966842, 0.0209989026, 0.0248766132, 0.0100648040, -0.0418512709, 0.0199078973, -0.0060843667, 0.0021917426, -0.0000032580, -0.0240356103, 0.0142589640, 0.0005505093, -0.0089339782, -0.0297125485, 0.0163048897, 0.0133033656, 0.0284885019, -0.0141256042, 0.0152143305, 0.0096128099, -0.0155390138, -0.0383149236, 0.0007733533, 0.0206291005, 0.0096407915, 0.0107809966, 0.0067606852, 0.0111801457, -0.0099439323, -0.0146046346, -0.0000381845, 0.0015905037, 0.0215236712, 0.0341199487, 0.0282533485, -0.0021936037, 0.0078758541, -0.0004218768, -0.0096924100, -0.0303603392, 0.0212261211, -0.0011701586, -0.0203208867, -0.0298173260, 0.0069422787, 0.0036287534, 0.0249649063, 0.0059700403, -0.0351714008, -0.0017390628, -0.0023122914, 0.0340909325, -0.0010420668, 0.0204072837, -0.0025343010, -0.0000506226, 0.0290086363, 0.0032953238, -0.0187494121, -0.0186566077, -0.0017091556, 0.0138239870, -0.0039926181, 0.0098828664, -0.0003528760, 0.0121481065, 0.0235690940, 0.0130402222, -0.0073331650, -0.0118340123, 0.0021070740, -0.0061649983, 0.0000000075, 0.0039065443, -0.0043090028, 0.0009158404, -0.0037411808, -0.0027762197, -0.0157240033, 0.0162099041, -0.0107011860, -0.0028707655, -0.0090448065, 0.0089365188, 0.0057177888, -0.0142366765, -0.0376064405, 0.0172754861, -0.0061562392, 0.0301061347, 0.0173167735, -0.0039532706, 0.0039901859, 0.0414232947, 0.0000003133, 0.0086529246, -0.0124362474, 0.0240148697, -0.0047602067, 0.0028322323, 0.0101346839, -0.0084465295, 0.0076626120, -0.0268274844, 0.0168694798, 0.0005978093, -0.0186453331, -0.0345570445, 0.0055160592, -0.0013029396, 0.0070482008, -0.0073195794, -0.0046410724, -0.0062708175, -0.0040445835, 0.0288224947, -0.0214979090, 0.0323919393, 0.0003074600, -0.0000004079, 0.0147694713, -0.0003323513, 0.0195490364, -0.0151733672, 0.0033754103, -0.0147328060, 0.0057405466, 0.0238124374, 0.0000047985, 0.0204522982, -0.0265923291, -0.0052677300, -0.0191737246, -0.0152539406, -0.0030651484, 0.0250195377, 0.0000000040, 0.0078184269, 0.0112006273, -0.0211376287, 0.0007728947, -0.0272618011, -0.0260517448, 0.0008220861, 0.0174066462, -0.0031739722, -0.0001114147, 0.0089704795, 0.0245551299, -0.0083073927, -0.0129327644, 0.0125659686, -0.0021705232, 0.0242102891, 0.0027813511, -0.0078099738, -0.0005363969, -0.0107913474, 0.0000002201, 0.0193179473, 0.0357725769, 0.0164877493, 0.0024121988, -0.0029269196, 0.0052933847, -0.0168407168, 0.0031212529, 0.0299368948, 0.0248676296, -0.0008303558, 0.0166852791, 0.0164413303, -0.0018717607, 0.0108715082, 0.0081855673, -0.0273311250, -0.0012250075, 0.0003342635, -0.0141179143, 0.0002418869, 0.0068150703, 0.0081380652, 0.0212160777, -0.0006219249, 0.0266282521, -0.0161436815, -0.0386070870, 0.0245433506, 0.0171019528, 0.0318098739, -0.0346776582, 0.0199203752, -0.0012354556, 0.0210630856, 0.0074259653, 0.0172894765, -0.0119171590, 0.0051237294, -0.0070748129, -0.0013719166, 0.0000007288, 0.0062335487, 0.0306115132, -0.0056857122, -0.0020767911, -0.0101829739, -0.0021257598, 0.0179107282, -0.0002178273, -0.0298980214, -0.0161356982, 0.0309487749, 0.0044056429, -0.0233653765, -0.0183843039, 0.0100672115, -0.0186371878, 0.0198030435, 0.0182397906, 0.0199990571, -0.0240588970, 0.0477131419, 0.0000484533, 0.0201569628, -0.0044780145, 0.0227949154, 0.0032461847, 0.0025267720, -0.0002969330, -0.0083509544, -0.0083004097, -0.0132623352, 0.0032656044, -0.0003151667, 0.0117780259, 0.0218794588, -0.0033066676, 0.0008395524, 0.0098029925, -0.0147186257, -0.0315703638, -0.0053732409, 0.0085499836, 0.0157573223, 0.0049159476, -0.0112424195, -0.0019375985, 0.0000000001, -0.0099400245, 0.0023550943, -0.0330831334, 0.0127597535, 0.0028928691, -0.0054223151, -0.0012238894, -0.0071011237, 0.0000000592, -0.0076624434, 0.0054878723, 0.0030783396, 0.0039783409, 0.0021944016, 0.0011632250, -0.0112266541, -0.0000000000, 0.0035720607, -0.0004456757, 0.0002568935, 0.0000111330, -0.0004158350, 0.0032344623, -0.0010883631, -0.0019603833, -0.0049665472, -0.0007552950, -0.0000854182, -0.0053698900, 0.0048740534, -0.0082673142, -0.0048304265, -0.0145883253, -0.0185616277, 0.0091902791, -0.0069698761, -0.0026792306, 0.0036433439, 0.0000000000, -0.0137764951, -0.0155381672, -0.0056095626, 0.0007716961, -0.0000475861, 0.0014781634, -0.0018888736, 0.0103595247, 0.0115598384, -0.0010699481, 0.0000735706, -0.0086601023, -0.0022623900, -0.0031202585, -0.0138860624, -0.0058153626, 0.0147955883, -0.0118701700, -0.0205815360, 0.0050252522, -0.0003471379, -0.0018501772, -0.0041238628, -0.0225599967, -0.0000068705, -0.0213571321, -0.0136014298, 0.0163590796, -0.0435592681, 0.0086462768, -0.0037020843, 0.0288228355, -0.0123162754, -0.0006231922, 0.0108011924, -0.0322320238, 0.0085870298, -0.0137271928, -0.0054401332, -0.0002187516, 0.0269846264, -0.0000004374, -0.0066870991, 0.0029713053, -0.0009565077, -0.0013929657, 0.0068709217, 0.0069196168, -0.0348381139, 0.0136168590, 0.0132601131, 0.0140597420, -0.0095848907, -0.0035221698, 0.0024272911, 0.0635406226, 0.0110611795, 0.0190942064, -0.0030463093, 0.0064823218, 0.0081543447, -0.0013118063, -0.0375444181, -0.0000077505, -0.0160720553, 0.0133437319, -0.0080918465, 0.0133846076, -0.0048948210, -0.0236593094, 0.0148845222, -0.0116449064, 0.0006302136, -0.0000691110, -0.0036668943, 0.0023400229, 0.0425581560, 0.0312604606, -0.0032261792, -0.0014409455, -0.0133769708, -0.0040263920, 0.0107566807, -0.0148156611, -0.0170761459, -0.0013155981, -0.0293631833, 0.0045324657, 0.0000011464, -0.0326451026, -0.0406621955, -0.0261236224, 0.0256983303, 0.0237467606, -0.0160872974, -0.0092782825, 0.0091711823, -0.0000192739, 0.0029839803, -0.0448584259, 0.0150521975, 0.0100980867, 0.0259326026, 0.0001465635, -0.0123414351, -0.0000000531, 0.0106308125, -0.0022509601, 0.0204702988, -0.0002020259, 0.0122563085, 0.0219415836, -0.0102736363, -0.0305013452, -0.0081209606, -0.0013088783, -0.0073105413, -0.0227986984, 0.0051425039, 0.0224881284, -0.0158978477, -0.0123628555, -0.0580289587, -0.0347445123, 0.0034424239, -0.0408309698, -0.0122533198, 0.0000001224, -0.0202732962, -0.0281375088, -0.0427169092, -0.0176904239, -0.0017512987, 0.0102268439, -0.0067661479, 0.0036233568, 0.0307409726, -0.0121274944, 0.0034891749, 0.0035583773, 0.0083874594, -0.0139044384, 0.0131688416, -0.0183058362, 0.0181883425, 0.0167032722, -0.0604425184, 0.0029537629, -0.0111256195, -0.0002359913, 0.0167572573, -0.0129904505, -0.0000000635, 0.0113874134, 0.0065940735, 0.0044717290, -0.0276834890, -0.0061021014, -0.0142452978, 0.0036843910, -0.0057996386, 0.0000000727, 0.0102236103, -0.0222425777, -0.0015886833, -0.0008723268, -0.0143915974, -0.0006654441, -0.0039812890, 0.0000000313, -0.0010033629, -0.0203427784, -0.0169939660, 0.0005764592, 0.0021572914, -0.0024299121, 0.0235676635, -0.0024550310, -0.0109436968, 0.0109680351, 0.0057588266, 0.0048332815, -0.0069715870, -0.0020238771, 0.0039090519, 0.0176549777, 0.0027427487, -0.0053507043, -0.0082875965, 0.0127050159, 0.0145695563, 0.0000001002, 0.0302189104, 0.0158411320, -0.0019055754, -0.0107936934, 0.0005902995, -0.0035549786, -0.0015831655, 0.0165835284, -0.0224757921, -0.0054898467, -0.0001601598, -0.0153654739, -0.0112987831, -0.0018216907, 0.0202303063, -0.0065884162, 0.0089750914, 0.0222633164, 0.0172532275, -0.0118669691, -0.0011954892, -0.0011045844, 0.0178801678, 0.0076027568, 0.0000000071, 0.0281992201, 0.0166515484, -0.0034032266, -0.0208874121, 0.0094793802, -0.0072129644, 0.0043134158, -0.0006817871, -0.0000125544, 0.0244275555, 0.0113231353, -0.0302025229, -0.0583551973, -0.0343058519, -0.0000878518, 0.0056738937, 0.0000000018, 0.0053277556, 0.0148345511, -0.0150815221, -0.0006444729, -0.0212985352, -0.0176957790, 0.0034524594, 0.0383706167, 0.0056599649, 0.0129630882, 0.0042599821, 0.0149625232, -0.0116247935, -0.0072148996, 0.0375243612, -0.0032553670, 0.0553023070, 0.0108729079, -0.0093083838, 0.0146368472, -0.0016120845, -0.0000008772, 0.0049660350, 0.0423643924, 0.0150297973, 0.0035802366, -0.0083737168, -0.0086228251, 0.0009126631, -0.0148771135, 0.0107387751, 0.0297711696, -0.0003079905, 0.0059471475, 0.0188137572, 0.0250550639, -0.0186497029, 0.0122655304, -0.0295805112, -0.0575223081, 0.0099015813, -0.0186545346, 0.0009096360, -0.0292438176, -0.0176784750, -0.0090244263, 0.0000000012, -0.0016758587, 0.0079474151, 0.0262462944, -0.0093695316, 0.0100574363, 0.0040672142, 0.0474372692, -0.0077887471, 0.0000000018, 0.0176563691, -0.0447630733, 0.0029049686, -0.0307439528, -0.0314172581, -0.0024474503, 0.0133688748, -0.0000000002, -0.0064316578, 0.0018030202, 0.0205274262, -0.0000959271, -0.0024027922, -0.0058084461, -0.0138415731, 0.0070997644, 0.0005979764, 0.0002894112, -0.0057558822, -0.0194175728, -0.0134799061, 0.0219413899, 0.0343706943, 0.0109762466, -0.0256827995, 0.0175676532, -0.0067804791, 0.0248324256, -0.0285116229, -0.0000000572, 0.0035805204, 0.0114166159, 0.0090713967, 0.0049429419, -0.0006704088, -0.0081362268, 0.0073168529, 0.0056100572, -0.0025049541, 0.0017796837, -0.0002436232, -0.0100337882, 0.0111719910, 0.0460422076, -0.0072256969, -0.0018001122, -0.0008221667, -0.0198431555, -0.0038448821, -0.0178687666, -0.0024713569, -0.0095508890, 0.0145575255, -0.0089375693, 0.0000002625, 0.0304435398, -0.0086581707, -0.0208748095, 0.0080660600, -0.0008611571, -0.0087607466, -0.0197171960, 0.0066531943, -0.0000003276, 0.0176048987, 0.0041499757, -0.0135283722, -0.0220957194, -0.0174881909, -0.0008481207, -0.0100079393, 0.0000000082, -0.0158989057, 0.0010001262, -0.0088083381, -0.0010054067, -0.0197534561, 0.0033037562, 0.0204081070, 0.0015027974, -0.0185536947, 0.0252161380, 0.0271709971, -0.0218312256, -0.0112290569, -0.0209527817, 0.0022397891, 0.0018172801, 0.0094674733, 0.0074102846, -0.0058565242, 0.0040531736, 0.0359402075, 0.0000000027, 0.0041521178, 0.0100792022, 0.0184319634, 0.0103084939, 0.0004690019, 0.0035066584, -0.0078284107, 0.0163760707, -0.0256284978, -0.0021587575, 0.0002278069, -0.0404388793, -0.0472777374, -0.0015281917, -0.0104408879, -0.0036379392, 0.0209966972, 0.0008047033, 0.0070442446, -0.0048674960, 0.0186485890, 0.0109859444, -0.0165781174, 0.0055279937, 0.0000000493, 0.0040252381, -0.0069820131, -0.0157675706, 0.0443622991, -0.0079460582, -0.0143837649, -0.0044021443, 0.0073486599, 0.0000000008, 0.0046164687, 0.0037635965, 0.0047726533, -0.0011310301, 0.0182656776, -0.0001739692, -0.0081115793, -0.0000000000, 0.0121496106, 0.0122267865, -0.0093051549, -0.0007218549, -0.0153413229, -0.0027823343, -0.0206488147, 0.0275449902, 0.0015134328, 0.0244373120, -0.0022322321, -0.0115081314, 0.0003898063, -0.0072467490, -0.0125818681, -0.0142266145, 0.0057578571, -0.0098521691, 0.0097815087, -0.0046563568, -0.0053360383, -0.0000123387, -0.0228276607, -0.0214823764, 0.0223889016, 0.0157602783, -0.0003949353, 0.0127666043, 0.0140990503, -0.0290124174, -0.0269947629, 0.0267063789, -0.0010525294, 0.0394271538, 0.0094029345, -0.0065843952, 0.0027854615, 0.0118209310, -0.0154346796, 0.0108218687, 0.0094150137, 0.0114130583, -0.0097849239, -0.0235376377, 0.0060937814, -0.0040799882, -0.0003512703, 0.0049905027, -0.0259596854, -0.0109123420, 0.0351094492, 0.0177155361, 0.0259323101, -0.0153725650, 0.0151904905, 0.0000238176, -0.0000873577, -0.0059140194, -0.0203651972, 0.0134983901, 0.0239217319, -0.0106632896, 0.0250726920, -0.0000001424, 0.0023160030, 0.0344565958, 0.0124231437, -0.0031079685, -0.0112776784, 0.0036397139, 0.0087665645, 0.0123321796, -0.0184090938, 0.0174588915, 0.0397062153, 0.0106023876, -0.0095111784, 0.0044866363, -0.0530614555, 0.0074620689, -0.0259625372, 0.0218017548, 0.0214281138, -0.0241619591, 0.0338736847, -0.0000303771, -0.0046922332, -0.0002137147, 0.0116223870, 0.0110658752, 0.0044603692, -0.0014825851, -0.0093470719, 0.0181652233, 0.0102097252, -0.0032035350, -0.0068036080, 0.0281905457, 0.0073083909, 0.0073307576, -0.0021145064, 0.0193588194, -0.0008549730, 0.0092205778, 0.0382767245, 0.0224080645, 0.0280552097, 0.0140057085, 0.0250997022, 0.0311657656, -0.0000190004, 0.0146638686, 0.0077039446, -0.0178809091, 0.0118701300, 0.0135111623, 0.0235927403, -0.0146115031, 0.0152283376, -0.0000014342, 0.0079499269, 0.0384830050, -0.0090876883, 0.0440248512, 0.0552791022, -0.0068358746, -0.0234185476, 0.0000001109, -0.0058019604, -0.0371600799, -0.0110719120, 0.0003458116, 0.0315265171, 0.0067091919, 0.0521287546, 0.0035196575, -0.0218231082, -0.0246257875, -0.0261206515, 0.0592498258, 0.0100091994, 0.0041735182, -0.0087285433, -0.0166933406, -0.0028633138, 0.0089424206, 0.0133746546, -0.0240357220, 0.0271771029, -0.0000175625, -0.0016478184, -0.0130997896, -0.0448599122, 0.0007650722, -0.0063497820, -0.0108498940, -0.0187196806, 0.0116772549, 0.0488548651, -0.0100967269, -0.0026469347, 0.0087066106, 0.0266255196, -0.0134931784, -0.0337457955, -0.0026793112, -0.0253510028, -0.0050249523, -0.0126022417, 0.0004359251, 0.0056868135, 0.0053564128, 0.0191123113, -0.0301311500, -0.0000036829, 0.0100146588, 0.0153017445, 0.0050157853, -0.0265679173, 0.0128677944, -0.0081269303, -0.0230564959, -0.0008676450, -0.0001478165, 0.0203888342, -0.0290851556, -0.0196796320, -0.0219773594, 0.0024711816, -0.0010906620, -0.0026259678, 0.0000013335, -0.0057811276, 0.0118405512, -0.0114793740, -0.0018905146, -0.0198760368, 0.0089844540, 0.0142981587, 0.0259147547, -0.0231609289, -0.0021570292, 0.0103255324, -0.0089066578, -0.0186040215, -0.0038940127, -0.0104468651, -0.0156794395, -0.0159231108, 0.0133568151, -0.0165739246, -0.0000575401, -0.0111451382, -0.0000070520, -0.0054872106, 0.0056418730, 0.0150635540, 0.0210098289, 0.0012412755, 0.0144689670, -0.0076267989, 0.0189456381, -0.0027017493, 0.0034957267, -0.0002523830, -0.0109349582, 0.0123212272, 0.0067570321, -0.0062057534, -0.0204790048, 0.0397787206, -0.0116408980, -0.0034472507, 0.0007003626, 0.0251716916, -0.0137228025, 0.0135885598, 0.0111252461, -0.0000104594, 0.0088116871, -0.0170905869, -0.0270611178, 0.0152936066, 0.0049152514, 0.0084418608, 0.0070633758, 0.0146244392, -0.0000826310, 0.0136664240, -0.0118751572, -0.0022688499, -0.0299997665, 0.0307694599, 0.0012717088, -0.0101896953, -0.0000029142, 0.0004538777, 0.0129304416, -0.0400712788, -0.0053418479, -0.0010528669, -0.0021830811, 0.0421928763, 0.0482714698, -0.0023761077, -0.0056399251, -0.0127151962, 0.0059835264, -0.0290064756, -0.0123365875, -0.0176201239, -0.0037939344, 0.0317872241, -0.0153886387, 0.0213825777, -0.0450819917, -0.0053351861, -0.0002383641, -0.0137913851, 0.0189396217, 0.0004038783, -0.0044672089, -0.0192500483, -0.0026917448, -0.0009697230, -0.0044495594, 0.0065962858, 0.0337459147, -0.0000109530, 0.0339915194, 0.0008693099, 0.0067893481, -0.0191346779, -0.0014701972, -0.0201244093, -0.0193360783, -0.0165178366, -0.0063606687, 0.0158950668, -0.0056566717, 0.0076940591, -0.0117351618, 0.0000000734, 0.0027274138, -0.0100894962, 0.0087422635, -0.0249601603, -0.0024063832, 0.0065736682, 0.0138631444, 0.0192577913, 0.0000003733, 0.0312515944, -0.0570123866, -0.0027558068, -0.0021456790, -0.0179203227, 0.0034802298, 0.0213272590, 0.0000000582, 0.0131476456, -0.0082639549, 0.0057625426, -0.0001637430, 0.0064460142, -0.0152819511, -0.0163374953, -0.0025902221, 0.0104671866, 0.0006691228, -0.0074816290, 0.0040595308, 0.0094703147, -0.0070256377, 0.0115709193, -0.0111190565, 0.0041558286, 0.0108244093, 0.0023744258, 0.0210464690, -0.0133811636, 0.0000000255, 0.0049170237, -0.0002943808, 0.0059454232, 0.0026847117, 0.0011288554, -0.0041708285, -0.0107303523, -0.0242748726, -0.0005639523, 0.0035703513, -0.0004540580, 0.0229128841, 0.0063908021, 0.0157107841, -0.0050091087, -0.0242682546, -0.0134150730, 0.0217011869, 0.0036978174, -0.0033848444, -0.0310506877, 0.0009067402, -0.0045940834, 0.0051399563, -0.0000019513, 0.0097746411, -0.0015245591, 0.0045751417, 0.0313799791, 0.0001091542, -0.0086306920, 0.0126568945, -0.0196316894, -0.0003842308, 0.0061653615, 0.0269076359, 0.0131124407, -0.0306456797, 0.0170989744, -0.0058368915, 0.0095888572, -0.0000000833, -0.0257970300, -0.0089861359, -0.0103795184, 0.0006557949, -0.0199770648, 0.0100620482, 0.0378058441, 0.0091431765, -0.0122031653, -0.0149845220, -0.0096540265, 0.0028363641, -0.0112191131, 0.0091093211, -0.0229058564, 0.0094301431, 0.0049820137, 0.0208423566, 0.0098799244, -0.0144180274, -0.0018470249, -0.0000300441, -0.0109185157, 0.0179993361, -0.0076296013, 0.0162690096, -0.0038027433, -0.0147371208, 0.0032801838, 0.0121717937, 0.0119827650, 0.0017679028, -0.0021137921, -0.0251428206, 0.0067156875, 0.0025240891, -0.0077267727, 0.0010558893, -0.0003642537, -0.0136261936, -0.0217874218, 0.0015841257, 0.0144936526, -0.0059282174, 0.0011886063, 0.0185119975, 0.0000005676, -0.0138940252, -0.0051991171, 0.0108391885, -0.0361851864, -0.0083754947, 0.0007027080, -0.0040610689, -0.0038747410, 0.0000011541, 0.0128467903, -0.0441940837, 0.0019731603, -0.0235127117, 0.0062804171, 0.0050406661, 0.0596184470, -0.0000000614, 0.0084990142, 0.0178783350, 0.0352804810, -0.0001601773, 0.0103066629, 0.0075281924, -0.0407601930, -0.0095963003, 0.0260401666, 0.0019492488, 0.0040153638, -0.0005102035, 0.0021669813, 0.0718464479, 0.0507069938, 0.0471727699, -0.0192239881, 0.0004585971, 0.0295505077, 0.0251439624, -0.0199277364, 0.0000001217, 0.0068093371, 0.0544400699, -0.0119979624, 0.0068317181, 0.0001578330, -0.0153777786, -0.0102784960, -0.0288889743, 0.0005428256, -0.0328040607, -0.0015067554, -0.0076810797, 0.0068798806, -0.0188953038, 0.0271746423, 0.0148854908, -0.0135203255, 0.0078899888, -0.0101155257, 0.0047100927, -0.0139496103, 0.0163698923, 0.0228047036, 0.0278738048, -0.0000287703, 0.0196783282, -0.0129217291, -0.0491851196, 0.0022854754, -0.0033162672, 0.0251545571, -0.0411966816, -0.0103650680, -0.0007727687, -0.0154231703, 0.0000216312, -0.0105769150, -0.0386047848, 0.0290149134, -0.0054524131, 0.0020543518, -0.0000008511, -0.0005492438, 0.0294567011, 0.0055849492, -0.0050737755, -0.0220384859, 0.0161626991, -0.0227841139, 0.0058580888, 0.0122552318, 0.0182736777, -0.0211832300, 0.0055257375, -0.0156828482, 0.0420930795, 0.0275690574, 0.0075299959, -0.0045745862, -0.0169031303, 0.0259548258, -0.0274717174, -0.0067601139, -0.0001195140, 0.0061603743, 0.0028313536, -0.0241551884, 0.0399137437, -0.0049362527, 0.0015575330, -0.0131374132, -0.0185542982, -0.0131094838, 0.0152507611, 0.0006725381, 0.0657432526, 0.0190208256, -0.0053135063, 0.0224436447, 0.0296107084, -0.0312320050, 0.0027210275, -0.0330686830, 0.0171916131, -0.0147596365, 0.0200794861, -0.0383509435, 0.0012460636, 0.0000028346, -0.0013288201, 0.0195046403, -0.0433377251, 0.0541794524, -0.0060965167, -0.0143412063, 0.0235017072, -0.0004901314, 0.0001454133, -0.0101582780, 0.0284622796, 0.0030609786, 0.0006333815, 0.0320314094, 0.0032310279, 0.0117158554, -0.0000002176, -0.0138674956, 0.0356091186, 0.0231071543, -0.0017142117, -0.0056911143, 0.0131581640, -0.0162832979, -0.0145606082, 0.0326241925, -0.0066540088, 0.0071017044, -0.0080863619, -0.0063617649, 0.0324621797, -0.0189859625, -0.0026386634, 0.0184128154, -0.0047277273, -0.0106088854, -0.0052928035, -0.0020324246, -0.0000236539, -0.0091496278, -0.0067499704, -0.0209495258, -0.0048111146, 0.0005221089, -0.0002197583, 0.0337341614, -0.0104285311, -0.0005750118, -0.0079833940, 0.0008201515, 0.0160420407, -0.0387708023, -0.0325898752, 0.0243454352, 0.0181596037, 0.0245400779, -0.0219521504, -0.0215771142, 0.0300680250, 0.0469471999, -0.0106534176, 0.0048028072, -0.0220346730, -0.0007293627, 0.0149959568, 0.0144627430, -0.0066520097, 0.0063986317, -0.0308451001, 0.0135969082, 0.0090469206, 0.0351479873, 0.0000576825, 0.0269649718, 0.0203134865, 0.0071078553, 0.0161649548, 0.0201729070, -0.0121751912, 0.0037896277, 0.0000007561, 0.0009645874, -0.0163310189, -0.0236062780, 0.0007750108, -0.0284928828, 0.0334971584, 0.0151024517, -0.0182536617, -0.0167187192, -0.0081332717, -0.0223391894, -0.0130441366, 0.0144014200, -0.0009948947, 0.0031274464, -0.0371329039, 0.0053857500, -0.0270127300, 0.0246368740, -0.0150931627, -0.0033269858, 0.0000301400, 0.0267129298, -0.0182115864, 0.0174534190, 0.0193865858, -0.0006071727, -0.0116269086, -0.0191892367, 0.0207424648, 0.0131965335, -0.0244338084, -0.0051862942, 0.0086436886, -0.0386071652, -0.0023939181, -0.0206840057, -0.0228051860, 0.0229192283, 0.0189109370, 0.0032875827, 0.0188129954, -0.0124213491, -0.0349463187, -0.0209727716, -0.0385633111, 0.0000070818, -0.0180101283, -0.0109972265, 0.0109342756, -0.0240754448, 0.0088897748, -0.0185752138, 0.0199220441, -0.0083971173, -0.0000115282, 0.0155842919, -0.0129078152, 0.0501442626, 0.0317614526, 0.0011507674, -0.0066768508, -0.0038188822, -0.0000000378, -0.0049387738, 0.0016010311, -0.0097696390, -0.0052177049, 0.0011058986, 0.0050931945, -0.0123277446, -0.0194220264, 0.0021181689, -0.0050943550, -0.0158254486, -0.0287677478, 0.0150275454, 0.0010001566, -0.0068442249, -0.0127645219, -0.0016808176, 0.0027212226, 0.0107942708, 0.0151481908, -0.0210806020, -0.0000786895, -0.0027200384, -0.0153047973, 0.0081716450, 0.0210100822, -0.0001980736, -0.0121106636, -0.0115188593, -0.0072717881, -0.0011858963, 0.0031729906, 0.0007139586, -0.0091675138, -0.0189768393, -0.0013039794, -0.0105280308, -0.0284377187, 0.0420188718, 0.0170388985, -0.0105714351, 0.0065015401, 0.0111445040, 0.0138287647, 0.0251893029, 0.0597791150, 0.0000774078, 0.0552076213, -0.0121876085, -0.0094327107, 0.0081137000, -0.0139651028, 0.0343552120, -0.0094722835, 0.0423044972, -0.0005165674, -0.0007722864, 0.0224489346, 0.0063999076, 0.0232441556, 0.0491710119, -0.0061349412, 0.0046510403, -0.0000003350, -0.0126174232, 0.0137347858, 0.0186150037, -0.0013540249, -0.0015890561, 0.0082382821, 0.0390065387, -0.0120423501, 0.0167970192, -0.0205562059, -0.0148313623, 0.0107722171, -0.0083472375, -0.0096246572, -0.0124702407, -0.0202792659, 0.0154489372, -0.0251520388, 0.0321463980, -0.0415791683, 0.0186612718, -0.0000128371, 0.0164482929, -0.0080480073, -0.0148130842, -0.0070341276, -0.0039374973, 0.0104052136, 0.0008637239, -0.0173108391, -0.0078003546, -0.0195740275, -0.0008229172, 0.0227623899, -0.0266717039, -0.0056701330, -0.0141073773, -0.0115757883, -0.0072249011, 0.0212921612, 0.0024331147, 0.0266907495, 0.0096463552, -0.0056795347, -0.0116910171, -0.0092851082, -0.0000525698, -0.0085726129, 0.0255416017, 0.0134219825, -0.0198540837, -0.0164918080, -0.0060189823, 0.0137764998, 0.0030817408, -0.0002237569, 0.0164740458, -0.0122847585, -0.0039933082, -0.0163106304, -0.0095889708, -0.0080561321, 0.0077409968, 0.0000000394, -0.0049791443, -0.0030953905, 0.0029377267, -0.0009297720, 0.0028495581, -0.0140825687, 0.0018765131, 0.0092753852, -0.0090837451, 0.0312452056, 0.0327725969, 0.0026769466, -0.0197730381, -0.0089361658, 0.0075890380, 0.0062248162, 0.0029743381, 0.0300823133, 0.0145233618, 0.0005273698, 0.0036100559, -0.0000310516, 0.0019185257, 0.0130088786, 0.0390460491, -0.0119438879, -0.0078060608, -0.0010639513, -0.0082848398, -0.0108144740, -0.0067331623, 0.0015186586, -0.0000555563, -0.0166263506, -0.0034287374, 0.0153768361, 0.0045242598, -0.0023156079, 0.0178438649, 0.0077342908, 0.0167689826, 0.0259842686, 0.0040726396, 0.0049124281, 0.0363630652, -0.0118971001, -0.0000505228, -0.0142614804, 0.0024054113, 0.0082230186, -0.0305721015, 0.0346523114, -0.0060081705, -0.0044002300, -0.0170023944, -0.0001480093, 0.0407590196, -0.0043392782, 0.0004118527, 0.0170706175, 0.0215903912, -0.0076866806, -0.0128836818, 0.0000000089, -0.0155853145, -0.0075355666, -0.0087382179, -0.0016037939, -0.0009476545, -0.0066610095, 0.0170898605, 0.0259080622, -0.0123850321, 0.0209778920, 0.0045097116, 0.0087653957, -0.0157971978, 0.0019129192, 0.0113651268, -0.0140902735, 0.0040048459, 0.0004484903, -0.0097743683, -0.0325012393, -0.0066000316, 0.0000178095, 0.0076360423, 0.0270118006, 0.0164384861, -0.0065746005, -0.0050221984, -0.0056243208, -0.0053053591, 0.0072439592, 0.0194834322, -0.0135172429, 0.0002170648, 0.0016737838, 0.0258230735, 0.0120955976, -0.0175692979, 0.0025144208, 0.0416447781, 0.0558900461, 0.0018181744, -0.0226177722, -0.0162950065, 0.0228750743, 0.0309057795, 0.0123990737, -0.0000239036, -0.0302025937, -0.0187404342, -0.0523057170, 0.0159599800, 0.0091276858, 0.0206871722, -0.0271929186, -0.0011113484, -0.0012078908, -0.0152590415, 0.0338377208, 0.0068621533, 0.0334866717, 0.0494096428, -0.0039012525, -0.0016142577, 0.0000000393, -0.0082805110, 0.0225468203, -0.0059868209, -0.0005799589, -0.0006744219, -0.0092429025, 0.0169177875, 0.0041326573, -0.0137978308, 0.0056178607, 0.0221822131, 0.0201113317, -0.0239570532, -0.0174112637, -0.0258460231, -0.0281365085, -0.0176553410, 0.0129606575, 0.0176274814, -0.0538072921, 0.0358255878, -0.0000028124, -0.0031568867, -0.0410207920, 0.0030784402, -0.0133819040, 0.0013690856, 0.0109714586, -0.0121129155, -0.0012902366, -0.0055101761, 0.0063375109, 0.0004018121, 0.0314900540, -0.0044585960, -0.0092857545, 0.0035328902, 0.0029918905, 0.0069076810, 0.0188904535, -0.0314924493, 0.0222646836, -0.0004543244, 0.0034800214, 0.0026748816, 0.0146661168, -0.0001099072, 0.0316298567, 0.0411028601, -0.0105798608, -0.0139102340, 0.0069939336, 0.0003973332, -0.0050260876, -0.0110741695, -0.0014967889, -0.0127965836, 0.0251529310, 0.0033815524, -0.0275592972, -0.0141135165, -0.0002214297, -0.0096068317, -0.0000001775, -0.0024210981, 0.0013653955, 0.0040667485, 0.0112148207, -0.0021546844, -0.0345113948, -0.0209209323, 0.0292550121, 0.0054892576, -0.0391167812, -0.0396872237, 0.0199930165, -0.0037667183, 0.0061592944, -0.0051936866, 0.0340205170, 0.0533348024, -0.0409763046, 0.0211463850, -0.0161195137, -0.0102239521, 0.0000715712, 0.0157294348, 0.0140971532, 0.0001965376, 0.0556754470, -0.0214970484, -0.0029563564, 0.0061098230, -0.0496908426, 0.0015571939, 0.0139551042, -0.0046681012, 0.0290915370, 0.0379938520, -0.0083627887, 0.0113638751, 0.0174406413, -0.0394605286, -0.0035377040, 0.0125358040, -0.0374432690, 0.0136293555, -0.0100465277, -0.0077660633, 0.0147763798, 0.0000195509, -0.0140764453, 0.0207023211, 0.0067270207, -0.0263765436, 0.0105551854, 0.0014686224, 0.0015317207, -0.0098920912, 0.0000048635, 0.0363871530, 0.0017179399, 0.0031334432, 0.0020334001, -0.0101429606, 0.0121294474, 0.0023821560, 0.0000001452, 0.0218214616, -0.0030985789, 0.0305532198, -0.0025345762, 0.0161668956, -0.0370175205, -0.0571041033, -0.0098529542, 0.0442492254, -0.0407158509, -0.0257340632, -0.0051721744, 0.0095649865, 0.0017114375, 0.0459496565, -0.0027245958, 0.0094545893, -0.0299338475, -0.0132769048, -0.0354257300, -0.0309516396, 0.0000052796, 0.0248914696, -0.0154199926, -0.0019873432, 0.0032953389, 0.0008827698, -0.0151891969, 0.0042071207, -0.0409827940, 0.0056216805, 0.0114262952, -0.0000995288, 0.0416201577, 0.0317811333, 0.0257195681, -0.0021765141, -0.0154258050, -0.0302812401, 0.0472107939, -0.0238808189, -0.0315211043, -0.0061034728, 0.0448205285, 0.0040575918, 0.0112847351, 0.0000124493, -0.0089458972, 0.0297275074, 0.0078890882, 0.0117223198, -0.0070458082, 0.0077572903, -0.0053434800, -0.0273576155, -0.0000654622, 0.0040816157, 0.0209092479, -0.0010961952, -0.0200252458, -0.0183175895, 0.0111501645, -0.0062498869, -0.0000001609, -0.0049325228, -0.0068896655, -0.0051568900, -0.0016822015, -0.0089653423, -0.0147580486, -0.0009219490, -0.0146271857, 0.0344777070, -0.0197922736, -0.0003400046, -0.0088957511, -0.0141730569, 0.0083575062, 0.0284472778, 0.0050984761, 0.0215124395, 0.0016618188, -0.0186642203, 0.0126991728, -0.0089896703, -0.0000709492, -0.0054894486, -0.0201810990, -0.0110957893, 0.0048953458, -0.0006503835, -0.0000274299, -0.0021539829, 0.0089645414, 0.0009743986, -0.0170676354, -0.0006797927, -0.0164976865, 0.0321788713, 0.0142267141, -0.0094062667, 0.0099692084, 0.0138554228, -0.0097127119, 0.0173688307, 0.0034573609, 0.0064158342, 0.0109070418, -0.0020122444, -0.0079757161, 0.0000026111, -0.0140054785, 0.0039919368, -0.0037574600, -0.0438716523, 0.0024914455, -0.0191191267, -0.0108336601, -0.0129487105, -0.0000723276, 0.0076609403, 0.0060375510, -0.0244557522, 0.0071404208, -0.0100772949, -0.0007485162, -0.0202532392, 0.0000017440, 0.0048735221, -0.0215687379, -0.0051151966, -0.0004577403, 0.0022602698, -0.0425837673, 0.0010772579, -0.0004685830, -0.0103693297, -0.0042789718, 0.0092170332, 0.0181534868, 0.0163925160, -0.0105408877, -0.0148721123, 0.0082534757, 0.0063487412, 0.0183125585, 0.0028319480, 0.0078397989, 0.0014548459, 0.0000122213, -0.0021604826, 0.0145602515, 0.0075035291, -0.0129378671, 0.0048262561, -0.0131711261, -0.0068634651, 0.0055450499, -0.0001794487, -0.0103170108, -0.0024590420, -0.0066913534, 0.0351852514, 0.0073447796, 0.0022192672, -0.0042337440, -0.0033788180, 0.0241077375, 0.0053389338, -0.0092014531, -0.0074334429, 0.0285800379, 0.0042564566, 0.0216694139, -0.0000052345, 0.0395877548, -0.0234813169, -0.0211405251, 0.0003670069, -0.0207456369, 0.0174336545, -0.0175963528, -0.0028620735, -0.0003015825, 0.0164517760, 0.0307131093, -0.0034025940, -0.0195382796, 0.0077513307, 0.0030735040, -0.0161076691, -0.0000000734, -0.0089670466, 0.0143255796, -0.0009843162, -0.0026598461, 0.0061787339, 0.0209020171, 0.0128828073, 0.0061180904, 0.0297013689, -0.0084480904, -0.0238145068, 0.0287437085, 0.0166151039, -0.0001182128, -0.0034262859, -0.0020966432, 0.0440589413, -0.0289597493, 0.0071056648, -0.0221786741, -0.0030434388, -0.0000452703, -0.0007887327, -0.0002073745, -0.0056596510, -0.0025725958, -0.0020098051, 0.0037925604, 0.0009908592, -0.0016946428, -0.0103936857, 0.0103979111, 0.0006991051, 0.0107938498, -0.0074979928, 0.0165983234, -0.0083575901, 0.0161870699, -0.0117402729, -0.0082613127, 0.0102996118, -0.0080208993, 0.0142331850, -0.0070066927, 0.0066745235, -0.0098221097, -0.0000028608, 0.0355424322, 0.0000561783, 0.0080065150, -0.0365831889, 0.0007982287, -0.0015105746, 0.0221180413, 0.0176761094, -0.0006806128, 0.0309914276, -0.0323895961, 0.0368519612, -0.0148759112, -0.0088131260, -0.0020117871, 0.0161603354, 0.0000000271, -0.0027848708, 0.0081034862, 0.0068372381, 0.0002700078, -0.0133187231, -0.0099709369, 0.0014205335, -0.0147126224, 0.0067207254, 0.0005809753, 0.0008011959, 0.0158191882, 0.0037409186, 0.0126736900, 0.0372977294, 0.0110938540, 0.0216314271, 0.0076890509, 0.0250617750, 0.0121325171, -0.0106510874, -0.0001217856, 0.0255888607, 0.0079591656, 0.0018415619, -0.0024544995, -0.0138959363, -0.0133646615, -0.0028106645, -0.0172652602, 0.0248841625, -0.0066690980, -0.0017284224, 0.0186092295, 0.0327085219, 0.0094138728, 0.0073602479, -0.0169524588, -0.0166641548, 0.0131641021, -0.0185780171, 0.0129078021, -0.0164885949, 0.0115313325, -0.0243879482, -0.0138114607, 0.0000076013, -0.0099895122, 0.0254654624, 0.0331519246, -0.0105676241, -0.0028141444, 0.0166194756, 0.0105073787, 0.0073339944, -0.0000612644, -0.0056760325, -0.0095354104, -0.0128724491, -0.0362230390, -0.0152311539, -0.0022682999, -0.0150224706, 0.0000000012, 0.0072411001, 0.0166901983, -0.0140311243, 0.0019302660, -0.0325064771, -0.0111860698, 0.0044757416, 0.0249946900, -0.0054832329, 0.0189674478, -0.0005679359, 0.0029083933, -0.0195192546, 0.0093185473, -0.0051172585, 0.0085222768, -0.0043886001, -0.0071339575, 0.0126482071, 0.0135555286, -0.0048013744, 0.0001431922, 0.0193988718, 0.0034299779, 0.0255920365, 0.0262598954, -0.0105948066, 0.0135812769, -0.0107578170, -0.0200480670, -0.0254237745, -0.0050247442, -0.0034780225, 0.0223401953, 0.0354927629, 0.0124127334, 0.0027026902, -0.0103730336, 0.0040265438, -0.0079691689, -0.0028481707, 0.0272751767, 0.0124059515, 0.0260392688, 0.0246564336, -0.0014947997, -0.0000486469, 0.0050465609, -0.0154841905, 0.0015245877, -0.0141668348, -0.0074329968, -0.0010335085, -0.0122059751, 0.0123420469, -0.0004523698, -0.0002615573, 0.0053459127, 0.0099963406, -0.0148832230, 0.0053600827, -0.0029948566, 0.0170520358, -0.0000000926, -0.0021349327, 0.0071194367, 0.0027852135, 0.0009935284, -0.0216624103, 0.0193643048, 0.0148826400, -0.0088882577, 0.0171644203, -0.0041858521, 0.0034578089, -0.0274677817, -0.0107265208, 0.0017254604, 0.0136856800, -0.0195383746, 0.0134244999, -0.0355434306, 0.0114681041, -0.0055219624, -0.0366195403, -0.0000727418, 0.0041756467, 0.0161161739, -0.0132386787, 0.0222433414, -0.0095536867, -0.0036665921, -0.0112730227, -0.0295751225, -0.0042200512, -0.0248418152, 0.0018717630, -0.0127909472, 0.0027191886, 0.0019576920, -0.0044146427, 0.0116229849, 0.0206924882, -0.0356432982, 0.0058532795, -0.0294274390, -0.0169018675, -0.0078180879, -0.0132180722, 0.0133376699, -0.0000744302, 0.0180868655, -0.0199539382, 0.0212651119, -0.0073799943, -0.0139398593, 0.0034594447, -0.0052804751, 0.0151771083, -0.0001677346, -0.0147734722, 0.0318407230, -0.0166209657, -0.0079382537, 0.0202148668, -0.0031575512, -0.0116186794, 0.0000000422, -0.0103919664, 0.0082030082, -0.0251095742, -0.0000685847, -0.0011860295, 0.0172716789, 0.0445704758, 0.0020778158, -0.0186919887, 0.0264921449, 0.0042265784, -0.0078000478, -0.0153738447, 0.0045095296, -0.0166471209, 0.0246683285, 0.0097786961, -0.0173002481, 0.0316507407, -0.0136494953, 0.0218121726, 0.0000056065, -0.0022016331, -0.0008663179, -0.0009215312, 0.0050888145, -0.0004931067, 0.0247307327, -0.0119607681, -0.0244966112, 0.0028783262, -0.0298718140, -0.0008719509, -0.0042401440, 0.0195011105, -0.0342507586, 0.0099417092, -0.0150842257, -0.0048280195, 0.0265406854, -0.0108327335, 0.0332075283, 0.0412058383, -0.0061788568, -0.0300485753, -0.0183652937, -0.0000061145, -0.0007279972, -0.0095623415, 0.0014900090, 0.0246027373, 0.0038005062, -0.0242936369, -0.0048727538, 0.0242882650, -0.0000000602, 0.0145592727, -0.0218750872, -0.0212407708, 0.0012984130, -0.0163574219, 0.0072984006, -0.0390674882, -0.0000001290, -0.0045307796, 0.0065216515, -0.0017685244, -0.0013951788, 0.0058491617, -0.0042516682, 0.0190122314, 0.0216338746, -0.0128343245, 0.0076090908, 0.0150047820, 0.0063943169, 0.0254595317, -0.0427273698, -0.0298875216, -0.0121539906, 0.0288837254, -0.0192722380, -0.0319936983, -0.0066654761, 0.0164266471, -0.0000605315, 0.0012576403, -0.0002338407, -0.0051639252, -0.0223330632, -0.0007762392, -0.0104231965, 0.0242285430, 0.0172181726, 0.0066456380, 0.0118866339, 0.0016747862, -0.0022093076, -0.0341013409, -0.0135778543, 0.0039957054, -0.0133893117, 0.0293870065, -0.0172381401, -0.0164847542, -0.0117721362, 0.0327096768, -0.0311580189, 0.0231807344, 0.0115210712, -0.0000201165, -0.0047579603, -0.0139305238, -0.0104057677, -0.0408917032, 0.0081202509, 0.0157165378, -0.0134511888, 0.0011049490, 0.0002139291, 0.0174862444, 0.0199972745, 0.0032759809, 0.0079441648, 0.0042911042, 0.0040082382, 0.0084367786, 0.0000010341, -0.0273246747, 0.0117307948, 0.0212152302, -0.0031686299, 0.0158223268, -0.0185858198, -0.0153314909, -0.0243635681, 0.0351952538, -0.0057309726, -0.0010549233, 0.0024466214, 0.0189108886, -0.0162300915, 0.0244285092, 0.0330469981, -0.0096569257, 0.0093612419, 0.0032988398, -0.0249559581, -0.0374515988, 0.0000052678, 0.0126485508, -0.0289379712, 0.0192719102, -0.0022821384, 0.0006199588, 0.0196222123, -0.0121749062, -0.0267629325, 0.0074057714, 0.0068779984, -0.0004272079, -0.0036022956, -0.0048422762, 0.0147675248, 0.0022624044, 0.0117675485, -0.0147874728, 0.0389006697, -0.0194900576, -0.0131527875, 0.0096236356, -0.0095847035, -0.0233291034, -0.0039698710, 0.0000009365, -0.0320706330, -0.0280160848, 0.0037081526, 0.0049294429, 0.0086054662, -0.0205245018, -0.0164873824, 0.0218113605, 0.0000033686, 0.0142647941, -0.0139817307, -0.0051476257, 0.0190042425, 0.0130353021, 0.0126741882, -0.0003151078, -0.0000000901, -0.0039029249, 0.0189813022, 0.0318943262, 0.0009780261, 0.0197306518, -0.0151935956, 0.0219919290, -0.0165879950, 0.0130146015, -0.0170599595, -0.0009754994, -0.0058698482, 0.0126079572, -0.0209088419, -0.0260622948, -0.0281267725, 0.0026102315, 0.0039731236, -0.0069852513, -0.0251870882, 0.0083366847, -0.0000036118, -0.0096484264, -0.0106580779, -0.0120252967, -0.0169655364, 0.0016255153, -0.0053643910, 0.0347446464, 0.0164515357, -0.0211742707, -0.0124495449, 0.0011796727, 0.0142944213, -0.0384839401, -0.0023306631, -0.0076820883, -0.0249882545, 0.0299197398, 0.0171533097, -0.0342295319, -0.0017942726, 0.0347605310, 0.0058449246, 0.0235726275, -0.0191741250, 0.0000079050, -0.0134033952, -0.0168863088, -0.0039720088, -0.0074947565, 0.0080086151, 0.0043619461, -0.0083463592, -0.0037283734, -0.0002692352, 0.0422348827, 0.0103342598, -0.0161634721, -0.0070503568, 0.0060370965, -0.0024769928, -0.0057611261, -0.0000000303, -0.0116931610, 0.0066078957, -0.0301745348, -0.0030688748, -0.0067102569, -0.0147192907, 0.0409993902, 0.0280405618, -0.0299514905, 0.0046266555, 0.0187557880, 0.0240031742, -0.0002562513, -0.0227587670, 0.0008756850, -0.0223814845, 0.0276584141, 0.0313861147, 0.0029910652, -0.0115638711, 0.0193011612, -0.0000187172, -0.0020173157, 0.0254576579, 0.0029588351, -0.0077702147, 0.0030016599, -0.0146393226, -0.0111612780, 0.0176678412, 0.0040709795, 0.0061164144, -0.0007615203, -0.0128185656, -0.0193427820, -0.0038782782, -0.0121714529, -0.0060493080, 0.0349649750, 0.0090199383, -0.0236010551, 0.0015088776, 0.0111225517, 0.0398188010, -0.0025810385, 0.0192681514, -0.0000648622, 0.0224828552, -0.0025045916, 0.0156701077, 0.0178911500, -0.0186282676, 0.0127748512, -0.0258781463, -0.0151848523, -0.0001880485, -0.0116325803, 0.0119614089, 0.0136829894, -0.0139370123, -0.0049377619, -0.0009476983, -0.0072205621, -0.0000004265, -0.0132503780, 0.0024855966, -0.0116936741, -0.0018611484, -0.0134937894, 0.0176787525, 0.0102589615, -0.0107233664, 0.0170707572, -0.0115302466, -0.0060743880, -0.0081075365, -0.0054915147, 0.0249660891, 0.0079869106, -0.0235310569, 0.0145574352, -0.0267252084, 0.0029609685, -0.0116474163, -0.0156674329, -0.0000139146, 0.0032523877, -0.0203130543, -0.0084791714, -0.0020672295, -0.0010218582, -0.0032486401, 0.0086862026, -0.0080155181, -0.0056004757, -0.0211219583, -0.0008408479, -0.0065459232, 0.0285657216, 0.0027097827, 0.0154834157, -0.0020811677, -0.0091104973, -0.0028295715, 0.0223013144, 0.0021180322, 0.0039512343, -0.0222225077, -0.0009998011, -0.0057728742, 0.0000789571, -0.0004473020, -0.0087452233, -0.0090705594, 0.0035682584, 0.0002301509, -0.0126958545, -0.0209043138, -0.0050397832, -0.0000938087, 0.0208706073, 0.0092261871, 0.0144992042, 0.0029451586, -0.0090196365, 0.0014612732, -0.0207803603, 0.0000002714, -0.0123193152, -0.0040084263, 0.0340698287, -0.0046291389, -0.0088574374, -0.0041177850, 0.0231784657, -0.0149020432, -0.0192622505, -0.0371736698, 0.0005884486, 0.0124171050, 0.0170598105, -0.0480832197, -0.0058619138, -0.0096004372, 0.0077745859, -0.0018659460, -0.0052072173, -0.0190539416, 0.0214397516, -0.0000161171, 0.0344183743, -0.0061867344, 0.0090340348, -0.0271188356, 0.0011175242, 0.0042504664, -0.0010468081, 0.0334595144, -0.0005030754, 0.0084605580, 0.0011362535, -0.0101751368, -0.0341113470, -0.0064704046, 0.0074917916, -0.0007579104, 0.0041889651, 0.0488796197, -0.0029823950, 0.0030579078, 0.0265986081, -0.0327222496, 0.0213335417, -0.0302453227, -0.0001971738, 0.0123384381, -0.0131194089, 0.0119041102, -0.0432641804, 0.0279700253, -0.0072065615, -0.0078307511, 0.0196230505, 0.0005470008, 0.0558557361, -0.0652922392, 0.0142408395, -0.0057889782, -0.0295921639, -0.0162034854, 0.0159746986, -0.0000092019, -0.0006943493, -0.0079815509, -0.0161045063, -0.0077009029, -0.0223873202, 0.0144850304, 0.0307188295, 0.0268789679, -0.0517838858, 0.0102718333, -0.0138860792, -0.0104383156, 0.0127440579, -0.0282630399, 0.0129292235, -0.0160433762, 0.0239841826, 0.0132076312, -0.0033503713, 0.0464456677, -0.0217111297, 0.0000621444, 0.0499649979, 0.0221011676, 0.0152897416, -0.0000631326, -0.0087827174, -0.0243123677, -0.0121617885, 0.0286051705, 0.0088486513, -0.0043529216, 0.0049985982, -0.0018893922, -0.0153257055, 0.0139765469, 0.0053671319, -0.0287467055, 0.0399062149, 0.0084565897, -0.0239531137, -0.0050544147, -0.0197206605, 0.0165287107, 0.0056129056, 0.0280789025, -0.0001700306, 0.0469361842, -0.0054988661, -0.0216773245, 0.0171053503, -0.0363417529, 0.0182683691, 0.0061607203, 0.0355187617, 0.0001906614, 0.0017540574, 0.0272757113, -0.0141766928, -0.0004449333, 0.0436706394, 0.0018561572, -0.0146504287, -0.0000035935, -0.0023660031, -0.0011269773, -0.0103270384, -0.0009751765, 0.0093449550, 0.0309171062, 0.0367309898, 0.0060100835, 0.0110682938, -0.0071623754, -0.0147947632, 0.0236743484, -0.0122062527, -0.0129447011, -0.0332315601, 0.0118707698, -0.0036873976, -0.0106884195, 0.0170254335, -0.0291136876, -0.0005000599, -0.0000633667, 0.0218671430, 0.0015773997, -0.0346675292, 0.0007731709, -0.0186032746, 0.0277253222, -0.0061915023, -0.0296178218, 0.0036568004, 0.0090841148, 0.0026218798, 0.0216708705, 0.0026113563, -0.0194960516, -0.0002016439, 0.0040658582, -0.0361848138, -0.0034541872, -0.0073488411, 0.0064325999, 0.0113447607, -0.0075675030, 0.0071107987, 0.0092330892, -0.0005303762, 0.0173314419, -0.0205681249, 0.0303740818, -0.0590786524, -0.0139608523, -0.0090374360, 0.0259338319, 0.0117084282, -0.0006290558, -0.0165362563, -0.0403117910, 0.0218542311, -0.0066366685, -0.0058609750, -0.0080133406, -0.0042852587, 0.0000000886, -0.0040232264, -0.0150685385, 0.0116074579, -0.0052995915, 0.0074713873, 0.0034574298, 0.0049615083, 0.0065498552, 0.0322509594, 0.0190628078, -0.0178852435, -0.0014524186, -0.0176443066, 0.0002031110, 0.0089160474, 0.0548979081, 0.0077745295, -0.0271077231, 0.0167553704, 0.0072271172, 0.0136534944, -0.0000377666, 0.0191673990, 0.0230726972, -0.0254076328, -0.0079037845, -0.0103103463, -0.0092792576, -0.0028841421, -0.0106077269, -0.0117596220, -0.0273919646, -0.0009971149, 0.0323179588, 0.0184818543, -0.0138746835, 0.0086026918, 0.0198830925, -0.0109321997, 0.0515641570, 0.0293713715, -0.0172830205, -0.0076312232, 0.0148874735, -0.0134303682, 0.0056381128, 0.0000083071, 0.0164350513, -0.0146674039, 0.0424330384, 0.0254988521, -0.0140599003, 0.0093524950, -0.0061563794, 0.0272820294, -0.0001130127, 0.0113190524, 0.0034599577, -0.0307671558, -0.0224737227, 0.0091161169, 0.0022872011, -0.0142769441, 0.0000003456, 0.0088949297, 0.0137208160, -0.0364380293, 0.0010750769, 0.0117103746, 0.0153824352, 0.0178961921, 0.0086246999, -0.0105909975, -0.0157128628, 0.0118184006, 0.0239604432, -0.0282608289, -0.0162724406, 0.0189526174, -0.0094992658, -0.0246648509, 0.0111986632, 0.0098793665, 0.0035677629, 0.0722987801, 0.0000183533, -0.0132330395, -0.0205404032, 0.0005185090, 0.0120696574, 0.0044627804, 0.0032795791, -0.0140096936, -0.0153883072, 0.0092957281, -0.0232915543, -0.0010716247, 0.0060573868, 0.0119589474, -0.0097400835, -0.0017492477, -0.0371618718, 0.0020105063, -0.0327102616, -0.0145743042, 0.0313803554, 0.0201712102, -0.0267778095, 0.0109394016, -0.0090383310, -0.0000552196, 0.0149274105, 0.0138526997, 0.0038197669, -0.0250022691, 0.0239700582, -0.0025718142, 0.0166230500, 0.0190799665, -0.0018272457, 0.0335843153, -0.0106919417, 0.0173800476, 0.0124190673, -0.0044924305, -0.0128742391, 0.0107226158, -0.0000007960, -0.0001678768, -0.0137945786, -0.0021283815, 0.0041407091, -0.0059914729, 0.0052922992, 0.0118138371, 0.0005057103, -0.0057906951, 0.0069857738, -0.0252813213, -0.0035584385, 0.0324863642, -0.0218342245, 0.0388256572, -0.0056537562, 0.0185058750, 0.0187926311, -0.0110661564, 0.0216237865, -0.0178773515, 0.0000430469, 0.0306442585, 0.0211348049, 0.0045942981, 0.0183169842, -0.0076911990, -0.0140980678, 0.0043494441, 0.0093120420, 0.0188296139, 0.0151389381, -0.0011287706, 0.0025891275, -0.0251010414, -0.0058038002, 0.0034297234, 0.0175461229, 0.0079784859, 0.0138925817, 0.0114630982, -0.0257054046, -0.0070065092, 0.0221502800, -0.0165655371, -0.0279644877, -0.0000707688, -0.0287634730, -0.0241982602, 0.0095277643, 0.0027227104, -0.0246555358, -0.0020314981, 0.0132092144, -0.0353708081, -0.0002248202, 0.0005831002, 0.0071369256, -0.0058752247, -0.0165393986, -0.0113654919, 0.0057815961, -0.0156669319, -0.0000000019, -0.0067173406, 0.0094895819, 0.0014024893, -0.0026265236, -0.0061663506, -0.0172902532, 0.0247224700, 0.0127736889, 0.0437062532, -0.0323169120, -0.0068999622, 0.0211970694, 0.0008582909, 0.0181647781, -0.0296602361, 0.0147070056, 0.0043170070, -0.0345754884, 0.0021853345, 0.0126725445, -0.0569862165, 0.0000128550, 0.0208837632, 0.0245744344, -0.0026172206, 0.0187338535, -0.0074759237, -0.0184175409, -0.0059853671, 0.0132639632, -0.0301768128, -0.0001410494, -0.0040835761, -0.0162711963, 0.0284671281, 0.0448954664, -0.0082247844, -0.0358276553, 0.0207628105, -0.0051793722, -0.0134754702, 0.0067542605, 0.0306031629, -0.0120523367, -0.0005041690, -0.0045668166, 0.0000027374, -0.0015952251, 0.0147692552, -0.0277055036, -0.0267710593, 0.0213571545, -0.0168586783, 0.0118575552, -0.0035197970, 0.0000360859, 0.0216701943, -0.0146338297, -0.0137195326, -0.0036681872, -0.0224949252, 0.0028358267, -0.0226816162, 0.0000027382, 0.0146693205, -0.0238786414, -0.0108539155, 0.0090866266, 0.0117444620, -0.0041127703, 0.0017563986, 0.0091979485, -0.0141390515, 0.0238630474, -0.0127087617, -0.0081553990, 0.0319904424, 0.0077493759, 0.0009496341, 0.0112384744, 0.0014694672, -0.0107989227, -0.0167810153, -0.0004849155, 0.0194903035, -0.0000001899, 0.0163527317, -0.0134207094, -0.0010121780, -0.0069457758, 0.0012476667, -0.0108142206, 0.0097821588, -0.0047126333, -0.0132172275, 0.0044883154, -0.0009899912, 0.0092882141, 0.0068476098, -0.0038264219, 0.0233849715, -0.0007874796, -0.0363394506, 0.0118863201, -0.0193466209, -0.0258016009, -0.0226114597, 0.0000970824, -0.0113017168, -0.0287196897, -0.0000822637, -0.0082459068, 0.0031895358, 0.0052513964, -0.0005646931, 0.0010263432, -0.0040293983, 0.0198338870, 0.0071692825, -0.0000162739, 0.0430913344, -0.0347848721, 0.0134978481, 0.0093265884, 0.0004058673, -0.0077097039, -0.0182812568, 0.0000000954, -0.0011939438, -0.0229776017, -0.0461801253, -0.0008096306, -0.0023506188, 0.0060174786, 0.0166339763, 0.0200326387, -0.0145865576, 0.0017460247, 0.0107369581, 0.0192673765, -0.0177080445, -0.0230644364, 0.0041750339, -0.0106224734, -0.0091505377, 0.0301680882, -0.0053883386, 0.0165992305, 0.0223944373, -0.0000074187, 0.0149951978, 0.0158590283, 0.0419553369, 0.0087195998, 0.0039125485, -0.0160181895, -0.0146449273, 0.0289011113, 0.0242884327, -0.0029058342, 0.0005635566, -0.0273823775, -0.0455610715, 0.0081813661, -0.0234529134, -0.0303691737, 0.0438729040, -0.0201387480, 0.0046841148, 0.0206184741, 0.0073595294, -0.0142717976, 0.0145580964, -0.0065048379, 0.0000007346, 0.0031400996, 0.0064099883, 0.0054215915, -0.0251374301, 0.0096741086, -0.0138049014, -0.0011332755, -0.0181614328, 0.0000325184, 0.0166353267, -0.0105676418, -0.0130409673, -0.0318179242, -0.0266140308, 0.0066980259, -0.0002981909, 0.0000000065, 0.0089367703, -0.0041111181, 0.0053719338, -0.0028136740, 0.0085140346, -0.0216113981, 0.0136043904, 0.0035431236, -0.0119972723, -0.0018288529, -0.0047126864, 0.0172781013, 0.0086303195, -0.0136515824, -0.0007300270, 0.0125105437, 0.0339028761, 0.0352143124, -0.0087592173, -0.0070810164, -0.0135527039, 0.0000002463, 0.0137081519, -0.0177586004, -0.0054543260, -0.0307603888, 0.0025877147, -0.0094406595, -0.0155165019, -0.0002222896, 0.0176845659, 0.0064654476, 0.0004264174, -0.0258489605, 0.0282942206, 0.0019301875, 0.0171308983, -0.0114652636, -0.0084515801, 0.0223512296, -0.0164057426, -0.0021619480, -0.0192108974, 0.0362104885, 0.0031107184, 0.0070832483, -0.0001017317, 0.0201915000, 0.0123291723, -0.0007267405, -0.0159774385, -0.0481790975, 0.0059440392, 0.0129748276, -0.0058801635, -0.0010089389, -0.0264703240, -0.0285200626, 0.0006386584, 0.0034316005, 0.0263716821, 0.0049365950, 0.0077718049, -0.0000002756, -0.0272167753, -0.0074768448, -0.0134305302, -0.0082954615, -0.0015671171, 0.0084018745, -0.0064741429, -0.0165581238, 0.0191618819, -0.0176532399, -0.0036364966, 0.0128484471, -0.0049130796, 0.0407986119, -0.0184920300, 0.0129247205, -0.0010363157, -0.0172647052, 0.0226187911, -0.0154957194, -0.0328240208, -0.0000118284, 0.0214237273, -0.0079743341, -0.0025655036, 0.0134788491, -0.0060527865, -0.0035167041, -0.0024984281, -0.0228905715, -0.0187311023, -0.0043771872, -0.0031267377, 0.0110067474, 0.0163400117, -0.0157836098, 0.0410525762, -0.0134703815, -0.0225123893, 0.0278617926, 0.0051543005, 0.0065795765, -0.0057008578, 0.0085331295, 0.0242662653, -0.0025803263, 0.0001516143, 0.0018489941, 0.0077392375, -0.0045122611, -0.0066339686, 0.0124808038, 0.0068370434, 0.0215010699, 0.0298295096, 0.0000064691, -0.0208624583, -0.0262874272, 0.0194459725, 0.0238118377, 0.0109350467, -0.0044067712, 0.0191477630, 0.0000000087, 0.0102107702, -0.0171758849, 0.0123922359, 0.0000367737, -0.0072519430, -0.0010405375, -0.0228927433, -0.0196715742, 0.0065707522, 0.0131926583, -0.0056388178, -0.0114700291, 0.0096734604, -0.0038853921, -0.0060296073, -0.0295415018, -0.0498841517, -0.0114588467, -0.0132098533, 0.0020657072, -0.0028035832, 0.0000000811, 0.0039132792, -0.0296729878, -0.0164473746, 0.0044360836, 0.0007700496, 0.0120513327, -0.0137156807, -0.0110899694, -0.0084317233, -0.0021082945, 0.0028096009, 0.0380843841, -0.0201440137, 0.0148467924, 0.0044038994, -0.0125381229, -0.0019396038, -0.0026612624, 0.0259701982, 0.0150069501, -0.0104444772, 0.0076377653, 0.0071964725, -0.0216837805, -0.0006935124, -0.0188668389, -0.0197753180, 0.0013622057, -0.0010532588, 0.0129218232, -0.0275699440, 0.0118143708, -0.0097954981, -0.0017270787, 0.0326393507, -0.0032409485, -0.0069752419, -0.0082862172, -0.0290756337, -0.0026470770, 0.0152094560, -0.0000000348, -0.0040739756, -0.0042673941, -0.0329750031, 0.0015672251, -0.0139417294, 0.0225280374, 0.0224869661, 0.0197172426, 0.0020591111, 0.0218315721, 0.0116594415, 0.0073088221, 0.0150127057, -0.0137536461, -0.0063072932, 0.0110474322, -0.0241939649, 0.0196225829, -0.0038164821, 0.0673856735, 0.0252221897, 0.0001022402, -0.0226522796, 0.0111313974, 0.0122899208, 0.0168484114, -0.0130579388, -0.0295892153, 0.0102585619, 0.0497148931, -0.0015174062, 0.0128492601, -0.0023426581, -0.0497478805, -0.0263432860, -0.0102231512, 0.0110890381, -0.0006703777, 0.0332635231, -0.0530074351, 0.0071711880, 0.0050462657, 0.0317213051, -0.0153545197, -0.0269883536, -0.0056282878, -0.0000092350, -0.0330435336, -0.0152261201, -0.0158077553, 0.0426632725, -0.0116980188, -0.0242470112, 0.0215124935, 0.0069963951, -0.0007546986, 0.0082541602, -0.0052728932, -0.0044236146, 0.0374742262, 0.0207312945, 0.0048284829, -0.0159358811, -0.0000000090, -0.0214036703, 0.0122631276, 0.0042412467, -0.0069441893, 0.0056590866, 0.0134857781, 0.0130690243, -0.0013604179, -0.0111205122, -0.0155393640, 0.0009299421, 0.0146713955, 0.0112410598, -0.0313173197, -0.0190868713, -0.0203588456, -0.0267827064, 0.0065217931, -0.0037239336, -0.0139022758, 0.0393706411, -0.0000268351, 0.0062385947, -0.0255118497, 0.0008587583, -0.0504673086, 0.0002192235, 0.0040678484, 0.0252613127, 0.0364946611, 0.0116044851, 0.0446583927, -0.0008715620, 0.0203657039, -0.0506908111, -0.0059115770, 0.0009778133, -0.0178271066, 0.0101293689, 0.0230858196, -0.0363724679, 0.0014436196, -0.0136135500, 0.0028332956, 0.0376398563, 0.0314211547, -0.0001377407, 0.0004401379, 0.0171466526, -0.0072967326, 0.0052998988, 0.0142121129, 0.0304557402, -0.0153882271, 0.0295473300, -0.0003970021, 0.0073438575, -0.0082750758, -0.0088526569, -0.0325926729, 0.0016802287, -0.0039702062, 0.0370128900, 0.0000000010, -0.0030347214, 0.0348199233, 0.0378706567, 0.0000256186, -0.0169728994, -0.0077864821, -0.0069691902, 0.0142033529, -0.0182543527, -0.0087238215, -0.0026111219, 0.0212035775, -0.0169835985, 0.0012473789, 0.0268720686, -0.0280979685, -0.0576679669, 0.0112901405, 0.0301795881, 0.0210103765, 0.0110180937, 0.0000208898, -0.0048121777, 0.0489310324, -0.0149394497, 0.0299881678, -0.0049024713, -0.0028301973, -0.0102072144, -0.0094717983, -0.0319248252, 0.0002376267, -0.0006173211, 0.0204378422, -0.0288568567, 0.0442944020, -0.0285046026, 0.0060472009, -0.0139856879, -0.0297189914, 0.0106184976, 0.0396123007, 0.0134181408, -0.0300853625, 0.0071161436, -0.0039071394, -0.0000074997, -0.0085595744, -0.0148893595, -0.0187251419, -0.0006717759, 0.0083067296, -0.0140292384, 0.0027931433, -0.0006385551, -0.0000662380, 0.0216024313, -0.0174158327, -0.0219735783, 0.0113301361, 0.0020859605, 0.0084517933, 0.0033650880, 0.0000000029, -0.0161415115, -0.0010894567, -0.0190766584, -0.0046529877, 0.0078070187, -0.0549919941, 0.0101771131, -0.0149941603, -0.0038001961, -0.0274685957, -0.0165928993, 0.0387012959, 0.0207351707, 0.0044029350, -0.0094772251, 0.0218781512, 0.0007004709, -0.0087870164, -0.0215213522, 0.0051277862, 0.0014687288, -0.0000019435, 0.0302334018, 0.0184566043, 0.0194329992, 0.0137599641, -0.0013197955, 0.0167306252, 0.0047545368, 0.0216358230, 0.0169369206, 0.0115563907, 0.0011701302, 0.0025526423, -0.0267916285, -0.0128512504, 0.0263457373, -0.0189241581, 0.0235239640, -0.0010481634, -0.0421172604, -0.0041668918, 0.0500898995, -0.0065119648, -0.0165028162, 0.0032187595, 0.0000019068, 0.0234620310, -0.0212335847, 0.0055886428, -0.0049049761, -0.0373696946, 0.0028647692, -0.0156519413, 0.0039589023, -0.0002944182, 0.0176748764, 0.0013999305, 0.0040853536, 0.0100712404, 0.0011215847, 0.0013072249, -0.0154325226, 0.0000000040, -0.0087120160, -0.0013822074, -0.0120057305, -0.0043512289, 0.0084947096, -0.0009074614, -0.0047262828, -0.0081489542, 0.0048687574, -0.0169472285, -0.0178279299, -0.0179629736, 0.0445704870, -0.0029551093, 0.0064587235, 0.0037696841, 0.0358938761, -0.0243021380, 0.0274967737, -0.0277688056, -0.0046287761, -0.0000994664, 0.0057330024, -0.0042620781, 0.0291187670, 0.0098523768, -0.0091501009, -0.0018076868, -0.0095298737, -0.0017556397, 0.0018516008, 0.0162667558, 0.0012520859, 0.0055409102, -0.0195501056, 0.0072920118, 0.0044098129, -0.0044548027, -0.0173008665, 0.0237703398, -0.0153878164, -0.0148615548, 0.0044615213, 0.0300006736, 0.0316340253, 0.0007478682, -0.0000302099, 0.0270855147, 0.0014130195, -0.0460639596, -0.0498799942, 0.0002436544, -0.0105670104, -0.0138089359, -0.0042527281, -0.0004280443, -0.0165084023, -0.0112291630, 0.0039133606, 0.0044798618, 0.0211613029, -0.0097147236, -0.0025185349, 0.0000000016, 0.0010918586, 0.0036902044, 0.0199262593, -0.0012666832, -0.0112299146, 0.0137951523, -0.0275992174, 0.0015809902, 0.0142538585, 0.0133440550, -0.0251833536, 0.0175427366, -0.0014449937, 0.0211236198, 0.0225984249, -0.0210232548, 0.0265555270, 0.0103439931, 0.0243660808, -0.0209978316, -0.0054093017, -0.0000387602, 0.0047991909, 0.0099530267, -0.0075017102, 0.0127103832, -0.0056378338, -0.0015173070, -0.0131428819, -0.0155259660, -0.0332003124, 0.0395072177, -0.0010972244, 0.0387122408, 0.0307437349, 0.0221995376, 0.0289012361, 0.0001572737, -0.0052194693, 0.0206454657, -0.0100783529, -0.0012055796, -0.0132012377, -0.0074227224, 0.0130302701, 0.0218640622, 0.0001864553, -0.0011720291, -0.0126670487, 0.0466224626, 0.0119668292, -0.0373840034, 0.0249643642, -0.0098422570, 0.0076425057, -0.0001042416, 0.0001938508, -0.0016165760, -0.0188194886, -0.0412877873, 0.0050924742, 0.0031745352, 0.0534770451, 0.0000000098, -0.0011602447, 0.0005747601, 0.0100671267, -0.0046994635, -0.0121735744, 0.0072707003, -0.0243563280, -0.0389260836, 0.0330667868, -0.0069915014, -0.0070334794, 0.0009594698, -0.0159644894, 0.0417626686, 0.0195140485, 0.0319014937, -0.0297345724, -0.0010771969, 0.0199669879, 0.0072285067, -0.0289271474, 0.0000143782, 0.0076140943, -0.0136699565, 0.0117572648, 0.0394144356, 0.0009531135, -0.0054996409, -0.0177398417, -0.0081369011, 0.0325253755, -0.0190304890, -0.0027777681, -0.0106441835, -0.0065363701, -0.0010425556, 0.0080040991, 0.0107344538, -0.0424270518, -0.0200530663, 0.0069105546, 0.0007296050, -0.0065474072, -0.0067732302, 0.0055011106, -0.0035678158, 0.0000032423, 0.0249638315, -0.0219426975, -0.0196977314, -0.0015133644, 0.0035280483, 0.0101962397, 0.0062558404, 0.0231787581, 0.0000111955, 0.0360107869, -0.0513665825, -0.0260996837, -0.0118744774, 0.0075785927, 0.0056756590, -0.0092235450, -0.0000000852, 0.0111140562, 0.0077394377, 0.0443211719, 0.0005948636, 0.0050251363, 0.0186836198, -0.0000438717, 0.0103958156, -0.0098406104, 0.0308964029, 0.0162433144, 0.0162039604, 0.0032082326, 0.0021013608, 0.0112663079, -0.0003492284, -0.0272894390, 0.0111588119, -0.0006897600, -0.0244678892, 0.0071237534, 0.0000033133, 0.0117974747, -0.0042279353, -0.0182338282, -0.0409096926, 0.0011619532, 0.0046073766, 0.0155723924, 0.0199971795, 0.0298347343, -0.0202522725, -0.0008165761, -0.0122869117, -0.0137107810, -0.0059355488, 0.0103158308, 0.0237624068, -0.0017013919, 0.0325890444, -0.0005674642, -0.0131688686, -0.0278903041, -0.0103769917, 0.0103760352, -0.0027412125, 0.0000157605, 0.0039234268, 0.0076067951, -0.0071836994, 0.0117549738, 0.0075248950, 0.0211008452, -0.0043958346, -0.0214118492, 0.0000534616, 0.0014409821, 0.0193585362, 0.0259945448, 0.0165641326, -0.0075460263, -0.0011234747, 0.0037102683, 0.0000000156, 0.0051567173, -0.0179951321, 0.0161798745, 0.0002584092, 0.0050572762, 0.0079955049, 0.0056944764, -0.0123598166, -0.0015551866, 0.0296795946, -0.0044779163, -0.0145268245, 0.0040014870, 0.0054529831, -0.0193715636, 0.0107868649, -0.0398159847, 0.0129113290, 0.0030685558, 0.0021583980, -0.0061982097, -0.0000001118, 0.0107499659, -0.0030324350, -0.0153206112, -0.0081396634, 0.0005093620, 0.0006923665, -0.0065216203, 0.0038015044, -0.0235220250, -0.0222169086, -0.0002086204, -0.0038142302, -0.0120423008, 0.0030331740, -0.0085394271, 0.0130108045, -0.0045728064, 0.0299654026, -0.0102041597, -0.0091685876, -0.0094713168, -0.0002406172, -0.0198070034, 0.0002218277, 0.0000055116, 0.0289945416, -0.0101432540, 0.0363869816, -0.0315084979, -0.0012042633, 0.0100595411, 0.0151703795, -0.0018344712, 0.0001172359, 0.0192774106, 0.0208216552, 0.0001245627, -0.0274666175, -0.0468513221, -0.0016186552, -0.0452206880, -0.0000000637, 0.0023939996, -0.0011622210, -0.0161221940, 0.0037903639, 0.0113739315, -0.0238710642, -0.0240865629, 0.0050368370, -0.0122797694, 0.0088878702, -0.0016069238, 0.0045341151, -0.0034521569, -0.0278903078, 0.0092877494, 0.0087613193, 0.0674600899, -0.0076670572, 0.0028731911, -0.0053534340, 0.0215851590, 0.0000115196, -0.0013429680, -0.0108019654, 0.0504609570, -0.0031354320, 0.0010574657, 0.0158380140, 0.0056378841, -0.0402500518, 0.0050387313, 0.0392809473, -0.0015557697, -0.0345601216, 0.0432874300, -0.0144532127, 0.0198839828, 0.0126855224, -0.0318546258, -0.0141682336, 0.0117653040, -0.0182559062, 0.0025305897, 0.0113757094, 0.0538851582, -0.0011367418, 0.0002068527, 0.0187746603, 0.0021483547, -0.0043399390, -0.0090479869, 0.0035825414, 0.0202302448, -0.0290759895, -0.0054958058, 0.0000939188, -0.0002932340, 0.0106630409, -0.0128076319, 0.0008955949, -0.0038785539, -0.0033013672, 0.0499649644, 0.0000000003, -0.0026864805, -0.0043513896, 0.0109782349, -0.0004257362, -0.0260170233, -0.0142840706, -0.0026554544, -0.0280043297, 0.0067231432, -0.0013411512, -0.0085736560, 0.0036588653, -0.0125518376, 0.0160293914, 0.0248630214, -0.0153369633, -0.0426536910, 0.0195564199, 0.0046487856, 0.0210877340, 0.0070555401, 0.0000144274, -0.0196785871, -0.0316307172, 0.0163969547, 0.0334042534, 0.0004241412, 0.0112943389, -0.0127790906, 0.0039271642, -0.0281242691, -0.0072316532, -0.0010879765, -0.0043206615, -0.0246712510, 0.0389731303, -0.0234006047, -0.0146988686, -0.0094095739, -0.0142584462, 0.0293673053, 0.0204572417, -0.0019224982, -0.0229271203, 0.0162680894, 0.0110533303, -0.0000259531, 0.0022472206, 0.0307891406, -0.0087780831, -0.0245721135, 0.0106575238, 0.0091901468, -0.0058619697, -0.0042209136, -0.0002579675, 0.0115523785, 0.0173228588, 0.0178037025, 0.0028590581, -0.0024432102, 0.0037508989, -0.0031622471, 0.0000000104, 0.0008090115, -0.0056709428, 0.0075589456, -0.0007843950, -0.0035344705, -0.0250130873, 0.0089096632, 0.0012578130, -0.0037096408, 0.0122255618, -0.0016194491, -0.0163311139, -0.0028530539, -0.0145488856, -0.0202352740, 0.0142595777, -0.0170006901, -0.0274396352, -0.0067121694, 0.0022523543, 0.0164127611, -0.0000005257, 0.0037186246, -0.0178544745, 0.0207523890, 0.0065700863, -0.0005907689, -0.0041649528, -0.0033250672, -0.0087525873, 0.0063265772, -0.0080866748, -0.0001056491, 0.0054267095, 0.0015332919, 0.0161922611, -0.0260126609, -0.0061902013, -0.0024658579, -0.0119704921, -0.0007752412, -0.0241895393, 0.0199672859, 0.0347792655, -0.0168809760, -0.0019098144, -0.0000381467, 0.0085732313, 0.0046993149, -0.0292466357, 0.0060324203, -0.0262912083, -0.0060546249, -0.0067109647, 0.0083553763, -0.0002776166, -0.0108622480, 0.0093500251, -0.0289390553, -0.0120875305, 0.0020398686, 0.0073843766, 0.0256099273, -0.0000004505, -0.0107085034, 0.0310013276, 0.0794478580, -0.0044394652, 0.0009868742, -0.0092259645, -0.0322956368, -0.0322299860, 0.0245987587, -0.0440422036, 0.0355446823, -0.0208058041, 0.0093456777, 0.0109190587, -0.0106003471, 0.0199715551, 0.0077155638, 0.0023756083, -0.0026674245, -0.0013989108, -0.0140680084, 0.0000214767, -0.0147782061, -0.0272750705, 0.0066637890, -0.0051694205, -0.0081210546, 0.0104672359, 0.0164210722, -0.0345154293, 0.0183280706, -0.0260981303, -0.0024859903, -0.0129703740, 0.0025327126, -0.0195050742, 0.0515408106, 0.0081541054, -0.0041034562, 0.0222777352, -0.0390506014, -0.0115352031, 0.0548375994, -0.0145789329, -0.0097454488, -0.0111657511, -0.0000830742, -0.0292310137, 0.0179138146, 0.0459002033, 0.0068657184, -0.0225722883, 0.0073256521, 0.0092908433, -0.0076801982, 0.0003501039, 0.0091292104, 0.0022422047, 0.0001327908, -0.0020243975, -0.0059328531, 0.0040053874, 0.0199558958, 0.0000000102, -0.0140271867, -0.0162937623, 0.0133167896, -0.0057197274, -0.0200371351, -0.0241675433, 0.0064312886, -0.0071379705, 0.0048033744, -0.0251258705, -0.0132840918, 0.0061179702, 0.0021920523, -0.0104616974, -0.0050282436, 0.0084657269, -0.0249889251, -0.0247690510, 0.0069588460, 0.0289685968, -0.0224230010, 0.0000067735, 0.0034139357, 0.0165315270, 0.0312949792, 0.0162206348, -0.0014178464, -0.0124700526, 0.0097168218, 0.0098846722, 0.0182056259, -0.0157772452, -0.0002355831, -0.0163485780, -0.0116922893, 0.0053389757, -0.0032839382, -0.0043621385, 0.0261383541, -0.0115912529, -0.0054328041, -0.0058924896, 0.0214546435, 0.0059515117, 0.0000988466, -0.0004723418, -0.0000068682, 0.0020486685, -0.0068393345, 0.0013877446, -0.0147858867, -0.0006815462, -0.0058789300, 0.0189899728, -0.0001807616, 0.0000035846, 0.0177991800, -0.0139419781, -0.0070173847, -0.0017550152, -0.0010878836, 0.0007912210, -0.0158780217, -0.0000000000, -0.0045790151, -0.0058912244, -0.0006132376, 0.0002022843, 0.0052315905, -0.0177786201, -0.0148218982, -0.0096751293, -0.0015564393, -0.0033994601, -0.0043473025, -0.0046932376, 0.0157516543, -0.0111106290, -0.0072449744, 0.0241266675, 0.0185502190, 0.0182926804, -0.0036038682, -0.0074679498, 0.0053021861, 0.0000077574, 0.0079266261, -0.0091427052, 0.0261239223, -0.0075870091, -0.0002340178, 0.0031257661, -0.0102104191, 0.0001209600, 0.0206549875, 0.0019387435, -0.0001644904, 0.0084969988, -0.0086890189, -0.0135305049, 0.0239792969, -0.0107893189, 0.0246221460, 0.0277846958, -0.0097301565, -0.0071020420, 0.0272861905, 0.0129279522, 0.0094854785, 0.0109191900, -0.0002048520, 0.0007292989, -0.0246775318, -0.0055922996, 0.0284813717, 0.0059275096, 0.0178074092, 0.0121955341, 0.0262035839, 0.0000995401, 0.0137362154, 0.0002098537, -0.0234433338, 0.0058958842, 0.0248415805, -0.0003602972, 0.0022262251, -0.0000000434, 0.0022166099, 0.0118812304, 0.0172272455, -0.0000450938, -0.0166615248, 0.0098557649, 0.0074956995, -0.0064261607, 0.0077832877, -0.0000584116, -0.0038677803, -0.0108187757, 0.0018749364, -0.0124204503, 0.0092464164, -0.0375291966, -0.0114415707, -0.0059402967, 0.0036923480, -0.0093610864, -0.0000580543, 0.0000102604, -0.0284983274, -0.0187746305, -0.0016695617, 0.0083565759, -0.0011600807, 0.0132558290, 0.0099526560, 0.0006425980, -0.0129457349, -0.0051240842, 0.0000835597, -0.0017292703, -0.0345475376, 0.0327454582, -0.0375599600, -0.0093964031, 0.0298081562, -0.0157219525, 0.0147520928, 0.0025407574, 0.0014037221, -0.0314608961, 0.0093225874, 0.0461117290, 0.0000170953, 0.0420589224, 0.0117616085, -0.0295610726, -0.0132812168, 0.0344583280, 0.0007608517, -0.0560256280, -0.0051838011, 0.0002960569, -0.0290913060, 0.0458463356, 0.0166658871, 0.0364960581, -0.0135655832, -0.0117581608, -0.0004756497, 0.0000000790, 0.0087997969, -0.0095620137, 0.0352615863, 0.0032983774, -0.0031197604, 0.0165763274, -0.0224882476, -0.0365554169, -0.0065810289, 0.0410871841, -0.0232314356, -0.0199529380, -0.0176303834, 0.0104690082, 0.0206280984, 0.0161984302, -0.0169825945, -0.0152637865, 0.0026509718, 0.0291859303, 0.0102998372, -0.0000051630, -0.0056127780, -0.0283642132, -0.0097498549, 0.0081328722, 0.0001384753, -0.0009143136, -0.0322317779, 0.0061233905, -0.0074565266, 0.0268269833, 0.0014444089, 0.0342398882, 0.0189776998, 0.0092341229, 0.0060796849, 0.0156654827, -0.0198654942, 0.0309199244, -0.0028397280, -0.0155731067, -0.0379103273, -0.0193077158, -0.0367084704, 0.0200444926, -0.0000060709, 0.0005516287, -0.0184985809, 0.0257595032, -0.0632421300, 0.0314777792, -0.0064402027, 0.0044729542, -0.0045346813, 0.0000117502, -0.0095646791, -0.0153617263, -0.0029496297, 0.0133878412, -0.0219948087, -0.0008686713, -0.0491854288, 0.0000001995, 0.0276982207, -0.0310923699, 0.0165749639, 0.0011358632, -0.0000556844, -0.0083136633, -0.0282140691, -0.0162453558, 0.0151359867, -0.0077355853, -0.0190870259, -0.0014699231, 0.0125032179, -0.0312644243, 0.0289059486, -0.0092219869, -0.0050657811, -0.0319867358, -0.0154825682, -0.0256235320, 0.0008985184, 0.0000004517, 0.0230684150, -0.0100432225, -0.0062988601, -0.0119745927, 0.0043393271, 0.0112485643, -0.0030938953, 0.0126618026, -0.0121111870, 0.0304449536, 0.0002587133, -0.0064108055, 0.0202144943, 0.0437909588, -0.0035933496, 0.0005198792, 0.0175538324, 0.0115671968, 0.0181310903, -0.0402660929, 0.0129800579, 0.0124811223, 0.0038575849, 0.0011395781, -0.0000413932, -0.0007274965, -0.0283691790, 0.0127382968, -0.0149285737, 0.0025379052, 0.0033502684, -0.0252258964, -0.0229634251, -0.0001160012, 0.0111057833, 0.0098171560, 0.0024916299, -0.0178514142, -0.0142634381, -0.0060454584, -0.0152858933, 0.0000000199, -0.0035767546, -0.0125354575, -0.0118840374, -0.0004683659, -0.0132117663, -0.0097258352, 0.0342234746, 0.0243365895, 0.0100679249, -0.0048384489, -0.0088667115, 0.0061256359, 0.0062737847, -0.0223300792, 0.0213445872, -0.0155075900, 0.0488701612, 0.0024850853, 0.0073696673, -0.0115222316, 0.0063902340, -0.0000166493, -0.0028525272, 0.0263700355, 0.0254427791, 0.0128372684, -0.0034062164, 0.0089955823, -0.0125316419, 0.0186300147, -0.0054748408, 0.0260449611, -0.0018742555, -0.0320643522, 0.0318523608, 0.0329438336, -0.0025675411, -0.0144927166, 0.0411698222, -0.0188065525, -0.0009208075, -0.0068258452, 0.0252572466, 0.0247605219, 0.0217007510, -0.0032279959, -0.0000330128, 0.0269238576, 0.0102004856, 0.0207528248, 0.0287773032, -0.0097580729, 0.0115322741, 0.0088926405, -0.0038334730, 0.0000694506, -0.0107552391, 0.0262752734, 0.0256112572, 0.0055071544, -0.0057467534, -0.0035732028, 0.0240555890, -0.0000000862, -0.0153055303, 0.0045929044, 0.0152037218, 0.0012364779, 0.0039360612, 0.0192125086, -0.0096107405, -0.0360312238, 0.0010825024, 0.0142946979, -0.0005227305, -0.0266126487, 0.0227524135, 0.0349334702, 0.0121594276, 0.0116956811, -0.0376022793, -0.0096556013, 0.0155948112, 0.0221156348, 0.0009338562, -0.0000007314, -0.0232831240, -0.0163753536, -0.0148961088, 0.0054302504, 0.0020060351, -0.0064172517, 0.0104213925, 0.0096916957, 0.0048072618, -0.0363784023, 0.0015656642, -0.0257735420, -0.0185467619, -0.0181983225, 0.0135262636, 0.0283762589, -0.0281980541, -0.0298244841, 0.0149785858, -0.0087509844, -0.0075354027, -0.0103718750, -0.0014114856, -0.0036232965, -0.0000214699, 0.0194304325, -0.0023599279, -0.0237018801, -0.0440811738, 0.0220387094, -0.0081385579, -0.0061672288, -0.0039140875, 0.0005003584, 0.0241645537, -0.0124611864, 0.0089637479, 0.0164086409, 0.0221848227, -0.0096753929, -0.0420413911, -0.0000000241, -0.0109593831, -0.0087904837, 0.0066224691, 0.0006285228, -0.0027252173, -0.0080243414, 0.0258646403, 0.0086550191, -0.0014725979, 0.0040612738, -0.0094349375, 0.0122545836, -0.0222722515, -0.0176586173, -0.0011581802, -0.0227857083, 0.0354162902, -0.0211813953, 0.0121984677, -0.0665194020, 0.0185152926, -0.0000375492, 0.0161675047, -0.0087796450, 0.0155511433, 0.0002988402, -0.0155681884, 0.0172857177, 0.0025523023, -0.0260561630, -0.0199400689, 0.0155611122, -0.0014184826, 0.0485692583, 0.0102652423, 0.0126804300, 0.0287184492, -0.0126556866, 0.0396599956, 0.0503677502, -0.0213335957, -0.0194257963, 0.0267141499, -0.0218680650, -0.0044283266, -0.0238588210, -0.0001066672, -0.0193740837, -0.0351326987, 0.0295276102, 0.0081845690, -0.0039718165, -0.0023265250, 0.0081996843, 0.0175780598, -0.0008330089, 0.0390800387, -0.0312158689, 0.0156229930, 0.0181752872, -0.0378952250, 0.0079666497, 0.0005206381, 0.0000000358, -0.0146225756, -0.0040409430, 0.0018591287, -0.0064149764, -0.0239147246, -0.0284771975, 0.0161246248, -0.0026608068, 0.0321035311, -0.0139356963, 0.0074460818, 0.0018872198, 0.0263861548, -0.0482023992, 0.0043456731, -0.0203218330, -0.0092013236, -0.0154070118, -0.0056827338, 0.0131148109, 0.0115731377, -0.0000444065, -0.0009479294, -0.0032641911, 0.0218108520, 0.0124806277, -0.0025909571, 0.0037484106, 0.0134136453, 0.0284651499, 0.0033886449, 0.0210059006, -0.0019442510, -0.0278445017, -0.0119436542, 0.0470761620, -0.0092356987, -0.0187085960, 0.0211685095, -0.0230995547, 0.0228614602, -0.0205778051, 0.0505722612, -0.0156104071, 0.0154460445, 0.0121470429, -0.0016492787, -0.0028714600, 0.0097379349, -0.0140544167, 0.0160772484, 0.0296826437, 0.0003687200, 0.0064852266, 0.0177399274, -0.0002811424, -0.0034734458, -0.0093158176, 0.0027219790, -0.0024014139, 0.0165601540, -0.0126690501, 0.0483639911, -0.0000000172, 0.0045116260, 0.0081854118, -0.0014831320, 0.0027650790, -0.0258573648, 0.0104069095, -0.0178686585, -0.0278841723, -0.0021204229, 0.0078752181, 0.0048534586, 0.0195554979, -0.0396323577, 0.0421686620, 0.0001043589, 0.0411833376, 0.0127314823, -0.0024826590, 0.0262163617, 0.0066463696, -0.0194284003, 0.0001512326, 0.0309300069, 0.0026393284, 0.0013915957, 0.0127041806, -0.0134818861, -0.0033533708, -0.0098801171, -0.0358531810, 0.0270510446, -0.0173680782, -0.0080912430, 0.0376138054, 0.0095890947, 0.0037328622, 0.0339471623, 0.0211503450, -0.0193338469, 0.0270422362, -0.0178359561, 0.0556811057, 0.0102648269, -0.0473895296, 0.0457235649, 0.0122641828, -0.0002188364, 0.0121833682, 0.0020217195, 0.0374235734, -0.0251206066, -0.0126623977, 0.0008805617, -0.0173474103, 0.0082041314, -0.0009105919, 0.0228862781, -0.0050956989, -0.0146052595, 0.0250393450, 0.0208779946, 0.0015909144, 0.0462628677, 0.0000004941, -0.0103781251, -0.0168177504, -0.0050353068, -0.0077347788, -0.0017059121, -0.0382531956, 0.0222883895, -0.0238876287, -0.0153663028, 0.0206321049, 0.0109749846, 0.0098937145, -0.0215777475, 0.0235281717, -0.0027343959, 0.0420534462, -0.0046135606, -0.0289259218, 0.0087376088, -0.0083148265, -0.0281947646, 0.0000917663, 0.0458308496, 0.0037999540, 0.0347623229, -0.0058442769, -0.0009092222, 0.0015928138, -0.0309350844, -0.0342873596, 0.0224533435, -0.0022199338, -0.0033164977, 0.0277129263, -0.0021946977, -0.0062859682, 0.0017547401, -0.0023582801, -0.0300460961, 0.0382642597, 0.0431967005, -0.0299446061, -0.0089724679, 0.0252643451, 0.0038139650, 0.0023313393, 0.0000059427, -0.0007545300, -0.0188093018, 0.0028684782, -0.0042794803, -0.0022045437, -0.0099519575, -0.0014033886, -0.0098513281, 0.0000619138, -0.0067467177, -0.0124253873, -0.0092217624, 0.0044381893, 0.0000951617, -0.0048641651, -0.0131792426, 0.0000000012, 0.0101206191, -0.0075824042, -0.0487350002, 0.0011964878, 0.0125474576, 0.0002532584, -0.0036560711, 0.0217575934, -0.0081411581, 0.0454104170, 0.0171672199, 0.0088384412, 0.0186684411, 0.0094665065, -0.0162790492, -0.0192271695, -0.0396011025, 0.0256176013, -0.0205297638, 0.0036686023, 0.0094330255, 0.0000059567, -0.0114121689, -0.0080789067, -0.0093406253, 0.0020056856, 0.0042476985, -0.0025306814, -0.0079788873, 0.0208885167, 0.0181200355, -0.0214285925, 0.0016133431, -0.0222763177, -0.0130367847, -0.0395929888, -0.0036039432, 0.0019550270, 0.0419846475, -0.0297661908, -0.0204139091, -0.0116881765, -0.0110563925, -0.0108464584, 0.0268569328, 0.0247330144, 0.0002405775, 0.0028521921, -0.0036056174, 0.0049183769, 0.0176588297, 0.0145825166, 0.0177254584, -0.0386365168, 0.0219266694, -0.0001465824, -0.0052902829, 0.0134165976, -0.0200497173, 0.0047155847, 0.0197989531, -0.0070104143, 0.0132127749, 0.0000000154, -0.0041627265, -0.0009898936, -0.0055274619, -0.0011767345, -0.0266451333, 0.0203175154, 0.0126385652, -0.0420037992, -0.0025700286, -0.0090996018, -0.0093791392, -0.0116770668, 0.0053622080, 0.0046601417, 0.0130796609, 0.0098380297, -0.0579471402, -0.0608520098, 0.0166491028, -0.0075856238, 0.0349809751, 0.0000324635, -0.0143171875, -0.0152624520, -0.0295172259, 0.0243389327, 0.0018206241, 0.0105223805, -0.0121682165, 0.0189423207, 0.0065492080, -0.0050492263, -0.0011882705, 0.0111978343, 0.0140693514, 0.0289616250, -0.0034227865, 0.0264229774, -0.0311799962, -0.0134628778, 0.0340187363, -0.0046136715, 0.0118434243, 0.0294110719, -0.0310253575, -0.0114767505, 0.0000007207, -0.0489213429, 0.0325386077, 0.0011308148, -0.0004182028, -0.0103076315, -0.0201617870, 0.0124049466, -0.0087737348, 0.0000016497, 0.0010711544, -0.0204263907, 0.0174939875, 0.0097216759, -0.0044527352, 0.0030120702, -0.0114628654, -0.0000000029, 0.0140243936, -0.0094557749, -0.0128369667, -0.0017829792, 0.0058500720, -0.0124761816, -0.0239797011, 0.0152689666, 0.0255358666, -0.0008828105, 0.0045490810, 0.0180482492, 0.0224771574, -0.0147553449, -0.0381605960, -0.0001574961, -0.0159370769, 0.0128794117, -0.0158114526, 0.0033650049, 0.0134806642, -0.0000088306, 0.0198767185, 0.0270161759, 0.0062454920, -0.0145475706, 0.0005066024, -0.0292187501, 0.0189240910, -0.0066967481, -0.0086092725, -0.0115072690, -0.0052696662, 0.0053339540, 0.0177876018, 0.0252481811, -0.0109426761, -0.0072589950, 0.0227863472, 0.0161540117, -0.0028145169, 0.0039676838, 0.0092711262, -0.0234646909, 0.0106136948, 0.0080674216, 0.0000064104, 0.0056832549, -0.0486956388, -0.0117466869, -0.0316019431, 0.0285632070, 0.0215459671, -0.0241779294, 0.0176856518, 0.0002139003, 0.0484614372, 0.0096485177, -0.0081845568, -0.0188668668, 0.0034926962, -0.0016888365, 0.0060496950, -0.0000002019, 0.0042374027, 0.0136846052, 0.0298931375, 0.0001278220, -0.0047161854, -0.0051768487, -0.0039013373, -0.0090343682, -0.0286359657, -0.0131249344, 0.0120901782, 0.0179348718, 0.0136499228, -0.0232826751, 0.0539201461, 0.0235543586, 0.0514775626, 0.0028542152, 0.0201588459, -0.0019814351, 0.0114414459, 0.0000057237, 0.0198348649, -0.0033026207, 0.0136382915, -0.0087854555, 0.0040277774, 0.0309132356, 0.0246461257, -0.0022334540, 0.0224279836, 0.0002364649, -0.0015976158, -0.0095232669, -0.0138958497, 0.0138098290, -0.0083574634, 0.0227587000, -0.0429655463, 0.0297135822, -0.0037155161, -0.0076794671, -0.0027993259, 0.0201710127, 0.0184588432, -0.0281801913, -0.0000696656, -0.0141462972, -0.0337825119, 0.0016500906, 0.0366562493, 0.0054349815, -0.0036961134, -0.0018236801, -0.0095836865, -0.0007836472, 0.0412429385, 0.0029106473, -0.0192317013, 0.0072584059, -0.0047124010, 0.0003186744, -0.0091939867, -0.0000000094, 0.0005904187, -0.0079099080, -0.0381655321, 0.0003152049, 0.0137004834, -0.0252358355, 0.0497113280, 0.0567225516, -0.0243630018, 0.0242130477, 0.0047170264, 0.0297450051, 0.0393045433, -0.0265200920, -0.0369722061, -0.0330703296, -0.0028441274, 0.0224018339, -0.0189374685, -0.0028624304, 0.0499506146, -0.0000066837, -0.0432066247, 0.0162804238, 0.0175433625, -0.0194068961, 0.0020631875, 0.0008153868, 0.0145098800, 0.0491489619, 0.0139043992, 0.0032999457, 0.0003508356, -0.0295040235, -0.0610571280, 0.0356564522, -0.0653682426, -0.0371660963, 0.0273989122, -0.0199046750, 0.0124699576, -0.0242746938, 0.0221023038, -0.0043435097, 0.0419466682, 0.0035393685, 0.0000015964, 0.0131165870, -0.0186595023, 0.0414510518, -0.0377809666, 0.0293557420, -0.0054011294, -0.0011191661, 0.0243006106, 0.0000135134, 0.0536350273, -0.0025951550, -0.0049162265, -0.0245494507, -0.0096907178, -0.0087428819, -0.0189031363, 0.0000000652, -0.0107322093, -0.0020132484, -0.0193636883, 0.0031287046, 0.0236405991, -0.0077953190, 0.0281691886, 0.0119045703, 0.0116813760, 0.0244786181, 0.0006951420, -0.0047801761, 0.0109057436, -0.0337097831, 0.0022607241, -0.0305228867, 0.0674641579, -0.0130620711, 0.0097131953, 0.0017947052, -0.0391894504, 0.0000058531, -0.0039557302, -0.0766480938, 0.0486471877, 0.0104655176, 0.0008448847, -0.0027081785, -0.0204331428, -0.0645695999, -0.0031126919, -0.0008751351, -0.0061182845, -0.0366269760, 0.0101054385, -0.0324740671, 0.0140939290, -0.0139370980, -0.0042112009, 0.0352340862, 0.0087166028, -0.0434300862, -0.0303057041, 0.0137942331, 0.0069483803, 0.0068056919, -0.0000602314, -0.0146663692, 0.0100226644, -0.0083919028, -0.0019738155, -0.0030243238, -0.0091419630, -0.0215836782, -0.0144406408, -0.0000406220, 0.0000619208, 0.0338030644, -0.0034659787, -0.0020669312, 0.0236540660, -0.0013713944, 0.0037130669, 0.0000000018, -0.0131907500, 0.0096748546, -0.0301083103, 0.0000145041, -0.0009585232, 0.0051761838, 0.0054654162, 0.0001960799, 0.0177402459, 0.0134906769, -0.0110620642, 0.0023382071, -0.0181624945, 0.0209778268, -0.0117441434, 0.0042621819, 0.0007956757, 0.0020776747, 0.0078392075, -0.0070456369, -0.0160274599, 0.0000089649, -0.0134872086, 0.0090843644, 0.0119381463, -0.0090315454, -0.0005612536, 0.0095588816, -0.0006649715, -0.0103215966, -0.0139072808, 0.0053468142, -0.0006693387, 0.0142584378, 0.0087745450, -0.0112839229, -0.0029889201, -0.0111679006, 0.0127467280, 0.0028063413, 0.0060611079, 0.0050618760, -0.0139672449, 0.0017409356, -0.0066139493, 0.0158714801, -0.0000102101, -0.0139433770, -0.0151631329, -0.0193216875, -0.0233938713, 0.0054621045, -0.0096018482, -0.0169993360, -0.0170802809, -0.0000471292, -0.0022368648, -0.0032787747, 0.0038749806, 0.0202976204, 0.0260381754, -0.0065593151, -0.0151127465, -0.0000000026, -0.0066145081, -0.0268493909, -0.0025413909, -0.0000522351, -0.0003274364, 0.0081108687, 0.0052810092, -0.0113436887, -0.0025763453, 0.0102669233, -0.0079395687, 0.0025554444, -0.0163922999, 0.0026535168, -0.0163953230, 0.0006711026, -0.0054916479, -0.0024300364, 0.0131266750, -0.0083730612, 0.0058667054, -0.0000005785, 0.0313485898, 0.0214307234, -0.0173613410, -0.0216911845, 0.0008659764, 0.0044970014, -0.0174506716, 0.0139849829, -0.0355075635, -0.0012911824, -0.0004591689, 0.0260469317, -0.0208411049, 0.0281070508, -0.0197587460, -0.0034472819, 0.0102142403, 0.0227586608, 0.0031218035, -0.0036254229, -0.0273062903, -0.0210070033, -0.0005111989, -0.0300668888, -0.0000507543, -0.0180614032, -0.0151539883, -0.0161317624, 0.0246981755, 0.0086351587, -0.0159434136, -0.0156023204, -0.0400308706, 0.0000283386, -0.0133134406, 0.0190577991, -0.0168592650, 0.0063241106, -0.0029521198, -0.0012993568, -0.0054090777, -0.0000000174, 0.0011120463, -0.0104999468, -0.0228362307, -0.0002987774, -0.0217418317, -0.0257240944, 0.0468760692, 0.0249927901, -0.0044430639, 0.0035549584, 0.0103878593, 0.0133783836, 0.0063289311, 0.0067850854, -0.0047194352, 0.0027095932, -0.0233669300, 0.0141543113, -0.0404261686, 0.0089764167, -0.0312112942, 0.0000460846, 0.0236466080, 0.0157174449, 0.0166537426, -0.0137780821, -0.0030532896, 0.0042736884, 0.0037129989, 0.0608347207, -0.0100583704, 0.0111172078, -0.0013766319, -0.0212469548, 0.0029380040, 0.0107007595, 0.0295541305, -0.0363338925, 0.0245789103, -0.0442119315, -0.0472869463, -0.0074845413, 0.0380439274, -0.0142955789, -0.0058880565, 0.0079116570, -0.0000167465, 0.0005889978, 0.0004372830, 0.0230571907, -0.0062135616, 0.0212645549, -0.0180545952, 0.0004376171, 0.0075916811, 0.0000001986, -0.0163371488, -0.0240465421, 0.0118623087, 0.0070138508, -0.0005913383, -0.0036684731, 0.0007336545, 0.0000000022, 0.0201865137, -0.0077580363, 0.0016678913, 0.0000250159, -0.0064642811, -0.0158329662, -0.0027413704, -0.0001884824, -0.0011096959, 0.0040487018, -0.0127035510, 0.0013098682, 0.0039424123, -0.0122994985, -0.0069582188, -0.0076124128, -0.0508911721, -0.0180582479, -0.0184073467, -0.0226609427, -0.0053768503, 0.0000008559, 0.0003353493, 0.0088311601, -0.0273989253, 0.0001685499, -0.0086893905, 0.0037525860, 0.0084291436, 0.0125577152, -0.0002952059, 0.0269699432, -0.0060487203, 0.0409977585, 0.0197685380, 0.0295081697, 0.0041273697, -0.0090066772, -0.0023319616, -0.0086688427, -0.0006718920, -0.0104873804, 0.0082552573, 0.0066839191, 0.0146937538, 0.0082547646, -0.0000050650, -0.0016363277, -0.0130125321, 0.0159329791, -0.0272268783, -0.0189605448, -0.0167226978, 0.0024245416, -0.0120225875, -0.0000945888, -0.0145762386, -0.0355200768, -0.0366580449, -0.0017641410, 0.0121826809, -0.0029881478, 0.0215243064, 0.0000000173, -0.0002347324, 0.0004176563, 0.0113074696, -0.0006378288, 0.0056110201, 0.0273738690, -0.0010769718, -0.0061982381, -0.0072771041, 0.0016083106, 0.0055092014, 0.0052345130, 0.0072635063, 0.0409290344, 0.0224708728, 0.0095998487, -0.0143873524, 0.0054463679, -0.0025774771, 0.0144059351, -0.0253109820, -0.0000162205, 0.0035707117, 0.0403649658, -0.0328171067, -0.0215087663, 0.0006859088, 0.0042756596, 0.0001373456, 0.0225662999, 0.0048929746, -0.0126308128, 0.0001229356, -0.0108007938, 0.0116416579, 0.0016856596, 0.0286525656, 0.0136511326, -0.0162206814, -0.0003008411, -0.0233492386, -0.0173718706, -0.0129895499, -0.0053988858, -0.0056285714, -0.0175299700, 0.0000005241, 0.0358574502, 0.0083409604, 0.0077968463, 0.0613391884, -0.0063594803, 0.0060032462, 0.0006691300, 0.0159831326, 0.0000018393, 0.0224103108, 0.0120204967, 0.0106942365, 0.0045086606, -0.0035827770, 0.0003961363, -0.0075441059, 0.0000000016, 0.0050805700, -0.0085281469, -0.0576451942, -0.0007603865, 0.0041820910, -0.0263134334, 0.0235577226, 0.0258120541, -0.0074653239, -0.0011096015, -0.0173681807, -0.0014066480, 0.0079911761, -0.0239433702, -0.0110477293, -0.0039719413, 0.0104118204, 0.0127312802, -0.0016242961, -0.0078757415, -0.0134799443, -0.0000082162, -0.0244791284, -0.0097848326, 0.0133147230, 0.0100558996, 0.0002723896, -0.0014326076, 0.0122132776, -0.0085002063, 0.0227616299, 0.0006293424, -0.0109482296, -0.0369770937, -0.0193574689, -0.0128967324, -0.0245183315, -0.0021729378, -0.0164922550, -0.0293701030, 0.0212439224, 0.0326601937, 0.0113453744, 0.0057608467, 0.0163770113, 0.0191211477, 0.0000032397, -0.0016083389, 0.0004437897, 0.0326442681, 0.0362824537, -0.0126637891, 0.0106194224, -0.0020911465, 0.0036379332, -0.0000036637, -0.0044649029, 0.0011734905, -0.0180614237, 0.0083063617, 0.0257453956, 0.0011229340, 0.0398942046, 0.0000000002, -0.0224455018, 0.0053800670, 0.0075289165, -0.0014405070, -0.0033738690, 0.0088965595, 0.0183750913, -0.0169399139, 0.0063057751, -0.0052847564, 0.0003490477, 0.0099672349, -0.0107601993, 0.0066752150, -0.0221437439, 0.0154950088, -0.0499018319, -0.0165768303, 0.0166967940, -0.0072769681, 0.0001564717, -0.0000042422, -0.0085482188, -0.0087714670, 0.0027324406, -0.0037894510, -0.0013305377, 0.0034106306, 0.0127414204, 0.0075278729, 0.0002075206, -0.0131923007, -0.0008184517, -0.0203618389, -0.0148608126, -0.0068021570, -0.0165277421, -0.0053772661, 0.0103680026, -0.0037221746, 0.0162957497, 0.0174580328, -0.0261512008, 0.0085302368, -0.0000670688, 0.0144556379, 0.0000007451, 0.0003488577, -0.0054300427, -0.0393962711, -0.0341400392, -0.0119454032, -0.0157960337, 0.0244884603, -0.0157933384, -0.0002383580, -0.0102646127, -0.0098478058, -0.0085912710, 0.0167305656, -0.0038509099, 0.0046609892, -0.0309345759, 0.0000000028, -0.0192855150, -0.0068765176, -0.0281581581, -0.0031694134, 0.0049757916, 0.0212766323, -0.0094064856, 0.0003447987, 0.0039851279, -0.0033951488, -0.0142114125, 0.0110320030, 0.0253264606, -0.0002464663, 0.0186644346, 0.0130928084, 0.0052090711, -0.0063663027, -0.0085651036, -0.0024107490, -0.0066573084, -0.0000083428, 0.0155446026, -0.0206076056, 0.0065349466, -0.0158547647, -0.0000802613, 0.0070373258, -0.0068351920, 0.0390313827, -0.0137733407, 0.0349635072, 0.0009404816, 0.0169267524, 0.0038771601, 0.0148118734, -0.0062240111, 0.0062940540, -0.0015689444, 0.0221035406, -0.0283341017, -0.0359597951, -0.0236496087, -0.0256707557, -0.0011511043, -0.0053615128, -0.0000072042, -0.0299178604, -0.0010871810, 0.0454878770, -0.0064238780, 0.0004171394, -0.0107924026, 0.0289350618, 0.0101609221, 0.0000012404, -0.0054972242, -0.0445391089, -0.0177852195, 0.0129610850, 0.0063809436, -0.0050204210, 0.0519689657, 0.0000000010, -0.0014004465, 0.0052602147, -0.0028778301, -0.0013110556, 0.0001854097, -0.0080493018, -0.0062956717, -0.0071273553, -0.0048184502, -0.0048249606, 0.0003574603, 0.0056203399, 0.0085731726, 0.0184783582, -0.0084535163, -0.0074692573, -0.0637904927, 0.0300105903, 0.0149529846, 0.0235858653, -0.0013998931, -0.0000010096, -0.0147711029, 0.0287679397, -0.0001593180, -0.0076756165, -0.0033808660, -0.0125976447, 0.0153453620, 0.0060875346, -0.0096602123, -0.0091175707, -0.0007169972, 0.0019467023, -0.0037120921, 0.0075067901, -0.0261780154, 0.0130128106, -0.0095601622, -0.0146347936, 0.0255925525, -0.0039035515, -0.0091022793, -0.0064267293, -0.0050610360, 0.0097280983, -0.0000046311, -0.0259190034, 0.0173914898, 0.0137000689, -0.0366621390, 0.0293136481, -0.0073220273, 0.0041111340, -0.0232086461, 0.0000530354, 0.0291608796, -0.0097386101, 0.0027071834, -0.0177034829, 0.0194975156, -0.0081162406, -0.0174113046, 0.0000001973, 0.0063982713, -0.0000932551, 0.0109693632, 0.0008709258, 0.0048773470, 0.0263549332, -0.0043813083, -0.0077052475, -0.0025954756, -0.0141738029, -0.0053965771, -0.0012434474, -0.0058742790, 0.0135528352, 0.0434116311, 0.0461084545, 0.0244359784, 0.0063534332, 0.0110067055, -0.0095367208, 0.0284349956, -0.0000120080, 0.0403988399, 0.0266558547, -0.0002872226, 0.0087453993, 0.0064570219, -0.0120333713, 0.0041981498, 0.0057767229, -0.0100353593, -0.0031022974, -0.0091384398, 0.0115300659, 0.0143998200, -0.0102668740, 0.0091054384, 0.0266645048, 0.0307739396, 0.0403997414, -0.0147317136, 0.0183397755, -0.0148246251, -0.0023408551, 0.0122893089, -0.0046312166, -0.0000097981, -0.0356507339, -0.0192796756, -0.0018656167, -0.0194736645, 0.0174199473, 0.0022164751, 0.0141085293, -0.0142252035, 0.0000109784, -0.0051827449, -0.0145540023, 0.0102666775, -0.0065408610, 0.0076176575, -0.0002242781, 0.0117785353, 0.0000000740, -0.0009062668, -0.0061599258, 0.0253506899, -0.0000571920, 0.0039560511, 0.0132322935, -0.0035099820, -0.0151061332, -0.0080656046, 0.0081680194, 0.0122647127, -0.0115120802, -0.0101819700, 0.0182264317, 0.0038525413, 0.0190178957, 0.0185413342, -0.0076904777, -0.0014183382, 0.0401277691, -0.0200817101, 0.0000005592, 0.0335479341, 0.0141178444, -0.0262515713, -0.0073274267, 0.0006821864, -0.0129424017, -0.0099897161, -0.0056867488, -0.0023508857, -0.0165301170, -0.0038351514, -0.0068770372, -0.0035952707, -0.0012916026, 0.0199909899, 0.0040998654, 0.0172966775, 0.0485960245, 0.0158852302, 0.0209202189, -0.0127432151, -0.0214584265, -0.0098696873, 0.0432248563, 0.0000011746, -0.0268990844, -0.0121473251, -0.0007750082, 0.0100881802, 0.0297953729, 0.0396763794, -0.0391150266, -0.0032186937, 0.0000124074, 0.0621019043, 0.0066715283, -0.0125536146, -0.0271219928, -0.0039916178, -0.0079295579, -0.0161656924, -0.0000001056, -0.0017482555, -0.0033551329, -0.0128886905, 0.0017522902, -0.0007165731, -0.0212473813, 0.0004481105, -0.0085800346, -0.0085066669, -0.0248120166, -0.0122567909, -0.0118854241, 0.0382884368, -0.0270096399, 0.0562384278, 0.0677228421, 0.0700338557, 0.0340783596, 0.0141712278, -0.0248846225, -0.0641590357, 0.0000300428, 0.0109238783, -0.0128573086, 0.0583792143, 0.0037490854, 0.0047178152, 0.0184853747, -0.0007179330, 0.0114205191, 0.0371717550, 0.0479674637, 0.0019018042, -0.0320663489, 0.0308713019, 0.0347797610, -0.0207963381, -0.0128333336, -0.0024696991, 0.0038702111, -0.0240528695, -0.0089534055, -0.0144346701, -0.0070132697, 0.0258178208, -0.0020004644, -0.0000022424, -0.0117848255, -0.0066056228, -0.0012046297, -0.0196213871, 0.0055934004, -0.0085709989, -0.0010652950, -0.0148796663, -0.0001244466, -0.0255454201, -0.0179883465, -0.0064039561, 0.0172140189, 0.0023111121, -0.0020309510, 0.0290875435, 0.0000000043, 0.0048208493, -0.0154615091, 0.0142738335, -0.0008336207, -0.0091942325, 0.0179782696, -0.0061632502, -0.0175646283, -0.0211768746, 0.0124525726, -0.0015037809, -0.0152757345, 0.0165740736, 0.0188946817, 0.0039215307, 0.0083678151, -0.0367565267, 0.0149832582, 0.0070102843, 0.0492243618, -0.0228957925, -0.0000015979, -0.0167651214, 0.0076565160, -0.0281757955, 0.0012436411, -0.0006281112, 0.0032473379, -0.0057502673, 0.0316573419, -0.0176591240, -0.0014615542, -0.0057770638, 0.0030858091, -0.0014250869, 0.0250490345, 0.0092712231, 0.0188466739, -0.0340165980, 0.0051261354, 0.0154748568, -0.0075798854, 0.0005467361, 0.0133355185, -0.0176604390, -0.0183092542, 0.0000075837, 0.0152931055, 0.0028032998, -0.0059139780, 0.0169410575, 0.0025618505, -0.0105087124, 0.0151146464, -0.0078265863, -0.0000062122, -0.0090568019, -0.0330643877, -0.0042792284, -0.0095156413, 0.0078622354, -0.0039022309, -0.0014927702, -0.0000000022, -0.0043587517, 0.0093405908, -0.0076462566, -0.0003995109, -0.0088175442, -0.0097448044, 0.0115893902, 0.0070716459, 0.0081500970, 0.0102255782, 0.0022422120, 0.0332615115, -0.0231844187, -0.0029969306, -0.0280827861, 0.0059737461, 0.0080256741, -0.0209757444, -0.0187655780, -0.0032129164, -0.0200727247, 0.0000017737, 0.0178000089, 0.0380246341, 0.0000642975, -0.0278537963, -0.0055554137, 0.0137659237, 0.0215522200, -0.0031986670, -0.0008696141, 0.0140800187, -0.0048341178, 0.0019407348, 0.0105203325, -0.0085310582, 0.0319193490, -0.0107256128, -0.0119182011, -0.0084364573, -0.0126339346, -0.0041025411, 0.0062027751, -0.0011768474, 0.0043192562, -0.0121873775, -0.0000147040, 0.0043578991, 0.0225905683, -0.0116729168, -0.0319973715, 0.0177504346, -0.0012177824, 0.0006899101, -0.0100676129, 0.0000093906, 0.0028662917, 0.0077989660, 0.0196546279, -0.0029455975, 0.0030618960, -0.0063814521, 0.0234505292, 0.0000000183, -0.0006823497, 0.0017536356, 0.0051306034, 0.0009520788, 0.0000814052, 0.0012110185, -0.0246274788, 0.0062652463, -0.0009000413, -0.0090322951, -0.0148754753, 0.0105191423, -0.0072432118, 0.0397775136, 0.0027150961, 0.0185774155, 0.0178644620, 0.0010176870, -0.0130065987, -0.0372628532, 0.0065334607, 0.0000195591, 0.0009365322, 0.0021366712, -0.0104479650, 0.0114905564, -0.0047178194, -0.0064674797, -0.0065867314, -0.0157944541, 0.0234497730, -0.0124676526, 0.0039917962, 0.0192873403, 0.0151379108, -0.0339138545, 0.0441017076, 0.0016525832, 0.0172246359, 0.0068286676, -0.0139199411, -0.0062576863, 0.0303365495, -0.0106477588, 0.0133516090, -0.0169357117, -0.0000021887, -0.0218962878, 0.0062619969, 0.0092792967, 0.0065257614, 0.0088130543, -0.0026086622, 0.0051801684, -0.0137897963, -0.0000020596, 0.0108808503, 0.0036230367, -0.0188394450, -0.0128655415, -0.0028803791, 0.0066385819, 0.0312400740, 0.0000000001, 0.0040712501, 0.0059192847, 0.0090829339, -0.0008836879, -0.0081733316, -0.0053846273, -0.0127678951, -0.0098506138, 0.0007889065, -0.0095618004, -0.0075481618, -0.0026937090, 0.0369973779, 0.0208709650, 0.0328160934, 0.0096687647, -0.0346380658, 0.0080768457, -0.0042304359, 0.0177250728, -0.0378988571, -0.0000015292, -0.0133944210, 0.0115456348, -0.0036658540, 0.0151402587, -0.0004975801, -0.0087621715, 0.0020788487, 0.0194815900, -0.0293707345, 0.0062310519, -0.0021858392, -0.0082826177, -0.0076272446, 0.0267482288, 0.0109419310, -0.0036436068, -0.0099090915, -0.0268444512, -0.0183783248, -0.0035581302, 0.0109293107, -0.0256201439, -0.0145756742, 0.0195061862, -0.0000014632, -0.0067531201, 0.0162922759, 0.0344618075, -0.0197940376, 0.0151401926, 0.0058619580, 0.0048013865, -0.0002608444, -0.0000000435, 0.0036594789, -0.0120603107, -0.0053398549, -0.0088742245, 0.0036952735, -0.0018320337, -0.0061151199, 0.0000000018, 0.0034003772, -0.0069104112, 0.0213736966, 0.0002416742, 0.0017482456, -0.0180909764, -0.0029921879, 0.0003792781, 0.0030004054, -0.0275673121, -0.0019287419, -0.0066442299, -0.0108530726, -0.0094039012, 0.0021942977, 0.0244917460, 0.0046590595, -0.0249402989, -0.0027862790, -0.0353633426, -0.0367116965, 0.0000027585, 0.0252012815, 0.0085337246, 0.0021907829, -0.0217158478, -0.0040105134, -0.0162564367, -0.0114898346, -0.0326281525, 0.0034159240, -0.0034684641, -0.0013666786, -0.0136752827, 0.0063522658, 0.0001926141, 0.0060252901, -0.0123285698, 0.0200168211, 0.0088570202, -0.0030746844, -0.0109199053, 0.0099478681, -0.0028183346, -0.0008851943, 0.0091550844, -0.0001282532, 0.0082433643, 0.0338085853, 0.0072244434, -0.0166232679, 0.0176021960, -0.0089633465, 0.0042301319, 0.0021078540, -0.0003430358, -0.0151939495, -0.0006038463, 0.0322635844, -0.0093853204, -0.0135277137, -0.0094004739, -0.0086191902, 0.0000000198, 0.0037323313, -0.0038636483, 0.0097002219, 0.0002682543, -0.0075849574, -0.0058935713, -0.0151189044, -0.0131818121, -0.0053154263, 0.0022404077, -0.0225137025, 0.0021495665, -0.0017151027, -0.0090210484, 0.0057718405, 0.0143209985, -0.0544315986, 0.0172840096, 0.0039805993, 0.0303919967, 0.0335993208, -0.0000222974, -0.0040447512, 0.0119983843, -0.0182357151, 0.0158506595, -0.0014208538, -0.0124389902, -0.0085505359, 0.0112333922, -0.0367980525, 0.0113016227, -0.0055585173, 0.0226214491, -0.0006241780, 0.0270639677, -0.0023649642, 0.0027394586, -0.0016256215, -0.0357053503, -0.0079065915, 0.0328944810, 0.0144843636, 0.0158628244, 0.0109633915, 0.0453431904, 0.0000037277, 0.0345960818, 0.0066708755, 0.0095441304, -0.0053569847, -0.0201074630, 0.0049345759, 0.0253335685, 0.0431340523, -0.0001631912, -0.0148522751, -0.0093692681, 0.0007227691, -0.0302283242, 0.0249613393, 0.0148679605, 0.0011024551, -0.0000002851, -0.0068605961, -0.0042010043, 0.0116861342, -0.0018065012, 0.0166499186, 0.0465114452, -0.0352646224, -0.0306508299, 0.0084160371, 0.0161983464, 0.0178608689, -0.0280071720, 0.0323748626, -0.0110301217, 0.0128585026, 0.0109061049, -0.0067249187, -0.0288927909, 0.0192680936, 0.0200649388, -0.0106810881, -0.0000050811, -0.0086497338, -0.0383923464, -0.0016745240, 0.0332880914, -0.0015783733, 0.0186494794, -0.0033138767, -0.0429084115, -0.0152599253, -0.0195482373, -0.0091942316, 0.0122515270, -0.0018034497, 0.0186148509, -0.0172995795, 0.0055380552, -0.0565103404, 0.0376064666, 0.0096350899, 0.0010641166, -0.0266159419, -0.0125822332, -0.0262455959, 0.0192666315, 0.0000002872, 0.0062966193, -0.0022545990, -0.0242677163, -0.0595000796, 0.0149591425, 0.0004785620, -0.0083413767, 0.0017699462, -0.0000003679, -0.0039983583, -0.0024210042, 0.0216776822, -0.0043630558, -0.0276365187, -0.0095089590, -0.0631443113, -0.0000000667, -0.0015027481, 0.0021339795, 0.0484603569, 0.0001335512, 0.0003704289, -0.0044329814, -0.0151639003, 0.0000002469, 0.0044143740, 0.0124294814, -0.0189950597, 0.0045684706, 0.0011734072, -0.0450519286, -0.0007508995, 0.0129361851, 0.0428275876, -0.0317779891, 0.0069475332, -0.0097637437, 0.0128436889, 0.0000000580, 0.0336072743, -0.0090619652, 0.0182541274, -0.0109785125, -0.0002974007, 0.0219289809, -0.0073025785, -0.0020868117, -0.0363506489, 0.0159756131, -0.0059818025, 0.0024541502, -0.0054720873, 0.0413480327, -0.0028129837, 0.0088017862, 0.0012304533, 0.0317167304, 0.0090410924, -0.0238832850, -0.0143197794, -0.0040078908, -0.0013933597, 0.0033824516, -0.0000064182, -0.0063476572, 0.0137753161, 0.0079769986, -0.0022850512, -0.0227953661, -0.0041531487, 0.0163897146, -0.0015175081, -0.0000917019, 0.0149963573, -0.0036725318, -0.0030574466, -0.0062460620, -0.0165260099, 0.0031785327, -0.0058137467, 0.0000000001, -0.0285887327, -0.0001893757, -0.0243984088, -0.0005777926, -0.0028409092, -0.0130386697, 0.0133469459, 0.0010776247, 0.0147247417, -0.0114603406, 0.0050278292, -0.0015684511, 0.0106043555, -0.0102236271, 0.0018026531, -0.0036794832, -0.0077879606, -0.0063691679, -0.0088722045, 0.0131748039, 0.0080561051, -0.0000067728, 0.0150293382, 0.0097322278, 0.0250018034, 0.0058237710, -0.0023597369, -0.0134716285, 0.0013195225, 0.0272579901, -0.0024758726, -0.0021691038, -0.0013164245, -0.0125826821, -0.0209769607, 0.0167975016, -0.0146213640, -0.0185885020, 0.0292969402, -0.0020928413, -0.0090874108, -0.0057210629, 0.0018384729, 0.0157024767, 0.0194446333, -0.0265447889, -0.0000339831, 0.0095338421, -0.0001618209, 0.0227914397, 0.0082934452, -0.0019504995, 0.0023166998, -0.0086538959, -0.0202502478, -0.0000014453, -0.0227501616, -0.0255657155, -0.0127203977, -0.0174826123, -0.0208587237, 0.0007507812, 0.0252530500, 0.0000000724, 0.0078759221, -0.0066658002, 0.0247191954, -0.0003636369, -0.0156019051, 0.0095558399, 0.0183912162, 0.0073184753, -0.0189941600, 0.0149519416, 0.0196794681, -0.0013307130, -0.0059167342, 0.0166330598, -0.0198522806, 0.0253046844, -0.0335308723, -0.0067372564, -0.0186793916, 0.0554405302, 0.0266493391, 0.0000002614, 0.0139919054, -0.0107323695, -0.0237575453, -0.0041877949, 0.0010371226, -0.0108327903, 0.0007918624, 0.0158904940, 0.0041552209, -0.0360824130, -0.0042566019, -0.0141867660, 0.0027850599, -0.0216722395, 0.0166921560, -0.0053738169, -0.0076921755, -0.0157272667, 0.0027980157, 0.0190004855, 0.0103281690, -0.0029175223, -0.0060011353, 0.0148041071, -0.0000185487, -0.0135675827, -0.0037171876, 0.0264091510, -0.0139563382, -0.0167238675, 0.0044550821, 0.0140155191, -0.0075235544, 0.0000408238, -0.0135021051, -0.0181827545, -0.0070704655, -0.0209369492, -0.0013884070, -0.0005188796, -0.0182461794, -0.0000000029, -0.0239947978, -0.0229269974, 0.0056189504, -0.0019490888, -0.0086683147, 0.0072857593, 0.0035320900, -0.0031605414, -0.0097568166, -0.0262220781, -0.0102564208, -0.0111345053, 0.0216539167, -0.0202755574, 0.0059347767, -0.0131807318, 0.0183077846, -0.0183159076, 0.0047363695, 0.0157229006, 0.0009341766, -0.0000029160, 0.0038781208, -0.0083326083, 0.0095470706, 0.0116288941, -0.0004565315, -0.0109373955, -0.0047664656, 0.0189144015, -0.0065216976, 0.0121679865, -0.0033775473, -0.0149942525, 0.0076500457, 0.0484173335, -0.0258881506, -0.0200809892, 0.0160355531, 0.0034398464, 0.0143574560, -0.0023293283, 0.0057460577, -0.0082521085, 0.0030570943, -0.0127404742, -0.0000885298, -0.0038418060, 0.0289990362, 0.0449482612, 0.0207062345, 0.0137238959, -0.0099387607, -0.0122732818, -0.0220718309, -0.0000021698, -0.0005288630, -0.0083852615, -0.0217437446, 0.0347007066, -0.0293680020, -0.0056263306, 0.0133802928, 0.0000000000, -0.0024298076, -0.0172540508, 0.0163327418, 0.0003096253, -0.0134920264, -0.0324258953, -0.0032918034, -0.0062974961, -0.0017297609, -0.0250807274, -0.0065240939, 0.0042682495, 0.0100491699, -0.0235453658, -0.0190276150, 0.0000194184, -0.0328578502, 0.0020914550, -0.0229800567, 0.0237902720, 0.0002692036, 0.0000063992, -0.0197557714, 0.0209204312, 0.0271894746, -0.0037031691, -0.0043638814, 0.0001511961, 0.0102049857, 0.0352946445, -0.0214830693, 0.0139850248, -0.0023290766, -0.0192525312, -0.0104535734, 0.0248306394, 0.0036211337, -0.0283984430, 0.0268152431, -0.0230655894, 0.0166719072, -0.0169957113, 0.0235785004, 0.0028496443, -0.0136064440, 0.0105351079, 0.0000685185, 0.0072633787, -0.0101538980, 0.0080176080, -0.0143157691, -0.0147520117, 0.0034124986, -0.0212641768, -0.0105506079, 0.0017275069, 0.0075879446, -0.0202597827, -0.0057421383, 0.0067418069, 0.0209212434, -0.0029903774, 0.0109917037, -0.0000000038, 0.0094128307, 0.0079269176, -0.0413635038, -0.0038359992, -0.0112477960, -0.0182530992, -0.0094294250, 0.0213875491, 0.0081034638, -0.0053013312, 0.0038056378, 0.0171996877, 0.0111957835, 0.0112675522, 0.0065002944, 0.0223011002, 0.0092034191, 0.0168136843, 0.0198447779, 0.0169064570, 0.0014683997, -0.0000296660, -0.0092515489, 0.0405380726, -0.0144832162, 0.0163236931, -0.0042149853, 0.0018190360, -0.0089556379, 0.0067031444, -0.0097490484, 0.0009476506, -0.0003874856, 0.0329972580, 0.0160917640, -0.0145554068, 0.0184859093, 0.0101338662, -0.0056056650, -0.0183468107, 0.0002814331, -0.0212601777, 0.0481347367, 0.0165320411, -0.0180600230, 0.0150747960, 0.0000440598, 0.0217404850, 0.0113769434, -0.0136112114, 0.0344638228, -0.0096786628, -0.0041074650, 0.0007210175, 0.0090470035, 0.0000135892, 0.0092999116, -0.0009482121, 0.0015556678, 0.0194342751, 0.0555791408, 0.0014440867, -0.0144310789, -0.0000000393, -0.0097544268, -0.0005656690, -0.0206712615, -0.0020203120, 0.0039495546, -0.0118061360, 0.0012031450, 0.0044015311, 0.0076949932, -0.0017632883, -0.0176771209, 0.0097057587, -0.0166853424, -0.0184238832, -0.0147381183, -0.0019663968, 0.0221720655, -0.0293972436, 0.0216693766, -0.0436127782, -0.0242869556, 0.0000525434, -0.0167216193, -0.0123765822, -0.0028783386, -0.0003903591, -0.0015275779, 0.0140992543, 0.0144461915, -0.0413728803, -0.0030613616, 0.0094456896, -0.0133385519, 0.0199009199, -0.0011117435, 0.0166738518, -0.0111537799, 0.0163894910, -0.0115640601, -0.0007496017, 0.0148200942, 0.0002840547, -0.0177390240, -0.0319452770, 0.0112800878, 0.0148676131, 0.0000034835, 0.0336013474, -0.0095163323, -0.0305090509, 0.0371438973, -0.0044023534, 0.0078954995, 0.0575491823, 0.0292084124, 0.0000144524, 0.0106283072, 0.0064297197, 0.0335184336, -0.0254572220, -0.0191348735, 0.0026090068, 0.0016295008, 0.0000000037, 0.0139395874, 0.0043142783, -0.0232755225, 0.0007251842, -0.0025548106, 0.0064700227, 0.0047938270, 0.0145383123, -0.0054682614, 0.0196665023, 0.0350103788, -0.0186007377, 0.0126334177, 0.0329521075, 0.0232341196, 0.0350399762, -0.0121918907, 0.0075532300, -0.0020114821, 0.0275458060, -0.0024738982, -0.0000038671, 0.0052108308, 0.0217215661, -0.0150825949, 0.0160738658, -0.0007264075, 0.0136497328, -0.0064331717, 0.0136045096, 0.0507630408, -0.0170388538, -0.0015138388, -0.0201034639, -0.0456838347, -0.0356234238, -0.0001581832, 0.0406724438, -0.0356532298, -0.0216742940, -0.0183601715, -0.0007415496, 0.0138756083, 0.0047944817, 0.0000455143, -0.0206203628, -0.0000300749, -0.0018293440, -0.0265060216, -0.0038246363, -0.0056085680, 0.0142144524, -0.0169139858, -0.0130276643, -0.0183056127, 0.0000589359, 0.0178633034, -0.0545523576, -0.0243946183, 0.0005140787, 0.0000254547, -0.0021318954, 0.0037835147, -0.0000000021, -0.0077881576, -0.0060833865, 0.0227421820, -0.0006201679, -0.0153283449, -0.0006546897, 0.0200078133, 0.0094155362, 0.0098285284, -0.0106669748, -0.0036757006, 0.0082119536, 0.0080883438, -0.0082185911, -0.0136901541, 0.0192951299, 0.0194351804, -0.0098499767, -0.0158800017, 0.0145657957, -0.0116381356, 0.0000180170, 0.0102515994, 0.0265499689, 0.0062479242, -0.0055156215, -0.0035678404, 0.0039629866, 0.0260343347, 0.0075670322, -0.0338569991, -0.0170435812, -0.0150408978, -0.0136655914, 0.0258146822, 0.0019652809, 0.0205503721, -0.0175866950, 0.0441538878, 0.0049462337, -0.0110772792, -0.0185385980, 0.0047866465, 0.0099546080, -0.0120794009, 0.0084839724, -0.0000012147, 0.0066513526, 0.0109292082, 0.0187221821, -0.0321880132, 0.0094985208, -0.0049860524, -0.0357846916, -0.0100354627, -0.0000079774, 0.0149301607, 0.0077652140, 0.0007607713, -0.0120948404, -0.0101604369, -0.0004166517, -0.0313010775, -0.0000000017, 0.0157773755, 0.0007426161, -0.0294030476, 0.0000592354, -0.0028370407, -0.0249112863, -0.0125627527, 0.0234566275, -0.0145859160, 0.0176645406, 0.0026007092, 0.0051611154, 0.0108380280, -0.0121035166, -0.0060025556, -0.0009729526, 0.0009574617, 0.0070197457, -0.0059325085, -0.0045911074, 0.0006885423, 0.0000006877, -0.0117350761, -0.0040299590, -0.0073351343, -0.0078837005, -0.0007237279, 0.0168702938, -0.0129116131, 0.0027861916, 0.0237328913, 0.0130706085, -0.0038953801, -0.0138709815, 0.0426221862, 0.0047513950, -0.0071114642, -0.0119702322, 0.0240162574, -0.0147206001, 0.0097837579, -0.0049407785, -0.0057277097, -0.0038551264, -0.0091112209, -0.0199549906, -0.0000288180, 0.0024360351, -0.0109005990, -0.0237232987, -0.0604812279, 0.0191287752, -0.0038716621, -0.0304303262, -0.0445516072, -0.0000469395, -0.0028902232, 0.0254190508, -0.0015480443, -0.0317215621, -0.0283291172, -0.0119986637, -0.0206082333, -0.0000000674, 0.0019717689, 0.0120553942, 0.0534174070, 0.0010941944, -0.0078383479, -0.0058005759, 0.0007025386, -0.0005109742, -0.0174754970, -0.0036121982, 0.0204702746, 0.0019473655, -0.0098791793, 0.0369670615, 0.0367298014, 0.0744813159, 0.0583059415, 0.0377610736, -0.0048215366, 0.0249970276, 0.0234611593, 0.0000464595, 0.0124049336, -0.0141543467, -0.0003522101, -0.0018095106, 0.0063049882, -0.0008327886, 0.0035065012, 0.0005251261, -0.0064770039, 0.0082559614, 0.0022874002, -0.0182229988, 0.0562313572, -0.0099334363, 0.0328887776, 0.0209591873, 0.0025306025, 0.0052781054, -0.0434945226, 0.0026618764, 0.0170778502, -0.0081757614, -0.0137263723, -0.0059194751, -0.0000024768, -0.0009139364, 0.0058086766, 0.0356703773, 0.0309274495, 0.0070078974, 0.0071505308, -0.0046760319, -0.0221630894, -0.0000051205, -0.0196495559, 0.0169661194, 0.0134333987, 0.0278325528, -0.0085759340, -0.0065576830, -0.0137504097, -0.0000000066, 0.0119636590, -0.0160414819, -0.0392719321, 0.0004764949, -0.0202571824, -0.0320743956, 0.0115606533, 0.0084468285, -0.0026269734, 0.0090272510, -0.0140648568, 0.0182972848, 0.0167866312, -0.0219198857, -0.0170798693, -0.0054797572, -0.0300838482, -0.0194612425, -0.0197488107, -0.0114386724, 0.0194990486, -0.0000035933, -0.0139900567, 0.0267951246, -0.0100024380, -0.0159032624, -0.0002486160, 0.0152519112, 0.0086042164, 0.0335711837, 0.0253358260, 0.0286192298, -0.0101366015, -0.0031820296, 0.0012727178, 0.0222178008, -0.0049908319, -0.0243893471, 0.0022037111, -0.0237252656, 0.0381229110, -0.0102984104, 0.0348039642, -0.0254028663, 0.0042510214, 0.0324849673, -0.0000096874, 0.0034883395, 0.0207518917, 0.0313940197, 0.0651196614, -0.0369947180, 0.0142983738, 0.0466278046, 0.0145068709, -0.0000549532, -0.0032149458, 0.0287138596, 0.0294131078, -0.0314083397, -0.0076267924, 0.0000085227, 0.0027706283, -0.0000000419, -0.0037092371, -0.0274553094, -0.0464136712, -0.0011182561, 0.0069215749, 0.0055132774, -0.0240447819, -0.0259956103, 0.0047927676, 0.0027808605, -0.0087013301, -0.0352247208, 0.0092546074, 0.0102289114, 0.0037857885, -0.0095578553, 0.0058093849, -0.0227510761, 0.0109982723, 0.0147292512, 0.0153317023, -0.0000078065, -0.0267906897, -0.0204669237, 0.0268459152, 0.0248919316, 0.0019300148, 0.0172358621, 0.0164128244, -0.0251325164, 0.0475025214, 0.0137559669, 0.0000318809, -0.0110927522, -0.0028429448, 0.0061424049, -0.0287084747, -0.0015123967, -0.0367320888, -0.0015034464, 0.0423114933, 0.0194783993, -0.0197436195, -0.0085758632, -0.0093242442, -0.0073705330, 0.0000037967, 0.0148193929, -0.0054129804, 0.0043498143, 0.0268198214, 0.0019789217, -0.0047754557, 0.0047231591, 0.0006546195, -0.0000009013, 0.0040270356, -0.0133171994, -0.0134943323, 0.0034755915, 0.0113499593, -0.0009447806, -0.0072445082, 0.0000000030, 0.0109094251, -0.0036431905, -0.0512502603, -0.0003716845, -0.0003577355, 0.0124189332, 0.0089876549, 0.0187388510, -0.0041305316, 0.0259980634, 0.0101250969, 0.0023022310, -0.0134090278, 0.0000465188, -0.0167659055, -0.0080990726, -0.0082304105, 0.0027637854, -0.0003921793, 0.0002729869, 0.0045290361, 0.0000002492, 0.0089551443, -0.0031628269, -0.0187710878, -0.0126345539, 0.0002392323, 0.0101123387, 0.0045621297, 0.0139270090, 0.0037003383, 0.0055278563, -0.0002007172, 0.0118870120, -0.0185052771, -0.0343802534, 0.0136516755, 0.0069711921, -0.0051710624, -0.0124771949, -0.0041751359, 0.0103057399, 0.0137420595, 0.0147926090, 0.0346764140, 0.0050263526, 0.0000000055, -0.0137960734, -0.0069309166, -0.0193894226, -0.0125242611, -0.0045105563, -0.0041754069, -0.0080156401, -0.0150931692, -0.0000317179, -0.0177798215, -0.0084033301, -0.0136411386, 0.0009835488, 0.0052630003, 0.0023437296, 0.0010685346, 0.0000000215, 0.0009100637, -0.0034862657, 0.0171574894, 0.0000468343, 0.0010306193, 0.0021991590, 0.0106887035, -0.0126296338, -0.0092237415, 0.0065460219, -0.0097397808, -0.0038394509, -0.0211391337, -0.0030650003, 0.0136711551, 0.0132118743, 0.0364831872, -0.0038337549, 0.0039173714, -0.0092859287, -0.0128950784, 0.0000000040, 0.0280242227, -0.0015988291, 0.0057341405, -0.0210404973, 0.0011861369, 0.0154968435, -0.0014696014, 0.0023513762, -0.0060600075, 0.0092013692, -0.0000648465, 0.0129041262, -0.0047857645, 0.0042407732, 0.0133503545, -0.0035563060, -0.0276688095, 0.0472651161, -0.0000414288, -0.0043151258, -0.0164232366, 0.0084850537, -0.0060340650, -0.0080083143, -0.0000030866, 0.0019725868, -0.0079739373, 0.0349461958, -0.0041309027, 0.0055290735, -0.0129420971, -0.0076590208, 0.0068722591, 0.0000010608, 0.0049431021, -0.0223944616, -0.0193001367, 0.0100568458, 0.0174242277, -0.0028219318, -0.0105913728, -0.0000000660, 0.0001052294, 0.0090833604, 0.0043245456, 0.0001631929, -0.0033745926, -0.0319424607, 0.0220303740, 0.0261117518, 0.0011705644, -0.0058812834, 0.0014177073, 0.0330039524, 0.0322025828, -0.0212146621, 0.0005801287, -0.0241151825, -0.0320836641, -0.0007055658, -0.0174536165, -0.0370737836, -0.0228389539, 0.0000021949, -0.0018462382, 0.0313705280, 0.0042550350, -0.0057241130, -0.0057142149, -0.0146472128, -0.0189598780, 0.0094711967, 0.0129663413, 0.0101978444, -0.0123304166, -0.0073432322, 0.0019320369, 0.0134346718, -0.0355068743, -0.0163822547, 0.0378488377, -0.0302082468, 0.0092772357, -0.0065030535, 0.0074282717, 0.0184248723, -0.0012028025, -0.0043869307, -0.0000077383, -0.0051886551, -0.0145633779, -0.0187892970, 0.0023267353, -0.0059271995, -0.0043507796, -0.0141675239, 0.0001659259, -0.0000008805, -0.0092127817, -0.0059897075, 0.0014999262, -0.0059732920, 0.0057307826, -0.0036171528, -0.0028383199, -0.0000000118, -0.0024553670, 0.0243014935, 0.0058830176, -0.0000372784, -0.0071460167, -0.0043419315, -0.0081083598, 0.0106033757, -0.0029731104, 0.0066592908, 0.0122894039, -0.0030120208, 0.0160960294, -0.0341890678, -0.0047588409, -0.0111810518, -0.0030075263, 0.0010392958, -0.0025003208, 0.0065277298, 0.0185409132, 0.0000000068, -0.0010996262, -0.0017695476, 0.0078543564, -0.0040868875, 0.0005141429, -0.0018469505, 0.0059607280, 0.0162334256, -0.0237962678, 0.0104272775, -0.0007223373, 0.0065222760, -0.0182472598, 0.0228672568, -0.0177030098, -0.0121631976, 0.0199867841, -0.0193276443, -0.0133440951, 0.0076460214, -0.0114592537, -0.0222427417, -0.0056891218, 0.0015589983, 0.0000001011, 0.0103063295, 0.0106097599, 0.0243081115, 0.0255095530, -0.0089655658, -0.0086806901, 0.0204417706, 0.0052914005, 0.0000000185, -0.0067988485, 0.0028324481, -0.0042288145, 0.0009547888, 0.0090226103, -0.0038401184, 0.0033122376, -0.0000000371, 0.0010571111, 0.0001058536, -0.0055474127, 0.0004850373, 0.0028209370, 0.0002855073, 0.0156371072, 0.0006561714, 0.0062453374, -0.0008544064, -0.0000970439, -0.0102840355, -0.0140083358, 0.0025444380, 0.0104059018, 0.0079959678, -0.0102633107, -0.0136961397, -0.0008389050, -0.0101638110, -0.0282222740, -0.0000009022, 0.0046257507, 0.0195073448, 0.0143136932, -0.0072253780, -0.0003904842, 0.0130658085, 0.0040502208, 0.0023145080, 0.0074861399, -0.0093399044, 0.0002894892, -0.0042176233, -0.0385336429, -0.0139630176, -0.0128336046, -0.0099376589, 0.0104568973, -0.0074013602, -0.0012559458, -0.0072995094, 0.0115167787, -0.0119984783, -0.0077124266, -0.0021550588, -0.0000190549, 0.0067459829, 0.0016852425, 0.0007049759, 0.0078914622, 0.0060429326, -0.0024156142, 0.0292452257, 0.0196606498, -0.0000000870, -0.0084353611, -0.0111391684, 0.0160700884, -0.0021337071, -0.0182840247, -0.0026234826, -0.0138104204, -0.0000000030, -0.0116153071, 0.0191962868, 0.0021774692, -0.0010724417, -0.0024669266, -0.0047107930, -0.0000471605, -0.0029122815, -0.0312588625, -0.0062828483, -0.0003129788, -0.0112246377, -0.0160173830, -0.0130345421, -0.0392159596, -0.0066445931, 0.0234647840, -0.0051006312, -0.0034708905, 0.0179989748, 0.0191577263, -0.0000003224, 0.0082032336, -0.0137027223, -0.0088712554, -0.0226065293, -0.0025445893, 0.0033858374, 0.0055727786, -0.0028752612, 0.0114871394, -0.0085939318, 0.0004934761, -0.0070695314, -0.0070574004, -0.0070596114, 0.0145806922, -0.0141799673, -0.0002179777, 0.0160660818, 0.0023516177, 0.0168034174, 0.0059430785, -0.0330765992, -0.0144688683, -0.0064186631, -0.0000618655, 0.0079453606, -0.0111315288, 0.0218592882, 0.0051003853, 0.0126742423, -0.0043543917, 0.0266394224, -0.0028522431, -0.0000004065, 0.0159907676, -0.0153540382, -0.0081976941, -0.0196469277, 0.0028792578, -0.0027963242, 0.0113729704, 0.0000000001, 0.0143427467, 0.0013202706, -0.0136771910, -0.0013644273, -0.0019204787, 0.0215443652, -0.0000968150, -0.0086506708, -0.0144030191, 0.0131644737, -0.0076930141, -0.0248986538, 0.0050794226, 0.0033635062, -0.0004208924, -0.0018706728, -0.0268401485, 0.0028507751, -0.0037398320, 0.0243992712, -0.0047991723, -0.0000000916, -0.0259080697, -0.0166597180, 0.0027571986, -0.0048735160, -0.0013167007, 0.0110742627, 0.0076750801, 0.0075367307, 0.0027266135, 0.0008283682, -0.0064789243, 0.0007676458, -0.0133113759, 0.0145103307, 0.0150418403, -0.0023346476, -0.0058949888, -0.0214869771, -0.0250040386, -0.0033062601, 0.0021479938, -0.0012301687, -0.0202902704, 0.0188721586, 0.0000004077, -0.0038896822, -0.0053383820, 0.0206934940, 0.0156868491, -0.0016184506, -0.0077397525, -0.0012780081, 0.0075706318, -0.0000000038, -0.0134544456, 0.0107462676, -0.0117872674, 0.0069521829, 0.0157602355, 0.0011054215, -0.0072801025, 0.0000000002, -0.0023848042, 0.0115664834, -0.0005677063, -0.0008866877, 0.0013222569, -0.0040439209, 0.0079115219, -0.0021498369, -0.0064203097, -0.0142673487, -0.0022473431, 0.0065114130, -0.0084833913, 0.0014477631, -0.0166801307, 0.0110245524, -0.0133944685, -0.0216827746, 0.0006578587, -0.0333676301, -0.0077767516, -0.0000034590, -0.0075445198, 0.0212846547, 0.0024204669, -0.0166596267, -0.0010775939, 0.0187271871, 0.0121707097, -0.0145479180, 0.0032636733, 0.0023293551, -0.0021997408, -0.0016873324, -0.0021830120, -0.0211884286, 0.0029022982, 0.0052575604, 0.0129402364, -0.0001136569, 0.0006729354, -0.0030619847, 0.0073023797, 0.0076131187, 0.0103276186, 0.0005118013, -0.0000023751, 0.0048199655, -0.0014741766, 0.0121177249, -0.0227551833, -0.0051068841, -0.0011332097, 0.0215532500, -0.0190960690, -0.0000009206, -0.0044842167, -0.0361069851, -0.0076604597, 0.0085501662, 0.0151712941, -0.0014857922, 0.0136937089, -0.0000000105, 0.0116165113, 0.0022827045, -0.0053823171, -0.0023243658, -0.0111520980, 0.0315772779, -0.0122478260, 0.0120502012, 0.0107533224, 0.0432597920, 0.0238815509, -0.0158820767, 0.0061303675, 0.0192102119, 0.0127242683, -0.0039309491, -0.0033547676, -0.0068902038, -0.0143302716, 0.0103271678, -0.0260602422, -0.0000001171, -0.0017421721, 0.0100971013, -0.0180831738, -0.0091766752, 0.0002876833, -0.0008105148, -0.0024831423, 0.0136421416, 0.0045159291, -0.0069286563, -0.0036856022, 0.0028598907, -0.0267315134, -0.0044621043, 0.0120394044, 0.0024962418, 0.0076755867, -0.0049132705, 0.0042781122, -0.0181633271, -0.0185461640, -0.0270208158, -0.0166334454, 0.0344361477, -0.0000007243, -0.0075536133, 0.0337798484, -0.0160708576, -0.0248774420, -0.0102135632, 0.0052267741, -0.0253769215, -0.0011966979, -0.0000573058, -0.0216164123, 0.0302352197, -0.0307678822, -0.0076600108, 0.0021305836, -0.0080807619, -0.0262991041, 0.0000004125, -0.0178120546, -0.0189519003, 0.0081089763, 0.0004260761, 0.0010312040, 0.0108741708, -0.0232473463, -0.0365875252, 0.0046669091, -0.0093248123, -0.0046679275, 0.0018810794, -0.0274302047, 0.0000281054, 0.0116407489, 0.0443648621, 0.0313426368, 0.0212927088, 0.0338184312, 0.0247225855, -0.0138669135, 0.0000018972, 0.0605663508, 0.0377035327, 0.0386637412, -0.0088747200, 0.0024316255, -0.0137225026, -0.0310293138, 0.0005040161, -0.0219288934, 0.0196949635, 0.0000661358, 0.0004173031, -0.0203540865, 0.0039926791, 0.0214729514, 0.0173261501, -0.0338980779, 0.0005097130, -0.0155419121, -0.0098634949, -0.0088025853, -0.0126219755, 0.0168382451, -0.0001546854, 0.0000000292, -0.0181357767, 0.0278664734, 0.0097975209, 0.0028407297, 0.0025770550, -0.0048832595, 0.0023946227, -0.0125181358, -0.0000002419, -0.0333209261, -0.0041118651, -0.0027187865, 0.0005372907, -0.0150365811, -0.0004912069, 0.0107819783, 0.0000000392, 0.0018624763, -0.0268982872, 0.0193676688, 0.0001067172, -0.0084421281, 0.0180148520, 0.0056536831, -0.0370787457, -0.0021071550, -0.0105387429, -0.0142937275, -0.0139937308, 0.0022262945, 0.0123624504, 0.0009183320, 0.0000444313, 0.0092680203, 0.0200916119, -0.0054230443, 0.0513579100, -0.0075077522, -0.0000000074, 0.0096672121, -0.0110499021, -0.0039191721, 0.0172405578, 0.0004177000, -0.0019572664, -0.0213381276, 0.0258365162, -0.0206513833, -0.0153945843, 0.0003408744, -0.0239697881, -0.0153058702, 0.0251831170, -0.0008833881, 0.0005807251, -0.0052975207, 0.0187451541, -0.0013762927, 0.0000345008, 0.0069940584, 0.0304255690, -0.0226616357, 0.0237456262, -0.0000342196, -0.0036920118, 0.0186595805, -0.0187717490, -0.0083772289, 0.0020483562, 0.0081536304, -0.0206741020, -0.0066843578, 0.0000027092, -0.0141343493, 0.0387480371, 0.0149425315, -0.0021248793, 0.0095853005, -0.0044287611, -0.0169069376, 0.0000001246, -0.0053521898, 0.0155275026, 0.0132518914, 0.0011663154, 0.0086889379, -0.0067159263, -0.0045117624, -0.0267332587, -0.0170080699, -0.0340567008, -0.0036609825, 0.0222783498, 0.0010086063, 0.0204648171, -0.0122725517, 0.0108705321, 0.0004220069, 0.0002901606, -0.0049279602, -0.0407182723, 0.0287165828, -0.0000027489, -0.0189857408, -0.0133449268, 0.0092105549, -0.0046642260, -0.0006331201, -0.0012662341, -0.0080572637, -0.0075184568, 0.0052861809, 0.0138954986, -0.0048858393, -0.0187148917, 0.0591496117, -0.0190688446, 0.0059912191, 0.0200768579, -0.0075434297, -0.0027727825, -0.0265397243, 0.0162246451, -0.0117288465, -0.0220288020, 0.0101942504, -0.0008509613, 0.0000000120, -0.0059768758, -0.0094342716, 0.0376161933, -0.0161551517, -0.0066243792, -0.0075523444, 0.0274368525, 0.0004430476, -0.0000022950, -0.0167691018, -0.0390301049, -0.0168647245, 0.0016797787, -0.0057128798, -0.0004242708, 0.0134383012, -0.0000000031, 0.0171523690, -0.0047038142, 0.0140510602, -0.0000261818, -0.0001313854, 0.0025241238, 0.0030436297, 0.0004872682, 0.0190183837, 0.0030430807, 0.0104977991, -0.0105992379, -0.0027350306, 0.0092263762, 0.0242257174, 0.0077536791, 0.0144399954, -0.0079628183, -0.0017650337, -0.0042134663, -0.0367790833, 0.0000000279, 0.0048724958, 0.0151263010, 0.0034502223, 0.0033007667, -0.0002452779, 0.0005580985, -0.0110488720, 0.0050309086, 0.0109448917, -0.0096457601, 0.0000624397, -0.0072902781, -0.0065198499, 0.0016015704, -0.0058918186, -0.0056170388, -0.0106179100, 0.0001050676, 0.0084852846, -0.0127488412, 0.0069257459, 0.0016975870, 0.0071216067, -0.0022506481, -0.0000079741, 0.0060540661, -0.0248824563, -0.0067105102, -0.0076071750, 0.0076519521, -0.0091758743, 0.0248861015, 0.0171501916, -0.0000016532, -0.0038973617, -0.0117222304, 0.0005455705, -0.0032329869, -0.0042254096, -0.0059178327, -0.0230138060, -0.0000000011, -0.0068611498, 0.0154113919, -0.0093547897, -0.0004940312, 0.0027149157, -0.0061793025, 0.0082292724, 0.0185860246, -0.0140950466, -0.0033712916, 0.0165370461, 0.0116491560, 0.0003617207, -0.0364574976, -0.0209648702, -0.0082544740, 0.0148207191, -0.0113125248, -0.0174322426, -0.0231858362, -0.0058360784, -0.0000000737, 0.0020976046, -0.0224823430, 0.0013009079, -0.0211863406, -0.0001727663, 0.0128215123, 0.0008849453, -0.0011356563, 0.0056906682, 0.0320412405, -0.0047706030, 0.0234498903, 0.0007520726, 0.0039364886, 0.0033175081, -0.0164981447, -0.0312056802, 0.0046403836, -0.0071950806, -0.0019927674, 0.0134725375, -0.0137079060, 0.0081720781, 0.0202775951, -0.0000473163, 0.0011298542, -0.0043348875, -0.0171356164, -0.0211697556, 0.0094367657, 0.0131144440, -0.0424162447, 0.0046331873, 0.0000001985, 0.0020522275, 0.0086992430, -0.0068114582, -0.0125785088, -0.0013632620, -0.0035598674, -0.0036185719, -0.0000001067, -0.0033937390, 0.0043586576, -0.0304355789, -0.0018248536, 0.0043798289, -0.0057108151, -0.0054226471, -0.0039448282, -0.0187148377, -0.0062066121, -0.0050238753, 0.0095198341, -0.0224206280, -0.0261743944, 0.0001688939, 0.0022033257, 0.0306468196, 0.0112692015, 0.0109007461, 0.0042948006, -0.0200034529, 0.0000009396, 0.0342040956, 0.0133878728, 0.0093214996, 0.0007849393, -0.0011342987, -0.0057788054, -0.0097849043, 0.0034440479, -0.0243897457, 0.0193978008, 0.0025327774, -0.0137711735, -0.0149050867, -0.0043237475, -0.0005972253, 0.0099473000, -0.0209572166, 0.0054738969, 0.0118097067, 0.0085937036, 0.0149596138, -0.0291017294, -0.0150828222, -0.0101466691, -0.0000002604, -0.0010704970, 0.0010310840, 0.0438945964, -0.0120693725, 0.0018406990, -0.0082585299, 0.0162192006, 0.0005856917, -0.0000000380, 0.0032656479, -0.0429319665, -0.0099867834, 0.0026683358, -0.0130582089, -0.0044500553, 0.0075066751, 0.0000000013, 0.0129144257, 0.0001138468, -0.0017089960, 0.0005210602, -0.0049122549, -0.0055439938, 0.0046809600, 0.0098681320, 0.0098431353, 0.0015307828, 0.0221879706, -0.0157984234, 0.0040068566, 0.0012538949, 0.0031506815, 0.0099941166, -0.0193655379, -0.0110048661, -0.0122619197, 0.0215567984, -0.0310585890, 0.0000012328, 0.0118422443, 0.0237411000, 0.0048669279, -0.0036701520, -0.0018844008, -0.0032696195, -0.0136088310, 0.0032614649, 0.0108064646, -0.0138326120, -0.0088613462, -0.0261955597, -0.0106373057, 0.0006513567, -0.0156397745, -0.0169317089, 0.0221109949, -0.0082073240, 0.0099039441, -0.0049165357, 0.0140104797, 0.0033391088, 0.0122060003, 0.0024286644, -0.0000703457, -0.0078757703, -0.0107363630, -0.0033152157, 0.0224262066, -0.0038616247, 0.0012228994, -0.0042793117, 0.0079598958, -0.0000014084, 0.0107098706, 0.0106011285, 0.0023455473, 0.0026662888, 0.0109394109, 0.0006158129, 0.0057670032, 0.0000000000, 0.0001182117, -0.0050872318, -0.0295770522, 0.0000692996, 0.0004730023, 0.0009371730, -0.0079098688, 0.0029977199, -0.0036392300, 0.0196680091, 0.0060277400, -0.0244164281, -0.0064388355, -0.0043068030, 0.0000765279, 0.0007921780, 0.0073333811, 0.0059545622, 0.0057358085, 0.0146108549, 0.0027802989, 0.0000000599, -0.0052927276, -0.0195009746, 0.0058345930, 0.0092987325, 0.0000684663, -0.0012555271, -0.0025920812, -0.0098606488, 0.0019479109, -0.0064295675, 0.0003329758, 0.0050023035, -0.0027554811, 0.0009231513, -0.0256722551, 0.0023535786, -0.0041155037, -0.0020070579, 0.0271401890, -0.0002041759, -0.0193445198, 0.0113254702, 0.0195846707, 0.0013033955, 0.0000002766, 0.0148212109, -0.0012782307, -0.0185444467, -0.0252137873, -0.0073950500, -0.0102534024, -0.0143202087, -0.0188713130, -0.0000434305, -0.0224486496, -0.0013726508, -0.0301312413, 0.0063934880, -0.0011853169, -0.0003269118, -0.0161937326, -0.0000000391, 0.0018548457, -0.0099847820, 0.0084599871, 0.0002448467, 0.0005749427, -0.0092150532, 0.0167018678, 0.0065083196, -0.0042451588, 0.0035247256, 0.0043522194, 0.0126477377, 0.0114260791, -0.0173799396, -0.0166932121, 0.0056430916, 0.0196224041, -0.0059769615, -0.0037723887, 0.0111475652, 0.0100534111, -0.0000012729, 0.0157244932, -0.0024008146, -0.0011587732, -0.0127971303, -0.0013083019, 0.0035719108, -0.0116949864, 0.0053968732, -0.0075701918, -0.0040362556, -0.0009996105, 0.0080754329, 0.0170165524, 0.0175325219, 0.0133587923, -0.0058426303, -0.0320029296, 0.0222168285, 0.0078050629, -0.0099381823, 0.0136997234, -0.0084210970, 0.0002299003, -0.0086514987, -0.0000000595, -0.0335266665, -0.0076251840, 0.0235558972, 0.0014143483, -0.0162645653, -0.0068522696, 0.0151041457, 0.0355243087, -0.0000540851, -0.0147591336, -0.0247300360, -0.0084003014, -0.0003265672, 0.0019372088, 0.0030271816, 0.0332263336, 0.0000000004, 0.0033998319, 0.0101968627, -0.0028804580, 0.0002984074, 0.0034975989, -0.0138134910, 0.0000593007, -0.0277751815, 0.0195120703, -0.0233398676, 0.0186496824, 0.0032180571, 0.0026338380, 0.0260123257, -0.0154948523, -0.0097199567, 0.0041546542, -0.0217686165, -0.0103472183, 0.0190334003, -0.0076086000, -0.0000027583, 0.0073488457, 0.0235032700, -0.0048654126, 0.0101975184, -0.0000492276, -0.0022294787, -0.0033602510, -0.0286144577, 0.0312642120, -0.0176538415, 0.0001982020, 0.0000126408, -0.0255567282, -0.0188644789, 0.0117184268, 0.0009618419, 0.0146132363, 0.0197509620, 0.0076612718, 0.0094244629, -0.0109881368, 0.0444091894, 0.0198207926, -0.0017922865, -0.0000017825, 0.0057572136, -0.0102504119, 0.0122186290, -0.0173571091, 0.0024250883, 0.0046184356, -0.0022093267, -0.0075424463, -0.0000612974, -0.0205500256, -0.0265385080, -0.0225456432, 0.0032135509, 0.0080565810, 0.0002452031, -0.0303825960, 0.0000001766, -0.0052048424, -0.0055263536, 0.0392031595, -0.0000009477, 0.0048249597, 0.0233432669, 0.0118038729, -0.0254503954, -0.0111509794, -0.0051434301, -0.0053815045, 0.0079523446, 0.0217848197, -0.0236713793, -0.0190006662, 0.0109824790, 0.0848466530, -0.0069754389, -0.0050807912, -0.0159664154, 0.0269518346, 0.0000001223, -0.0081786886, -0.0497263446, 0.0171843749, -0.0095710419, -0.0014504747, 0.0019025489, 0.0003715966, -0.0129120434, -0.0056936587, -0.0199531782, 0.0000147457, -0.0094627040, 0.0477856398, 0.0174671002, 0.0199303627, -0.0130581101, -0.0027584182, 0.0560804047, 0.0068850168, 0.0058145542, -0.0169001594, -0.0156682562, -0.0107252412, 0.0044883033, -0.0000865152, -0.0127618005, -0.0043863188, 0.0090068439, 0.0058422987, 0.0107815731, -0.0029772627, -0.0069651445, 0.0017857542, 0.0000000362, 0.0086615002, 0.0102751013, 0.0094495341, -0.0011848287, -0.0061529768, -0.0006645728, -0.0041067540, 0.0000000007, -0.0034054208, 0.0186565351, -0.0163743272, 0.0001504749, 0.0015857841, -0.0059322543, 0.0138450284, 0.0021412312, -0.0025575198, -0.0098178033, -0.0043329061, 0.0217493996, -0.0043833912, -0.0087296003, -0.0190670956, -0.0107172979, -0.0445092842, -0.0030252789, -0.0084131304, -0.0083097788, -0.0196032543, -0.0000036013, -0.0026403549, 0.0216353629, 0.0208325069, -0.0092567662, -0.0015678231, 0.0037223154, -0.0049527106, 0.0098041166, 0.0001443775, 0.0250967406, -0.0050198585, 0.0012458510, 0.0004129825, -0.0033661653, 0.0134378420, -0.0127377827, 0.0129679283, -0.0146103660, -0.0074178181, -0.0092547666, 0.0138536831, 0.0060894359, -0.0116977813, -0.0156513117, 0.0000003395, -0.0194242392, 0.0139786610, 0.0127163380, -0.0045596040, 0.0026781685, -0.0161523763, 0.0117465677, -0.0265667122, -0.0000292049, -0.0266090892, 0.0060054860, -0.0159397274, 0.0018917389, -0.0032054351, -0.0038444179, 0.0046263370, -0.0000000015, -0.0075931898, -0.0149490796, 0.0254496802, -0.0023731221, -0.0157287326, 0.0044434974, 0.0056893672, -0.0213165656, 0.0050236601, 0.0010968408, 0.0082146907, -0.0180966593, 0.0106852669, -0.0015923704, -0.0095635802, -0.0023132593, -0.0119531322, 0.0188791994, -0.0190763660, 0.0315759182, -0.0160744414, -0.0000029526, -0.0010068121, 0.0135356551, 0.0068842196, -0.0135289766, -0.0000476885, 0.0025876516, -0.0097499015, 0.0280379578, -0.0257541854, -0.0126177240, -0.0039465451, -0.0184009410, -0.0215607639, 0.0150822792, -0.0143838562, -0.0198124368, 0.0264975931, -0.0126264822, -0.0048528654, -0.0082906717, 0.0027766591, -0.0032876211, -0.0019224279, 0.0032013264, 0.0000001890, -0.0079232566, 0.0070713856, 0.0014526203, 0.0005369884, 0.0063256691, 0.0028825558, -0.0122452714, 0.0071652280, -0.0000003569, -0.0138418209, -0.0083331522, -0.0188385304, 0.0148462737, -0.0011711977, -0.0008988591, 0.0013467339, -0.0000000003, -0.0155414399, 0.0104395775, -0.0007669071, 0.0001297113, 0.0023555201, -0.0166427325, 0.0368994735, -0.0080678035, -0.0120869698, -0.0157118607, -0.0067357523, 0.0285229404, -0.0062948614, -0.0167605001, -0.0142190531, 0.0037969204, -0.0163903367, -0.0060588196, 0.0054988172, 0.0145480419, 0.0002364600, -0.0000015442, 0.0081139430, 0.0190031193, 0.0161086302, -0.0076544280, -0.0002823512, 0.0014381822, -0.0135308066, 0.0326940790, 0.0020203423, 0.0130371917, -0.0028924772, 0.0131065156, -0.0091628786, 0.0168513916, -0.0051696585, -0.0090256613, -0.0093953591, -0.0174309351, 0.0007750715, 0.0056359312, -0.0001324374, -0.0082081826, -0.0052812453, -0.0197511502, 0.0000061769, -0.0087476810, -0.0041983156, 0.0059123980, -0.0046170838, 0.0031146349, -0.0077113733, -0.0086645326, -0.0261028558, -0.0000005892, 0.0049829511, 0.0140161375, -0.0016036551, 0.0056560491, 0.0124654947, -0.0019573900, 0.0015654976, -0.0000000029, 0.0105651757, -0.0022840474, -0.0189543460, -0.0004397182, -0.0026729559, -0.0070579732, 0.0186650213, 0.0208076350, -0.0044059046, 0.0167062860, 0.0088913823, 0.0081388550, 0.0083824592, -0.0092293788, -0.0243593454, -0.0038378446, 0.0013349579, -0.0020620583, -0.0224882253, 0.0003920442, -0.0179654788, -0.0000008684, 0.0079790233, 0.0107734613, 0.0035549079, -0.0191983711, -0.0023076951, -0.0018745115, -0.0101316730, 0.0192649830, 0.0008056022, 0.0151008237, -0.0238721501, -0.0032190317, -0.0029281548, 0.0034929214, 0.0165675599, -0.0217389427, 0.0182519518, 0.0006656747, -0.0056370250, -0.0086134681, 0.0096440380, -0.0191293415, 0.0206938852, 0.0152542964, -0.0000030936, 0.0011705918, 0.0051164576, -0.0179023147, -0.0192362759, -0.0078726169, 0.0076561254, -0.0239667073, -0.0130378744, -0.0000067968, -0.0126463827, -0.0047478788, -0.0062716049, 0.0217666496, 0.0164058805, -0.0039082477, 0.0165252984, 0.0000000054, -0.0186149757, 0.0123665994, -0.0107995886, 0.0012759387, -0.0159557052, -0.0155791454, 0.0290833469, 0.0025013329, -0.0081764208, -0.0148659907, -0.0153855300, 0.0309293233, -0.0122358948, 0.0100910608, 0.0204465427, 0.0172158405, 0.0111559462, -0.0060496563, 0.0147541594, -0.0117629971, -0.0414239913, -0.0000048969, 0.0269427765, 0.0483243875, 0.0145851998, 0.0081708794, 0.0007623463, -0.0152008003, -0.0020402109, 0.0208308138, 0.0098169129, 0.0136694750, 0.0013797148, 0.0260466132, -0.0295049641, -0.0040983260, -0.0009124713, 0.0142486244, -0.0261193234, -0.0068088463, -0.0128212459, 0.0046006381, 0.0107401684, 0.0253781062, 0.0045533008, -0.0075468039, -0.0000005509, -0.0364806056, -0.0106204720, -0.0139929568, -0.0014983236, -0.0021425665, -0.0006982256, 0.0136739276, 0.0049479194, -0.0000007371, -0.0267425533, -0.0149711929, 0.0131670581, -0.0091460925, 0.0143618258, -0.0039693867, -0.0060194456, 0.0000000001, 0.0042568902, 0.0350697115, 0.0042215879, -0.0079627298, -0.0100187147, 0.0211721901, -0.0263653733, 0.0006176349, 0.0117801614, 0.0227572285, 0.0175102670, -0.0225001387, 0.0064122146, -0.0016972627, -0.0182305109, 0.0120419962, 0.0263750106, -0.0119559402, 0.0090021379, 0.0160234943, -0.0070532472, 0.0000030424, -0.0152657861, -0.0166305695, 0.0016661549, -0.0110243363, 0.0015705281, -0.0109610856, -0.0001509276, -0.0098155122, 0.0166797545, 0.0297837630, 0.0019856521, 0.0050029014, 0.0067087105, -0.0039820820, -0.0195328388, 0.0015626225, -0.0015015668, 0.0036172478, -0.0236693881, 0.0327969678, -0.0353125073, -0.0136222849, 0.0003583443, 0.0034477324, -0.0000025060, 0.0077857426, 0.0289608110, 0.0184558537, 0.0051386519, -0.0000824946, -0.0100225629, 0.0287200641, 0.0322288051, 0.0000133174, -0.0073487568, -0.0048870640, 0.0194072518, 0.0037006193, -0.0450599790, -0.0029088508, 0.0158359520, 0.0000000367, -0.0001236977, -0.0253062267, 0.0284919031, 0.0009137040, 0.0013772971, 0.0032127032, -0.0252696611, -0.0317472406, -0.0150454883, -0.0088843256, -0.0038028264, -0.0034341021, 0.0065137479, 0.0239679832, -0.0040246453, 0.0053607812, -0.0307219196, 0.0217472110, -0.0002924406, 0.0241432507, 0.0300453436, 0.0000000398, -0.0207689498, -0.0245022587, -0.0145173511, 0.0022023993, -0.0014638592, -0.0059286542, 0.0167793352, 0.0025908398, 0.0118957572, -0.0233382080, 0.0028675864, -0.0212009493, -0.0126774535, -0.0051388578, 0.0047857398, 0.0180021897, -0.0156346541, 0.0039660460, 0.0309324954, -0.0206624717, -0.0023379941, 0.0218260102, 0.0195602700, -0.0136321159, -0.0000046355, -0.0012051947, -0.0196787249, -0.0211165715, -0.0225334354, 0.0098442873, -0.0163826197, 0.0084963730, -0.0237869937, -0.0000005075, 0.0021551829, -0.0213720426, -0.0072180643, -0.0179713704, 0.0086829774, 0.0001946320, -0.0172384717, -0.0000000015, -0.0084266271, 0.0172822475, -0.0081870491, -0.0031354828, -0.0034790947, 0.0180170890, 0.0122573208, 0.0070647034, -0.0096667502, 0.0373871773, 0.0100744041, 0.0035571526, 0.0190308392, -0.0091688242, 0.0052551706, -0.0173590481, 0.0202549305, 0.0064938259, -0.0260074269, -0.0094342288, -0.0457927249, -0.0000041231, -0.0046184505, -0.0131088877, 0.0017200696, -0.0240446553, -0.0005705070, -0.0015249416, -0.0098280953, 0.0201084707, -0.0066325949, 0.0388966873, -0.0186747778, 0.0065583256, 0.0352990888, 0.0159790926, 0.0069059045, -0.0077775377, 0.0050769523, -0.0280367602, -0.0085405391, 0.0006452278, -0.0174868684, 0.0105368979, -0.0096097635, -0.0090640942, -0.0000000539, 0.0032340880, -0.0043103751, 0.0434654318, 0.0035481083, -0.0066268253, 0.0066353837, -0.0121225799, 0.0100280391, 0.0000000908, -0.0164995044, -0.0118131721, -0.0249407627, -0.0022993265, -0.0162138157, -0.0014793501, -0.0046934010, 0.0000000120, 0.0123637412, -0.0054981229, -0.0196871236, -0.0002654304, 0.0011876231, -0.0271847360, 0.0188760087, 0.0099168587, 0.0111119030, -0.0181037057, 0.0078645954, 0.0142841842, 0.0067356382, -0.0292281341, -0.0221394226, 0.0022530318, 0.0239770245, -0.0232683588, -0.0096875187, -0.0006187211, 0.0175606273, 0.0000000196, 0.0092231799, -0.0013057539, -0.0062192590, 0.0019743112, 0.0003798350, 0.0048940503, -0.0090925889, -0.0010346705, -0.0107875010, -0.0161287542, -0.0001846049, -0.0234044343, 0.0038799120, -0.0004984663, -0.0134777613, -0.0234121867, -0.0295661893, -0.0185884982, 0.0302711911, 0.0066232006, -0.0005341702, 0.0158564113, 0.0017838082, -0.0089671509, -0.0000149147, 0.0165318754, 0.0129945995, 0.0064473031, -0.0273519717, 0.0063649658, 0.0002620404, 0.0132223396, -0.0075714332, 0.0000095216, -0.0100348387, -0.0041862577, 0.0162912440, -0.0181168392, -0.0313150883, -0.0034173019, -0.0060972995, 0.0000000055, -0.0080055827, -0.0182534829, 0.0165991280, 0.0011962620, 0.0066550123, 0.0112166312, -0.0174994655, -0.0097952019, -0.0062395879, 0.0047599850, 0.0195008293, 0.0236885808, 0.0385360941, 0.0112859393, 0.0104511967, 0.0359498449, 0.0407916494, 0.0219120234, 0.0038254487, 0.0367865115, 0.0171291009, 0.0000008445, 0.0038557628, -0.0136711719, 0.0316390172, 0.0004967558, 0.0004372618, -0.0184718668, -0.0183701552, 0.0117105385, -0.0012004848, -0.0070839464, -0.0013256239, -0.0389642566, 0.0138431992, -0.0163321886, 0.0345418230, 0.0051741144, 0.0076695611, 0.0032656714, 0.0182253011, -0.0099756774, -0.0248875711, -0.0120672360, -0.0047788336, -0.0097438777, -0.0000174407, 0.0177483838, 0.0273595713, 0.0314936265, 0.0117541905, 0.0138168484, 0.0062418487, 0.0152441729, -0.0081015071, 0.0000007684, -0.0079151634, 0.0152587015, 0.0215901490, 0.0341907330, -0.0021943364, -0.0044300109, -0.0043637799, -0.0000000146, 0.0013641173, -0.0195997674, -0.0216287207, -0.0003523358, -0.0031773965, -0.0230977889, 0.0084221195, -0.0106990933, -0.0025192588, -0.0061728326, -0.0346488357, 0.0160146095, 0.0059364173, -0.0295290537, -0.0326178484, -0.0131163597, -0.0309134685, 0.0157621354, -0.0146807740, 0.0078738658, -0.0268453229, 0.0000004798, -0.0022932021, -0.0121744461, 0.0102117825, 0.0012418630, -0.0106689800, -0.0057188803, -0.0200985260, 0.0273599792, -0.0107963057, 0.0173857305, -0.0068564191, 0.0023066148, 0.0175446551, 0.0172191467, 0.0016135296, -0.0184658282, -0.0098219123, -0.0139826443, 0.0134146512, -0.0003920570, -0.0026463508, -0.0098922690, -0.0029870044, 0.0255775303, 0.0000078510, -0.0116726952, 0.0299385432, -0.0006972969, 0.0126529830, 0.0285984091, 0.0126754651, -0.0129242372, 0.0229785051, 0.0000138203, -0.0082692504, -0.0003504331, 0.0176703855, 0.0299380161, -0.0080469586, 0.0034509094, 0.0162044019, 0.0000000280, -0.0064977896, 0.0159021579, -0.0275148358, 0.0009223956, 0.0044063223, -0.0044128248, -0.0111648636, -0.0429410562, -0.0168241374, -0.0133210849, -0.0250248238, -0.0027236268, 0.0208281763, -0.0145379407, -0.0022984305, 0.0094376430, -0.0286438446, 0.0238761045, 0.0185335502, 0.0035441485, 0.0014693093, -0.0000018048, -0.0265043676, -0.0075335940, 0.0270007867, 0.0218581408, -0.0022005816, -0.0005984496, 0.0017469365, -0.0047751674, -0.0051326873, 0.0251347329, 0.0001174246, 0.0222420525, -0.0119047686, 0.0088284248, 0.0040617916, 0.0078790747, -0.0079391645, 0.0122014051, 0.0014015550, 0.0099032233, -0.0051026423, 0.0074527608, -0.0018118819, -0.0001097519, 0.0000000035, -0.0187110119, -0.0075128246, 0.0050659860, 0.0243864283, 0.0013067775, -0.0012031225, 0.0050686556, 0.0006632557, -0.0000000592, -0.0037213233, -0.0134470072, -0.0011824169, 0.0059457785, 0.0101128155, -0.0006431624, 0.0018822494, -0.0000000808, 0.0001164612, -0.0068977592, -0.0051472280, 0.0001412720, -0.0009322231, 0.0107994229, 0.0035426228, -0.0041901604, 0.0086446833, 0.0084098289, 0.0055600288, -0.0099183824, -0.0115310112, 0.0106750531, -0.0021695797, -0.0076381364, -0.0009635711, -0.0028872853, 0.0019346860, 0.0062947120, 0.0005075115, 0.0000000103, -0.0097487886, -0.0105048949, -0.0160910301, -0.0002003999, 0.0000704006, -0.0005734891, -0.0017284763, 0.0077500949, 0.0020264443, -0.0077650142, -0.0000113332, -0.0073922048, -0.0009081434, 0.0000736800, -0.0122852800, -0.0023144877, 0.0114441756, -0.0044932389, 0.0021777856, 0.0097290752, -0.0263159145, 0.0030344832, 0.0206582509, -0.0033463540, 0.0000000003, -0.0028116782, -0.0018782914, 0.0227241702, 0.0179339871, -0.0050037056, -0.0043317201, -0.0171952974, -0.0029051139, 0.0000065469, -0.0103384089, 0.0270945895, -0.0082786661, 0.0017508999, 0.0144175449, 0.0000882400, 0.0065756813, 0.0000000479, 0.0078039430, -0.0169651043, -0.0178786293, 0.0000220242, 0.0066406019, -0.0015819812, 0.0445644446, -0.0091909347, -0.0143762613, -0.0165294744, -0.0082016550, 0.0084164040, 0.0000213416, -0.0167715829, -0.0122665940, -0.0068944725, 0.0193338096, 0.0058638882, 0.0022433442, -0.0046537672, -0.0180961210, 0.0000000000, 0.0013202840, 0.0002834797, -0.0107682962, -0.0044016945, 0.0007809578, 0.0147876292, -0.0027097089, 0.0054110857, 0.0053291805, -0.0133826034, 0.0001679775, 0.0052883853, 0.0029251005, -0.0095347678, -0.0094210003, -0.0136091718, -0.0169456191, 0.0150417751, 0.0087586343, 0.0057518347, 0.0129602617, -0.0051728874, -0.0068018287, -0.0189011805, -0.0000089006, -0.0083070258, 0.0116930595, -0.0107008694, -0.0037229497, 0.0013735885, -0.0007034101, 0.0039744200, -0.0035417276, 0.0000013379, 0.0120979417, 0.0040996005, 0.0028143832, 0.0294118635, -0.0106466115, -0.0000887294, -0.0224125683, 0.0000310759, -0.0138094658, 0.0043375310, -0.0033888542, -0.0059174146, -0.0079364022, -0.0363665931, 0.0119236484, 0.0175293274, 0.0129309315, -0.0006942092, 0.0005463446, 0.0106002148, -0.0041195648, -0.0357981324, -0.0125477873, -0.0275759399, -0.0046146107, 0.0203959867, -0.0134386336, -0.0058921906, -0.0175793152, -0.0000000255, 0.0047453791, -0.0059600812, 0.0306461994, 0.0003161763, 0.0009140986, 0.0103890290, -0.0047343727, 0.0198605433, 0.0019020113, 0.0292807873, -0.0000843409, -0.0052251844, 0.0127684576, 0.0267630275, -0.0022130872, -0.0293450262, 0.0074120490, -0.0091799097, -0.0000917082, -0.0092082415, -0.0046432228, 0.0268275440, -0.0024083785, -0.0036763705, -0.0000000015, -0.0014324033, -0.0008333218, -0.0104102269, 0.0085763708, -0.0025757363, -0.0027023945, -0.0214579906, 0.0066637001, -0.0000001941, -0.0016229778, -0.0012950958, -0.0124883624, 0.0122719333, 0.0071904240, 0.0010818362, -0.0241854992, -0.0000133452, -0.0026646110, 0.0147242574, 0.0097637959, -0.0005422412, -0.0000067184, -0.0137198400, 0.0171548966, 0.0026468085, 0.0014502696, 0.0022670014, 0.0196536053, 0.0105901696, -0.0015662157, -0.0216453895, -0.0036912540, -0.0035016045, 0.0130310412, -0.0051284796, -0.0011532204, -0.0159568824, -0.0012433610, 0.0000000003, 0.0015087049, -0.0141952224, 0.0160366185, -0.0063607837, -0.0008784813, 0.0262845196, 0.0165901370, 0.0102094291, -0.0016343192, 0.0163231585, -0.0000623170, 0.0102324830, 0.0120060183, 0.0020656683, 0.0104124118, -0.0100196134, -0.0083566252, 0.0008037388, -0.0034902841, 0.0071210894, -0.0196557231, -0.0137137016, -0.0166204702, -0.0058980267, -0.0000005262, 0.0079714498, 0.0061950446, -0.0026216884, 0.0237579383, 0.0018714425, -0.0059440881, -0.0128376633, 0.0072627454, 0.0000000424, 0.0036818765, 0.0130817238, -0.0052432474, 0.0072742724, 0.0075274091, 0.0021076910, -0.0026374143, -0.0000035275, -0.0060381610, -0.0040894775, -0.0457090214, -0.0036824541, 0.0004993555, -0.0079936814, 0.0236700941, 0.0134268748, -0.0039655836, 0.0196090732, -0.0046183406, -0.0024050204, -0.0052633509, -0.0074761389, -0.0104872733, -0.0114101795, -0.0185945071, 0.0194323603, 0.0023010802, 0.0128672617, -0.0156069007, 0.0000000366, -0.0000937077, 0.0017003698, 0.0147264795, -0.0054422673, -0.0000822767, 0.0127852950, 0.0033239350, 0.0164828114, -0.0085477550, 0.0099879643, -0.0001486028, 0.0096273189, -0.0048126653, -0.0080629420, -0.0082314732, -0.0123567414, 0.0037369095, -0.0165802408, 0.0095875207, 0.0092553347, 0.0090532154, 0.0010803359, -0.0273287613, -0.0042268154, 0.0000000021, 0.0007343941, -0.0055375574, 0.0208753403, 0.0126015004, 0.0038000371, -0.0037767780, 0.0027612671, 0.0034081889, 0.0000001130, -0.0157141741, 0.0003811467, 0.0200986844, 0.0184907783, -0.0043492918, 0.0015813339, 0.0095870104, -0.0001889747, -0.0002423706, -0.0015073190, 0.0159082804, 0.0000153358, 0.0045138253, 0.0085141035, -0.0261659548, -0.0194543246, -0.0055677365, 0.0006210626, 0.0123756221, -0.0063369675, -0.0055570952, 0.0044451305, -0.0169449598, -0.0109971585, -0.0220921803, -0.0085812993, -0.0092863403, 0.0067197969, 0.0074992958, 0.0000000031, -0.0085270600, 0.0049107610, -0.0300086625, -0.0159144104, 0.0002681693, -0.0020530673, 0.0062104724, 0.0150820259, -0.0107487608, -0.0126527641, 0.0009284030, -0.0017485181, -0.0213197414, -0.0035232680, 0.0286187511, 0.0062513705, 0.0129683223, 0.0104525629, -0.0072352574, -0.0018492088, -0.0090215756, -0.0005629749, -0.0063615898, -0.0086699873, 0.0000001777, -0.0007114809, -0.0071495469, 0.0111992927, 0.0064098965, -0.0015697489, -0.0047893459, -0.0009825792, 0.0000669045, -0.0000001663, 0.0080932491, -0.0297802538, -0.0021921587, 0.0058233449, 0.0104488228, -0.0005763565, 0.0043419246, -0.0000025785, 0.0037145785, 0.0077795903, 0.0138629973, 0.0000687134, -0.0005190257, -0.0012427403, -0.0019931104, 0.0038391380, 0.0140738096, 0.0111749936, 0.0146781430, -0.0087517062, -0.0005139860, 0.0019371184, -0.0034453357, -0.0119188474, -0.0169598758, -0.0081104739, -0.0035387082, 0.0020570243, -0.0180273727, 0.0000000300, 0.0003151871, 0.0056850906, -0.0057866992, -0.0058338926, -0.0002600681, -0.0019399317, -0.0003066488, -0.0018990227, -0.0026640072, -0.0015969602, -0.0018960348, 0.0074891024, -0.0124771390, 0.0000404753, -0.0071656602, -0.0071716947, 0.0173844881, -0.0011477598, 0.0007226521, 0.0012546828, -0.0081303790, -0.0040055793, -0.0063561262, -0.0008393030, -0.0000091291, 0.0130158253, -0.0061838818, -0.0089116730, 0.0283467378, -0.0002945596, -0.0073073283, 0.0023207010, 0.0078874687, 0.0000000050, 0.0086511597, -0.0028172070, -0.0098732244, 0.0035543297, 0.0211985502, -0.0000671360, 0.0013933989, -0.0000003594, 0.0023975132, 0.0018696086, -0.0358243026, -0.0003327390, -0.0001652304, 0.0132331708, -0.0046806796, 0.0058253612, -0.0056644822, 0.0244009830, 0.0051297252, -0.0063285315, -0.0019177459, 0.0029412759, -0.0069163349, -0.0045810416, -0.0066700182, 0.0068828287, 0.0052573751, -0.0009796401, 0.0080969203, 0.0000000378, -0.0106004821, -0.0182181541, -0.0053755906, -0.0175197478, 0.0002928185, 0.0081494134, 0.0196688920, 0.0034117152, 0.0045739310, 0.0069654728, -0.0008649086, 0.0181498770, -0.0108729005, -0.0191963147, 0.0054741162, 0.0114398273, 0.0006504979, -0.0102786403, -0.0042938157, 0.0028039648, -0.0085133389, -0.0258396082, -0.0019658857, -0.0055165403, 0.0000000021, -0.0099294754, 0.0113626588, 0.0348421596, -0.0042925295, 0.0019713792, -0.0037360939, -0.0009476762, -0.0004433412, 0.0000000764, 0.0010976741, -0.0093025155, -0.0051672477, -0.0024522380, 0.0137110194, -0.0015163328, 0.0212001689, -0.0000000098, 0.0026862968, -0.0004406584, 0.0268089529, -0.0131769897, -0.0002581236, -0.0269010216, 0.0212064590, -0.0042000180, 0.0293010920, -0.0143194282, 0.0019457705, -0.0115959588, -0.0020099366, -0.0005931711, 0.0122349262, -0.0044984096, 0.0071384138, 0.0010593656, -0.0026634245, -0.0081760846, -0.0397292525, 0.0000000274, 0.0168711450, 0.0342284329, 0.0022209263, 0.0062962649, 0.0000747214, -0.0073620817, -0.0160891339, -0.0109071601, -0.0124116801, -0.0054421597, -0.0008771949, -0.0094404928, -0.0063366736, 0.0221398678, -0.0384652503, -0.0358466990, 0.0225794893, -0.0106081972, 0.0175280850, 0.0059340522, 0.0036291599, 0.0055083386, 0.0044159833, 0.0343725458, -0.0000001798, -0.0039235651, 0.0042928606, -0.0014014074, -0.0304044001, -0.0022400382, 0.0087757623, 0.0191219468, 0.0168761946, -0.0000097474, -0.0049418984, 0.0017368717, -0.0179885123, -0.0014722449, 0.0253191069, -0.0035097911, 0.0027122705, 0.0000000607, -0.0053018695, -0.0117049916, -0.0135072498, 0.0004724737, 0.0028940416, 0.0154344961, -0.0081410408, -0.0160090122, -0.0001286022, 0.0131590553, -0.0011097982, 0.0191672072, -0.0023688076, 0.0285148416, 0.0167960264, 0.0240554623, 0.0108263055, 0.0277588814, 0.0178593658, -0.0216781665, -0.0025118140, -0.0000001017, 0.0056256889, 0.0115936268, 0.0429507494, 0.0200283919, 0.0006891527, -0.0043273377, -0.0148765938, -0.0123065226, 0.0029601250, 0.0172148962, 0.0008125094, -0.0014838751, -0.0072670593, -0.0219448116, 0.0131625477, -0.0033317606, -0.0006329115, 0.0105672637, -0.0049097259, 0.0027505702, -0.0145900641, -0.0163374878, -0.0025060610, 0.0104181375, -0.0000000029, -0.0019422243, -0.0053562303, 0.0123429326, 0.0103475880, -0.0008848805, 0.0020137802, -0.0069017117, 0.0062950687, -0.0000072392, -0.0020225991, 0.0182441715, 0.0046680425, -0.0031678670, 0.0024945121, -0.0007025811, 0.0053396542, 0.0000000004, -0.0072251945, -0.0050866832, -0.0005326637, 0.0001110518, 0.0052888533, -0.0002194827, 0.0233850554, -0.0048264237, -0.0028776510, -0.0007987611, -0.0097858021, 0.0037503331, 0.0073936400, 0.0013171264, -0.0048737600, -0.0014933931, 0.0119269984, 0.0122852689, 0.0045940396, 0.0066724699, -0.0172786303, 0.0000000000, 0.0107023641, 0.0151235601, 0.0178649630, 0.0030446455, -0.0000803499, -0.0018853198, -0.0128879556, -0.0133044142, 0.0068266201, -0.0049423655, 0.0001977632, -0.0080408715, 0.0048383838, -0.0160919130, -0.0116838561, -0.0080448166, -0.0101854559, 0.0209129173, 0.0013733596, 0.0104879206, 0.0175849665, 0.0075046048, 0.0008191471, 0.0223348085, -0.0004633491, 0.0111978762, 0.0089623490, -0.0011765696, -0.0083570872, 0.0048715300, -0.0029998468, 0.0421945378, 0.0295380838, -0.0000045731, -0.0102277128, -0.0210933108, 0.0229554381, -0.0210401788, -0.0105951130, -0.0063850502, -0.0114147393, -0.0012698658, -0.0041675894, 0.0409511253, 0.0577962101, 0.0007955206, -0.0019881416, 0.0157635789, -0.0477179289, 0.0068156626, -0.0013187754, -0.0117532592, 0.0033077230, 0.0058635813, 0.0121758841, 0.0049538100, -0.0094600022, -0.0081751049, -0.0295381173, -0.0128353452, 0.0072573493, -0.0150706451, 0.0476151705, -0.0000031166, -0.0191735402, -0.0180385411, -0.0161425341, 0.0131076975, -0.0135421744, -0.0051091276, 0.0022393912, -0.0233440008, 0.0134062031, 0.0056398935, 0.0004862436, 0.0152370967, 0.0106087765, 0.0333923176, 0.0250337459, 0.0165191796, -0.0006866431, -0.0031158875, -0.0242455974, -0.0062532006, 0.0190196596, -0.0064526969, -0.0081182849, -0.0043303580, 0.0000000003, -0.0119255474, 0.0044466779, 0.0106052328, 0.0182746705, 0.0006168308, -0.0029437167, -0.0049632527, -0.0047891322, 0.0000005636, -0.0072948942, 0.0274307784, -0.0014418325, 0.0118660349, 0.0070617255, 0.0012393274, -0.0011169570, -0.0000007442, 0.0030320298, -0.0073075634, -0.0091210864, -0.0026581490, 0.0013777355, -0.0108542023, 0.0299705341, -0.0018990429, 0.0040533082, -0.0180086624, -0.0100726904, -0.0044595357, 0.0009909166, -0.0198738985, -0.0021051783, -0.0067257797, -0.0103060771, 0.0153104868, -0.0026927153, 0.0079570394, -0.0249152258, 0.0000000004, -0.0034360630, 0.0018281136, 0.0126882875, 0.0024812059, -0.0000433350, 0.0055527566, -0.0068530492, 0.0138448989, -0.0006273182, -0.0055356543, 0.0001110917, -0.0098236594, -0.0008050773, 0.0088571319, -0.0166677665, -0.0201057009, 0.0088212844, -0.0066089681, 0.0025762287, 0.0025666091, 0.0183886513, -0.0010259739, -0.0071498579, -0.0052034860, 0.0000000002, 0.0060713273, 0.0095727891, 0.0217224229, 0.0125682345, 0.0016689406, -0.0188269895, 0.0143871550, 0.0089096818, 0.0000023410, -0.0001105502, -0.0148069160, 0.0099342633, 0.0211455859, -0.0034247753, 0.0012342697, -0.0098277023, 0.0004491247, -0.0109655047, -0.0075601954, -0.0000265460, -0.0001292582, 0.0049013798, -0.0085124588, 0.0102767777, 0.0075961226, 0.0095453868, 0.0147102512, -0.0077133616, 0.0151651762, 0.0102436366, -0.0089063365, -0.0150883095, -0.0261107087, -0.0306258164, -0.0042939251, -0.0066359281, -0.0000156614, -0.0017651177, 0.0000000006, -0.0147135314, 0.0091825183, -0.0132306824, -0.0106025878, -0.0007560149, -0.0004325116, -0.0075315712, 0.0229867734, 0.0102375811, 0.0080914823, -0.0024221921, 0.0107857883, -0.0014837491, 0.0162066910, -0.0002803343, -0.0038692348, 0.0028760221, -0.0309194699, 0.0218366291, -0.0141847944, -0.0157863498, 0.0292771813, -0.0023240419, 0.0146678165, -0.0000000138, -0.0007469603, -0.0069367592, -0.0162145440, -0.0209493525, 0.0011383609, 0.0095009673, 0.0170930140, 0.0211004708, 0.0000001435, 0.0031555949, -0.0213648360, -0.0241288189, -0.0021684961, 0.0322786644, -0.0048778527, -0.0193124060, 0.0000010731, -0.0036008626, 0.0225974843, 0.0209814608, 0.0001180466, -0.0074652191, 0.0175149012, -0.0192084312, 0.0019059754, 0.0018323824, 0.0011050018, 0.0147332363, 0.0122422427, 0.0094591007, 0.0120793460, 0.0044372524, 0.0184392128, 0.0102135316, -0.0253518037, 0.0177918281, -0.0417401418, 0.0186314136, -0.0000000557, 0.0135610364, -0.0000867346, -0.0045710406, -0.0000760539, -0.0001433381, -0.0012707696, 0.0103777358, -0.0315560289, 0.0082423892, 0.0038448106, 0.0002297202, 0.0261122864, 0.0174616668, -0.0205921214, 0.0198042020, 0.0119469110, -0.0062230793, -0.0086749550, -0.0156078907, 0.0179065298, -0.0279188622, -0.0183907915, -0.0011851781, -0.0022413782, -0.0000014870, -0.0037213012, -0.0060723294, 0.0175102204, 0.0068612373, 0.0027230633, -0.0021559421, 0.0047094366, 0.0172228683, -0.0000000245, 0.0146492934, -0.0169915371, 0.0018317506, -0.0028988637, 0.0124548543, -0.0004938669, 0.0009492860, -0.0000005586, -0.0053776992, 0.0123573272, -0.0046036090, -0.0022151209, -0.0004262638, -0.0130552659, 0.0189018846, 0.0090049822, 0.0157977361, 0.0127768507, 0.0057407455, -0.0110082142, -0.0110862060, -0.0135407243, 0.0029040829, -0.0107463188, -0.0037181219, -0.0029478231, 0.0005243823, 0.0046571554, -0.0159681160, 0.0000000113, 0.0000179318, 0.0076657450, -0.0016234589, -0.0006823937, -0.0000185446, 0.0083186654, 0.0012922849, -0.0091059776, -0.0038850438, -0.0027565882, -0.0005293477, 0.0043126214, -0.0088782441, 0.0109529337, -0.0224054977, -0.0230139159, 0.0067223748, 0.0006725453, 0.0090775648, 0.0041503427, 0.0128895119, 0.0034864256, -0.0094637442, 0.0036377599, 0.0000000001, -0.0181648284, -0.0000838282, 0.0015363259, -0.0055568730, 0.0009382995, 0.0018422608, -0.0110016046, 0.0320816375, 0.0000000802, -0.0112531111, -0.0213410333, 0.0081380541, 0.0078129983, -0.0059455317, 0.0001644926, -0.0067735086, 0.0014701383, -0.0015529527, 0.0053556412, 0.0121102240, 0.0000026036, 0.0017831138, 0.0017137884, -0.0007957694, -0.0069442051, 0.0012103283, 0.0008429711, 0.0332033075, -0.0135470722, -0.0077222046, 0.0042096898, 0.0032970395, -0.0016829130, -0.0125706447, -0.0042247963, 0.0023504761, -0.0007274132, 0.0044472581, -0.0000000000, 0.0005576268, -0.0093981912, -0.0038884499, 0.0027117282, -0.0000987562, 0.0247741938, 0.0091836527, -0.0015426998, -0.0002673524, -0.0055850367, 0.0001305689, -0.0066205724, -0.0005666723, 0.0057590725, 0.0089731831, -0.0137552647, -0.0105547281, 0.0057034148, 0.0019325144, -0.0024687960, -0.0209946893, -0.0169790685, -0.0012357744, -0.0021293142, 0.0000000024, -0.0067220130, -0.0012685800, 0.0219148491, 0.0106320390, -0.0073072766, -0.0008560180, 0.0108954376, 0.0062360880, -0.0000013529, -0.0027067391, -0.0084848506, -0.0301446877, -0.0000967474, 0.0144359423, -0.0012058784, -0.0125775971, 0.0000000199, 0.0047389106, -0.0068179220, 0.0032759262, -0.0000335823, -0.0028511423, -0.0130591691, 0.0365498476, 0.0092358794, 0.0057182438, -0.0170523953, -0.0007738227, 0.0146089587, -0.0024135872, -0.0272056963, -0.0081258621, -0.0017987313, 0.0076020705, -0.0043132324, -0.0019985333, -0.0261218250, -0.0238604825, 0.0000000005, 0.0157735478, 0.0146476459, 0.0127180973, 0.0030077084, 0.0004300890, 0.0168043021, -0.0018030932, 0.0034206531, 0.0090115005, 0.0051566614, -0.0002488779, 0.0042692143, -0.0017938233, 0.0085418327, -0.0157091171, -0.0275811050, -0.0102028418, -0.0024231109, -0.0015869697, 0.0115496721, 0.0114900302, 0.0013441611, -0.0026920890, 0.0002806939, 0.0000000091, 0.0302536469, 0.0055866078, 0.0125829661, 0.0268634018, 0.0019319102, -0.0134681296, -0.0085363379, 0.0019125484, 0.0000023385, -0.0134007819, -0.0048167575, 0.0153610669, 0.0085070441, -0.0119320313, 0.0066187195, -0.0039124703, 0.0000000515, -0.0055179894, -0.0111274347, -0.0429100208, 0.0001713888, 0.0102935163, 0.0187878590, 0.0135601144, 0.0018348419, -0.0118593294, 0.0282926317, 0.0008679242, 0.0100259930, 0.0028395683, 0.0086440910, -0.0005691060, -0.0369727053, -0.0192999858, -0.0093732551, -0.0125230346, 0.0028420985, 0.0235244222, 0.0000000003, -0.0121717146, -0.0189850293, -0.0188700613, -0.0049099973, 0.0012446003, 0.0073649730, 0.0231925957, 0.0172629226, -0.0008653903, -0.0205453746, 0.0013633097, -0.0020106656, -0.0152862193, -0.0249642357, 0.0193020198, 0.0051746476, -0.0011399877, 0.0072591095, 0.0054860767, -0.0064129294, 0.0045474274, -0.0274918023, -0.0098491358, 0.0069212038, -0.0000006276, -0.0061747585, -0.0045560207, 0.0168681331, 0.0021490778, -0.0033083970, 0.0126245869, -0.0089445729, -0.0007692488, -0.0000181819, -0.0016099993, 0.0237347595, -0.0280752629, -0.0190794766, 0.0142552666, -0.0064913915, -0.0238839053, 0.0000001641, -0.0099997632, -0.0186405871, -0.0083741751, -0.0000913260, 0.0064425021, 0.0006829764, 0.0474828854, -0.0275839549, -0.0045762160, -0.0189047791, -0.0189336054, 0.0083070453, -0.0123379985, -0.0339913256, -0.0063957367, 0.0096786683, 0.0355592147, 0.0030945975, 0.0140093984, -0.0219755005, -0.0070228875, -0.0000005643, 0.0227327272, -0.0119314287, 0.0503426939, 0.0062698564, 0.0024704149, 0.0187563784, -0.0164725296, 0.0132748829, -0.0069571263, 0.0236571413, 0.0005181539, -0.0067856470, 0.0096458392, 0.0169901568, 0.0127205187, -0.0185059085, -0.0244561415, 0.0201645847, -0.0153284995, 0.0188708175, -0.0045898650, -0.0143959960, -0.0137630571, -0.0071704546, 0.0000053305, 0.0049766968, -0.0073519270, 0.0113461046, 0.0010513106, 0.0069577666, -0.0137821725, 0.0205715429, 0.0095947422, -0.0000002601, 0.0092512621, -0.0168344378, 0.0047604865, 0.0118904458, 0.0049678534, -0.0017869300, 0.0026990366, -0.0000501936, 0.0099503212, 0.0079932800, 0.0035969375, -0.0000028254, 0.0015008294, -0.0148682706, -0.0200782847, 0.0122673456, 0.0214734264, 0.0090573765, 0.0003765292, -0.0128595484, 0.0020070809, -0.0180637594, -0.0205422044, -0.0216069929, -0.0220289920, -0.0104394965, -0.0106615052, -0.0278014503, -0.0038452283, 0.0000000643, 0.0009237553, -0.0042248252, -0.0123617360, -0.0129738320, -0.0012217818, 0.0140801966, 0.0090625854, -0.0159266293, -0.0015585697, 0.0159092452, -0.0017328144, 0.0129825529, -0.0120834354, -0.0016032022, -0.0029572812, -0.0138717284, 0.0049271858, -0.0090951640, -0.0094474461, -0.0101094022, 0.0090788426, -0.0112116551, 0.0060974518, -0.0046070721, 0.0000000184, -0.0081654685, -0.0118190031, 0.0308831837, 0.0070531121, -0.0034012012, -0.0058637932, -0.0160451252, -0.0061187558, -0.0000017633, -0.0027356546, 0.0002813399, -0.0115778679, 0.0097988183, -0.0017133574, 0.0013946267, 0.0020788563, -0.0000000940, -0.0127519500, -0.0181240160, -0.0020816741, 0.0000668046, -0.0004806324, -0.0190259591, 0.0330064856, 0.0003038232, 0.0142170060, 0.0052330545, 0.0042013982, 0.0108793126, -0.0057662753, -0.0016676642, -0.0107891858, -0.0091144461, 0.0115011893, 0.0042142337, -0.0032366621, 0.0079322709, -0.0429569781, 0.0000000370, 0.0143883936, 0.0267867167, 0.0143849785, 0.0015866832, -0.0003221025, 0.0007029761, -0.0167155638, 0.0195387173, -0.0031081382, 0.0038003819, -0.0002102640, -0.0100331139, 0.0023032920, 0.0127297165, -0.0126955658, -0.0152703384, -0.0003718307, 0.0115101403, 0.0139154540, 0.0007374587, 0.0126056997, 0.0019006139, 0.0029450101, 0.0003417883, -0.0000316345, 0.0015642339, -0.0037021514, 0.0081396597, 0.0118852509, 0.0077575906, -0.0005983695, -0.0052636308, 0.0011745509, -0.0000005392, -0.0027342304, 0.0260400213, 0.0016411345, 0.0095608784, 0.0025983837, -0.0038038152, -0.0092331115, -0.0000000333, 0.0055504218, 0.0043260930, 0.0109460121, -0.0000987224, 0.0005951439, -0.0025214162, -0.0000786752, 0.0112649994, 0.0013439285, -0.0190668125, -0.0084369294, 0.0030472158, 0.0020002269, -0.0270178337, -0.0239500254, -0.0078337509, -0.0240784772, -0.0053791958, -0.0115755312, -0.0296704173, -0.0037746369, -0.0000000311, -0.0091032023, 0.0009562511, 0.0040419758, -0.0005742274, -0.0002594265, 0.0119352564, 0.0161880590, -0.0089716110, -0.0088786911, 0.0092894686, -0.0019751040, -0.0029319748, 0.0036393437, 0.0074847555, -0.0049898601, -0.0181175917, -0.0029442857, -0.0031459872, -0.0032245596, -0.0044770869, 0.0357922949, -0.0058272453, -0.0184925143, -0.0078584291, -0.0000079319, -0.0165635403, -0.0000810584, 0.0100523578, 0.0065871128, 0.0092084436, -0.0175414868, -0.0045747124, -0.0126492651, -0.0000003473, -0.0025365006, -0.0008758306, -0.0003443547, 0.0231626686, 0.0042377925, 0.0014655773, -0.0180614386, -0.0003540168, -0.0028939997, -0.0046207160, 0.0137594203, -0.0043731690, -0.0005247460, -0.0275295582, 0.0134500302, -0.0052805906, 0.0160927624, -0.0029792991, -0.0002801883, -0.0148637034, -0.0003300939, -0.0219495203, -0.0034827816, -0.0194542035, 0.0128121907, 0.0009713653, -0.0077910800, -0.0037277532, -0.0266601816, -0.0000003567, 0.0138206705, 0.0082607949, 0.0045876899, -0.0095134787, -0.0017302358, 0.0027806808, -0.0061390968, 0.0246554147, -0.0065161367, 0.0117170354, -0.0030240749, -0.0182585996, 0.0006981973, 0.0191269461, -0.0270252135, -0.0250059124, 0.0307726469, 0.0066153524, 0.0066269627, 0.0052292207, -0.0229086392, 0.0018431686, 0.0267494284, -0.0006389270, -0.0000000885, 0.0051237438, 0.0070540337, 0.0042868415, 0.0120494980, 0.0124142133, -0.0000490961, -0.0026891881, -0.0010519160, 0.0000000731, 0.0050975569, 0.0314556621, 0.0060078679, 0.0018525273, 0.0136446934, -0.0046297582, 0.0012931766, 0.0000000113, 0.0101983156, 0.0002880882, 0.0277387500, -0.0113360686, 0.0031889579, -0.0009054236, 0.0128938314, 0.0099938912, -0.0054739597, -0.0065560751, -0.0164821539, 0.0134643083, 0.0059086168, -0.0030577080, -0.0130616827, -0.0038353810, -0.0304802023, 0.0075546219, -0.0147614339, -0.0196885616, -0.0057827677, -0.0000000195, -0.0022358526, 0.0069239601, -0.0225171596, 0.0006060942, -0.0031633859, -0.0061249994, -0.0035490883, -0.0018344934, -0.0114634288, -0.0088986745, 0.0000294199, -0.0056142933, 0.0178707503, 0.0187020805, -0.0087461211, -0.0151297348, 0.0210231375, -0.0028429250, -0.0052405493, -0.0010867550, 0.0190752614, 0.0097230226, -0.0006693711, 0.0146027766, -0.0000000041, 0.0213483311, 0.0058714747, 0.0553807616, 0.0044271913, -0.0014168031, -0.0051384959, -0.0009657003, 0.0253670886, 0.0000007959, -0.0099650482, -0.0041264733, 0.0149439257, -0.0051480997, -0.0062612789, 0.0008456809, -0.0002679121, -0.0002726985, -0.0136207240, 0.0129107684, 0.0322886631, -0.0000148648, 0.0058269063, 0.0078233350, 0.0125575280, -0.0048018098, -0.0137913777, 0.0030318245, 0.0112439683, 0.0245647244, 0.0012168853, -0.0110493721, -0.0034738549, -0.0368621945, -0.0087381676, -0.0269379485, -0.0103029395, -0.0019539555, 0.0187770352, -0.0000000167, -0.0099181831, -0.0020829746, -0.0362671837, -0.0058788331, 0.0001573173, 0.0154469423, -0.0007940251, -0.0001017616, 0.0000054510, -0.0237403288, 0.0011331302, -0.0014515916, -0.0111703649, 0.0049519818, 0.0081626987, -0.0076723448, 0.0023836726, -0.0040950677, 0.0234940853, 0.0002269767, -0.0162784830, -0.0260550771, -0.0350153744, 0.0004812559, -0.0000001286, 0.0017263151, 0.0051994286, 0.0044281874, 0.0143364361, -0.0001431182, -0.0017297138, 0.0336274356, 0.0262126252, 0.0000004129, -0.0008805541, -0.0214829817, 0.0328457579, -0.0001682712, -0.0313418657, 0.0022530360, 0.0291584786, 0.0006476240, 0.0057440591, -0.0059008300, -0.0181478225, 0.0007885643, -0.0015236271, 0.0229352843, -0.0457088575, -0.0150046516, -0.0102397893, 0.0266687963, 0.0110622207, -0.0083556855, 0.0122460322, 0.0304092132, 0.0013369247, 0.0013576676, -0.0318149365, 0.0170905702, 0.0005224783, 0.0395475850, 0.0125156343, -0.0000000283, -0.0232554115, -0.0042175567, -0.0075111846, 0.0125983069, -0.0011864436, -0.0074726734, -0.0040571797, 0.0129119623, 0.0150662567, -0.0312518440, 0.0043136268, -0.0211730953, -0.0392754376, -0.0414305069, 0.0360351950, 0.0287946612, 0.0066101090, -0.0031765208, 0.0049894610, -0.0040806360, 0.0159675013, -0.0018889995, 0.0000194548, -0.0173242800, 0.0000000064, -0.0006199731, 0.0029234446, 0.0135098994, -0.0186755341, 0.0035484990, -0.0181408450, 0.0066719269, -0.0035595384, 0.0000013543, 0.0020259062, 0.0009142100, -0.0094887465, 0.0209644753, -0.0014695831, -0.0009053460, -0.0085701765, -0.0012963550, -0.0158933662, -0.0096672745, 0.0120823402, -0.0102262581, 0.0037998282, -0.0419707298, 0.0210029483, 0.0054604965, 0.0260031279, -0.0071645733, 0.0015255795, 0.0147778234, 0.0070476653, -0.0242883265, -0.0076520862, -0.0374855474, -0.0071470235, -0.0088954009, -0.0219849851, -0.0299696159, -0.0340507664, 0.0000000116, 0.0144081255, 0.0261034500, -0.0002394468, -0.0045565898, 0.0027002476, 0.0008610455, -0.0135435965, 0.0169471521, -0.0040617841, 0.0228105988, -0.0005615219, -0.0037189124, 0.0121154319, 0.0250813700, -0.0111049907, -0.0300133862, 0.0310356654, -0.0136261731, 0.0036169863, -0.0045554894, -0.0077462895, 0.0021608155, -0.0054418524, -0.0037201757, 0.0000000001, -0.0128994556, -0.0113377394, -0.0117230359, -0.0012254972, -0.0033299315, 0.0042647296, 0.0063332464, 0.0094538471, 0.0000002446, 0.0299684592, -0.0093737328, -0.0209146552, -0.0014495220, 0.0176838413, -0.0004417952, -0.0125655821, 0.0000016280, -0.0178801101, 0.0149476212, -0.0170200765, -0.0001315095, 0.0025652961, 0.0029230677, 0.0071542924, 0.0125263063, -0.0018410224, 0.0161121748, -0.0019004300, 0.0120135555, -0.0070852567, -0.0196304172, -0.0064925533, 0.0046904082, -0.0017276155, 0.0021661364, 0.0114530800, -0.0004612190, 0.0038066544, -0.0000000001, -0.0011734045, 0.0024033389, 0.0272382125, -0.0017428691, 0.0004128765, -0.0123109063, -0.0023842063, 0.0070594633, 0.0087503791, 0.0246247351, -0.0001110633, -0.0060933945, -0.0019985295, 0.0035609438, -0.0165833849, -0.0002207166, 0.0224850383, -0.0182431601, -0.0022826572, 0.0076290425, -0.0158080943, -0.0158546884, 0.0030224847, 0.0183439907, -0.0000024509, -0.0124860937, 0.0107013294, -0.0144254696, -0.0265744403, 0.0033993924, 0.0113349380, 0.0080214078, -0.0054023932, -0.0000007026, 0.0043482543, -0.0088387430, -0.0042614411, -0.0176457167, 0.0056667854, -0.0077931411, -0.0113905184, -0.0000025384, -0.0042217914, 0.0082320310, 0.0387063846, -0.0000543914, -0.0059177666, -0.0073825456, 0.0045463964, -0.0058996407, 0.0127219595, -0.0182646476, 0.0026440984, 0.0198042914, 0.0002173119, -0.0039138659, 0.0145867113, 0.0227653440, 0.0089166434, 0.0000024302, 0.0014516672, -0.0327362269, 0.0107955132, -0.0000009600, 0.0300560724, 0.0162243079, 0.0340039842, 0.0265354607, -0.0034498728, -0.0001245451, -0.0121650547, -0.0117530189, -0.0006048540, 0.0227957778, -0.0001766356, -0.0112018129, 0.0125577692, 0.0173732433, 0.0107185869, 0.0039287731, -0.0010021694, 0.0007811208, -0.0151681351, 0.0027191730, 0.0176299624, -0.0138642751, -0.0322983675, 0.0058867815, -0.0000165439, -0.0085535450, -0.0001718520, 0.0010738551, 0.0188296754, 0.0102687338, 0.0008896899, 0.0210019164, -0.0060903346, -0.0000024160, 0.0030918589, 0.0062058810, -0.0000465771, 0.0101512223, -0.0025522886, -0.0004404538, -0.0292701125, -0.0000019220, -0.0007823932, -0.0012677447, 0.0132681560, 0.0002812469, -0.0035352965, -0.0100069456, -0.0021318465, -0.0040041013, -0.0075556366, -0.0075313635, -0.0149869770, -0.0012540125, -0.0052983668, -0.0240309536, -0.0318323299, -0.0089704078, -0.0236489922, 0.0050150491, -0.0070918780, 0.0036550078, -0.0086401692, 0.0000000017, 0.0055424017, -0.0020580888, 0.0207491182, -0.0107849203, -0.0122597134, 0.0005213518, -0.0149550112, 0.0196501538, -0.0057272324, 0.0215884112, 0.0003492898, -0.0101640606, 0.0117092971, 0.0092376033, 0.0117330244, -0.0151811782, 0.0024773432, -0.0034514184, -0.0228422917, 0.0065314467, 0.0041165831, -0.0552539043, -0.0297892299, 0.0254175942, -0.0000030222, 0.0080007808, -0.0272555575, -0.0048036072, 0.0204508454, 0.0246910695, -0.0084975511, 0.0003710964, 0.0148410937, 0.0000153925, 0.0013071622, 0.0059953337, 0.0473254248, 0.0157926343, -0.0107333735, -0.0078422269, 0.0092091020, 0.0000000780, 0.0067971302, 0.0137849208, 0.0171849951, 0.0012203405, 0.0083757918, 0.0065178899, -0.0298591480, -0.0042493865, -0.0129040908, -0.0009779716, 0.0144990748, -0.0184501689, -0.0066392352, 0.0095034596, -0.0196358059, 0.0236705355, -0.0221679118, 0.0064046546, 0.0041842829, -0.0100560626, -0.0035356069, -0.0000180107, 0.0140134981, 0.0270021614, -0.0188169014, -0.0075324993, -0.0014711528, -0.0145290671, 0.0089742364, -0.0234672427, 0.0054795761, 0.0132281920, -0.0090894215, 0.0035773818, 0.0062157596, -0.0165336914, 0.0165523626, 0.0112627028, 0.0025182578, 0.0300040375, -0.0112942373, 0.0053840429, 0.0402300470, -0.0021032558, -0.0032090913, 0.0005286162, 0.0000000000, -0.0004250620, -0.0011296005, -0.0025422790, 0.0122292945, -0.0010033586, -0.0030330382, -0.0047496380, 0.0081923818, 0.0000000177, -0.0033269755, 0.0008669295, -0.0002468382, 0.0101768477, -0.0039576408, 0.0008653140, 0.0040741144, -0.0000006921, 0.0077429572, 0.0083312681, -0.0011996080, -0.0000032560, 0.0004549891, -0.0060965223, 0.0117473435, 0.0036221719, -0.0090374956, 0.0017834528, 0.0061104205, 0.0056694960, 0.0046561495, -0.0128833372, -0.0021404075, -0.0039854110, 0.0013625409, 0.0007939240, -0.0052041309, 0.0031264750, -0.0024685769, 0.0000000000, -0.0014360492, -0.0012037968, -0.0028591605, -0.0052556242, -0.0000731279, 0.0079181930, 0.0032532667, 0.0070018228, 0.0113358414, -0.0052811778, 0.0000198572, -0.0023037698, 0.0048982385, -0.0055152830, -0.0051356852, -0.0006289146, -0.0048358082, -0.0039316532, -0.0013575768, 0.0021411304, -0.0058691395, -0.0109441373, 0.0049549085, 0.0038065333, 0.0000000000, -0.0131144673, 0.0077719125, 0.0071165869, -0.0016253598, -0.0002495791, -0.0022643546, -0.0129727814, 0.0001713379, -0.0000020687, -0.0022453330, 0.0090254201, -0.0049850806, -0.0040870281, -0.0009386116, 0.0010656816, 0.0057152975, 0.0000000055, 0.0020071180, -0.0098309424, -0.0198979732, 0.0000009557, 0.0048753652, -0.0020351838, 0.0197879896, -0.0045250962, -0.0050945380, -0.0059240554, -0.0144550037, 0.0040984382, 0.0071942168, -0.0044633597, 0.0025279950, -0.0044929134, 0.0153911496, 0.0119607933, -0.0011876647, 0.0053783627, -0.0217931997, 0.0000000000, -0.0021075364, -0.0005075464, 0.0092047304, -0.0048557408, -0.0000260568, 0.0055369353, -0.0029426445, -0.0017803244, 0.0164393466, -0.0016277949, 0.0000918110, -0.0040746168, -0.0000895856, -0.0029384787, -0.0027312725, -0.0006452657, -0.0128456820, 0.0027511888, -0.0047263592, -0.0057390863, -0.0017706760, 0.0150902253, -0.0068729366, -0.0069159735, 0.0000000000, 0.0098616900, 0.0002114686, 0.0067431419, -0.0097941943, -0.0035196538, 0.0012261240, 0.0041520074, -0.0023786044, 0.0000000958, -0.0078684269, -0.0073311133, -0.0002587631, 0.0023590268, 0.0025013713, -0.0013840336, -0.0295558833, 0.0000104139, -0.0069750980, -0.0053647598, 0.0161251239, -0.0001862004, -0.0156083452, -0.0098048802, -0.0006736032, -0.0083828811, 0.0093745328, -0.0168989990, -0.0007908293, 0.0040503507, -0.0036026887, -0.0105225062, -0.0033136837, -0.0000789530, 0.0031176177, -0.0095966719, -0.0003418149, -0.0188003220, 0.0081405016, 0.0000000000, 0.0001715159, -0.0103344917, 0.0042120987, -0.0016552849, 0.0001704952, 0.0158840083, 0.0024937110, 0.0101207746, -0.0078907525, 0.0182841290, 0.0001727302, -0.0187768042, -0.0092971902, 0.0242369510, 0.0078990785, -0.0100834006, 0.0028804271, 0.0010969517, -0.0150311701, -0.0033063611, -0.0094620856, 0.0174658690, -0.0034851385, -0.0091994526, 0.0000000000, 0.0113153309, -0.0014332724, 0.0101044625, 0.0042077028, -0.0031533020, 0.0006019415, 0.0015199903, -0.0139555996, 0.0000000006, -0.0063352860, 0.0043386584, -0.0120742442, -0.0002697294, 0.0002227021, -0.0008692451, -0.0139678437, -0.0000001759, -0.0001359732, 0.0025739986, 0.0091990149, 0.0000124400, 0.0005596856, -0.0056257318, 0.0168828946, 0.0017818613, -0.0148709211, -0.0089605525, -0.0079395883, 0.0107060159, -0.0048684399, -0.0184467733, -0.0129342694, 0.0039767097, 0.0096960729, -0.0070669139, -0.0017751696, -0.0111477086, 0.0094037279, 0.0000000000, -0.0015659377, -0.0003516793, -0.0001235360, -0.0065352255, 0.0002146516, 0.0128421718, 0.0030965905, 0.0049330438, -0.0082064206, 0.0007073649, -0.0000191309, -0.0085754283, 0.0066186418, 0.0169850513, 0.0014696312, -0.0025419628, 0.0017869317, -0.0047020311, -0.0052521117, 0.0099552935, -0.0010268500, 0.0024311729, -0.0114405705, -0.0023817297, 0.0000000004, -0.0041503254, -0.0050704880, -0.0089543546, 0.0033316023, -0.0015358805, -0.0023926010, 0.0028209507, 0.0033393307, 0.0000000036, 0.0038079459, -0.0030740818, -0.0015937325, -0.0024869118, -0.0020936797, 0.0011685789, -0.0077286502, -0.0000017947, 0.0013453573, 0.0070000766, -0.0126376655, 0.0000188097, -0.0003501436, 0.0015447552, 0.0022884912, 0.0060578077, -0.0014279195, 0.0113546792, 0.0044084168, -0.0003335413, -0.0010846584, -0.0028811251, -0.0011652736, -0.0067859930, 0.0029359527, 0.0049996548, -0.0003437248, 0.0096999416, -0.0044958144, 0.0000000000, -0.0059037227, -0.0051753181, 0.0047147041, -0.0069346763, -0.0001100888, 0.0037757847, -0.0032093592, 0.0068604113, -0.0029392091, 0.0062573683, 0.0000753381, 0.0060149892, -0.0036959944, -0.0073550614, 0.0003209010, -0.0011089887, 0.0047410242, -0.0110567017, -0.0055688326, 0.0029377721, -0.0112306522, 0.0069631194, 0.0035494079, 0.0000593634, 0.0000000000, 0.0134281553, 0.0017250974, -0.0239885356, 0.0270496923, -0.0034886466, 0.0011966616, -0.0040417956, 0.0107458895, 0.0000000338, 0.0010268205, -0.0006135359, 0.0025073709, -0.0154069960, 0.0030872498, 0.0004070656, 0.0130635835, -0.0000004026, -0.0008397779, 0.0219725650, -0.0090231271, 0.0000271713, 0.0010040258, 0.0043309210, 0.0045554871, 0.0092437472, 0.0114937183, 0.0133075817, 0.0122689530, -0.0013642517, -0.0085395295, 0.0161713362, 0.0100131901, 0.0024826913, -0.0126416786, -0.0218794867, -0.0023118078, -0.0094282394, 0.0006227167, 0.0000000000, 0.0019850784, 0.0095729195, -0.0237345304, 0.0202017464, -0.0000983529, 0.0048470469, 0.0121052004, -0.0068978649, 0.0058433525, -0.0120459320, -0.0020423147, 0.0155346794, -0.0012608273, 0.0032018395, -0.0010127474, 0.0299466122, -0.0298762321, -0.0036349173, -0.0012213030, 0.0209928825, 0.0041871895, -0.0001370193, 0.0048848502, -0.0021284628, 0.0000000001, -0.0144940298, 0.0035404756, 0.0005102403, 0.0076407837, -0.0002273723, -0.0023308783, -0.0068914369, 0.0120408954, 0.0000001254, 0.0085728243, -0.0107250605, -0.0014641386, 0.0098398756, -0.0023677947, 0.0012680179, 0.0018550347, -0.0000031544, -0.0016849849, -0.0030267958, -0.0050498275, -0.0013572559, -0.0003396436, -0.0134672541, 0.0180774312, 0.0113437138, 0.0130472593, -0.0018944023, 0.0106259063, 0.0115142046, -0.0114777833, -0.0112860026, 0.0002406312, -0.0106633324, -0.0012266634, 0.0036657536, -0.0057214689, 0.0088569121, -0.0046908278, 0.0000000000, 0.0022873846, 0.0064056921, 0.0023551562, 0.0076132235, -0.0000951654, 0.0104284454, 0.0066284775, 0.0119172158, 0.0029963884, -0.0063399309, 0.0000680890, -0.0080392547, -0.0003836496, 0.0095568309, -0.0085605737, -0.0115329186, 0.0014286024, -0.0072355350, 0.0019231460, 0.0046061501, 0.0050333701, 0.0040698536, -0.0170948654, -0.0042901523, 0.0000000016, -0.0048862831, -0.0033693784, -0.0118342061, 0.0142054325, 0.0002878082, -0.0017506223, -0.0191697851, 0.0114779063, 0.0000000169, -0.0037777626, -0.0091441171, 0.0009510035, 0.0048117028, 0.0007106049, 0.0010630370, -0.0033736147, 0.0000091955, -0.0029453568, 0.0046258131, -0.0089973630, 0.0000035197, 0.0005182291, 0.0085103456, -0.0013359479, -0.0060950001, -0.0051684151, 0.0142908804, 0.0228515156, -0.0067541823, -0.0083486577, 0.0061099012, 0.0030808232, -0.0012435643, -0.0138094649, -0.0017129494, 0.0005924751, 0.0054800767, -0.0087617375, 0.0000000001, -0.0053075040, -0.0114255678, -0.0060628224, -0.0059649618, 0.0000032534, 0.0168725215, 0.0057262871, 0.0119271409, -0.0029995847, -0.0051773740, -0.0000142037, 0.0027670488, -0.0040721414, -0.0176733658, 0.0084317075, 0.0004132098, -0.0047061420, 0.0037627153, 0.0032848432, 0.0046395808, -0.0180188604, -0.0170501731, -0.0042496296, -0.0014866675, 0.0000000000, -0.0115711456, -0.0026123945, 0.0027784479, 0.0043634023, -0.0016376724, -0.0013440609, 0.0109415669, 0.0049713459, -0.0000000064, 0.0163719673, 0.0097124428, -0.0002068515, 0.0146845225, -0.0135191008, 0.0006417907, 0.0043669809, -0.0000094326, -0.0065860441, -0.0136547061, -0.0482357927, 0.0000873128, -0.0005788621, -0.0031942814, 0.0204983577, 0.0054772859, 0.0081235124, 0.0102769285, -0.0072273482, -0.0037143992, -0.0134347267, -0.0068854443, -0.0015844437, -0.0018494526, -0.0125592593, 0.0311319288, 0.0000676455, 0.0405289792, -0.0183806345, 0.0000000000, 0.0029266768, 0.0028563773, 0.0380526409, 0.0031134714, -0.0000617311, -0.0051350752, -0.0115087759, 0.0295762196, -0.0008483138, 0.0081858542, 0.0002157580, -0.0257549342, -0.0080446405, -0.0161971133, 0.0017938849, -0.0113139842, 0.0210898872, -0.0118952524, 0.0054045436, -0.0039713401, 0.0014416669, -0.0016820144, 0.0047472250, 0.0126391463, -0.0000000651, 0.0251873937, 0.0013707096, 0.0156752877, -0.0044162003, 0.0006681191, -0.0010339443, 0.0043623322, 0.0188160557, -0.0000127530, -0.0039085783, -0.0033816176, 0.0080095828, 0.0032144815, 0.0046930104, -0.0084283231, -0.0098010479, 0.0000003056, -0.0149296755, 0.0081303138, 0.0203375928, -0.0001260900, -0.0023817006, -0.0043634712, 0.0154952705, -0.0065688076, -0.0045126388, -0.0109618446, -0.0120388875, 0.0176952239, 0.0040450073, -0.0286027882, -0.0143083008, 0.0069862963, -0.0019450933, 0.0029789063, 0.0046495399, -0.0092592305, -0.0035689571, -0.0000000047, 0.0037337414, -0.0163300168, 0.0089079412, 0.0092612971, 0.0001334742, 0.0162860006, -0.0079232855, -0.0024615796, -0.0014646886, 0.0163308885, -0.0005632790, 0.0009595312, 0.0093961209, 0.0167912040, 0.0153289512, 0.0020398174, -0.0050624376, -0.0047435616, 0.0033556107, 0.0191015750, 0.0027562473, -0.0185642578, 0.0024598776, 0.0016892853, 0.0000000000, -0.0076107238, 0.0034106900, 0.0162025411, 0.0022732746, 0.0000261079, 0.0000534925, 0.0239512194, 0.0079330606, -0.0000005451, 0.0011793547, -0.0127684204, 0.0022005537, 0.0067623369, -0.0046440633, -0.0020767306, 0.0082539264, -0.0000005349, -0.0073372116, -0.0066259042, -0.0035108102, 0.0000210151, 0.0029272533, -0.0059892940, 0.0115662413, -0.0037345530, 0.0045794589, -0.0006139973, -0.0128642740, 0.0100043584, 0.0062251734, -0.0166025441, -0.0101550780, 0.0001815022, 0.0079259872, 0.0022142208, -0.0039273496, 0.0145426886, -0.0051940894, 0.0000000000, 0.0085266996, -0.0036863706, -0.0035225921, 0.0050369706, 0.0000834965, 0.0016154277, -0.0145807434, 0.0022218758, 0.0185100660, 0.0054586376, 0.0002444944, -0.0075611672, 0.0015633992, 0.0049670790, -0.0000262739, -0.0006937070, 0.0000026550, 0.0001827674, 0.0013687621, 0.0059964191, -0.0106492434, 0.0460182987, 0.0085512912, 0.0044037891, -0.0000001799, 0.0082258424, 0.0045325039, -0.0095633343, -0.0044986410, 0.0033133593, 0.0042874021, -0.0078240111, -0.0027739585, 0.0000069631, -0.0130369905, -0.0140236570, -0.0007648712, -0.0042970986, 0.0224037822, -0.0078586489, 0.0014321742, -0.0000012511, 0.0023464521, 0.0116344932, 0.0491600037, 0.0003535851, -0.0149390195, 0.0052618226, -0.0278842878, -0.0089810332, 0.0162106231, -0.0112911640, 0.0132057685, -0.0007250291, -0.0091229631, 0.0215691272, 0.0041513331, 0.0182688665, -0.0201762840, -0.0329235457, -0.0002217878, -0.0399646536, -0.0025668666, -0.0000001189, 0.0069284630, -0.0065112268, -0.0204164963, 0.0152861224, -0.0009190502, -0.0036234516, 0.0137075474, -0.0335991979, 0.0001631919, 0.0208339095, -0.0021010970, 0.0081022028, 0.0061380849, 0.0236991681, 0.0093939342, 0.0195324309, -0.0116217136, 0.0084933667, -0.0237632692, 0.0159920827, -0.0085331649, 0.0045381756, -0.0047137449, -0.0011407149, 0.0000000000, 0.0014921641, -0.0010090913, -0.0041078860, 0.0071712658, -0.0018606468, -0.0013792696, 0.0112619204, -0.0021150350, 0.0000000045, 0.0028398673, 0.0058021420, -0.0034534878, -0.0048564933, 0.0020791402, 0.0015304146, -0.0019609404, -0.0000034487, -0.0006154208, 0.0070800274, 0.0003804526, 0.0000059034, -0.0002081755, -0.0012448103, 0.0109390542, 0.0049848706, -0.0007186136, 0.0002057336, -0.0061409171, 0.0016007740, -0.0058454294, -0.0011773950, -0.0014415646, -0.0024200426, -0.0032807845, -0.0057986630, 0.0020623149, 0.0096415300, -0.0090649668, 0.0000000000, -0.0073328153, 0.0040093693, -0.0011295257, 0.0023756409, -0.0000832324, -0.0005397459, -0.0037538179, 0.0014243693, 0.0041463133, 0.0016866236, 0.0000197780, -0.0018879033, 0.0024230357, 0.0079589831, -0.0049161576, 0.0027262096, 0.0012648269, -0.0170466509, -0.0051548877, 0.0127559667, 0.0016847057, 0.0029180977, -0.0007161084, -0.0079464093, 0.0000000000, -0.0012814881, -0.0050182980, -0.0213259738, 0.0073019476, -0.0017161693, 0.0057581426, -0.0003715789, 0.0031777006, 0.0000000149, -0.0066771433, 0.0000943987, 0.0056125908, 0.0086158747, -0.0072001228, 0.0007320739, 0.0095117949, 0.0000000004, 0.0037457121, 0.0054680747, -0.0098783998, 0.0000281899, -0.0067257714, -0.0079291109, 0.0159452818, 0.0069383630, 0.0029871780, 0.0100824609, 0.0110773835, -0.0048728874, 0.0013982814, -0.0017174655, 0.0005210937, 0.0067494153, -0.0129732415, -0.0027656038, -0.0061025764, -0.0026073398, -0.0105386470, 0.0000000000, 0.0027219122, 0.0089120250, -0.0122311162, 0.0064878073, 0.0000316468, 0.0122884940, 0.0005930287, 0.0081970468, 0.0053609675, -0.0030697491, 0.0000491045, 0.0039471299, -0.0003976971, 0.0054846574, -0.0014282898, 0.0008554225, -0.0211567301, 0.0104967495, -0.0025481554, 0.0167371202, 0.0082268044, 0.0170030035, 0.0030285022, 0.0097704316, -0.0000000000, 0.0243852586, -0.0012564049, 0.0077545461, -0.0043417737, -0.0020344940, -0.0007144534, 0.0031933885, 0.0084478743, 0.0000000086, -0.0096111624, -0.0047126706, -0.0063564912, -0.0079434607, -0.0017972273, -0.0028725425, -0.0172508638, -0.0000005997, 0.0044513824, 0.0155864265, 0.0288317930, 0.0001635317, 0.0032635494, 0.0066333883, 0.0012113721, -0.0007710905, -0.0148447230, -0.0239761472, 0.0089988075, 0.0217244215, -0.0039793225, -0.0128866099, 0.0025192855, 0.0102596702, -0.0042285677, -0.0140873166, 0.0059473333, -0.0364339873, 0.0300525054, -0.0000000000, 0.0073876441, -0.0052947700, 0.0013440527, 0.0055256756, 0.0002755216, 0.0247934721, 0.0092283143, -0.0088869305, -0.0119563304, 0.0107744094, -0.0001830937, 0.0065903398, 0.0244378019, 0.0153272264, 0.0237209685, 0.0013606972, -0.0212589893, 0.0066636982, -0.0194501765, 0.0088237282, 0.0125648184, -0.0004924452, 0.0014739076, -0.0007842108, 0.0000000004, -0.0031551672, 0.0012158626, -0.0050839293, -0.0008927133, -0.0003830552, -0.0039476808, 0.0099145621, 0.0040055057, 0.0000002157, 0.0063467659, -0.0077938936, -0.0015083831, 0.0024381769, -0.0026619760, 0.0014206432, -0.0047592064, -0.0000377861, 0.0015967677, -0.0036529440, -0.0053489325, -0.0000005372, 0.0002174668, -0.0029459046, 0.0017637215, 0.0105437431, 0.0142438412, 0.0007055825, -0.0013644805, 0.0096842162, 0.0010241151, 0.0003243907, -0.0009650071, -0.0067686844, 0.0036912956, 0.0000703148, -0.0015974781, 0.0037693339, -0.0047289100, 0.0000000001, 0.0014204354, 0.0012482457, 0.0033541864, 0.0002516278, -0.0000956944, -0.0028329045, -0.0006218486, 0.0000794887, 0.0057802084, 0.0087553021, 0.0002550478, 0.0013999761, -0.0010648901, 0.0010834869, 0.0010992045, -0.0006730862, -0.0058545466, -0.0064059217, -0.0031094649, -0.0006288326, -0.0018828675, 0.0327836424, 0.0045442050, 0.0009201990, 0.0000000000, 0.0118620461, 0.0011361184, -0.0253933277, 0.0039861966, -0.0056257234, 0.0012797647, -0.0079859169, -0.0059977495, 0.0000000005, -0.0002518217, -0.0030613465, 0.0062712301, -0.0076363529, 0.0133482758, 0.0006021826, 0.0059220148, -0.0000000000, 0.0098719317, 0.0265838895, 0.0194150060, 0.0000058853, 0.0017444643, -0.0053294161, -0.0019083190, 0.0106734941, -0.0101452833, -0.0039696814, 0.0008273425, 0.0150193674, 0.0152432434, 0.0045124879, -0.0041443454, 0.0021171095, 0.0129008722, -0.0237996634, -0.0053499900, -0.0230518319, 0.0000481226, -0.0000000000, 0.0041560931, 0.0019388176, -0.0295419674, -0.0014901002, 0.0007637775, -0.0055890619, 0.0110435942, -0.0188757237, 0.0072600669, -0.0167223047, 0.0000095831, 0.0197748505, -0.0008134342, -0.0024160647, -0.0131058265, 0.0229860656, 0.0073645110, -0.0110456124, -0.0236726757, 0.0175501816, 0.0119257635, 0.0084601445, 0.0053814682, -0.0082726451, 0.0000000000, -0.0054615233, -0.0007124342, -0.0022040361, 0.0131602129, 0.0009292876, -0.0021802324, -0.0284309890, -0.0152812516, -0.0000018580, -0.0014923126, 0.0436089151, -0.0094385268, 0.0140893999, 0.0066502243, 0.0014740393, -0.0150271524, -0.0000005171, -0.0147638610, -0.0221716650, -0.0251426268, -0.0039549600, 0.0044008824, -0.0120085785, 0.0344365016, -0.0038787078, 0.0007834879, -0.0028832257, -0.0210394450, 0.0009874246, -0.0111860475, -0.0292203072, -0.0045516780, -0.0062411125, 0.0111476034, 0.0156200584, 0.0020338080, 0.0074514695, -0.0270886421, 0.0000000000, 0.0029245736, -0.0104033798, 0.0213327315, 0.0007890384, 0.0004074108, 0.0141533725, -0.0087315505, 0.0174081121, -0.0069035003, 0.0166879110, 0.0001009107, -0.0139411716, 0.0028627296, 0.0191230588, -0.0098008057, -0.0147147430, -0.0004440676, 0.0053899130, 0.0076916930, 0.0034022736, -0.0105084274, -0.0081260419, 0.0020302106, -0.0101612927, 0.0000000000, -0.0162622072, -0.0020227341, -0.0070973472, -0.0009014290, -0.0016951230, 0.0031773066, 0.0078304624, -0.0084150303, 0.0000000003, 0.0088928705, -0.0177961569, -0.0103219189, 0.0067692827, -0.0041974317, -0.0001363110, 0.0227450114, 0.0000000006, -0.0008873523, -0.0148944780, -0.0283222832, 0.0000661012, 0.0029163926, -0.0047587953, -0.0087426081, 0.0015479074, 0.0213698447, 0.0263573900, 0.0059968573, -0.0045623910, 0.0180759653, 0.0196680781, 0.0112160398, 0.0087419432, 0.0079602404, 0.0063639004, -0.0046083364, 0.0234739315, -0.0205863714, 0.0000000000, 0.0067732446, 0.0222149938, -0.0028501216, 0.0043613845, 0.0003502974, -0.0111263115, -0.0060983216, 0.0125922067, -0.0000991231, 0.0042186459, -0.0029511240, -0.0030711924, -0.0063366354, -0.0190505013, -0.0036898099, 0.0120414421, 0.0052722795, -0.0001529794, 0.0235142056, -0.0032038887, -0.0129955793, 0.0182715729, 0.0100849541, -0.0031117280, -0.0000000232, -0.0239028111, -0.0101719853, -0.0070038675, 0.0036411239, -0.0016116181, 0.0043489742, -0.0398048051, -0.0082321391, -0.0000877657, -0.0117825577, 0.0311798621, -0.0127121098, 0.0097998846, 0.0138233835, -0.0031351654, -0.0012405561, -0.0000000372, -0.0249895938, -0.0218699239, -0.0181280468, 0.0002032499, -0.0010302594, 0.0044001872, 0.0226062257, -0.0177668538, 0.0047967206, -0.0111764250, -0.0095035434, -0.0085900184, -0.0136491675, -0.0144822923, -0.0010218186, 0.0092014717, 0.0008230344, 0.0152793527, 0.0118722869, 0.0015023543, -0.0230135377, -0.0000000060, -0.0002957732, -0.0099538229, 0.0207384266, 0.0017659186, 0.0000604698, 0.0268926527, -0.0077772932, 0.0152041931, -0.0114873573, 0.0242299549, 0.0002436372, -0.0357399583, 0.0072436114, 0.0182893928, -0.0015977804, -0.0215186961, -0.0054759448, 0.0169093087, -0.0010773230, 0.0031928394, -0.0200907979, 0.0106669525, -0.0176390335, -0.0092817582, 0.0000000035, -0.0048023490, -0.0063648075, -0.0032438461, 0.0143544162, 0.0003027219, -0.0071563129, -0.0068271444, 0.0082072280, 0.0000000000, 0.0026671626, -0.0240902435, -0.0040358137, 0.0150945568, 0.0075560771, 0.0012479568, -0.0037113698, -0.0000005271, -0.0027995212, -0.0006667906, -0.0087710787, -0.0001764615, -0.0040551526, -0.0003731199, 0.0010311683, -0.0010127153, 0.0070658987, 0.0136970282, 0.0089602545, -0.0120073371, -0.0074007711, -0.0026621984, -0.0026036454, -0.0156293735, -0.0161450189, -0.0053118197, -0.0010113397, 0.0075372020, -0.0185820349, 0.0000000025, -0.0058492250, -0.0110587897, -0.0104121491, -0.0098481420, -0.0001031385, 0.0088600488, 0.0092863403, 0.0170703959, 0.0007837634, 0.0020797667, -0.0015569292, 0.0011591014, -0.0058610397, -0.0047815242, -0.0028540634, -0.0023812647, 0.0113417115, -0.0101499036, 0.0063952920, 0.0044647688, -0.0233543012, -0.0088451551, 0.0003651165, -0.0066805761, 0.0000000005, -0.0116799111, 0.0077324435, 0.0012820021, 0.0144146262, -0.0031733846, -0.0054081860, 0.0073707271, -0.0026225161, -0.0000009775, 0.0104395440, 0.0111119058, -0.0083618425, 0.0099462317, 0.0034444458, 0.0032939466, -0.0024324250, -0.0000159889, -0.0093264086, -0.0094165439, -0.0276749376, -0.0000158747, 0.0010038503, -0.0204687919, 0.0337358415, 0.0118071567, 0.0069377483, 0.0013587804, -0.0180319026, 0.0167076755, -0.0061703101, -0.0191780124, -0.0108747995, -0.0097590163, 0.0112498887, 0.0042140153, -0.0037644957, 0.0125631774, -0.0202840175, 0.0000000005, 0.0016730179, 0.0124051590, 0.0130210966, 0.0003158577, 0.0001722054, 0.0067405235, -0.0104483496, 0.0169642251, 0.0075652944, 0.0094831735, 0.0005459210, -0.0106397411, -0.0037247825, 0.0076635540, -0.0081512863, -0.0094175329, 0.0108835865, -0.0160379466, -0.0036918821, 0.0094500855, 0.0022127789, 0.0149075631, -0.0056291851, -0.0109829325, 0.0000000020, 0.0000726609, -0.0005656954, 0.0017532242, 0.0119665442, -0.0014814689, -0.0042141275, 0.0024524305, -0.0067904838, 0.0000002863, 0.0033531592, -0.0203250069, -0.0044612042, 0.0148325115, 0.0129204812, -0.0010241844, 0.0033387132, 0.0001426826, -0.0008384314, -0.0068214796, -0.0057859011, -0.0002160545, -0.0021795044, 0.0037330289, 0.0028626730, -0.0023927281, 0.0091732834, 0.0062847468, -0.0114211841, -0.0037419617, 0.0041572321, -0.0026178733, -0.0171696357, -0.0094039124, -0.0062316931, -0.0092317211, -0.0029358021, 0.0009576301, -0.0244114585, 0.0000000005, -0.0028824345, -0.0101608885, -0.0205723979, -0.0195453037, -0.0000390274, -0.0035512929, 0.0018479514, 0.0097890245, 0.0097824847, -0.0043274025, -0.0010835883, -0.0010995541, -0.0030412679, -0.0046023261, 0.0088423220, 0.0029356012, 0.0078029642, -0.0091509968, 0.0023337875, 0.0049034562, -0.0195987839, 0.0300317686, -0.0066000950, -0.0020214550, 0.0000000000, -0.0110798422, 0.0015144643, -0.0058893729, 0.0143111469, -0.0028377657, -0.0031148323, -0.0231665168, 0.0062364577, -0.0000001664, -0.0109914914, 0.0141879451, -0.0033705048, 0.0106622139, 0.0055984822, 0.0016446206, -0.0048908936, -0.0000263449, -0.0173112564, 0.0022088368, 0.0140468478, 0.0000284019, -0.0057952232, -0.0066727242, 0.0145066986, -0.0026000845, 0.0073373388, -0.0004140523, 0.0078748409, 0.0011272125, -0.0076867263, -0.0138584739, -0.0015944166, -0.0098710619, -0.0102714570, -0.0021050279, -0.0084772361, 0.0023333842, -0.0175606497, 0.0000000000, -0.0032482680, -0.0033637083, -0.0048346920, 0.0072224881, 0.0001290118, 0.0142538073, 0.0096369879, 0.0146534834, 0.0012210646, -0.0018921740, 0.0001852215, -0.0034461073, 0.0015686681, 0.0173102710, -0.0122561790, -0.0030386781, -0.0039072577, 0.0043222266, -0.0010179160, 0.0325498618, -0.0087531246, -0.0003098048, -0.0135082332, -0.0049629938, -0.0000000000, 0.0064029554, 0.0016474372, 0.0109278904, -0.0137278801, 0.0013471789, -0.0012075648, 0.0308169723, 0.0036599757, 0.0000000051, -0.0046729757, -0.0298605673, -0.0057591009, 0.0284948461, -0.0058778762, -0.0020953165, -0.0025301955, -0.0000046418, -0.0000441923, -0.0122948075, -0.0033901434, -0.0000506824, -0.0163376722, 0.0047587464, -0.0123595707, -0.0158148389, -0.0041317362, -0.0028202443, -0.0069776718, -0.0006261461, -0.0012556373, 0.0008383762, -0.0185519736, -0.0086593553, -0.0110165738, 0.0118697751, 0.0000690728, 0.0182643943, -0.0106619317, -0.0000000000, 0.0061923033, -0.0167639628, 0.0159003846, -0.0071110032, 0.0001048434, -0.0023034101, -0.0039444063, 0.0186440293, 0.0011668830, 0.0154383564, -0.0022167459, -0.0162458923, -0.0043138657, -0.0006740782, 0.0266820546, -0.0086765531, 0.0091635026, -0.0059240274, -0.0013982046, -0.0029150569, -0.0042636953, 0.0079903072, 0.0211162884, -0.0025404710, -0.0000000000, 0.0012852795, 0.0042581614, -0.0244097766, -0.0114117125, -0.0008126967, 0.0106568597, -0.0065700235, -0.0019714020, 0.0000000010, -0.0015794169, -0.0003378497, 0.0071752719, -0.0105668465, -0.0043485472, -0.0016386230, 0.0152692171, -0.0000000001, -0.0025128732, 0.0192229226, 0.0111483671, 0.0001759141, -0.0013594503, -0.0109899985, -0.0102889426, 0.0107037649, 0.0191049762, 0.0018352586, -0.0005360208, -0.0058375215, 0.0097253947, 0.0090555009, 0.0093694562, 0.0124632921, -0.0063708872, -0.0212430861, -0.0028343885, -0.0076189321, 0.0046680868, -0.0000000000, 0.0151332850, 0.0135397483, -0.0143228853, 0.0235204305, 0.0001914684, -0.0025523738, 0.0044414555, -0.0246477518, 0.0008357674, -0.0091405427, -0.0002641584, 0.0106687471, -0.0009641970, 0.0075992933, -0.0003582378, 0.0263137314, -0.0215469934, 0.0076421895, -0.0045339703, 0.0195706990, 0.0249600206, -0.0038967403, 0.0031210359, 0.0092203598, -0.0000000006, 0.0187058467, 0.0052183131, -0.0033430452, 0.0068877670, 0.0016992629, -0.0039560888, 0.0147581203, 0.0232540630, 0.0000007401, -0.0034699179, -0.0218380578, 0.0112335514, -0.0026498088, 0.0064168731, -0.0018173928, 0.0169042759, 0.0000001221, 0.0139447916, 0.0219981559, 0.0096275918, 0.0003779777, -0.0006279951, 0.0001230597, -0.0165910032, 0.0062444466, -0.0015544845, 0.0103091607, -0.0003820598, -0.0016578690, 0.0150658051, 0.0135761788, 0.0098596262, 0.0020597866, -0.0052734762, -0.0200699233, 0.0005541922, -0.0052246419, 0.0026756625, -0.0000000003, 0.0032286500, 0.0124593657, -0.0370681621, 0.0092943339, -0.0024524424, -0.0201818608, 0.0106238425, -0.0146622006, 0.0087434007, -0.0001481358, -0.0002964162, 0.0413755886, -0.0132259894, -0.0013260411, -0.0100992527, 0.0321021974, -0.0157519672, -0.0105477767, 0.0188404955, 0.0210001003, -0.0093405331, 0.0150141409, 0.0011191890, -0.0083582625, 0.0000000000, -0.0025263994, -0.0015602602, -0.0156916659, 0.0084305881, -0.0005726017, 0.0057633733, -0.0115478300, -0.0025095921, 0.0000004811, 0.0126317246, -0.0015371752, -0.0022349153, 0.0044919690, -0.0021965911, 0.0024203507, -0.0079770684, -0.0000000004, -0.0050564907, 0.0062684938, -0.0095405672, 0.0004950848, -0.0096122297, -0.0145118497, 0.0169095825, 0.0085722627, 0.0082192980, 0.0063954182, 0.0027401536, -0.0083667859, -0.0143092377, -0.0155379614, 0.0033799037, 0.0007382447, -0.0245947056, -0.0154219232, 0.0002561922, 0.0086661512, -0.0130793918, 0.0000000000, 0.0009536510, -0.0031383997, -0.0042065876, 0.0036068184, 0.0000479694, 0.0091547938, 0.0019932149, 0.0126856891, -0.0027669086, -0.0073599103, -0.0003009284, -0.0178157557, 0.0042538908, 0.0113629717, -0.0130622322, 0.0026935386, 0.0075740069, -0.0011595340, -0.0066752164, 0.0216992386, -0.0007039973, -0.0002949693, 0.0005010662, -0.0025879215, 0.0000000000, 0.0122069819, -0.0016094866, -0.0002194495, -0.0116286855, -0.0010770117, 0.0052466365, 0.0138058458, 0.0018213928, -0.0000000005, -0.0023375230, 0.0084315250, -0.0176178645, -0.0021462843, -0.0125049166, -0.0022898715, -0.0101652797, -0.0000000000, -0.0009871357, -0.0101787774, -0.0183642469, 0.0000000386, 0.0002803250, -0.0001899823, 0.0007017542, -0.0029850937, 0.0119419880, -0.0112918047, -0.0042832168, 0.0140238488, -0.0116251875, -0.0043841917, -0.0047055064, 0.0026654908, 0.0005243819, 0.0142955538, 0.0032977501, 0.0099664163, 0.0105874166, -0.0000000000, -0.0013598155, -0.0007157094, 0.0206622742, 0.0090181362, 0.0000543955, 0.0021127637, -0.0130229974, 0.0147577021, -0.0047916183, 0.0391370282, -0.0000694313, -0.0183330495, 0.0131969508, 0.0201660283, 0.0084154122, -0.0096489089, -0.0020835458, -0.0156646762, -0.0044734883, -0.0108071920, -0.0075373477, 0.0058801281, 0.0109813288, 0.0051909508, -0.0000001834, 0.0055267210, -0.0057580732, 0.0155915814, 0.0041906862, 0.0007999438, 0.0042016949, -0.0151204169, -0.0038446956, -0.0000003341, 0.0021155518, 0.0304274801, -0.0030528195, 0.0023442458, 0.0104072932, -0.0097014699, -0.0085792867, -0.0000503423, -0.0172606912, 0.0038927905, 0.0073160669, 0.0000859076, -0.0162802562, 0.0081737861, 0.0165365487, -0.0024235160, 0.0047972081, -0.0127643384, -0.0108164027, -0.0120084174, -0.0125515852, -0.0182049256, -0.0089305593, 0.0047456361, -0.0195772126, 0.0105314655, 0.0144042093, -0.0089703966, -0.0006793117, -0.0000000859, 0.0048233015, -0.0230172090, 0.0181366038, 0.0065254970, 0.0004758909, 0.0105912825, -0.0025329276, 0.0052087940, -0.0181852449, 0.0100124311, -0.0021600167, -0.0255469698, 0.0047672158, 0.0176754780, -0.0037711957, -0.0094283707, 0.0259705503, 0.0060270075, 0.0007185121, 0.0110694412, 0.0007343162, 0.0103947911, -0.0133155687, -0.0069848839, 0.0000000000, 0.0037988746, -0.0035337079, 0.0110778110, 0.0189157538, -0.0001202408, -0.0045949565, 0.0144081209, 0.0096695507, 0.0000006908, -0.0152366925, -0.0163785517, -0.0042658402, 0.0122666648, -0.0012483906, -0.0003221220, -0.0124667203, -0.0000149280, -0.0093822116, -0.0086568445, 0.0062446417, 0.0000061242, -0.0000443193, -0.0018621905, 0.0099374466, -0.0113401543, 0.0000792639, -0.0031136288, 0.0097699761, 0.0068219700, -0.0150740677, -0.0162874460, -0.0163987037, -0.0090643959, -0.0131536014, -0.0201489776, -0.0069330060, 0.0020656656, 0.0003644201, 0.0000000000, 0.0074969949, -0.0114997728, -0.0186426435, -0.0005165268, 0.0001177294, 0.0160156265, -0.0012317691, 0.0210182313, 0.0074705593, 0.0071265171, 0.0001583948, -0.0091592837, 0.0015240636, 0.0220523719, 0.0176979266, -0.0028966202, -0.0094119534, -0.0013975514, -0.0072061513, 0.0170308314, -0.0099149877, 0.0049706278, 0.0086326478, -0.0090189129, -0.0000001283, 0.0010426092, -0.0131134205, 0.0119922180, 0.0137189459, -0.0024708356, -0.0136469956, 0.0023136563, 0.0113082016, -0.0000038580, -0.0017913764, -0.0267687216, 0.0061640982, 0.0001558078, 0.0118177040, -0.0041456707, 0.0287928637, -0.0000446176, -0.0127091799, -0.0130419238, 0.0089816628, -0.0019413024, 0.0025857640, 0.0022821950, -0.0136520611, -0.0035964255, 0.0217717383, 0.0177278891, -0.0066845487, -0.0035825595, 0.0147415800, 0.0129783042, -0.0105833560, -0.0148048392, -0.0078885844, -0.0104136718, -0.0036643499, 0.0198337752, -0.0205539856, -0.0000000341, 0.0009190060, -0.0147099672, -0.0148380650, -0.0106430901, -0.0000758595, -0.0108259376, -0.0094055366, -0.0030240195, 0.0095533878, 0.0087705757, -0.0059557655, 0.0113796955, -0.0097416611, -0.0061706561, 0.0089231487, 0.0101382872, 0.0072726905, -0.0076354621, 0.0161711331, 0.0052396711, -0.0385099053, -0.0030637966, -0.0007515652, -0.0000985812, 0.0000000000, 0.0000643002, -0.0007841488, -0.0030863839, -0.0009468386, 0.0000096354, -0.0011738995, 0.0046532354, -0.0016317272, 0.0000000000, 0.0023647975, 0.0013511324, -0.0004983955, 0.0017076072, -0.0000015511, 0.0006403596, -0.0002705436, 0.0000000000, 0.0033335832, -0.0016391699, -0.0030367624, 0.0000001451, -0.0005241372, -0.0023269418, 0.0013876994, 0.0012594793, -0.0001063460, -0.0001160833, -0.0000539102, 0.0021129756, -0.0016756768, -0.0005631595, -0.0007592263, -0.0018653919, 0.0021292833, 0.0021916993, -0.0011258007, 0.0018355772, -0.0026658576, 0.0000000000, 0.0001398700, -0.0004568210, -0.0016033988, 0.0013481658, -0.0000745471, -0.0008356728, -0.0013348578, 0.0017098621, 0.0023649398, 0.0025817086, 0.0000150571, -0.0011950524, 0.0008803445, -0.0012821535, -0.0021830259, 0.0007170393, -0.0027430395, 0.0007833611, -0.0032317070, 0.0008033888, -0.0001984357, -0.0064110840, 0.0000794208, -0.0014529106, 0.0000000000, -0.0027120004, 0.0032432477, -0.0050218091, -0.0016187787, -0.0000440300, -0.0014291789, 0.0064344429, -0.0048547890, -0.0000000013, 0.0023153871, 0.0036279284, -0.0029220071, -0.0014865826, -0.0016993633, 0.0005314079, 0.0042577144, 0.0000000000, -0.0002218795, -0.0004901033, -0.0092926128, 0.0000003590, -0.0004257109, -0.0035360523, 0.0053545702, -0.0012730213, -0.0000854039, -0.0008735099, -0.0029964680, 0.0057641692, -0.0008290623, -0.0002342109, 0.0015237385, -0.0039094817, 0.0054764375, 0.0046205116, -0.0027967861, 0.0059352471, -0.0083263768, -0.0000000000, 0.0008964823, 0.0042720283, 0.0009923801, -0.0007017813, -0.0000798971, -0.0024062460, -0.0038353174, 0.0051819980, 0.0108384686, 0.0066129221, 0.0000236019, -0.0021827032, 0.0011668061, -0.0021858229, 0.0008228580, 0.0018160321, -0.0092833610, -0.0015071894, -0.0093512144, 0.0020182540, -0.0042336415, 0.0152064264, 0.0059804339, -0.0076033971, 0.0000000000, -0.0047387532, 0.0024108994, 0.0031923458, -0.0054203770, -0.0022658270, 0.0024173784, -0.0079302946, -0.0058120908, -0.0000000000, 0.0006078711, 0.0008213619, -0.0138893444, -0.0083302874, 0.0071630459, -0.0002275032, -0.0016968179, -0.0000000000, -0.0072343210, 0.0011197315, 0.0129154101, -0.0000038411, 0.0018442884, -0.0069974191, 0.0068873647, 0.0023609665, -0.0036244753, -0.0073594959, 0.0013942104, 0.0017196994, -0.0157998893, 0.0012817702, 0.0039807735, -0.0017962371, 0.0005591318, -0.0149674611, 0.0047856933, -0.0108671449, -0.0000227810, 0.0000000000, 0.0022205298, 0.0175428614, -0.0050017391, 0.0051689553, 0.0001595055, -0.0011058876, 0.0069036903, 0.0015378102, -0.0065132673, -0.0003115280, -0.0000290705, -0.0104172844, -0.0019433604, 0.0175399110, -0.0002736304, -0.0062227440, 0.0070257671, -0.0072946190, 0.0036621727, 0.0029037963, 0.0094461739, -0.0014220318, -0.0010415068, -0.0002953330, 0.0000000000, -0.0087836469, 0.0031578185, 0.0012345951, -0.0036512399, 0.0007465230, 0.0009637157, -0.0036006842, -0.0010435936, -0.0000000000, -0.0045049740, 0.0062067779, -0.0109313317, -0.0048337178, -0.0015712273, -0.0005693969, 0.0001705327, -0.0000000000, -0.0032971532, -0.0043362849, 0.0032281934, 0.0000001086, -0.0050330148, 0.0022772006, 0.0030857332, -0.0005941214, -0.0032408217, -0.0057848007, -0.0018382618, -0.0030365649, -0.0099794529, 0.0005855506, 0.0084817698, -0.0035621270, -0.0013473543, 0.0005958272, 0.0006346683, -0.0046958202, -0.0052260454, 0.0000000000, -0.0008279065, 0.0024926327, 0.0052992697, -0.0049404558, 0.0000044193, 0.0022645465, -0.0017881731, -0.0034685603, -0.0045604170, 0.0026050890, 0.0000086333, -0.0067017460, -0.0036656768, 0.0096992161, 0.0058221086, 0.0008545904, -0.0029456546, -0.0028537256, 0.0033941506, -0.0099736210, 0.0050961603, -0.0025632815, -0.0030170314, 0.0005087946, 0.0000000000, 0.0003344521, -0.0006690448, -0.0028345443, -0.0002058522, -0.0005026495, -0.0022618973, -0.0054210420, 0.0033260381, 0.0000000038, 0.0013639090, 0.0006811688, 0.0019458652, 0.0030256587, -0.0025694398, 0.0009530361, -0.0009207670, -0.0000000035, 0.0014790166, 0.0057802694, 0.0002358331, 0.0000051476, -0.0006874490, -0.0056368988, 0.0032800073, 0.0049459138, -0.0034145287, 0.0015999399, 0.0056961249, 0.0010526089, 0.0012132832, -0.0085571585, 0.0029110555, -0.0041949037, 0.0039806357, 0.0027100476, -0.0021463954, 0.0033394608, -0.0018611196, 0.0000000000, -0.0018353994, -0.0026896871, -0.0003173102, -0.0021117837, -0.0000254000, 0.0052170018, 0.0009092607, 0.0008891893, 0.0027927784, -0.0024982973, 0.0000381031, 0.0014627354, 0.0007864921, -0.0047480413, -0.0055027008, -0.0003804796, -0.0034327190, 0.0043422598, -0.0006856618, 0.0000687552, -0.0041233893, -0.0074984771, -0.0053991405, -0.0094594378, 0.0000000000, -0.0024557204, 0.0059859194, 0.0132949352, 0.0029565787, -0.0035145914, -0.0055907369, -0.0053162752, -0.0039642663, 0.0000000004, -0.0058782427, 0.0030009653, -0.0015414522, -0.0080725271, 0.0087726815, 0.0006441499, 0.0028694298, 0.0000000000, 0.0002981509, -0.0028735385, -0.0120696323, 0.0000096994, -0.0009875261, 0.0005236485, 0.0142710553, 0.0059686364, -0.0058534960, -0.0036611268, -0.0066868416, -0.0079410151, -0.0086070923, 0.0072995611, -0.0068162917, -0.0017801529, 0.0115638375, -0.0084811775, 0.0019414218, -0.0059876670, 0.0098927990, -0.0000000000, -0.0011793773, 0.0161369201, -0.0130633358, 0.0060757804, -0.0000812335, -0.0064744614, -0.0086674336, -0.0002797779, -0.0044900468, -0.0031877228, 0.0000088398, 0.0118810562, -0.0085231792, 0.0075801280, -0.0023929335, -0.0037274749, 0.0016330745, -0.0097107785, 0.0118145691, 0.0055177482, 0.0100727426, 0.0024308837, -0.0003132460, -0.0018853481, 0.0000000000, -0.0003903974, 0.0004571351, -0.0051448382, 0.0037719074, -0.0031761588, -0.0028274145, 0.0051925513, -0.0065397508, 0.0000000043, -0.0002594952, 0.0042344774, -0.0019488279, 0.0039585354, 0.0020766435, 0.0004723946, -0.0037596552, -0.0000000000, 0.0029366708, -0.0047384524, -0.0007798702, 0.0000010583, -0.0007089577, 0.0004080696, 0.0108951349, 0.0014426500, -0.0014251007, 0.0009594568, -0.0038965174, 0.0030899930, 0.0014292838, 0.0030970760, -0.0031210443, -0.0017207296, 0.0047781970, -0.0042543802, -0.0022323709, 0.0021047108, 0.0044877152, 0.0000000000, -0.0057844208, 0.0006284062, -0.0076466966, 0.0011871473, -0.0001153402, 0.0021002144, -0.0016168150, 0.0051147388, 0.0038518123, 0.0009524197, 0.0000133963, -0.0018758050, -0.0057283007, 0.0061715995, -0.0048460886, 0.0042217015, -0.0050934325, -0.0094185518, -0.0045236107, 0.0028728682, -0.0036346240, 0.0039231665, 0.0063699055, 0.0001091745, 0.0000000000, -0.0000042502, -0.0009357135, -0.0049641440, 0.0056037139, -0.0033932901, -0.0020185951, -0.0005776301, 0.0001214836, 0.0000000027, 0.0029728073, -0.0030199715, 0.0006820638, 0.0022000184, -0.0012154173, 0.0007835518, 0.0030021723, 0.0000000001, 0.0070234775, -0.0010496257, -0.0018455756, 0.0000049129, -0.0006092295, -0.0003208785, 0.0023630022, 0.0055367481, -0.0012365811, 0.0034858987, -0.0006351869, 0.0069675962, 0.0054017608, 0.0004039806, 0.0008060475, -0.0049015577, 0.0047067860, -0.0011069076, -0.0046581291, 0.0011528205, 0.0001562610, 0.0000000000, -0.0043362267, -0.0016548345, -0.0052041495, -0.0016754239, 0.0000496769, 0.0021095218, 0.0003070537, 0.0007123746, 0.0040362990, -0.0032571445, 0.0000407935, 0.0057394165, -0.0014204320, 0.0004657849, -0.0074631637, 0.0060705692, -0.0051232469, 0.0036095711, -0.0022639567, -0.0002479746, -0.0054791346, -0.0035511435, 0.0004997271, 0.0001080227, 0.0000000000, 0.0006582986, 0.0000827923, -0.0012397274, 0.0015983833, 0.0001662090, -0.0007053528, 0.0094200019, 0.0002039260, 0.0000000000, -0.0002139263, 0.0015410401, -0.0020168603, 0.0027562245, 0.0002631961, 0.0004446854, 0.0005920894, -0.0000000000, -0.0003826950, -0.0023876827, -0.0009288439, 0.0000001257, -0.0006744363, -0.0018713826, 0.0029931383, -0.0015217913, -0.0013726949, 0.0012289686, -0.0002482129, 0.0043555084, -0.0013632042, -0.0002964380, -0.0000709926, -0.0031184694, 0.0004358196, -0.0005643526, -0.0020624697, 0.0023562189, -0.0016110301, 0.0000000000, -0.0053261733, -0.0003516029, -0.0081651602, 0.0016071124, -0.0000853312, 0.0007206473, -0.0000836757, 0.0046722088, 0.0038684274, 0.0002309363, 0.0000117674, -0.0000563559, 0.0011460581, 0.0027431331, -0.0015929353, 0.0018084805, -0.0055657448, -0.0045569371, -0.0026937700, -0.0002216920, 0.0005331867, 0.0008617546, 0.0026388823, -0.0002732458, -0.0000000027, -0.0122268526, -0.0064776517, 0.0176192764, 0.0017417958, -0.0016682001, -0.0036899575, 0.0138096223, -0.0036174608, -0.0000002527, -0.0100503284, 0.0099733006, -0.0037134369, 0.0059707430, 0.0038284990, -0.0078756334, 0.0017484704, -0.0000000049, -0.0113110710, -0.0120813511, -0.0087211244, -0.0002012723, -0.0152368788, 0.0048897555, 0.0030679177, -0.0174616128, 0.0116184726, 0.0026229799, -0.0007339422, 0.0019845455, -0.0016998836, 0.0075465110, -0.0047026533, 0.0101169869, -0.0161810778, 0.0142234992, 0.0021226620, -0.0021675264, -0.0229459759, -0.0000000001, -0.0010813143, -0.0083721075, 0.0251033325, -0.0022935928, 0.0001252140, 0.0051500103, -0.0133697893, 0.0087464536, -0.0059245853, 0.0217679571, -0.0012205860, -0.0276860707, -0.0020428349, -0.0081324819, 0.0164097082, -0.0049599609, 0.0056203245, -0.0088361967, 0.0017290174, -0.0079917433, -0.0041519552, 0.0002822260, 0.0001280447, 0.0002182664, 0.0000000000, -0.0109071648, -0.0048425309, 0.0005309752, 0.0128101697, 0.0009384801, -0.0008329314, 0.0037730657, -0.0038359789, 0.0000000468, -0.0028770990, 0.0104503864, -0.0050731855, -0.0008113610, 0.0009053724, -0.0011431003, 0.0010121941, -0.0000000000, 0.0004703719, -0.0059180330, -0.0080373324, -0.0000000005, -0.0001582874, 0.0044451687, 0.0030857644, -0.0031070330, 0.0059419507, 0.0011598193, -0.0018658233, 0.0011141696, -0.0033867615, 0.0037849722, -0.0003192260, 0.0021330467, -0.0138460314, 0.0045704707, -0.0008063014, 0.0061823488, -0.0021688193, 0.0000000000, -0.0000721144, -0.0044145025, 0.0012396919, -0.0032969005, 0.0000746554, 0.0014595164, -0.0036897389, 0.0079191094, 0.0023664148, 0.0106313648, 0.0000007606, -0.0103016496, 0.0010997260, -0.0015778639, 0.0047951387, 0.0000271303, -0.0007848989, -0.0084284218, 0.0001123770, -0.0010673065, -0.0088389367, 0.0239384864, 0.0096310219, -0.0014058504, -0.0000000181, -0.0103145111, -0.0055064359, 0.0097106416, 0.0103750201, -0.0076490268, 0.0040789540, -0.0091403462, 0.0047654537, 0.0000000104, 0.0028421346, -0.0027834780, -0.0079779513, -0.0050174003, 0.0184762701, -0.0063984613, 0.0161149688, -0.0000000394, -0.0087177511, 0.0074284500, 0.0205289740, -0.0006838584, -0.0039136987, 0.0072361543, -0.0103323190, -0.0012915398, -0.0041011097, 0.0018647370, 0.0060072453, 0.0035197411, -0.0062858970, 0.0062631401, -0.0019640001, 0.0032067257, -0.0240540430, -0.0051947669, 0.0069249468, -0.0131418994, -0.0202663168, -0.0000000009, -0.0115962643, 0.0006018848, 0.0019231460, 0.0004626349, -0.0006985721, -0.0005723485, 0.0040575010, 0.0010505912, -0.0013492184, 0.0018484255, -0.0013677133, -0.0141824456, -0.0151012233, 0.0116936984, -0.0005296032, 0.0025754771, 0.0270189941, -0.0219378527, 0.0121632451, 0.0032954752, -0.0038644895, -0.0020987832, -0.0007309947, -0.0000134224, 0.0000000000, 0.0000102613, 0.0006909893, 0.0002070059, -0.0015896145, 0.0004555812, -0.0011924545, 0.0014857004, -0.0004108050, 0.0000000000, 0.0013717521, 0.0018151125, 0.0002331815, 0.0005774244, 0.0005677137, 0.0004273706, -0.0016966396, 0.0000000000, -0.0005522948, -0.0015695051, -0.0013620757, 0.0000000501, -0.0010031968, -0.0024608856, 0.0005811515, 0.0012793576, 0.0003173379, -0.0009792935, -0.0002962260, 0.0008193109, -0.0031006276, -0.0006777276, -0.0002116738, -0.0017722095, 0.0020909738, 0.0021295394, -0.0008362291, 0.0023579511, -0.0032011515, 0.0000000000, -0.0010486720, 0.0003372276, -0.0010321029, 0.0013794537, -0.0000947747, -0.0006968500, -0.0008961121, -0.0004110282, 0.0010614740, 0.0015547337, 0.0000169467, -0.0009055751, 0.0000427663, 0.0000152396, -0.0046372735, 0.0000758812, -0.0018777230, -0.0003735950, -0.0017766537, 0.0009634576, 0.0021007836, -0.0070174104, -0.0043768063, -0.0042044804, 0.0000000000, -0.0076844213, 0.0005854178, 0.0140348608, -0.0008865651, -0.0013052771, -0.0018577005, 0.0004230684, -0.0005606331, 0.0000000001, 0.0030201590, 0.0017766354, 0.0020974120, -0.0026493173, 0.0033889161, 0.0010898521, -0.0042042872, 0.0000000000, 0.0006227827, 0.0015174277, -0.0051084114, 0.0000025333, -0.0006837535, -0.0100750774, 0.0108354716, 0.0060756253, -0.0017756283, -0.0064490284, -0.0034938131, -0.0025505445, 0.0001752445, -0.0018328815, 0.0008529150, -0.0033317492, 0.0159545522, -0.0046966644, 0.0024257335, -0.0051426082, 0.0034511299, 0.0000000000, 0.0014600141, 0.0052692425, -0.0102684684, 0.0022479743, 0.0000300970, 0.0005119730, -0.0012565434, 0.0000966356, -0.0041278820, -0.0037104189, 0.0000086344, 0.0029471035, -0.0027773522, 0.0095353490, -0.0106692575, -0.0024622735, -0.0001998676, -0.0049682362, 0.0046015959, 0.0009327092, 0.0067929863, 0.0022274961, 0.0059602377, -0.0027166647, 0.0000000000, -0.0067429896, 0.0058330093, 0.0067850407, -0.0115037644, -0.0028782678, 0.0000966047, 0.0052079498, 0.0018429094, -0.0000000000, -0.0037904545, -0.0018478429, -0.0070672501, -0.0063941302, 0.0045586661, -0.0036296914, 0.0089291930, -0.0000000000, -0.0040393295, 0.0019346330, 0.0001171277, -0.0000015463, -0.0091348747, 0.0078142164, 0.0002261561, -0.0056110141, 0.0006422930, -0.0083708614, 0.0004898936, 0.0081888046, 0.0012870100, 0.0103150988, -0.0040950598, 0.0077980151, -0.0048549874, -0.0022458723, 0.0080637634, -0.0146426484, -0.0031504263, -0.0000000000, 0.0030163319, 0.0023012925, 0.0063507645, -0.0091779586, 0.0002280249, 0.0076705101, -0.0033534232, -0.0073765093, -0.0050554019, 0.0010929311, -0.0004802279, -0.0134208165, -0.0072496822, -0.0044798926, 0.0179425869, -0.0038468554, -0.0041975947, -0.0079271337, -0.0017726901, -0.0093141869, 0.0114153279, 0.0097516086, 0.0026711149, -0.0017846677, 0.0000000000, -0.0045943605, -0.0003425064, -0.0072920485, -0.0028738165, -0.0003023160, -0.0013864082, -0.0089418720, -0.0004327154, -0.0000000085, 0.0000764624, -0.0001254381, -0.0001530305, -0.0033553820, 0.0014449353, 0.0007562021, -0.0035780543, 0.0000000001, 0.0010202826, 0.0033828837, 0.0059955870, 0.0000048419, -0.0006982567, -0.0015317078, 0.0063075610, 0.0010265849, 0.0055058058, -0.0017522274, 0.0048265629, 0.0033538057, -0.0032028386, 0.0032158701, 0.0033172758, -0.0059336899, -0.0046541886, -0.0100807790, -0.0037570372, 0.0004344117, -0.0016939676, 0.0000000000, -0.0079800570, 0.0001269808, -0.0115656005, 0.0097972499, -0.0001546291, 0.0046957280, 0.0018989739, 0.0022450713, 0.0040355572, 0.0024811097, 0.0000266435, -0.0027022820, 0.0042961333, 0.0167421903, -0.0113353431, 0.0019522350, -0.0086957719, -0.0039022295, -0.0093774209, 0.0073471148, -0.0029667781, -0.0001379280, 0.0065692402, -0.0034412148, 0.0000000000, -0.0024802259, 0.0003700682, -0.0077082338, -0.0010968563, -0.0022924521, 0.0012627500, 0.0042103222, -0.0034454835, -0.0000000000, -0.0012771756, -0.0000522964, 0.0138223274, -0.0067979740, 0.0003974024, -0.0001220612, 0.0056728893, -0.0000000000, 0.0001561830, 0.0054783230, 0.0082387170, 0.0000002980, 0.0018714340, -0.0028153227, -0.0015851249, 0.0038216210, -0.0027637184, -0.0001344238, 0.0013814225, 0.0017098219, 0.0084280130, 0.0081761302, -0.0035549053, 0.0019120874, 0.0038242273, -0.0059093703, 0.0066840816, -0.0029351769, 0.0008215487, -0.0000000000, 0.0029812832, 0.0085876016, -0.0046459176, 0.0017217410, -0.0000058288, -0.0013893425, 0.0014295522, -0.0002460198, -0.0052270251, -0.0055899546, -0.0000235917, 0.0000915007, -0.0186576732, -0.0091121253, 0.0079249861, -0.0020653505, 0.0070355018, 0.0002559998, -0.0068437085, -0.0040989663, 0.0057967943, -0.0082038818, -0.0089291241, -0.0032080321, 0.0000000000, -0.0191786978, 0.0001849448, -0.0014976138, -0.0028516324, -0.0019913758, -0.0013806638, 0.0091413138, -0.0056032166, -0.0000000564, -0.0009734700, 0.0068223253, -0.0038193185, -0.0013176911, -0.0003556714, 0.0009628846, -0.0087607410, 0.0000000000, -0.0025347359, -0.0077575832, -0.0229546707, 0.0000000821, -0.0009913335, -0.0045821755, 0.0166807715, -0.0025444620, 0.0020584452, -0.0056691999, -0.0095246360, 0.0058516711, -0.0015922865, -0.0086377002, -0.0026851336, -0.0072936970, 0.0025274879, 0.0058576236, -0.0030327535, 0.0045329742, -0.0097335214, 0.0000000000, -0.0059823492, 0.0067829164, 0.0150626311, -0.0028706149, -0.0001048621, 0.0011134082, -0.0066071423, 0.0143267903, 0.0078636929, 0.0092388215, 0.0000281864, -0.0155599732, 0.0011513107, 0.0049328106, -0.0033927192, -0.0055303485, -0.0026294687, -0.0135926325, -0.0065120379, -0.0070232009, -0.0007995425, -0.0033601034, -0.0032057643, 0.0023631107, 0.0000000000, -0.0077520730, -0.0066023879, -0.0028437935, -0.0031325526, 0.0016410822, 0.0032104894, 0.0008680995, 0.0092228549, 0.0000000000, 0.0084335972, 0.0150903193, 0.0143033992, -0.0078832889, -0.0018455018, 0.0005785347, -0.0052589220, 0.0000000000, 0.0105489399, 0.0070150932, -0.0054052905, 0.0000003187, 0.0028063969, -0.0036600975, -0.0078483485, 0.0075643971, 0.0062153270, 0.0053749140, -0.0059342631, -0.0059173419, 0.0059787608, -0.0040965686, 0.0087981578, -0.0003232001, 0.0137744667, 0.0043400726, 0.0028545768, -0.0014232032, -0.0079944329, 0.0000000000, 0.0004135613, -0.0142901493, 0.0005982678, 0.0029875878, 0.0000736779, 0.0038157450, -0.0002101426, -0.0147031434, -0.0097398357, 0.0034880978, 0.0000051640, 0.0131034916, -0.0029571680, 0.0058126776, -0.0102230506, -0.0043065962, -0.0032048763, 0.0156421736, 0.0027884298, -0.0027701685, -0.0052045127, -0.0033745668, -0.0052723591, -0.0026271977, -0.0000000066, -0.0091424091, 0.0017674268, 0.0124080814, -0.0112679275, 0.0013557380, -0.0024168943, 0.0064755841, -0.0026225443, -0.0000238779, -0.0053348579, -0.0247372091, -0.0104234470, -0.0059295832, 0.0017121284, -0.0015161718, 0.0014360828, -0.0000000105, -0.0035474375, -0.0088006249, -0.0012240270, -0.0000076410, 0.0040021162, 0.0053201090, 0.0148739051, -0.0084682871, -0.0017856848, -0.0011155617, -0.0034847958, 0.0109017249, 0.0079643736, -0.0042282534, 0.0005620238, 0.0068207611, 0.0066414666, -0.0124259321, -0.0096922200, -0.0067183273, 0.0164418742, -0.0000000017, 0.0002880826, 0.0025287645, -0.0089611951, -0.0083806776, -0.0000380111, 0.0039745043, 0.0054191020, 0.0089051323, 0.0163883679, -0.0044090906, -0.0001799039, -0.0228926949, 0.0129301129, -0.0009890707, 0.0131650399, 0.0022251133, -0.0078571485, -0.0102456622, -0.0096947635, -0.0088847587, -0.0129305730, 0.0065105273, -0.0113199763, -0.0008658111, 0.0000000003, -0.0029463458, -0.0026247585, -0.0089967353, 0.0170648061, -0.0018345906, -0.0051758708, -0.0030291590, 0.0116164992, 0.0000000041, 0.0071374821, -0.0019592894, -0.0018896200, -0.0050250930, 0.0037814032, 0.0020126153, -0.0037923937, -0.0000000474, 0.0040653259, 0.0178740378, 0.0021172429, 0.0000137250, 0.0007121483, 0.0013333871, 0.0180045459, 0.0095915478, -0.0062450753, 0.0077441847, 0.0117115872, -0.0023566505, -0.0086254384, -0.0034112534, 0.0038532126, -0.0078916932, -0.0081245834, -0.0163199026, -0.0027982511, 0.0005918496, 0.0070660356, 0.0000000000, -0.0085354494, 0.0037583367, -0.0177862328, 0.0003148550, -0.0001668267, 0.0083855521, 0.0044865534, 0.0052852295, 0.0024592788, -0.0093409503, 0.0000919021, 0.0035289621, -0.0042333226, 0.0054683099, -0.0126010757, 0.0029083318, -0.0007458841, -0.0143138813, -0.0062152902, 0.0187710077, -0.0054883659, -0.0040266775, 0.0022038189, -0.0009267853, 0.0000000000, -0.0153514296, 0.0014318385, -0.0116303740, 0.0030652983, 0.0010647652, -0.0035938597, -0.0052992953, -0.0092464834, -0.0000000669, -0.0050900686, 0.0200922620, -0.0015141866, 0.0093568703, 0.0005715109, 0.0010205030, -0.0039961236, -0.0000000000, -0.0008112130, -0.0075653810, -0.0097861113, 0.0000003895, -0.0012924101, -0.0054475940, 0.0070564058, -0.0029092897, -0.0006193124, 0.0007770794, -0.0072320597, 0.0005341550, -0.0021448864, -0.0041106073, 0.0067185927, -0.0094114412, 0.0004579450, 0.0064034089, -0.0019115668, 0.0046849400, -0.0156887472, 0.0000000000, 0.0022481375, -0.0013694565, 0.0041071814, -0.0070194998, -0.0001260187, 0.0026874631, -0.0043940237, 0.0108196614, 0.0049649277, 0.0094989259, 0.0000484130, -0.0084744990, -0.0056816419, 0.0011620148, 0.0002728673, -0.0001161672, -0.0027025444, 0.0048317211, -0.0038152898, -0.0072838706, -0.0086894967, 0.0089368885, -0.0043736785, -0.0003600034, 0.0000000000, -0.0138591882, -0.0069810408, -0.0042164545, 0.0265110191, 0.0001560235, 0.0011174863, -0.0065419259, 0.0128861023, 0.0000000208, 0.0045806966, -0.0003868576, -0.0011836777, 0.0056652729, 0.0041524433, 0.0002579886, 0.0013713900, -0.0000000033, -0.0011015044, 0.0051978878, -0.0056210961, 0.0000018554, 0.0001791991, 0.0063028699, 0.0108660860, -0.0023519674, 0.0056066527, 0.0061442764, 0.0140490914, -0.0040830579, -0.0093279062, -0.0034379587, 0.0072630332, -0.0025225081, -0.0264827609, -0.0011092220, -0.0029470227, 0.0009156677, -0.0096821291, 0.0000000000, -0.0105195455, -0.0018595775, -0.0020290159, 0.0048789517, -0.0000263431, 0.0083262241, 0.0008854574, 0.0117686475, 0.0038115478, -0.0018772328, 0.0000158395, -0.0095970314, -0.0036165826, 0.0078134509, -0.0029844372, -0.0041419100, 0.0074564805, -0.0026016538, 0.0000860582, 0.0103988405, -0.0141306221, -0.0020044385, -0.0061289957, -0.0012221758, 0.0000000000, -0.0102849025, -0.0021853433, 0.0156155238, 0.0030679067, -0.0000731538, -0.0006889146, -0.0015712414, -0.0013732204, -0.0000000000, 0.0011004965, -0.0065900935, -0.0055178022, -0.0089344485, -0.0028705688, 0.0005552014, -0.0094441362, -0.0000000000, -0.0011484587, -0.0062010274, -0.0045703789, 0.0000021408, -0.0002839290, -0.0054285624, 0.0113723772, 0.0065126647, -0.0065574404, -0.0096380431, -0.0005861846, 0.0010094030, -0.0074265846, -0.0052843047, -0.0038891805, -0.0030173461, -0.0054370440, -0.0051603783, -0.0017409921, -0.0006619435, 0.0027117387, 0.0000000000, -0.0088024298, 0.0066266088, -0.0066692578, 0.0005179041, -0.0000736421, -0.0002631668, -0.0062596113, 0.0088510793, -0.0000845863, -0.0025502325, 0.0000172296, -0.0067974371, 0.0008060998, 0.0209715422, -0.0074404986, -0.0018929908, 0.0026657523, -0.0169322472, 0.0008090145, -0.0036266833, 0.0070593758, 0.0165564418, -0.0012764286, 0.0018624435, 0.0000000000, -0.0159034505, -0.0061892723, -0.0035043184, 0.0077871936, 0.0021804629, 0.0103956908, -0.0170643851, 0.0087359538, -0.0000000000, 0.0024704970, -0.0009526964, 0.0020057976, 0.0048582801, 0.0056420253, -0.0012552929, 0.0016712568, 0.0000000002, -0.0060383114, 0.0086217457, 0.0189131014, -0.0000033525, 0.0010007449, 0.0036802664, -0.0121495221, -0.0041827313, 0.0121851638, -0.0043094638, 0.0164215621, -0.0001208193, -0.0048961453, -0.0039875112, 0.0076313121, 0.0020924094, -0.0243447442, -0.0070833508, 0.0021126524, -0.0055583538, -0.0153563088, -0.0000000000, -0.0001615550, -0.0016769054, 0.0082659405, 0.0022338058, 0.0002129203, 0.0065888860, 0.0094964672, 0.0009865018, -0.0059461854, -0.0033388725, -0.0000399406, -0.0177063122, -0.0011428974, 0.0058861631, 0.0014901136, -0.0050818170, 0.0156096285, 0.0019078844, -0.0004263174, 0.0070398436, -0.0036652097, -0.0012653752, -0.0008270807, -0.0059692087, -0.0000000000, -0.0063512255, -0.0017293659, 0.0090795076, 0.0102827922, -0.0042939465, 0.0087143099, -0.0005378222, 0.0023301905, 0.0000000000, 0.0006000939, 0.0166244097, 0.0037934897, -0.0003589941, 0.0131796012, -0.0008806978, 0.0132630151, -0.0000000000, 0.0056127799, 0.0102244159, 0.0048455186, 0.0000252094, 0.0004077595, -0.0025566334, -0.0036056475, 0.0021443404, -0.0061456920, -0.0032278157, -0.0021596013, -0.0044666305, -0.0007693978, 0.0071016792, -0.0098978356, 0.0020111029, -0.0040516988, 0.0017073493, 0.0085845301, -0.0028803993, -0.0145392716, -0.0000000000, 0.0047416743, 0.0034047801, 0.0033174877, 0.0042511197, 0.0002982296, 0.0027515488, 0.0050429534, -0.0121100284, -0.0059868898, 0.0011290219, -0.0000510173, 0.0028771223, -0.0174972974, 0.0054634712, -0.0078931134, -0.0088398149, 0.0078723505, -0.0037510463, 0.0062638931, 0.0029961788, 0.0035390835, 0.0011945635, -0.0033591106, -0.0042191078, -0.0000000000, 0.0168195814, 0.0037188819, 0.0031849223, 0.0113592744, 0.0009274675, -0.0053630085, -0.0003558318, 0.0062622451, 0.0000000231, -0.0082962178, 0.0040502134, -0.0025183267, -0.0110916840, 0.0096303858, -0.0010792067, 0.0081635052, -0.0000000001, 0.0028642286, 0.0059117433, -0.0066189282, -0.0000017755, -0.0063581252, 0.0141754197, 0.0105383499, 0.0061121662, 0.0027291495, 0.0116364416, -0.0016452242, -0.0079544112, -0.0129509233, 0.0152578615, -0.0044638906, 0.0012452290, 0.0019720397, -0.0093453825, 0.0062047374, 0.0045974981, 0.0080175987, -0.0000000000, -0.0035886434, 0.0063744574, -0.0143376933, 0.0083930241, -0.0005987998, -0.0040576444, -0.0086614480, -0.0001871788, -0.0107256593, -0.0038298126, -0.0000580887, 0.0211550146, -0.0035682013, -0.0029020547, -0.0011725032, 0.0045575439, 0.0015233266, -0.0111737680, 0.0173475482, 0.0223904215, -0.0014392884, -0.0006978865, 0.0007832127, -0.0045274859, 0.0000000000, -0.0095755374, 0.0005043910, 0.0047102608, 0.0116736619, 0.0002216614, 0.0006619624, -0.0044025383, -0.0006303779, 0.0000000000, 0.0009867749, -0.0005783865, -0.0024784764, -0.0030964124, 0.0036257061, 0.0010057666, -0.0036723677, 0.0000000000, 0.0007132438, -0.0016271145, 0.0043272306, 0.0000003894, 0.0001731497, -0.0112438397, 0.0097290948, 0.0017338727, -0.0110906903, -0.0048493212, -0.0030519404, 0.0003610595, -0.0052026394, -0.0019883683, 0.0037555851, -0.0051274211, -0.0018200787, -0.0114333015, -0.0009705905, -0.0062473090, -0.0087569421, -0.0000000000, -0.0076945378, 0.0018675065, -0.0158281978, 0.0013834526, -0.0000306965, 0.0035257302, 0.0026546335, 0.0005379473, 0.0040633697, -0.0068512144, 0.0000156733, -0.0040701055, -0.0027013021, 0.0121709807, -0.0074157841, -0.0004412608, -0.0056831697, -0.0075093159, 0.0001499654, 0.0000051146, 0.0040442417, 0.0085295085, 0.0068903086, -0.0030724872, -0.0000000000, 0.0011785724, -0.0001137643, 0.0096520763, -0.0009925127, -0.0033051278, 0.0082874754, -0.0045583239, 0.0048885914, 0.0000000000, 0.0013891640, -0.0096290065, -0.0073994133, 0.0016752236, 0.0055359583, -0.0007267115, 0.0070381449, 0.0000000000, 0.0001795100, 0.0075310967, 0.0094084572, 0.0000005299, -0.0002830436, 0.0037279734, -0.0062746294, -0.0018088698, 0.0012097353, -0.0049848612, 0.0009138852, 0.0025772322, 0.0013465878, -0.0025365064, -0.0054633990, -0.0022140287, -0.0150251836, 0.0009963093, 0.0009351880, 0.0013822410, -0.0249521881, -0.0000000000, -0.0024869153, 0.0083899116, 0.0091275200, -0.0011853162, 0.0000196180, 0.0023542177, 0.0019261182, -0.0094461674, -0.0021777183, 0.0047275857, 0.0000101872, -0.0089938724, -0.0072338064, 0.0046437308, -0.0026391482, -0.0049866629, 0.0007839065, 0.0004823028, 0.0089042429, 0.0008976095, 0.0000276644, 0.0197350532, 0.0012527341, 0.0036887587, -0.0000000647, -0.0036027255, -0.0053265346, 0.0162880011, -0.0112713538, -0.0019755368, 0.0041159978, 0.0063237487, 0.0074910978, -0.0000028375, 0.0018382031, -0.0105103739, -0.0066987588, -0.0041796924, 0.0041819033, -0.0063074734, -0.0012949212, -0.0000000235, -0.0140482783, 0.0052956473, 0.0209356695, -0.0008214818, -0.0010740944, 0.0056571122, -0.0113762254, -0.0116610983, 0.0095406733, -0.0077761677, 0.0059032091, -0.0007243567, 0.0017776580, -0.0037173256, 0.0021023145, 0.0062531088, -0.0160029344, -0.0053284070, 0.0021694093, -0.0163049586, -0.0163378082, -0.0000000117, -0.0112641314, -0.0093729720, 0.0154126268, 0.0008175043, -0.0027526575, 0.0012729970, 0.0041571185, -0.0067117456, -0.0020802768, 0.0009115159, -0.0017555596, -0.0241773389, 0.0060830400, 0.0066322037, 0.0107262172, 0.0020072085, 0.0158693567, -0.0112239830, 0.0023023426, -0.0071248971, -0.0031509202, 0.0037230710, 0.0007167204, -0.0018636128, 0.0000000000, -0.0200322308, -0.0087462924, 0.0111900484, 0.0175457858, -0.0030374280, -0.0016606527, -0.0070509566, 0.0089286575, 0.0000000023, -0.0020225735, -0.0013518209, -0.0155365821, 0.0003914865, 0.0090684704, 0.0000240636, 0.0044524190, 0.0000000000, -0.0058412906, -0.0018528112, -0.0029519957, 0.0000023367, -0.0004456134, 0.0057555740, 0.0223877747, -0.0017871360, 0.0050881300, -0.0017683053, 0.0108593982, -0.0001146597, -0.0169024952, 0.0047874474, 0.0040645511, 0.0023825651, -0.0082148788, -0.0113996528, 0.0000849513, -0.0035193241, 0.0077526057, 0.0000000000, -0.0035259873, 0.0151642011, -0.0075401999, 0.0097504668, -0.0000203623, 0.0115058273, -0.0012959733, 0.0141932331, 0.0052331965, -0.0008904928, 0.0000071212, -0.0150667736, 0.0004425912, 0.0204173531, -0.0034025076, -0.0060453396, 0.0000407045, -0.0175313428, 0.0100224195, 0.0068922709, -0.0052490681, 0.0295818299, -0.0047944011, 0.0056987144, -0.0000000208, -0.0117420657, -0.0149977356, -0.0063960552, 0.0247794464, 0.0007566024, 0.0022308992, -0.0160523467, 0.0314071514, 0.0000052129, -0.0094047012, 0.0102409152, 0.0069334512, -0.0045726579, 0.0207362399, 0.0009490638, 0.0043135607, -0.0000013255, 0.0062925150, 0.0271011498, 0.0183549691, 0.0000517613, 0.0022484756, 0.0084607825, 0.0101783369, -0.0087526310, 0.0091970824, 0.0034271597, 0.0208906513, -0.0021386773, -0.0036271906, 0.0004584204, 0.0125690792, 0.0013757187, -0.0230226200, -0.0332704261, -0.0041753938, -0.0166173521, -0.0131404977, -0.0000000000, -0.0179042425, -0.0238348935, -0.0367793925, 0.0107517559, 0.0009967152, 0.0181724224, 0.0040048989, -0.0121239023, 0.0060229907, -0.0081390347, -0.0001398531, 0.0154888565, 0.0120208422, 0.0409016982, -0.0161703601, 0.0157183595, -0.0120718880, -0.0047984943, 0.0058997748, 0.0319041274, -0.0288394205, -0.0015931702, -0.0010357824, 0.0005793235, 0.0000000000, 0.0000499810, -0.0001928521, -0.0006163204, -0.0014473356, 0.0003560895, -0.0012925908, -0.0022356273, -0.0007734242, 0.0000000000, 0.0022525794, 0.0015441672, 0.0009031097, 0.0010088753, 0.0007116285, 0.0004908617, -0.0015764198, 0.0000000000, -0.0006254314, -0.0017263466, -0.0008039559, 0.0000001320, -0.0008190432, -0.0017603583, 0.0005077174, 0.0013442631, 0.0004250034, -0.0002093162, 0.0000126159, -0.0007307954, -0.0006821452, -0.0006810744, -0.0002038883, -0.0018588991, 0.0020935351, 0.0019365649, -0.0008259811, 0.0016793791, -0.0027148116, -0.0000000000, -0.0011033840, -0.0001467400, 0.0001854898, 0.0015571748, -0.0000810912, -0.0010668463, -0.0004872580, -0.0005965268, 0.0009534179, 0.0010526230, 0.0000144499, 0.0004054324, 0.0006911655, -0.0003797374, -0.0042533269, 0.0003537954, -0.0006714626, 0.0023244990, -0.0018368408, 0.0011008425, 0.0012321224, -0.0021979075, -0.0010444368, -0.0000823568, 0.0000000000, -0.0016805704, 0.0002913281, -0.0009515177, -0.0022911008, 0.0002948673, -0.0015771183, -0.0073952810, -0.0026616261, 0.0000000000, 0.0034944324, 0.0017214930, 0.0001032785, 0.0023994294, 0.0006393516, 0.0006729874, -0.0017810374, 0.0000000000, -0.0007960709, -0.0018716707, -0.0015803649, 0.0000003590, -0.0010406545, -0.0032718729, 0.0019895511, 0.0022813105, 0.0004609372, -0.0026126967, -0.0006964558, 0.0006944066, -0.0011048201, -0.0014939959, -0.0005283278, -0.0030504256, 0.0026071081, 0.0025569752, -0.0022345388, 0.0020319903, -0.0029895662, -0.0000000000, -0.0001185372, 0.0049156053, -0.0008670953, 0.0009201321, -0.0000835729, -0.0021091539, -0.0006416684, 0.0004830287, 0.0022246451, 0.0014341606, 0.0000225878, 0.0000437950, 0.0000388827, 0.0022401356, -0.0057443939, 0.0007100738, -0.0016670650, 0.0041676541, -0.0038160926, 0.0002561260, 0.0018829424, -0.0008919510, -0.0016018188, -0.0047993567, 0.0000000000, 0.0012496649, -0.0001724840, 0.0116321053, -0.0000506442, -0.0021073390, 0.0001001938, -0.0014263367, -0.0010465368, -0.0000000000, -0.0023599840, -0.0026208821, -0.0099961776, -0.0060208612, 0.0042786291, -0.0002026736, 0.0024478282, -0.0000000000, 0.0005388723, -0.0041788598, -0.0003797328, -0.0000001023, -0.0070295162, 0.0053892350, 0.0070379372, -0.0018569218, -0.0070597581, 0.0077361385, 0.0017787006, -0.0055581774, -0.0112512568, 0.0021613028, 0.0014994139, 0.0026521944, 0.0011114806, -0.0098299421, 0.0058609475, -0.0020176813, 0.0137787201, -0.0000000000, -0.0046677808, 0.0128131229, -0.0033299208, -0.0005509591, 0.0002246125, -0.0000529830, -0.0009646318, 0.0060469420, -0.0004751539, -0.0012875366, -0.0000328370, -0.0038395913, 0.0010639747, 0.0058906735, 0.0045418018, -0.0028409746, 0.0029282665, -0.0088016978, 0.0140782623, -0.0027137671, -0.0051920400, 0.0017174903, -0.0021509118, -0.0030521692, 0.0000000000, -0.0020313654, 0.0030787827, 0.0041906321, -0.0081031667, 0.0002792578, 0.0014654925, -0.0077310377, -0.0023709380, 0.0000000000, -0.0011800085, -0.0006400164, -0.0039139935, -0.0018648182, 0.0020050949, 0.0000497211, 0.0000656798, 0.0000000000, 0.0001056480, 0.0001832145, 0.0024773497, 0.0000000106, -0.0045137140, -0.0005540458, 0.0006908744, -0.0022967362, -0.0010279753, -0.0028265985, 0.0010961753, -0.0015414108, -0.0064974958, -0.0012854661, 0.0044709337, -0.0037106597, 0.0008106656, 0.0007083842, -0.0004262142, 0.0014322321, -0.0014997482, 0.0000000000, -0.0018069413, 0.0050536939, 0.0018681330, 0.0021675173, 0.0000025438, -0.0000379294, 0.0010871592, -0.0027186936, 0.0005564805, 0.0022074429, 0.0000091011, -0.0038643777, 0.0008749837, 0.0044665597, -0.0018828138, -0.0020665347, 0.0024815341, 0.0001429830, 0.0008166909, -0.0011279166, 0.0005828950, -0.0024439858, -0.0023592091, 0.0003373595, 0.0000000000, -0.0003119677, -0.0002431519, -0.0020376081, -0.0017523853, 0.0003953892, -0.0014639783, -0.0023510919, -0.0003232353, 0.0000000014, 0.0023675982, 0.0016861552, 0.0009912377, 0.0014006699, 0.0000632707, 0.0009920313, -0.0036956856, -0.0000000000, 0.0003797658, -0.0024516515, -0.0011359927, 0.0000023883, -0.0013883018, -0.0029981441, 0.0013022671, 0.0025903536, 0.0000105688, -0.0003880519, -0.0001445691, -0.0007472975, -0.0012616848, -0.0010602725, 0.0013920863, -0.0032007457, 0.0031755907, 0.0026535937, -0.0012407372, 0.0029339779, -0.0029077034, 0.0000000000, -0.0022986094, -0.0003181938, -0.0000225948, 0.0016628575, -0.0000679577, -0.0008946157, -0.0013020325, -0.0015286915, 0.0012081385, 0.0008969338, 0.0000289124, 0.0029688478, 0.0008753986, -0.0007906220, -0.0059633558, 0.0000872451, -0.0018605229, 0.0030555318, -0.0027077850, 0.0008495596, 0.0010145459, 0.0013806857, -0.0014200701, 0.0014019137, -0.0000000000, 0.0006754062, 0.0024286655, 0.0008626632, -0.0039576464, 0.0005133976, 0.0053132167, -0.0009388832, 0.0049413554, 0.0000000000, -0.0015909218, -0.0088329008, 0.0045860335, 0.0014628401, -0.0038731627, 0.0001667711, -0.0036395267, 0.0000000000, 0.0001082703, 0.0040408075, 0.0041244328, 0.0000000155, -0.0046418118, -0.0065299077, -0.0061616125, 0.0027683210, 0.0010463821, -0.0080932491, -0.0003572086, 0.0024207814, 0.0013342382, -0.0050364551, 0.0004622125, -0.0062818988, -0.0085055437, 0.0043208296, -0.0015293232, -0.0040075397, -0.0167605430, 0.0000000000, 0.0012423771, -0.0074336892, 0.0020212594, -0.0022067013, -0.0001016123, 0.0030236403, 0.0007966636, -0.0083756912, -0.0022346645, 0.0011418179, 0.0000123617, 0.0098464703, -0.0013343886, -0.0044373795, 0.0028043345, 0.0021118149, -0.0049965661, 0.0071620164, 0.0010766245, 0.0015608055, 0.0054489109, -0.0008098324, -0.0020844783, -0.0002504535, 0.0000000000, -0.0004503473, 0.0000543919, 0.0016154425, -0.0014583231, 0.0009442834, -0.0010881114, -0.0022292202, -0.0011994429, 0.0000000000, 0.0007878082, 0.0011791083, 0.0001346634, -0.0012807118, -0.0006113534, 0.0005426316, -0.0020040427, 0.0000000000, -0.0005211116, -0.0022673754, 0.0000168312, 0.0000001454, -0.0008654071, -0.0029946128, 0.0007860960, 0.0014077973, -0.0017593125, -0.0007133892, 0.0001154906, -0.0010147031, -0.0026965798, -0.0005893995, 0.0001554682, -0.0018662767, 0.0009678501, 0.0019888012, -0.0007594406, 0.0033990594, -0.0022233126, -0.0000000000, -0.0024852324, -0.0001378645, -0.0005848563, 0.0017723980, -0.0000864996, -0.0010821226, -0.0013166515, 0.0003730011, 0.0009530240, 0.0008291326, 0.0000132111, -0.0016896894, 0.0013350553, 0.0021661627, -0.0041581886, -0.0007349954, -0.0004086617, -0.0008993006, -0.0019789026, -0.0002239826, 0.0017725241, -0.0013954955, -0.0019832752, 0.0008257799, 0.0000000000, 0.0007636601, 0.0006207484, -0.0001983666, -0.0013097257, 0.0000563231, -0.0014206370, -0.0003714024, -0.0000145984, 0.0000000002, 0.0026276391, 0.0006679606, 0.0007649029, 0.0011435498, -0.0000142890, 0.0007801441, -0.0032703229, -0.0000000000, 0.0005649417, -0.0015054565, -0.0008902635, 0.0000010491, -0.0014317294, -0.0028443497, 0.0016698873, 0.0036281920, 0.0004041932, 0.0003818608, 0.0000162449, -0.0007688527, -0.0001659237, -0.0002679254, -0.0005548049, -0.0032517419, 0.0028909114, 0.0026752977, -0.0011608453, 0.0036055895, -0.0018883647, 0.0000000000, -0.0026038261, -0.0011607754, -0.0006334301, 0.0015198670, -0.0001075215, -0.0007642517, -0.0007894877, -0.0020441771, 0.0002702980, 0.0005325791, 0.0000255324, 0.0035358628, -0.0001040966, -0.0013776877, -0.0049427133, 0.0001208224, -0.0023140544, 0.0032880362, -0.0011758992, 0.0010410454, -0.0000687945, -0.0014365205, -0.0001389995, 0.0006369194, 0.0000000000, 0.0005289227, 0.0003198112, 0.0002422406, -0.0012020271, 0.0002710189, -0.0015656418, -0.0031403915, -0.0004938136, 0.0000000000, 0.0014137597, 0.0008558693, 0.0004976600, 0.0016311996, 0.0016869402, 0.0004145604, -0.0016189868, 0.0000000000, -0.0003387206, -0.0012250966, -0.0005883388, 0.0000000396, -0.0008812220, -0.0012231370, 0.0019446564, 0.0008467048, 0.0002917380, -0.0012754390, 0.0001199911, 0.0001615329, -0.0012434643, -0.0004712859, 0.0002678644, -0.0019544300, 0.0018043139, 0.0018675340, -0.0007997251, 0.0015454248, -0.0026314459, 0.0000000000, -0.0009372939, 0.0003280673, 0.0006101538, 0.0012377168, -0.0000804762, -0.0007922080, -0.0008081011, -0.0008124569, 0.0008183219, 0.0010878388, 0.0000124451, 0.0001199900, 0.0000955012, -0.0006339566, -0.0036032135, -0.0000389271, -0.0000291447, 0.0017827789, -0.0007896375, 0.0010197685, 0.0018969717, 0.0192677137, 0.0113849789, -0.0034169783, -0.0000000009, -0.0112983594, -0.0107447943, 0.0042967559, -0.0087587265, -0.0027421156, 0.0036923066, -0.0023554142, 0.0003500583, -0.0000000113, -0.0008754162, -0.0031283943, 0.0019674294, -0.0008580915, 0.0046544881, -0.0053646788, 0.0063056438, -0.0000000028, -0.0128424233, 0.0077327560, 0.0044396808, -0.0005795156, -0.0003256711, 0.0001151458, -0.0084461095, -0.0063633933, 0.0003720556, -0.0057449574, 0.0060651824, 0.0096668582, 0.0071227262, -0.0048527885, -0.0014370765, 0.0043256483, -0.0095178215, -0.0040250551, -0.0032903806, -0.0125604225, -0.0212424453, -0.0000000000, 0.0000849130, -0.0068649231, 0.0097660869, 0.0023224044, 0.0001259163, -0.0009018578, 0.0020178163, 0.0028422696, 0.0044143293, 0.0108898515, -0.0006340189, -0.0149442488, -0.0014481819, 0.0059139179, 0.0022969542, 0.0046104281, 0.0152100986, -0.0056347302, 0.0007491523, -0.0047153966, -0.0106932381, 0.0033838102, -0.0012522297, 0.0017483633, -0.0000000000, -0.0002053558, 0.0004254907, -0.0057510310, -0.0041295658, 0.0024859793, 0.0012279871, -0.0061383094, -0.0046520433, -0.0000000028, 0.0030331218, -0.0021684377, 0.0016072100, -0.0012713908, -0.0027051915, -0.0002146359, -0.0071835900, 0.0000000000, -0.0001682420, 0.0033693472, -0.0011343058, -0.0000000000, 0.0007505018, 0.0014892118, -0.0030006988, 0.0019581346, 0.0031240266, -0.0035258115, -0.0011271770, 0.0031149052, 0.0067963065, 0.0003262651, -0.0018092369, 0.0018635127, 0.0009226482, -0.0005696716, -0.0047760764, 0.0000263020, 0.0111351544, 0.0000000000, 0.0013907393, -0.0089398641, 0.0009644459, -0.0056204610, 0.0000321971, 0.0029239154, 0.0018691093, 0.0022451920, 0.0020702234, -0.0005868947, 0.0000010162, -0.0055887019, -0.0031280895, -0.0024832247, 0.0042588501, 0.0041335379, 0.0019163748, -0.0011894772, -0.0104123745, -0.0035397862, 0.0016049357, 0.0044250977, 0.0048542209, 0.0019648897, -0.0000000135, 0.0095985075, 0.0103711970, 0.0055065183, -0.0013438083, -0.0006693132, -0.0015168645, 0.0045455201, 0.0025617795, -0.0000029004, -0.0080994703, -0.0042077722, -0.0039244960, 0.0008827500, 0.0002246225, -0.0051406841, 0.0040653385, -0.0000000074, -0.0102059385, 0.0034582017, 0.0015524735, -0.0007565944, -0.0173171554, 0.0100067174, 0.0073104384, -0.0011444666, 0.0019834661, 0.0013811931, 0.0036190173, 0.0016092156, 0.0039656218, 0.0046285489, -0.0046326518, 0.0036253573, -0.0007348026, -0.0060514733, 0.0018613554, -0.0047092754, 0.0069174077, -0.0000000014, 0.0036849852, 0.0001550119, -0.0001837592, 0.0020481134, -0.0090371389, 0.0000765407, 0.0031422600, 0.0075588538, -0.0077845277, -0.0005263087, -0.0008670080, 0.0006111179, -0.0009335193, 0.0070688734, 0.0144543862, 0.0051387157, 0.0067473683, -0.0114862267, 0.0084919045, -0.0017844714, 0.0129900808, -0.0018635920, -0.0011120758, 0.0005756024, 0.0000000000, 0.0002030220, 0.0003558201, -0.0004498176, -0.0016025415, 0.0004069009, -0.0014533467, -0.0027592087, -0.0000804219, 0.0000000000, 0.0017887627, 0.0019813629, 0.0013594668, 0.0014883316, 0.0010435096, 0.0004065986, -0.0020868424, 0.0000000000, -0.0005596711, -0.0018114037, -0.0012323161, 0.0000000436, -0.0010908275, -0.0012880490, 0.0012166243, 0.0012210279, 0.0005492459, -0.0013208168, -0.0003204775, -0.0004750938, -0.0009054793, -0.0005980112, -0.0000040796, -0.0017010577, 0.0024582429, 0.0021835153, -0.0010091926, 0.0024330977, -0.0030404211, 0.0000000000, -0.0015705941, -0.0003959875, 0.0007458011, 0.0014372092, -0.0000972739, -0.0010287130, -0.0008962311, -0.0014091050, 0.0013258837, 0.0009569949, 0.0000175035, 0.0005241351, -0.0000562608, -0.0004965545, -0.0045216717, -0.0000047607, -0.0006599129, 0.0046066060, -0.0017264733, 0.0011758073, 0.0018926058, -0.0001965711, 0.0010078466, 0.0035977543, 0.0000000000, -0.0015638612, 0.0031431396, 0.0016600268, 0.0002016214, 0.0018171120, 0.0031956008, -0.0021051897, 0.0040837252, 0.0000000000, 0.0003483633, -0.0030997021, 0.0014117965, 0.0000992525, -0.0013869103, 0.0007350962, -0.0040252581, 0.0000000000, -0.0007474210, 0.0019588973, 0.0076692202, -0.0000002929, -0.0001273537, -0.0063890135, -0.0007784549, 0.0029105563, -0.0026444602, -0.0039145364, -0.0026324366, 0.0016533061, 0.0024918616, -0.0043261182, -0.0003349941, -0.0048301029, 0.0028096053, 0.0033142022, -0.0004631711, 0.0009980283, -0.0157200973, -0.0000000000, -0.0024803933, -0.0065059257, -0.0008057072, 0.0008442854, -0.0000160199, 0.0026420604, -0.0001198701, -0.0046768943, -0.0003259305, 0.0002473910, 0.0000089092, 0.0056443741, 0.0009437809, 0.0020832736, -0.0039423024, -0.0007759070, -0.0004407632, 0.0069425623, -0.0069375173, 0.0023329868, 0.0051123858, 0.0136706447, 0.0129878018, -0.0054572425, 0.0000000000, -0.0160821732, -0.0068796934, -0.0038380655, -0.0044250195, -0.0033427982, 0.0088283969, -0.0083925733, 0.0012731330, -0.0000000000, -0.0016399744, 0.0034623214, -0.0033649991, -0.0033008130, 0.0041066464, -0.0014172319, 0.0153464144, 0.0000000000, -0.0036560716, 0.0105582271, 0.0098820394, -0.0000030769, 0.0023090683, -0.0028168273, -0.0144399367, -0.0071205636, -0.0044210027, -0.0027504065, 0.0059638242, 0.0045348266, 0.0071116555, -0.0031206172, 0.0004487127, 0.0035811642, -0.0153311063, -0.0000155980, 0.0045056618, -0.0095262220, -0.0214348454, 0.0000000000, -0.0016704014, 0.0015383053, 0.0074231098, 0.0044297487, 0.0002777466, 0.0005609314, 0.0045510647, -0.0062612281, 0.0009058225, 0.0085260887, -0.0000717160, -0.0065405141, 0.0014766093, 0.0090952422, -0.0004330215, -0.0035039443, 0.0066216267, -0.0071956133, 0.0049565402, -0.0074563734, -0.0074124830, -0.0028710035, -0.0019938643, -0.0004971137, 0.0000000000, 0.0015681804, 0.0023570322, -0.0006633945, -0.0011983410, -0.0002024186, -0.0010688307, -0.0014328703, -0.0010858476, 0.0000000006, 0.0030551373, 0.0010741227, -0.0007571067, -0.0010901090, -0.0002462296, 0.0008680781, -0.0021668214, -0.0000000000, -0.0004357430, -0.0028193125, -0.0002180843, 0.0000024833, -0.0011290564, -0.0028759742, 0.0043059480, 0.0026590293, -0.0023980415, -0.0010064425, -0.0004803853, -0.0003403687, -0.0028917983, 0.0017944868, 0.0005596786, -0.0032432911, 0.0062046777, 0.0027956297, -0.0013919839, 0.0036493368, -0.0023818819, 0.0000000000, -0.0025047038, 0.0029637625, -0.0013354508, 0.0023196202, -0.0000834148, -0.0016529829, -0.0020085864, -0.0012073417, 0.0021989192, 0.0009422126, 0.0000249212, 0.0003106887, -0.0036649948, 0.0001791374, -0.0067862021, -0.0009348373, -0.0025717653, -0.0033472313, -0.0029346084, 0.0010319724, 0.0052060331, 0.0028416086, 0.0018214155, -0.0061045741, 0.0000000000, -0.0095442086, -0.0018179242, -0.0090054534, 0.0002107188, -0.0003079613, -0.0012557639, 0.0065693287, -0.0015053506, -0.0000000000, -0.0071930974, 0.0018782950, 0.0133375218, 0.0010681077, -0.0007728435, 0.0000564080, 0.0041722273, 0.0000000000, -0.0003745451, 0.0043734564, 0.0011990517, 0.0000000005, 0.0020668525, -0.0007180268, -0.0077265571, 0.0011132659, 0.0005400249, 0.0079650581, 0.0024594036, 0.0018166826, 0.0166723039, 0.0014455282, -0.0025569170, 0.0066359756, 0.0050264001, -0.0057087000, 0.0048689125, -0.0011086129, 0.0008092548, -0.0000000000, 0.0000892323, 0.0038451285, -0.0047487165, -0.0012882797, -0.0000185687, -0.0022731395, 0.0028165942, 0.0034156230, -0.0098521439, -0.0035570287, -0.0000276414, -0.0017035539, -0.0034816400, -0.0034093328, 0.0052108080, 0.0019983104, 0.0024112924, -0.0018698934, -0.0025545864, -0.0045918971, -0.0052882843, -0.0013420206, -0.0007187724, -0.0039402526, 0.0000000000, 0.0003036505, 0.0012234491, -0.0037561040, -0.0042955070, 0.0001140607, -0.0048730774, -0.0107736420, -0.0071656876, 0.0000000000, 0.0012202866, 0.0050795488, 0.0031614378, 0.0041041560, 0.0020633189, 0.0007007784, -0.0000710975, -0.0000000000, -0.0011391810, -0.0048273453, -0.0066708964, 0.0000000021, -0.0006017371, -0.0022248807, 0.0046072351, 0.0020637673, -0.0007616780, 0.0016752892, -0.0003104960, -0.0007892795, -0.0027021996, -0.0012306698, 0.0029793810, -0.0036327313, 0.0017581736, -0.0003139768, -0.0032826758, 0.0025537347, 0.0054329489, 0.0000000000, -0.0011486347, 0.0079114493, -0.0029185470, 0.0024819225, -0.0002077459, -0.0043731416, -0.0037612834, 0.0041303416, 0.0041092327, 0.0030804966, 0.0000302340, -0.0054372773, 0.0000247995, -0.0003862800, -0.0060877455, 0.0019473040, -0.0038705072, 0.0095769372, -0.0035626716, -0.0004725931, 0.0017029323, 0.0023070364, 0.0068192245, 0.0029623709, 0.0000000000, -0.0040972810, 0.0007304302, -0.0077564204, -0.0062554507, 0.0022703505, 0.0069111912, 0.0021232939, 0.0088984566, 0.0000000000, 0.0033467305, -0.0047397753, 0.0054196711, -0.0009713272, -0.0044453442, 0.0000800072, -0.0020475760, -0.0000000000, -0.0006351768, 0.0053064595, 0.0042466326, 0.0000001512, 0.0018786730, -0.0061562657, -0.0121725528, 0.0084312884, 0.0020573968, 0.0041210884, -0.0010847623, 0.0049753897, 0.0137048587, -0.0076780342, -0.0006187397, -0.0075772689, -0.0020343924, 0.0058636307, -0.0000983294, -0.0003661393, -0.0167893395, 0.0000000000, -0.0037321306, -0.0199784953, -0.0020137688, -0.0014696034, -0.0000336333, 0.0042833518, 0.0054087681, -0.0091371983, -0.0017519944, 0.0028356053, 0.0000047080, 0.0147729181, -0.0037124462, -0.0031123559, -0.0014383409, 0.0026529783, -0.0071644406, 0.0023220635, -0.0027365533, -0.0029046477, -0.0061489418, 0.0054496904, -0.0005761919, -0.0027731461, -0.0000000040, -0.0041839639, -0.0022864817, -0.0019255811, 0.0049524349, -0.0002588243, -0.0047991425, -0.0062877703, -0.0063827927, -0.0000016540, -0.0001736820, -0.0028899789, -0.0009147454, 0.0019587760, 0.0062177349, -0.0017196913, 0.0022960864, -0.0000000021, -0.0019587092, -0.0029056948, -0.0039724745, -0.0001684885, 0.0010030338, 0.0091569964, 0.0051650521, 0.0010569906, -0.0032977031, 0.0079928664, -0.0011463803, -0.0010801989, 0.0033880186, 0.0024476612, -0.0018158576, 0.0090199942, -0.0108958017, -0.0077758650, -0.0004411155, -0.0040815827, 0.0169986505, -0.0000000001, 0.0007855275, 0.0051578800, -0.0059406953, -0.0046543088, -0.0010013124, -0.0017966735, -0.0006417643, 0.0112850238, -0.0000009894, -0.0002355507, -0.0001165269, -0.0176010877, 0.0021304814, -0.0023511248, 0.0063830921, 0.0027649594, 0.0068663298, 0.0016914172, -0.0053432812, -0.0011368376, -0.0101489183, -0.0093251960, -0.0001245705, -0.0012569842, 0.0000000000, 0.0079436507, 0.0055954400, -0.0019879693, -0.0013606781, -0.0020090868, -0.0066026705, 0.0008684822, -0.0013160359, 0.0000000004, 0.0012499080, -0.0055820872, -0.0005617966, 0.0004902189, -0.0017248178, 0.0013567585, -0.0030738513, 0.0000000001, 0.0006561814, -0.0053959228, -0.0097583355, 0.0000127265, -0.0011925763, -0.0015929753, 0.0125900954, 0.0071324855, -0.0022627171, 0.0042437813, -0.0010381101, -0.0003459413, -0.0033755237, 0.0036585121, 0.0009296430, -0.0062365266, 0.0113283182, -0.0007647070, -0.0001581460, 0.0042176279, 0.0162380040, 0.0000000000, 0.0001702353, 0.0068368549, -0.0067521380, 0.0007104386, -0.0002272840, -0.0011272783, -0.0027903412, 0.0042959773, -0.0006044103, -0.0018099024, 0.0000621379, 0.0106110806, -0.0042433804, -0.0004447634, -0.0034587078, 0.0021860306, -0.0104466779, -0.0018271683, 0.0032711842, 0.0011578437, 0.0065478804, -0.0006446972, 0.0000009192, -0.0012484718, 0.0000000000, -0.0016608417, 0.0000065927, -0.0037980136, -0.0103775263, 0.0005521755, -0.0024767448, -0.0062214895, -0.0057871342, -0.0000000007, 0.0024361114, -0.0000834348, 0.0022926957, 0.0028634053, -0.0000389737, 0.0009923594, -0.0044225110, 0.0000000000, -0.0011611026, -0.0025850777, -0.0015335225, 0.0000000440, -0.0009231181, -0.0060916431, 0.0001143837, 0.0018634216, 0.0009724788, -0.0034544209, 0.0002309059, 0.0028044926, 0.0020374693, -0.0033955073, 0.0028933797, -0.0048806299, 0.0051293224, 0.0012416804, -0.0040864535, 0.0019614296, -0.0018379039, 0.0000000000, -0.0004526608, 0.0031345077, 0.0007082372, 0.0013497241, -0.0001655903, -0.0020802626, 0.0013956842, 0.0028596090, 0.0052931705, 0.0022315832, 0.0000299177, -0.0023012832, 0.0016845593, 0.0011438527, -0.0061524785, 0.0013518255, -0.0018115500, 0.0050789602, -0.0060020010, -0.0041847453, 0.0032256024, -0.0054374221, 0.0018362843, -0.0065561263, 0.0000000000, 0.0083075790, 0.0065895556, -0.0023627218, -0.0020483155, -0.0036584076, -0.0046745036, 0.0046339161, -0.0025839105, 0.0000000000, 0.0020018071, -0.0104268016, -0.0008630454, -0.0001191181, 0.0005432657, 0.0002166018, 0.0015127966, 0.0000000000, -0.0013948331, -0.0057799248, -0.0133832665, 0.0000006980, -0.0018341750, 0.0033857441, 0.0139317224, 0.0048680459, -0.0010809504, 0.0054776906, -0.0014007302, 0.0015818214, -0.0015012833, 0.0045448062, -0.0019138003, -0.0033677309, 0.0098573705, -0.0051712277, -0.0012481977, 0.0012548912, 0.0194563493, 0.0000000000, 0.0003791921, 0.0090207690, -0.0104463249, 0.0008406313, -0.0000643918, -0.0025220832, -0.0035943361, 0.0066343565, 0.0013621436, -0.0006356341, 0.0000137225, 0.0048967740, -0.0090505769, -0.0009864616, 0.0010352961, 0.0030232316, -0.0099038845, -0.0049370620, 0.0047486634, 0.0019695375, 0.0067620818, -0.0025947185, -0.0010149239, 0.0004162612, 0.0000000000, 0.0004477422, 0.0021964535, 0.0028739639, -0.0016270826, 0.0011857244, -0.0023057032, -0.0034367088, -0.0010583960, 0.0000000000, 0.0000056830, 0.0017459901, -0.0014363729, -0.0005681669, 0.0002639038, 0.0005972113, -0.0021006558, 0.0000000000, -0.0006942763, -0.0033463740, 0.0007928934, 0.0000000286, -0.0008426752, -0.0027543227, 0.0030545341, 0.0015713379, -0.0032798871, -0.0005937047, 0.0008665646, -0.0016648680, -0.0059987018, -0.0000193011, 0.0006729272, -0.0027781818, 0.0035391871, 0.0023187185, -0.0011367381, 0.0035203607, -0.0028641201, 0.0000000000, -0.0028285545, 0.0025390664, -0.0012390184, 0.0015019984, -0.0001159705, -0.0020724509, -0.0036341432, 0.0002476628, 0.0005932010, 0.0021040675, 0.0000176791, 0.0018008963, 0.0026619914, 0.0025480497, -0.0047900868, -0.0012604833, 0.0001781371, 0.0035107280, -0.0005720769, 0.0015977256, 0.0035153849, 0.0019966350, 0.0060771694, -0.0063810619, 0.0000000000, 0.0022412967, 0.0019897935, 0.0028007075, 0.0044960058, -0.0050236071, 0.0010435336, 0.0003794066, -0.0036742380, -0.0000000000, 0.0010512802, -0.0044303187, -0.0073435199, -0.0031830941, 0.0066518569, -0.0007919126, 0.0074957744, 0.0000000000, -0.0001490679, -0.0011315586, -0.0092496118, -0.0000059373, -0.0030682487, 0.0123285139, 0.0124410242, 0.0001981764, -0.0018056296, 0.0126770930, 0.0006993703, -0.0016704520, -0.0061667371, 0.0069289724, -0.0051593604, 0.0028404489, 0.0033203885, -0.0094868690, 0.0047019110, -0.0006999833, 0.0156538095, -0.0000000000, -0.0042784447, 0.0054590115, -0.0104531338, -0.0008502975, 0.0001553590, -0.0003831327, -0.0001513755, 0.0071812072, -0.0035847509, -0.0034193625, -0.0000428901, -0.0018703160, -0.0094205253, 0.0021318041, 0.0074096899, 0.0017286884, -0.0023204447, -0.0083164731, 0.0119123990, -0.0018449179, -0.0054022288, 0.0094896918, 0.0074073006, 0.0063699880, 0.0000000000, -0.0069142994, -0.0068652318, 0.0035091625, -0.0011293878, 0.0027852331, 0.0158508085, 0.0069639049, 0.0105957361, -0.0000000000, -0.0009503538, 0.0015181584, -0.0007885895, -0.0036684340, -0.0051860674, -0.0008253214, 0.0028211088, 0.0000000000, 0.0007370435, 0.0126831522, 0.0100529371, -0.0000134710, 0.0008851318, -0.0029384389, -0.0183733460, -0.0013104244, 0.0026324634, -0.0016301719, 0.0000842917, 0.0058056009, 0.0083336513, -0.0054852203, -0.0047659152, -0.0000753716, -0.0104649495, 0.0040412550, 0.0015793638, -0.0014094410, -0.0296763834, 0.0000000000, -0.0027838396, -0.0223918762, 0.0068201884, -0.0017659726, 0.0002922546, 0.0068906792, 0.0066661965, -0.0124320602, -0.0007909607, 0.0037114723, -0.0000563061, 0.0003979470, -0.0007901834, 0.0033025574, 0.0047132182, -0.0007685903, 0.0022716976, 0.0002616063, 0.0023799951, -0.0056042885, -0.0060161999, 0.0010221761, 0.0001399345, -0.0024448021, -0.0000000000, 0.0104237525, -0.0019891746, 0.0051755132, -0.0024507511, -0.0011879593, -0.0006104649, 0.0158766843, 0.0087443320, -0.0000000001, -0.0075943032, -0.0113530643, 0.0003237061, -0.0033195952, -0.0054528080, -0.0014878620, -0.0008365801, 0.0000000000, 0.0023955596, 0.0027836848, -0.0061767483, -0.0000004136, 0.0009066770, 0.0086294403, 0.0003753699, -0.0031765273, 0.0062322514, -0.0007781347, 0.0043468345, 0.0045353477, 0.0050232480, 0.0014049974, -0.0004819687, 0.0025508478, -0.0137071442, -0.0026937993, -0.0004208974, -0.0037737712, 0.0098401941, -0.0000000000, -0.0016045729, -0.0075233048, -0.0004047148, -0.0018715366, -0.0003331079, 0.0035291249, -0.0034621584, 0.0020868513, -0.0038249139, -0.0015338623, -0.0000236105, 0.0044675618, -0.0028496771, -0.0080220355, 0.0113004250, 0.0065112957, -0.0039738636, -0.0087988842, 0.0121185770, -0.0009800682, -0.0011214840, -0.0015304568, 0.0014809580, 0.0019596997, 0.0000000000, 0.0002672839, 0.0020050381, 0.0014844083, 0.0007138150, 0.0020213458, -0.0029729381, -0.0043561081, -0.0016426047, 0.0000000000, -0.0001711462, 0.0002547585, 0.0006247941, 0.0010226341, 0.0016010175, 0.0009156507, -0.0035543977, 0.0000000000, -0.0011662947, -0.0028368658, 0.0000667374, -0.0000000136, -0.0004966162, -0.0028913680, 0.0049722949, 0.0038597179, -0.0042799707, 0.0048212805, -0.0000080863, -0.0024682041, -0.0031617917, -0.0005854854, 0.0014148343, -0.0041690595, 0.0014786414, -0.0003165298, -0.0003048686, 0.0049459459, -0.0026573902, -0.0000000000, -0.0031004457, 0.0001514542, -0.0052291988, 0.0007764515, -0.0001331028, -0.0002237457, -0.0031011461, 0.0027543288, 0.0002702702, -0.0000405332, 0.0000127838, 0.0022020154, 0.0022579175, 0.0003082923, -0.0034566538, -0.0000258173, 0.0014734154, 0.0076440317, -0.0027287612, -0.0005641001, -0.0001841870, 0.0015753567, 0.0044884807, -0.0045644469, -0.0000000000, -0.0046733287, -0.0015649124, 0.0134314224, 0.0044984752, -0.0049886391, 0.0097918408, -0.0022605523, 0.0042616837, 0.0000000000, 0.0047351792, -0.0003530123, -0.0050377580, -0.0030199795, 0.0026289378, -0.0003596157, 0.0074849478, 0.0000000000, 0.0005081606, 0.0007909632, 0.0068128775, -0.0000000090, -0.0001972952, -0.0032583552, -0.0064276597, -0.0041255103, 0.0008141571, -0.0082106283, 0.0013966012, -0.0022671635, -0.0043258397, -0.0045008399, -0.0024304863, -0.0037321586, -0.0157203190, 0.0045044417, 0.0009717470, 0.0015122686, -0.0271908399, -0.0000000000, -0.0046754749, 0.0022492851, 0.0075985827, 0.0052814237, 0.0000206472, -0.0034081761, -0.0024905435, -0.0073965252, 0.0004033466, 0.0074357437, 0.0000118068, -0.0007093636, -0.0013712803, 0.0122618806, -0.0061022672, -0.0051224418, -0.0012385776, 0.0032930393, 0.0153400414, -0.0000552553, 0.0063089160, 0.0136278784, 0.0106566390, -0.0037322179, -0.0000000423, -0.0036769854, -0.0023899984, 0.0090630874, -0.0024832997, -0.0054413369, -0.0013596608, 0.0009217022, 0.0003890384, -0.0000007595, 0.0011802410, -0.0070529468, -0.0032639224, -0.0013362155, 0.0084416624, -0.0067297160, 0.0132339615, -0.0000000103, -0.0125436336, 0.0028564525, 0.0053743790, -0.0010485075, -0.0007235273, 0.0104938447, 0.0015715203, -0.0046223947, 0.0007202196, 0.0027646229, 0.0053548841, 0.0011291230, -0.0034983819, 0.0042534722, -0.0016975001, 0.0068705752, -0.0121042924, -0.0055358005, 0.0025340638, -0.0093513057, -0.0024669254, -0.0000000028, -0.0007439774, 0.0050415257, 0.0067513338, -0.0001399963, -0.0040083062, -0.0007448955, -0.0000672258, 0.0066358834, -0.0027751857, 0.0075566983, -0.0014256644, -0.0168549120, -0.0062279245, 0.0029255955, 0.0115865534, 0.0037123684, 0.0158285424, -0.0062377453, 0.0087841442, -0.0013985835, -0.0063038305, -0.0052983477, -0.0098820142, -0.0023011107, 0.0000000000, 0.0031151227, 0.0034211332, 0.0070620216, -0.0049663843, 0.0000587565, -0.0062504644, -0.0025390491, -0.0054089846, 0.0000000000, -0.0013246125, -0.0054458445, -0.0066545410, -0.0041197669, 0.0007695155, -0.0000020874, -0.0095794993, -0.0000000000, -0.0004601471, -0.0055115945, -0.0115449214, 0.0000002297, 0.0002583021, 0.0045742672, 0.0166151300, 0.0023643624, -0.0043100007, 0.0013736861, 0.0010072039, 0.0001391459, -0.0074825520, 0.0024168761, 0.0009911463, 0.0002721140, 0.0128644947, -0.0088491607, -0.0006744973, -0.0014490420, 0.0275847539, 0.0000000000, -0.0009167864, 0.0083766691, -0.0083408281, -0.0010765608, -0.0000099094, 0.0019417177, -0.0027161560, 0.0089916997, 0.0030036634, -0.0015628325, 0.0000078272, -0.0030299642, 0.0022109181, 0.0008048334, 0.0018788552, 0.0013338831, -0.0046217768, -0.0143642537, 0.0015293441, 0.0005182034, 0.0028278960, -0.0050852154, 0.0049064192, -0.0030484828, -0.0000000157, 0.0140380543, 0.0087921740, -0.0033689425, -0.0090056118, -0.0027703459, -0.0074430974, 0.0127451550, 0.0005376020, -0.0000066469, -0.0005563937, -0.0077174539, 0.0028993024, -0.0090968516, -0.0098734861, -0.0017114108, -0.0019443741, -0.0000000152, -0.0025316444, -0.0005885182, -0.0169207156, -0.0000422055, 0.0014827538, 0.0033494993, 0.0132553326, 0.0082456889, -0.0001803514, 0.0066863480, 0.0003831160, 0.0102698198, 0.0087308167, 0.0125757372, 0.0033308060, -0.0056328708, 0.0139703508, -0.0065419669, -0.0080933832, 0.0045749946, 0.0227611121, -0.0000000000, -0.0048930082, -0.0041250349, -0.0112808738, 0.0012508261, -0.0014070657, -0.0005286868, -0.0009234439, 0.0085338559, 0.0015896313, -0.0002640334, -0.0000974839, 0.0041049812, -0.0144268861, 0.0098132947, -0.0031689939, 0.0097943842, -0.0060930066, -0.0322179198, 0.0014438211, -0.0036526765, 0.0151951220};
# 32 "firmware/parameters.h" 2
# 1 "firmware/weights/b11.h" 1
# 12 "firmware/weights/b11.h"
dense_bias_t b11[64] = {0.0047328859, 0.0791613385, 0.0179932825, -0.0588467084, 0.0854095519, 0.0054225051, 0.0480527915, 0.0209382381, -0.0111687733, -0.0232774876, 0.0096686287, 0.0866177380, -0.0419886187, -0.0182112046, 0.0228265747, -0.0129679060, 0.0031864175, 0.0874417946, -0.0269430988, 0.0569277778, -0.0372657292, -0.0174144972, 0.0067201816, 0.0404185988, -0.0235452689, -0.0597794876, 0.0693394393, 0.0664683729, -0.0240900759, -0.0294956341, 0.0384166539, 0.0412157476, 0.0859646350, -0.0151832812, 0.0385287032, 0.0153879588, 0.0774663687, -0.0461441278, -0.0109520173, -0.0038052113, -0.0117377406, -0.0366628021, -0.0346690193, 0.0075755715, 0.0088621313, 0.0184535496, 0.0102474736, -0.0640702918, 0.0095944386, -0.0251349080, 0.0690741017, 0.0118214302, 0.0746809319, -0.0294394419, -0.0447200760, 0.0091095995, 0.0235267654, 0.0643530041, 0.0241033025, 0.0751135498, -0.0956484377, 0.0218590815, -0.0090002837, 0.0139467325};
# 33 "firmware/parameters.h" 2
# 1 "firmware/weights/s13.h" 1
# 12 "firmware/weights/s13.h"
batch_normalization_2_scale_t s13[64] = {0.8240613937, 0.7952441573, 1.1076991558, 31.7638072968, 1.0181471109, 1.3158843517, 0.9819008112, 1.1551754475, 1.0001453161, 1.8751798868, 1.2719696760, 0.9726943970, 27.9962596893, 1.0277979374, 1.2067061663, 1.1699460745, 0.9639709592, 0.8867593408, 2.5429670811, 0.8378449678, 31.3142337799, 6.0606417656, 0.8202456236, 1.0369423628, 29.4626979828, 19.0645656586, 0.8629739285, 0.9720590115, 0.9259679914, 1.1550227404, 1.0969558954, 0.8593781590, 0.9804451466, 1.2021747828, 0.8418190479, 1.1856111288, 1.1957306862, 0.8934603333, 1.1455159187, 1.1546412706, 1.1991730928, 0.9695633650, 29.9046344757, 0.9710432887, 0.9443335533, 0.9810821414, 0.8264495730, 31.2347240448, 1.1523441076, 1.3869395256, 0.9395396113, 1.2356824875, 0.9879558086, 24.1813735962, 1.0650019646, 1.1270705462, 0.9189287424, 1.0251383781, 0.8849875331, 0.9328518510, 1.0067813396, 1.0332924128, 0.9530172348, 0.9874320030};
# 34 "firmware/parameters.h" 2
# 1 "firmware/weights/b13.h" 1
# 12 "firmware/weights/b13.h"
batch_normalization_2_bias_t b13[64] = {-2.0406296253, -1.8210399151, -0.8075646162, -0.0083901342, -0.5156366229, -0.6877397895, -0.9303618670, -0.5827026367, -0.3039992452, -0.6998090744, -0.3889875412, -1.0506423712, -0.1824594140, -0.4129003882, -0.5588939786, -0.4152829647, -0.9814587235, -1.6556444168, -0.2428364307, -1.5693199635, -0.0034043775, -0.0708567947, -0.5075516701, -0.9770079255, 0.1930354238, -0.1675368249, -1.2825387716, -1.0135356188, -0.2482153475, -0.2505725622, -0.9384264350, -0.5123076439, -1.1897178888, -0.6659387946, -1.0025962591, -0.5041254759, -0.4782708883, -0.6461372375, -0.7066997290, -0.8115918040, -0.6311261058, -0.6977043748, -0.0113760354, -0.4078884125, -0.8607704043, -1.0398062468, -1.4513269663, -0.3115346134, -0.6514700055, -0.4536357224, -0.9987766147, -0.6479609609, -0.7684191465, -0.1533783972, -0.8951721191, -0.6737998724, -1.0233179331, -1.0772485733, -1.3966048956, -1.6380081177, -0.6461144686, -0.6847373247, -0.4702886045, -0.8345837593};
# 35 "firmware/parameters.h" 2
# 1 "firmware/weights/w14.h" 1
# 12 "firmware/weights/w14.h"
dense_1_weight_t w14[2048] = {0.0248945653, -0.0383470953, -0.0161468871, -0.0602505989, -0.0458377749, -0.0814889669, 0.0104143359, -0.0197988283, -0.0207348093, 0.0097593609, 0.0137399705, -0.0442282893, -0.0322954133, -0.0122557310, -0.0517134964, -0.0532558002, -0.0462484807, -0.0209898055, 0.0400287062, 0.0267757829, 0.0150829600, -0.0762174726, -0.0952323452, 0.0290321186, -0.0766248479, 0.0071897414, 0.0126231480, -0.0437874086, -0.0257457979, -0.0191471558, 0.0042096940, -0.0319667943, 0.0534933470, -0.0403832942, 0.0387391746, -0.0592738092, -0.0405157171, -0.0081716888, 0.0100759575, -0.0444116704, 0.0264244154, 0.0047733495, -0.0179329123, 0.0581643507, 0.0781372935, -0.0086821523, -0.0468419269, -0.0212517828, 0.0429698341, -0.0053518545, -0.0624623448, 0.0617304258, 0.0049926355, 0.0187828038, -0.0766449273, 0.0241275523, -0.0351572819, 0.0456681326, -0.0495183095, -0.0616771020, -0.0498198345, 0.0422787741, -0.0363279916, 0.0742309839, 0.0272298530, 0.0200616885, -0.0484315604, -0.0200658645, -0.0064179604, 0.0194562487, 0.0482913032, -0.0228719842, 0.0297909211, 0.0419792309, -0.0341703258, 0.0129631208, 0.0012327059, -0.0169194546, -0.0154343443, 0.0472524539, -0.0066709286, -0.0595482625, -0.0087335603, -0.0610349253, 0.0587323532, 0.0045451038, 0.0041250722, -0.0873713493, 0.0391075760, 0.0146404197, 0.0177905206, 0.0433849245, 0.0735369325, -0.0282967705, 0.0103627853, -0.0744601563, -0.0000460222, 0.0001329832, -0.0000627451, 0.0001049484, -0.0018162689, -0.0004456139, -0.0001057880, -0.0012286558, 0.0019154794, -0.0004487865, -0.0004846589, -0.0032345350, 0.0000367727, -0.0002078311, 0.0019517816, 0.0010633641, 0.0000705503, 0.0002904020, 0.0009705603, -0.0016783368, 0.0002217044, -0.0006342045, -0.0000857086, 0.0006161049, -0.0005617631, 0.0003493305, 0.0002250270, 0.0004865883, -0.0015686215, 0.0005104131, 0.0002435874, 0.0000293407, -0.0032674544, -0.0023749790, -0.0257450640, -0.0178077053, -0.0016914904, 0.0434871726, -0.0392331667, 0.0343550406, 0.0020859265, 0.0381399691, 0.0069656288, 0.0152107514, -0.0042877109, -0.0171648972, -0.0985349268, 0.0525205508, -0.0163862482, -0.0216579437, -0.0542637482, -0.0140872998, 0.0541096292, 0.1003780738, -0.0453741699, 0.0158067569, -0.0544123836, 0.0199953243, 0.0268762819, 0.0210332572, 0.0604907535, 0.0371175893, -0.0171104632, 0.0429452509, 0.0187338665, -0.0221380647, -0.0683158115, 0.0408517793, -0.0259320699, 0.0227041766, -0.0441425070, 0.0550873429, 0.0249013621, 0.0356232002, 0.0388864726, -0.0389880277, 0.0034238615, -0.0273956303, -0.0256814808, -0.0028394067, 0.0087453881, -0.0097885858, -0.0128638744, -0.0200454593, -0.0153863532, -0.0204761624, -0.0646767914, 0.0445226207, -0.0500578992, 0.0114503279, 0.0282722879, 0.0412332714, 0.0225840621, -0.0179781709, 0.0131344413, -0.0180390254, 0.0121870916, 0.0807975307, -0.0135394931, -0.1239193082, 0.0075497245, -0.0366742350, 0.0300001744, 0.0264739376, 0.0060198093, 0.0136843072, 0.0696094111, -0.0773505270, 0.0036531556, -0.0948450118, 0.0124383811, -0.0011995388, 0.0174635686, 0.0433179326, -0.0146259023, -0.0497666486, -0.0636042207, 0.0675406680, 0.0646375194, 0.0144049078, 0.0730908439, 0.0725742802, 0.0428747870, 0.0524140112, -0.0812053308, 0.0863207132, 0.0598075911, -0.0472424552, 0.0079371165, 0.0527818650, -0.0352642648, 0.1198539585, 0.0230324268, -0.0406471193, -0.0071725519, -0.0101743191, 0.0508800559, 0.0109480452, 0.0014005714, -0.0132716177, -0.0339123383, -0.0750487447, -0.0577583499, -0.0213767327, -0.0212736260, -0.0334070437, -0.0718884617, -0.0202183034, -0.0518021472, 0.0109462542, -0.0179922562, -0.0588820130, -0.0226707570, 0.0311311092, 0.0314629078, 0.0163089298, 0.0024103473, -0.0601692982, 0.0976847336, 0.0106690917, -0.0143521838, 0.0096835745, -0.0073970603, 0.0019943621, 0.0134333838, 0.0037115882, 0.0045071985, 0.0166243576, -0.0027904080, -0.0389654078, 0.0078553809, 0.0708970279, 0.0271458533, 0.0225172825, -0.0024421837, 0.0366816670, 0.0010185821, 0.0004841383, 0.0015506712, -0.0043492070, 0.0478867963, -0.0091555472, 0.0277947411, 0.0286521651, 0.0281867273, -0.0040945485, 0.0151450941, 0.0132876989, 0.0311844256, 0.0081527326, -0.0351775177, 0.0102397930, 0.0002355712, 0.0000621007, 0.0045700041, 0.0057976190, 0.0108742677, -0.0009161353, 0.0009569781, -0.0202686805, -0.0165463500, 0.0053698127, -0.0096008945, 0.0142274201, -0.0316710882, 0.0100850761, 0.0080038132, -0.0086085629, 0.0080115357, -0.0260832030, -0.0378972031, -0.0261134151, 0.0088827517, -0.0191559549, 0.0146647235, -0.0139245521, -0.0313124433, -0.0132923042, -0.0039479011, 0.0327215120, -0.0202165376, 0.0275116134, -0.0121201500, -0.0243116952, -0.0189482104, -0.0855436027, 0.0284725148, -0.0037584249, 0.0240651816, 0.0597722642, -0.0354032405, -0.0039933249, -0.0372290462, -0.0019108560, 0.0273530241, -0.0439334735, 0.0420403108, 0.0055698897, -0.0424654037, 0.0292236973, 0.0063349595, -0.0337184966, 0.0368611440, -0.0264882930, -0.0071284985, 0.0655587018, 0.0627334192, 0.0424342118, 0.0593813919, 0.0083373878, 0.0438215733, 0.0138649903, 0.0097817527, -0.0352402776, -0.0183783416, -0.0109945573, 0.0321262740, -0.0219564624, -0.0320724063, -0.0714678615, 0.0134209581, 0.0134510603, 0.0171149522, 0.0086057121, 0.0028037196, -0.0235709455, -0.0115724532, -0.0420911387, -0.0017478581, 0.0033343285, 0.0198549256, 0.0821324661, 0.0145880561, -0.0004312223, -0.0083970241, 0.0620170534, 0.0045232475, 0.0296209343, 0.0221436918, -0.0836811736, 0.0144070955, 0.0194723308, 0.0458787642, 0.0103978375, 0.0111472672, 0.0543893762, 0.0446460433, 0.0151181780, -0.0033691493, 0.0057265302, -0.0000442083, 0.0053286841, -0.0079111056, -0.0093325684, -0.0110257491, -0.0056821345, -0.0024317554, -0.0076443609, -0.0076565025, -0.0162492320, -0.0031760973, -0.0053321728, 0.0032473169, 0.0002164088, -0.0039631431, -0.0038955696, -0.0076159579, -0.0077398526, -0.0022178122, -0.0099024037, -0.0028905293, 0.0095921084, -0.0041665672, -0.0049081836, -0.0018107856, 0.0006316903, -0.0103684124, -0.0082954587, 0.0029144101, -0.0000472836, -0.0609138124, 0.0234787371, 0.0982403085, -0.0351761281, -0.0232853033, 0.0580756590, 0.0430842675, 0.0050465353, 0.0337836146, -0.0492032282, -0.0578161739, -0.0334829316, 0.0647189692, 0.0600603595, 0.0217322502, 0.0409782380, 0.0206774231, -0.0226606652, -0.0381233133, 0.0217886958, 0.0109906485, 0.0184568763, 0.0451396666, -0.0171950404, -0.0067911572, -0.0355655998, -0.0444310047, 0.0148358289, 0.0208729282, 0.0563146360, 0.0127635607, 0.0510254353, -0.0131953359, 0.0452486239, -0.0279689822, 0.0676296726, 0.0182008408, 0.0076630707, -0.0925315917, -0.0285038464, 0.1052256972, -0.0041869245, 0.0046363221, 0.1037954539, -0.0288109649, -0.0018272415, -0.0195065998, -0.0734796748, -0.0103441952, -0.0263948683, 0.0451963246, 0.0272902492, -0.0017432657, -0.0549447127, -0.0000862299, -0.0068970523, -0.0885087997, 0.0387829803, -0.0159935895, -0.0057806093, -0.0021378254, -0.0833992064, 0.0403079242, -0.0417896584, 0.0263729505, -0.0078371717, -0.0672329888, 0.0489288978, -0.0001104528, -0.0097944541, -0.0661504641, 0.0040544178, 0.0558417961, -0.0642151609, 0.0677390844, 0.0872722939, -0.0007028801, 0.0035824850, 0.0227378085, 0.0495396331, -0.0128473891, 0.0011518107, 0.0668900609, 0.0057289535, 0.0182224791, 0.0202958006, 0.0184181128, 0.0747694224, -0.0072156829, 0.0623189919, 0.0102201328, -0.0293809474, -0.0040413286, -0.0965552554, -0.0077993823, -0.0018875096, -0.0529815815, -0.0192658156, -0.0070020109, -0.0147102755, 0.0494173393, -0.0483571626, -0.0595925935, 0.0099026747, -0.0328664035, -0.0504518896, -0.0590783209, 0.0245448779, -0.0540308356, -0.0063677528, 0.0159521382, -0.0118688624, 0.0089346906, 0.1035534069, 0.0068643847, 0.0324243419, 0.0572679974, 0.0343444087, -0.0342990980, 0.0196641982, 0.0286710802, 0.0358108245, -0.0530742891, -0.0452506281, -0.0753047615, -0.0580643006, -0.0439264290, -0.0187646020, 0.0074240323, 0.0136481961, 0.0180843603, 0.0136964824, 0.0356318429, -0.0386359207, 0.0229492076, -0.0184764508, -0.0084672263, -0.0501383990, -0.1134219095, 0.0117209209, -0.0255433042, 0.0526543856, -0.0481448211, 0.0132722473, 0.0489239246, -0.0603996404, -0.0026532304, 0.0027068492, -0.0226835068, -0.0323546454, -0.0213695187, -0.0477640107, -0.0125147421, 0.0467022881, -0.0004968282, -0.0050386391, -0.0314351320, -0.0353931934, 0.0034568296, -0.0481715724, -0.0026441088, -0.0123551441, 0.0004209590, 0.0068973964, -0.0141375586, 0.0130634671, -0.0175691508, 0.0031412116, -0.0113081252, -0.0010032241, -0.0104415743, -0.0077679921, -0.0126108536, -0.0256807785, 0.0074162544, 0.0000486213, -0.0164055191, -0.0059741898, -0.0038869812, 0.0169579294, -0.0000696013, -0.0100384438, -0.0266820546, 0.0046934290, -0.0009883246, -0.0070982855, 0.0028561517, 0.0146443211, -0.0035153052, -0.0031065657, -0.0026909304, 0.0014457584, 0.0715016797, -0.0445511751, -0.0017154157, -0.0219405945, 0.0361231714, -0.0412067585, 0.0057495199, -0.0380772091, -0.0044325199, 0.0561694466, 0.0355543569, -0.0133334501, 0.0478379130, -0.0160893332, -0.0040202686, -0.0224938616, 0.0707189292, -0.0011904807, -0.0065917252, 0.0365478955, -0.0550855808, 0.0397297703, 0.0159729552, -0.0478045791, -0.0194313116, -0.0153177092, -0.1027325466, -0.0438025184, -0.0789598972, 0.0092275068, 0.0424109101, 0.0264421646, -0.0000115596, 0.0000379827, 0.0001540379, 0.0003364545, -0.0002181951, -0.0001978974, -0.0004127249, -0.0001852768, 0.0001293472, -0.0002316138, -0.0004911806, -0.0002530141, 0.0000579686, -0.0001022772, 0.0002652958, 0.0001154675, -0.0000220068, -0.0001115360, -0.0002549751, -0.0002891948, 0.0000350942, -0.0005914731, -0.0001315103, 0.0004997907, -0.0003917956, -0.0000319005, -0.0000173025, 0.0001196176, -0.0002794314, -0.0002094432, 0.0000730511, 0.0002362115, 0.0130133601, -0.0173950512, 0.0325483754, 0.0040561561, -0.0380500592, 0.0239308625, -0.0025493391, -0.0122850267, -0.0015177866, -0.0208371803, 0.0023391801, 0.0103598246, 0.0229846686, 0.0104307970, -0.0068513975, 0.0013628398, 0.0055653253, -0.0031639754, -0.0284514818, 0.0026345991, 0.0185541343, 0.0263596848, 0.0185775533, -0.0038618427, -0.0294872876, -0.0293867290, 0.0183964223, -0.0107229576, -0.0206309911, -0.0265121926, 0.0100032790, -0.0257280059, 0.0373500027, -0.0404852368, -0.0526977703, 0.0169265121, 0.0280390847, 0.0026352466, 0.0717118233, -0.0582925379, 0.0647765100, 0.0407302566, 0.0031393263, 0.0248690303, -0.0152427088, -0.0154111991, 0.0000391361, 0.0294945184, 0.0194691289, -0.0241509322, 0.0384461321, 0.0889605731, 0.0206523258, -0.0330733582, 0.0236420892, -0.0346114114, -0.0347313397, -0.0261188112, 0.0193558075, 0.0404529758, 0.0613302253, 0.0305517856, -0.0476266108, 0.0025699802, 0.0714333802, -0.0292613525, -0.0819387510, -0.0656032711, 0.0021814781, -0.0509156287, 0.0168384314, -0.1056218967, -0.0229113381, 0.0484904833, 0.0004294977, 0.0816907957, -0.0263705496, -0.0588847473, 0.0818719342, -0.0240351111, -0.0009461225, -0.0458645411, 0.0485638157, 0.0037023909, 0.0543184206, -0.0446592271, -0.0339518711, 0.0147590553, 0.0116872108, -0.0245651528, -0.0446993299, 0.0296682287, 0.0527463071, 0.0497343689, -0.0364207625, -0.0340360589, 0.0067089158, -0.0057564597, -0.0229405276, 0.0207386874, 0.0068318220, 0.0162856746, 0.0029965134, 0.0066016796, 0.0008659658, 0.0179695897, -0.0109623615, 0.0068226457, 0.0133321267, -0.0017069606, -0.0075540296, 0.0173133761, 0.0054714074, -0.0001255148, 0.0041557746, 0.0237945449, -0.0033865445, 0.0044133696, -0.0122869546, 0.0089931050, 0.0038803187, 0.0115799475, 0.0280783754, 0.0007220440, 0.0146632651, 0.0177616533, 0.0079974094, 0.0013194208, -0.0165820904, -0.0174965058, 0.0450028442, -0.0362406559, -0.0025504888, -0.0019014508, -0.0619619377, -0.0475435816, -0.0282583162, 0.0024757613, -0.0225882679, -0.0051235342, 0.0069208397, -0.0183950569, -0.0034916799, -0.0254016332, -0.0068091345, 0.0123270974, 0.0013571433, -0.0042841407, 0.0146992980, -0.0311202090, 0.0031452633, -0.0089819757, 0.0101474896, 0.0286273062, -0.0240461044, -0.0364704542, -0.0192372072, 0.0113195842, 0.0001111820, 0.0170162935, 0.0213368256, -0.0100027863, 0.0100941062, -0.0124617592, 0.0275092814, -0.0684960410, 0.0288407449, 0.0144502698, -0.0167922489, -0.0077691348, -0.0387197211, 0.0005304207, 0.0352617875, 0.0307007954, -0.0667285323, 0.0603267215, -0.0245244522, -0.0566862710, -0.0420528464, -0.0570081435, 0.0142428763, 0.0028645683, -0.0607990697, 0.0060121096, 0.0514802150, -0.0615295544, 0.0148344012, -0.0200403221, 0.0376841724, -0.0402462669, 0.0172148682, 0.0080759227, -0.0326837003, 0.0434159860, 0.0718749315, 0.0577252321, -0.0070050503, -0.0181328468, -0.0364571661, 0.0360077135, -0.0469734520, -0.0916143134, -0.0520664342, 0.0583530851, 0.0084107919, -0.0157602411, -0.1054625735, 0.0178447347, 0.0127471555, 0.0391697586, -0.0665550232, 0.0004405819, -0.0010731104, -0.0353713408, -0.0209661666, 0.0109745404, -0.0148372585, 0.0730258450, -0.0353953652, 0.0368968695, 0.0293081086, 0.0940074399, 0.0524471290, 0.0599710718, -0.0236900263, -0.0396164544, 0.0482382402, -0.0354185142, -0.0056401393, 0.0400309712, 0.0283143278, 0.0626203045, 0.0431469157, 0.0032088819, -0.0193872973, -0.0328047536, -0.0330830812, 0.0403852984, -0.0563003570, -0.0270217545, 0.0465687439, 0.0377985016, 0.0163936317, 0.0421604775, 0.0396565199, -0.0346783213, -0.0467045233, -0.0050599431, -0.0586804077, -0.0410434343, 0.0213860646, -0.0067163394, 0.0394243151, 0.0400062092, 0.0053487113, 0.0076500657, 0.0090912981, -0.0315045044, 0.0498858839, -0.0139437132, -0.0001569985, 0.0005320056, 0.0125997122, -0.0029020079, 0.0559051707, 0.0254124198, 0.0070811948, -0.0440297201, 0.0085519953, 0.0485685878, 0.0012462562, -0.0287810806, 0.0157884732, 0.0399883054, 0.0150852399, 0.0219246652, 0.0068240678, 0.0183659289, 0.0417006835, -0.0177493673, -0.0198068712, -0.0445228517, -0.0021098913, 0.0053101154, -0.0173147209, 0.0082473038, 0.0151265804, -0.0370669886, -0.0163526293, -0.0078679901, -0.0032524830, -0.0175396651, 0.0464769229, -0.0459312312, 0.0173227582, 0.0497806892, 0.0276341364, 0.0020791786, 0.0142869027, -0.0260105841, 0.0246217474, -0.0156024434, -0.0594942570, 0.0572113432, -0.0172581952, 0.0124354195, -0.0361477360, -0.0663879067, 0.0345305018, 0.0369815566, -0.0089431452, -0.0269068275, -0.0214326829, -0.0232846476, -0.0015232034, -0.0513461754, -0.0322785415, -0.0373011157, -0.0589150116, -0.0046360204, -0.0508690365, -0.0345852263, -0.0613050461, -0.0161791779, 0.0466073528, 0.0005434414, 0.0721877217, 0.0009739459, 0.0107593164, 0.0289344043, 0.0802009553, 0.0050199423, -0.0298947543, -0.0477906764, -0.0213601366, -0.0207111817, -0.0258682873, -0.0021887203, 0.0353347249, 0.0598799661, 0.0705888122, 0.0288247764, 0.0527984723, -0.0087866979, -0.0105280383, -0.0268653110, -0.0435064249, 0.0319264531, -0.0231028143, 0.0686703697, -0.0547153987, 0.0489370376, -0.0129891355, 0.0308860876, 0.0457537621, 0.0350547358, -0.0666470751, 0.0462511443, 0.0028821956, -0.0046912641, -0.0663638413, 0.0149108423, -0.0236647353, -0.0597525649, -0.0132376291, -0.0008266242, 0.0040148175, -0.0019804637, -0.0039614192, 0.0500840880, -0.0081308531, 0.0155878803, 0.0088068163, 0.0080132596, -0.0411285609, -0.0425099246, 0.0145464679, 0.0467417464, -0.0368051007, -0.0490455367, 0.0527452044, -0.0067175017, -0.0087777851, 0.0163979586, -0.0436870754, -0.0193828344, 0.0042108726, -0.0243425630, -0.0478683859, 0.0039820485, -0.0590376668, -0.0738813877, -0.0151939411, -0.0197092928, 0.0459367037, 0.0172820296, 0.0012847539, -0.0388545133, 0.0553194731, 0.0387150533, -0.0692992061, 0.0028545964, -0.0420688614, 0.0551412106, 0.0217591077, -0.0729981735, 0.0583643802, -0.0542659797, -0.0232804995, -0.0260887016, 0.0595226586, -0.0367522687, -0.0062874272, 0.0172614045, 0.0349397510, 0.0411890335, 0.0295344237, -0.0523791388, 0.0201659445, 0.0462072343, 0.0777879879, -0.0138655156, -0.0226283185, -0.0184756964, -0.0163467452, 0.0490235202, -0.0120485900, -0.0290700886, 0.0496714599, 0.0023813341, 0.0257290192, -0.0641498119, -0.0082886973, -0.1152989939, -0.0431840979, -0.1051707715, -0.0415527187, 0.0139382845, -0.0179174338, 0.0139826210, 0.0002769629, 0.0481339097, -0.0521818809, -0.0664317980, 0.0132784080, -0.0512831807, -0.0124078309, 0.0237032454, 0.0060951211, 0.0322262459, 0.0122677078, -0.0310711209, -0.0259445086, 0.0147412941, 0.0065175914, -0.0342179090, 0.0842922777, 0.0093387850, 0.0345464125, 0.0130410539, 0.0969780609, 0.0629620180, 0.0198370386, 0.0075391135, -0.0005415796, -0.0256166440, -0.0803372264, 0.0089281462, 0.0552429967, 0.0128513584, -0.0046357736, -0.0133223394, -0.0382821448, -0.0428773798, 0.0037282263, -0.0055275415, 0.0823383257, -0.0322739296, 0.0117236534, 0.0409269743, -0.0002165979, 0.0804886147, -0.0277646165, 0.0111070480, 0.0688504577, 0.0309395287, -0.0068750540, -0.0074701440, 0.0468842611, 0.0490743481, 0.0766558349, 0.0079713939, 0.0392862596, 0.0397429466, -0.0326226577, -0.0837200433, -0.0050768629, -0.0254766475, -0.0243055467, -0.0710715353, -0.0280941594, -0.0193458926, 0.0591483414, -0.0511684380, 0.0331549756, 0.0006718914, -0.0273341592, -0.0484605245, 0.0187861100, 0.0288187563, -0.0554806329, -0.0273403265, -0.0443364941, 0.0423738919, 0.0556425191, 0.0286675636, -0.0786134005, 0.0561444871, -0.0353449211, -0.0263431687, 0.0717596859, 0.0356620029, 0.0253594909, -0.0621682890, -0.0023468197, -0.0542270727, -0.0193407927, -0.0268674418, -0.0401104018, 0.0472850315, 0.0715706348, 0.0518044122, 0.0103495484, -0.1045848057, -0.0132425930, 0.0018229928, -0.0916144177, 0.0042810887, 0.0445391759, -0.0278251804, 0.0430158116, 0.0935117826, -0.0419540517, 0.0209779516, 0.0292205997, -0.0421503261, 0.0895175114, 0.0094551742, 0.0027501727, -0.0911587253, 0.0235961638, 0.0078771701, 0.0255245268, -0.0001382133, 0.0377433114, 0.0268079825, -0.0077400999, 0.0554013029, -0.0065548900, -0.0270539895, -0.0283577759, 0.0561581813, -0.0003662116, 0.0043806145, -0.0118106361, 0.0274079777, 0.0053795925, -0.0185502488, -0.0421475619, -0.0983240828, -0.0333728977, -0.0187033098, -0.0607816838, -0.0356247723, -0.0524243489, 0.0198881701, 0.0348932371, 0.0400054455, -0.0094010606, -0.0002949593, 0.0526379123, -0.0113515742, 0.0375301763, 0.0037533692, 0.0169717334, 0.0037367709, -0.0566476658, 0.0122734858, -0.0219522137, 0.0257763192, -0.0004076345, 0.0242413376, -0.0066095721, -0.0089250952, -0.0362457484, -0.0292733219, -0.0051183216, 0.0138186179, 0.0250615142, -0.0425185002, -0.0014054447, -0.0103449589, 0.0012458720, -0.0065844776, -0.0048422720, 0.0207181703, -0.0074337292, -0.0614096373, 0.0281120390, -0.0125084212, -0.0365708582, 0.0218168888, 0.0199306440, -0.0645647496, 0.0504717231, 0.0458096638, 0.0038014301, -0.0283215381, 0.0898196399, 0.0161163528, 0.0141574489, -0.0593940206, 0.0277172457, -0.0235122368, 0.0109018357, -0.0178531688, -0.0540028252, 0.0150808077, -0.0068553113, 0.0776529238, 0.0006516509, 0.0252914745, -0.0290528443, -0.0969105288, -0.0553145334, -0.0266298465, -0.0401479825, 0.0143445553, 0.0590893254, 0.0482859761, -0.0862312466, -0.0128797749, 0.0005079862, -0.0794147849, 0.0201454051, 0.0382870026, 0.0149186654, 0.0116942804, -0.0184258632, 0.0075562536, 0.0198256429, -0.0288819075, -0.0345940627, -0.0595295988, -0.0550468005, 0.0056837481, -0.0732919127, -0.0179404933, -0.0178165436, -0.0011851909, 0.0646276623, -0.0089086052, -0.0374854356, -0.0177022014, -0.0599235035, 0.0110616349, 0.0495384298, -0.0016849717, 0.0530939326, -0.0284127351, -0.0185435601, 0.0176964421, 0.0017653246, -0.0000896671, 0.0072407690, 0.0014501612, -0.0002407256, -0.0001249201, 0.0017020832, 0.0001202690, 0.0005947616, -0.0002102030, -0.0002840367, -0.0019529340, 0.0006147271, -0.0005266006, 0.0022689670, -0.0003905168, -0.0000062758, -0.0012317228, -0.0000685895, -0.0028102025, -0.0004695464, 0.0010666432, 0.0004349836, -0.0009431234, -0.0003640391, 0.0003792611, -0.0005499048, 0.0000694159, -0.0025442836, -0.0010748879, 0.0002034153, 0.0010876323, -0.0140591916, 0.0179531034, -0.0525376871, 0.0756824091, 0.0419004411, 0.0383298360, 0.0393150039, 0.0290295277, -0.0065855640, -0.0162636265, 0.0465911776, -0.0103463996, 0.0363016799, 0.0518075712, 0.0250913352, 0.0407657921, 0.0434951223, 0.0154009303, 0.0707254708, -0.0036856362, -0.0154497493, 0.0158903170, -0.0022850428, 0.0053204359, 0.0521330498, 0.0529951528, -0.0717140362, -0.0045789191, 0.0178837255, 0.0297516584, -0.0541305989, 0.0154075641, -0.0077676089, 0.0425649174, -0.0919301808, 0.0771631896, -0.0141265104, 0.0556770042, 0.0751322806, 0.0536032505, 0.0238590501, 0.0426411033, -0.0182034820, -0.0451345220, 0.0081932154, -0.0088720480, 0.0198757164, -0.1151684895, 0.0907738432, -0.0285285376, -0.0046321750, 0.0208632033, -0.0175010525, -0.0533124395, 0.0014036405, -0.0643569827, 0.0345070735, -0.0302529372, -0.0808304325, -0.0413636342, -0.0434123166, -0.0015192395, 0.0326636583, -0.0457583442, -0.0066025686, 0.0501417220, -0.0423781425, -0.0304338299, -0.0420169719, 0.0221932437, -0.0270112362, 0.0481240749, 0.0922127068, -0.0213081781, -0.0010323767, -0.0236385278, -0.0134232454, 0.0657243207, 0.0238702204, -0.0598280653, -0.0491537526, 0.0593199469, -0.0069391015, -0.0275599919, -0.0619606562, 0.0428184867, 0.0560880117, -0.0574055277, -0.0549091958, -0.0449230820, -0.0256781541, 0.0418161154, -0.0111558251, 0.0528780892, -0.0182996131, -0.0619560145, 0.0713286623, 0.0018081600, -0.0059273425, -0.0160156470, 0.0266376697, 0.0280522518, -0.0462107733, -0.0004493216, 0.0692225024, -0.0276170932, -0.0247518532, -0.0255269259, 0.0244283006, 0.0358052999, 0.0852711201, -0.0346946046, -0.0217607841, -0.0851293504, -0.0925241783, -0.0163407568, -0.0439432636, -0.0199140906, 0.0026790998, 0.0613097772, -0.0569996089, -0.0024106547, 0.0037510765, -0.0002488600, -0.0468970425, -0.0264631268, 0.0560583696, 0.0335039310, -0.0138732335, 0.0066752629, 0.0138700968, 0.0058087115, -0.0019186822, -0.0279320069, -0.0101756901, -0.0038438733, -0.0075991717, -0.0127875842, -0.0182750225, -0.0318941399, -0.0155513426, -0.0100547727, -0.0145942168, -0.0131171383, -0.0107020410, -0.0137352627, -0.0118878316, -0.0063381847, 0.0005376328, -0.0273501836, -0.0056393119, -0.0041867932, -0.0124842459, 0.0003355341, -0.0111330347, -0.0136397528, -0.0201513730, -0.0261807423, 0.0162449032, -0.0027179199, -0.0410742573, 0.0244000219, -0.0085082753, -0.0313245580, -0.0226547047, 0.0185831618, -0.0427903049, 0.0048904098, 0.0170107894, -0.0602839142, -0.0199206509, 0.0268393401, -0.0107086012, -0.0004215059, -0.0466356501, 0.0270597413, -0.0371013544, -0.0124500031, 0.0032064340, -0.0068351077, -0.0061636684, 0.0230548047, -0.0122384820, -0.0170549601, -0.0484457612, 0.0222275853, 0.0101112425, 0.0156244915, -0.0017182094, -0.0033789589, 0.0008405116, -0.0011667071, 0.0036117432, 0.0038778842, -0.0138729308, -0.0135488594, 0.0026168085, -0.0055614561, 0.0216128230, 0.0234127846, -0.0108649489, 0.0118019097, -0.0117438296, -0.0657161325, -0.0320019051, -0.0369929262, -0.0147354491, -0.0054730470, -0.0100270147, -0.0228524264, 0.0067554312, 0.0257122125, 0.0208769571, -0.0371338129, -0.0264187437, -0.0315664485, -0.0208827592, -0.0361994430, 0.0043568360, 0.0014011452, 0.0121827852, -0.0076863556, -0.0163168181, -0.0028633443, -0.0270105284, 0.0492428355, 0.0000854693, 0.0208912771, -0.0513366759, -0.0144276610, 0.0270805340, 0.0467775092, -0.0808205232, -0.0470582843, 0.0102682728, 0.0604980700, -0.0289013740, -0.0003542759, -0.0164393056, -0.0234256368, 0.0018992269, 0.0332633220, -0.0422900505, 0.0021556881, -0.0103575140, 0.0199070238, -0.0419990830, -0.0011539689, 0.0432774089, -0.0463807210, -0.0586659163, -0.0139366277, 0.0208260324, -0.0590004921, 0.0245447401, 0.0380815268, -0.0525793880, -0.0033636605, -0.0167866983, 0.0042146151, -0.0805848017, 0.0506732501, -0.0254102144, -0.1025790125, 0.0207216591, 0.0101981461, -0.0416161343, -0.0716150478, 0.0089648431, -0.0561632775, -0.0176501609, 0.0304755047, -0.0255178660, 0.0118698487, 0.0339564532, 0.0534586310, -0.0068124831, 0.0079929326, 0.0601423122, -0.0766898021, 0.0417911075, 0.0836435109, -0.0479999445, -0.0475041009, 0.0468782336, -0.0403763130, 0.0237137359, 0.0598400496, 0.0158201829, 0.0502891317, 0.0465330034, 0.0076394221, -0.0825322196, 0.0054733520, 0.0114347246, 0.0184208751, 0.0454185829, 0.0305957347, -0.0494227260, 0.0305693876, 0.0158601776, 0.0573556200, 0.0234119520, 0.0096655013, 0.0408308506, 0.0644162297, 0.0172702391, 0.0152991284, 0.0114775263, 0.0612100735, 0.0209816508, -0.0242769979, 0.0221187808, -0.0344929770, 0.0562231466, -0.0072206277, 0.0418432765, -0.0403032452, -0.0354127102, -0.0652189255, 0.0001862268, -0.0096141938, -0.0027594634, 0.0037719309, -0.0237776078, 0.0056442092, -0.0027097501, -0.0068595065, -0.0196927339, -0.0119937081, -0.0175432656, 0.0208535176, 0.0056397105, -0.0116249025, -0.0228202660, 0.0011033356, 0.0042601442, -0.0197589230, 0.0066624475, -0.0125161679, -0.0094399331, -0.0119676786, -0.0058546276, 0.0122667030, 0.0124782203, -0.0255359821, -0.0212329216, 0.0055359975, -0.0106547493, -0.0348019600, 0.0034210191, 0.0113344342, 0.0622636639, -0.0128961401, -0.0432703272, 0.0407974981, -0.0206189342, 0.0194932576, -0.0319116674, -0.0178886950, 0.0727088004, -0.0100332629, -0.0711854100, -0.0462628268, 0.0045042881, 0.0179649573, -0.0344194174, 0.0731198788, 0.0785370469, -0.0094884969, -0.0213310104, 0.0541061871, 0.0221211556, 0.0115836635, -0.0625467226, 0.0535109751, 0.0500904880, 0.0239140037, 0.0416042469, -0.0542828292, 0.0063788155, 0.0128923682, -0.0381811969, -0.0903873593, -0.0027982097, 0.0422271639, 0.0466635749, -0.0652663708, -0.0107688960, 0.0078645023, -0.0785300583, -0.0686068237, -0.0320181027, 0.0343560539, 0.0663586780, 0.0033223073, 0.0099058691, -0.0179458689, -0.0733078495, -0.0309066195, -0.0340718515, -0.0235464927, 0.0135584725, -0.0501235314, -0.0446982160, -0.0259472076, -0.0017121370, 0.0781132281, 0.0171727370, 0.0092647905, 0.0552515388, -0.0496394224, 0.0745909512, 0.0163149610, -0.0186717808, -0.0408957377, 0.0748561323, 0.0176637657, -0.0049664918, -0.0581512898, -0.0692442879, -0.0348604098, -0.0131814200, -0.0203531068, 0.0308497120, 0.0221322756, -0.0447755791, 0.0299693123, 0.0165508520, 0.0175754670, 0.0216895342, -0.0719225556, 0.0592625625, 0.0291631874, -0.0992696583, -0.0169270281, 0.0153537104, -0.0395373851, -0.0125738857, 0.0749825686, 0.0364684761, -0.0627786145, 0.0360882767, 0.0612209924, -0.0058167228, 0.0453487895, 0.0234493092, -0.0574933439, 0.0071640909, -0.0580396950, 0.0103601031, 0.0508462973, 0.0018583264, 0.0285898410, -0.0240228232, -0.0193411652, -0.0417674184, 0.0068384595, 0.0251602624, -0.0461597294, 0.0090858033, 0.0009475573, 0.0307965148, 0.0555718094, -0.0364958793, -0.0331296250, 0.0661037862, -0.0336427130, -0.0343062952, 0.0530319922, -0.0281137805, 0.0349214002, -0.0041828332, 0.0002666832, -0.0228141304, -0.0542863235, 0.0290545523, 0.0014790847, -0.0688810050, 0.0124253882, 0.0013403911, -0.0322996750, -0.0567666478, 0.0169011317, -0.0213800054, 0.0081874477, -0.0106841372, -0.0595493205, 0.0112520494, 0.0196875539, -0.0020687338, -0.0321900062, 0.0502288043, -0.0262287427, 0.0122126006, -0.0364023410, -0.0091603091, -0.0218922347, -0.0345081799, -0.0252485927, 0.0592894964, -0.0039603035, -0.0108329635, -0.0582006276, -0.0275680274, 0.0214070156, -0.0362670831, -0.0369345993, 0.0295719765, -0.0455560870, -0.0463455841, 0.0209235046, -0.0879635662, 0.0079367701, 0.0001513025, 0.0267833676, 0.0349486843, -0.0343411453, 0.1064901501, 0.0485220850, -0.0573784672, -0.0581661388, -0.0341745615, -0.0309941377, -0.0073990505, 0.0053214622, 0.0823086053, -0.0591402613, -0.0068780631, 0.0104883267, 0.0543569587, -0.0286872704, 0.0414843336, -0.1023795679, -0.0077432231, 0.0756377354, 0.0291522406, -0.0403979011, -0.0576862097, 0.0592437759, -0.0638744086, -0.0224924963, 0.0084419083, 0.0044226428, 0.0043656561, 0.0578997917, -0.0226346850, -0.0635456592, 0.0523757786, -0.0368587859, -0.0617670193, -0.0473765843, 0.0376970395, -0.0521042906, 0.0271165166, 0.0944330394, 0.0384175666, 0.0303227007, 0.0279155560, 0.0384664051, 0.0224900134, 0.0011780678, 0.0468620546, 0.0077986801, 0.0675855204, -0.0192776006, -0.0134092681, 0.0008929316, 0.0399398357, 0.0427001044, -0.0382629447, -0.0722704008, -0.0331870988, 0.0354756266, -0.0562910847, 0.0164410118, 0.0175732616, 0.0196149871, -0.0366400778, -0.1227747723, 0.0337932296, -0.0179177765, -0.0557386205, 0.0517410785, 0.0600466952, 0.0366081297, 0.0386121050, 0.0175292324, -0.0177699588, -0.0514772758, 0.0341802314, -0.0485252813, 0.0279209856, 0.0608437322, -0.0451162308, -0.0231305677, 0.0521947294, 0.0485627949, -0.0184473880, 0.0160325859, -0.0039010770, 0.0774268582, 0.0224035680, -0.0039993008, -0.1087456718, -0.0044471053, -0.0421089791, -0.0365803950, 0.0364850871, 0.0192142334, 0.0068134102, 0.0776500106, 0.0434172004, -0.0408582576, 0.0194418691, -0.0003500095, -0.0023773296, 0.0082185064, -0.0092744026, -0.0217963457, -0.0410810784, -0.0045101065, -0.0119363992, 0.0574450642, -0.0113288313, -0.0292582605, -0.0145148924, 0.0252449922, -0.0500666685, -0.0429830290, -0.0152119128, -0.0195782278, -0.0410394035, 0.0256365798, 0.0113125648, 0.0208171643, 0.0036524080, 0.0043859980, 0.0444288924, 0.0064391172, 0.0192120913, -0.0321415626, -0.0930505991, 0.0322133489, 0.0556309856, 0.1107027754, -0.0691293254, 0.0172478557, 0.0016260116, 0.0223733634, -0.0362632126, 0.0279219504, -0.1020871997, -0.0337255560, 0.0529388562, -0.0052250582, -0.0442357697, -0.0487447344, 0.0081203412, 0.0057463255, -0.0254105777, -0.0435103960, 0.0026759813, 0.0533179343, -0.0383712240, -0.0505294949, -0.0262220781, 0.0303743910, 0.0445362218, 0.0604056306, -0.0005719676, -0.0047489689};
# 36 "firmware/parameters.h" 2
# 1 "firmware/weights/b14.h" 1
# 12 "firmware/weights/b14.h"
dense_1_bias_t b14[32] = {0.2146167755, 0.2214489132, 0.0054188035, 0.1812140197, 0.2020682991, 0.2891074121, 0.0777086392, 0.2192692012, 0.3179458678, 0.2951558530, 0.1704185754, 0.2275371999, 0.2674847543, 0.2429715395, 0.0364500694, 0.2614704967, 0.1342103928, 0.1337470263, 0.1711866260, 0.1926809698, 0.1692563891, 0.1787161380, 0.0971323177, 0.1947920024, 0.1975948960, 0.1676036119, 0.2438343912, 0.0888918936, 0.2978717089, 0.2453358769, 0.2540655136, 0.2388480902};
# 37 "firmware/parameters.h" 2
# 1 "firmware/weights/s16.h" 1
# 12 "firmware/weights/s16.h"
batch_normalization_3_scale_t s16[32] = {4.3556599617, 4.9522395134, 4.9672784805, 4.1285414696, 4.8730092049, 4.6720499992, 4.6748566628, 5.6080069542, 4.7448697090, 4.9394102097, 4.8293328285, 4.4335975647, 4.3173899651, 4.8259410858, 5.4498839378, 4.2898979187, 4.9502778053, 4.9797568321, 5.1793470383, 4.6754112244, 5.0590214729, 4.8895244598, 5.8042583466, 5.0556221008, 4.7220778465, 3.9376349449, 4.6782913208, 5.6092295647, 4.1410117149, 4.3534274101, 5.0255765915, 4.9444394112};
# 38 "firmware/parameters.h" 2
# 1 "firmware/weights/b16.h" 1
# 12 "firmware/weights/b16.h"
batch_normalization_3_bias_t b16[32] = {-1.3953984976, -1.5037552118, -0.9394526482, -1.4673980474, -1.5505818129, -2.0181181431, -1.1323317289, -1.7730188370, -2.2864291668, -1.7523987293, -1.5186371803, -1.6618158817, -1.5908648968, -1.7322933674, -0.9935515523, -1.7769644260, -1.3599730730, -1.3152033091, -1.6223104000, -1.4166438580, -1.1481733322, -1.6130375862, -1.4946029186, -1.5869934559, -1.3380337954, -1.1516513824, -1.6919952631, -1.3831071854, -1.8348617554, -1.5135914087, -1.6855173111, -1.7464964390};
# 39 "firmware/parameters.h" 2
# 1 "firmware/weights/w17.h" 1
# 12 "firmware/weights/w17.h"
dense_2_weight_t w17[640] = {-0.3219617307, -0.3179474175, -0.3253006935, -0.2589250803, 0.4034900069, 0.0481836461, -0.2321068943, 0.3224567175, 0.0490757860, -0.5594977140, -0.2907572389, 0.3328317404, 0.1186585650, 0.2496749461, 0.5478585958, 0.3961219490, 0.0938529149, -0.4292225540, 0.0353041850, -0.2507978976, 0.1306921691, 0.4478748143, 0.1734087169, -0.1830087304, -0.4584992230, -0.1587257981, -0.2033100277, -0.4038180709, 0.0544106998, 0.2438288182, 0.1039087772, -0.1365180612, 0.2885256708, 0.3181439936, -0.4317970574, 0.2644504011, -0.2466239780, -0.4264128208, 0.2869094014, -0.4487296343, -0.2592520416, -0.1104102135, -0.3426728547, -0.1458358914, 0.5788726807, -0.2000946999, 0.4775440693, -0.1264424920, 0.1899713278, 0.3901678026, -0.3648368418, -0.3174109161, -0.1581761092, -0.4119109809, -0.2001538724, -0.3609199822, -0.4081478119, -0.0293288175, -0.0115374653, -0.1290116310, 0.4460703433, -0.4505265653, 0.1697140336, -0.3923392892, -0.4240191579, -0.2221123576, 0.0102752484, 0.4372277856, -0.4797076881, -0.4149713218, 0.4086229503, -0.3166967630, 0.5494102240, -0.4518771172, 0.0215601120, 0.1694392413, -0.4631322026, -0.3623555601, 0.2004909664, -0.0205024295, -0.3311504424, -0.3432491124, -0.3914877176, 0.4735004604, -0.1867079139, 0.4522098005, -0.1031799018, -0.4581660628, -0.4764231145, -0.3008555472, 0.5985341072, 0.3897138536, 0.2728939056, 0.2413118631, -0.0842421725, -0.4263275266, -0.0149603775, -0.1901595592, -0.2309327871, -0.0616116337, 0.1076694950, -0.4096595645, 0.3365105391, 0.2728334069, -0.3412545323, -0.4508252144, -0.2507954240, 0.6632753611, 0.1783749610, 0.5011398196, -0.0741535351, -0.3864972591, -0.0946905464, -0.2081571966, -0.6000017524, 0.0727541447, -0.4328612089, 0.0808093473, -0.4568633139, 0.1336751133, -0.2163202763, -0.0341569856, -0.3494573534, -0.5567946434, -0.4808311164, -0.3922828734, 0.5496722460, -0.3653877378, -0.4267916977, -0.0780498981, 0.5096622705, 0.5380080342, -0.2578559220, -0.1442847550, -0.4612121284, 0.1629597545, 0.2646968663, 0.3548305929, -0.0786983520, -0.3554342091, 0.5644682646, -0.0177438408, -0.5122707486, -0.3711305261, -0.5126488805, -0.2639793158, 0.1767037362, 0.3698061109, -0.3364403248, -0.3361505270, 0.1744204611, -0.2066193223, 0.2232363671, 0.3855482042, -0.4293889105, -0.3208785951, 0.2224975079, -0.0519845858, -0.4982999265, -0.4525011778, -0.2736226618, -0.4179122150, 0.5727269650, 0.4156655073, -0.3648410141, -0.2752669752, -0.0592525229, 0.0101399720, 0.4449844360, -0.0107176295, -0.4189511538, -0.0463974215, 0.4143799245, 0.2591044307, -0.0967632532, 0.0783545077, 0.4898529351, -0.2530736625, -0.2036074996, -0.5793952942, -0.3806542158, -0.3577158749, 0.1746481806, 0.5410496593, 0.2987476885, -0.5284059644, -0.2739526629, 0.0539253093, -0.3683422208, -0.2005708069, 0.4618459642, 0.4783128798, -0.4335046113, -0.2663624883, 0.0198937524, 0.3589497805, 0.2697358429, 0.1116078794, -0.4433115721, -0.2805630267, 0.1081112921, 0.0465980507, 0.6346914172, -0.0053433520, -0.2157240510, -0.3726603389, -0.2036376446, -0.1870508641, -0.1012313738, 0.2632401884, 0.5455251932, 0.1899952143, -0.4852023721, -0.3290181160, 0.6081418395, -0.3379441500, 0.1064617783, -0.2379045188, -0.3650225401, -0.0921568722, 0.2589272261, 0.4620382786, -0.3896888196, 0.6225335002, -0.3938128650, 0.3039845824, -0.2293570787, -0.0750252604, -0.0367767178, -0.3991792202, -0.3296299279, -0.0705290437, 0.2986037731, -0.1979105771, 0.4687527120, -0.0549109392, -0.3513127863, -0.1560391337, 0.4559908807, -0.5193260312, -0.4763489366, -0.1808625162, 0.1340042800, -0.3925270140, 0.0777327046, 0.1410570294, 0.5383218527, 0.1301476806, -0.1023566946, 0.4379508793, -0.2222501487, -0.4795772135, -0.4348625541, 0.0247826278, 0.5529038906, 0.3840188980, -0.0969756916, -0.3401172459, -0.5038390160, -0.0876133740, 0.3744409978, -0.0718197748, -0.1881173551, -0.2152882069, 0.4375225008, 0.2366296947, 0.3789722919, 0.2498126626, 0.4206594825, 0.0220718123, -0.1651047766, -0.1339094788, 0.4488303065, -0.3641944826, 0.0170216672, 0.4579128325, -0.0846294165, -0.1714863628, -0.4993346632, -0.2481306493, 0.0912456810, 0.2503419816, -0.0160956345, -0.4239720404, -0.3077189624, 0.0150009114, -0.3552541733, 0.2603850663, 0.4830082655, -0.2482696623, -0.2125735730, 0.2437630296, -0.2507100403, -0.2347468883, 0.1201485768, 0.1704643667, -0.4443548024, -0.1344950050, -0.2729717493, -0.2161600441, 0.0766621456, -0.3966138661, -0.4252302349, -0.3044054210, -0.2016918063, 0.4997044206, -0.4941283762, -0.4626188278, -0.2404577285, 0.2672201991, -0.3088748157, -0.4444860518, 0.3517723083, 0.3231914639, 0.1691435874, -0.0775433257, 0.0144601520, 0.4249167740, -0.3129459023, 0.3732481301, -0.4691541195, -0.2504251301, -0.1465549320, -0.2877074182, -0.1611984223, -0.0026230980, 0.3124041557, 0.5242832899, -0.5207684636, -0.2883646190, -0.5517493486, -0.0332042798, -0.1528947651, -0.2571667731, -0.1975224018, 0.5302066207, 0.1960174888, -0.5716041923, -0.3926523328, -0.2130222321, 0.4096651971, 0.1854655743, -0.3664943576, -0.4188233018, -0.3449970782, -0.2692835331, -0.3333630562, -0.0559656881, 0.2880204916, -0.0099188592, -0.3822135031, -0.2485366166, -0.3124951124, -0.2251814455, -0.2381618023, -0.3467586040, 0.6012063622, -0.4258618653, 0.1227595434, -0.0367565192, 0.5269293189, -0.5037749410, 0.4864117503, -0.1642638594, -0.2439964861, 0.2859804928, -0.3225239813, -0.3397781551, 0.3920062184, 0.2096997350, -0.0219944790, 0.3938233554, -0.3657183051, -0.3209987581, -0.5318020582, -0.1664972603, -0.2658616900, 0.1130217165, 0.1872348636, -0.2547289431, -0.2447672635, -0.5035233498, -0.3242903054, -0.2144943476, -0.2935825288, -0.3516923189, -0.0240502544, 0.2547376156, 0.3387868702, -0.1332403719, -0.3402659893, -0.0125078782, 0.1184533238, -0.4199330807, 0.0042021391, -0.3692505956, 0.5927565694, 0.2492166758, 0.3077112734, 0.0902901217, -0.2521517575, 0.0554874651, -0.3572229147, 0.2232719362, -0.2134809941, 0.0895926952, 0.0521411784, -0.2631281912, 0.1072005257, -0.2365556657, 0.0386358164, -0.2507415414, -0.4846200943, -0.3505975306, -0.0679713115, -0.0373630077, 0.2997417152, 0.6022399068, -0.3007915616, -0.0557477251, 0.4145163596, -0.1612062007, -0.2002648860, 0.1188616976, -0.0433373488, 0.0613249056, -0.1245988160, -0.1619302481, -0.4895159304, 0.1505568027, -0.0418844186, -0.2696838081, -0.0366436243, 0.2700554132, 0.3525425792, 0.0408923700, 0.2036526650, -0.5218380094, -0.3921124041, 0.5536988378, -0.0668000132, 0.2746134400, 0.3288580179, 0.3457250893, -0.0194766708, -0.2555481493, -0.1853886992, -0.4548073709, 0.3162918091, 0.4467211068, -0.2108203024, 0.2963097095, 0.0741789639, 0.0027215441, -0.2023313940, -0.2139503062, 0.0719911382, -0.4492568076, -0.1279122829, 0.5907252431, 0.2340369821, 0.5594138503, 0.3163151741, -0.2485144585, 0.2463837564, 0.3889266551, 0.1722907871, 0.5070196390, -0.2305362821, 0.1748796850, -0.1282514334, -0.0295460820, -0.1193820760, -0.0719534457, 0.5592195988, -0.5587149262, -0.0948314220, 0.1403487921, -0.1219928637, -0.2601611316, 0.1054949388, 0.5014094114, -0.2751744390, -0.4110785425, -0.1698471457, 0.4777669609, -0.3423879147, -0.3858631551, -0.4645465314, -0.0710202381, -0.1768646389, -0.0324396677, -0.3871386647, -0.3210443556, -0.1198339239, 0.4487899542, -0.3199375272, -0.2486183643, -0.3856948018, 0.3300523460, -0.4585408568, -0.3404814601, 0.2562626302, -0.2090929300, -0.3624032438, 0.5069327950, 0.1613596231, -0.0410045609, -0.2921402454, 0.3612013161, -0.2045998424, -0.2511519790, -0.3593572676, 0.4075330794, -0.3147437572, 0.0693027973, -0.2964383662, 0.0578434169, 0.3925376832, 0.1001910120, -0.2743220925, 0.3711382151, 0.3638832867, 0.0413737223, 0.1969943345, -0.1547901034, -0.2187084854, -0.0828316584, -0.4287728667, 0.1645261943, -0.3090519905, -0.3838739097, 0.2430522293, 0.5354354978, -0.4523912668, -0.3446881771, 0.1471635103, 0.3770377636, -0.2237408161, 0.1949094832, 0.0993445590, 0.4248429239, -0.2373193949, 0.3600160778, -0.3050585687, -0.4543933570, 0.1344990134, 0.2003426999, -0.0729193985, -0.1549998820, -0.3190129697, 0.5143399835, 0.4175634980, 0.5406430364, 0.0359943919, -0.2061853409, 0.0787925571, 0.3104555607, -0.3905118406, -0.0787934363, 0.0068881796, 0.0452791899, 0.2574585080, 0.2325134873, 0.1285036802, -0.2730311155, -0.5620608330, -0.0500617027, -0.3030829132, 0.4209191799, 0.3350128233, -0.4406996071, 0.3783540428, -0.3183709681, 0.0323414691, 0.5213636756, -0.3831048608, 0.5684383512, -0.4552493691, -0.2689042091, -0.4026924074, 0.0220402293, -0.5076163411, -0.1129975766, -0.1255742908, -0.1146090776, -0.1178133786, 0.4179041088, 0.0289601739, 0.5951974392, -0.0981149971, 0.5956001282, -0.1257319152, 0.2477414459, 0.1040276513, 0.0060272012, 0.3469789028, 0.0371518247, -0.3443826735, -0.4520216286, -0.4477707148, 0.3596610427, 0.2552888095, -0.5291432738, -0.3085330427, -0.5889159441, 0.2269656509, 0.2738843262, -0.1051775962, -0.0616755113, -0.2810493410, 0.0089059575, 0.2995770574, 0.4101028144, -0.2196316868, -0.1383188218, -0.4259396195, -0.3823560774, 0.4641948938, 0.5177618861, -0.2417598814, -0.4390452504, -0.3130626678, -0.0194734540, -0.5639134645, -0.3354435265, 0.3788914680, 0.3394177556, 0.3611572981, 0.2978766263, 0.2382244319, -0.3900963664, -0.1499983221, -0.1206938922, 0.3360696137, -0.4569860995, -0.2047561258, 0.0056743762, 0.2733449042, 0.2655707300};
# 40 "firmware/parameters.h" 2
# 1 "firmware/weights/b17.h" 1
# 12 "firmware/weights/b17.h"
dense_2_bias_t b17[20] = {-0.0915184021, 0.0379908420, -0.0559477620, -0.0872862488, -0.0069240648, 0.0368544906, -0.0073806145, -0.0308654867, 0.0540143698, 0.0131187113, 0.0687365457, -0.0370402373, 0.0517627038, -0.0569901168, 0.0931971744, -0.0078883879, -0.0448688082, 0.0763967335, -0.0585049056, -0.0245482568};
# 41 "firmware/parameters.h" 2





struct config2_mult : nnet::dense_config {
    static const unsigned n_in = 3;
    static const unsigned n_out = 16;
    static const unsigned reuse_factor = 1;
    static const unsigned strategy = nnet::latency;
    static const unsigned n_zeros = 0;
    static const unsigned multiplier_limit = ((n_in * n_out + reuse_factor - 1) / reuse_factor) - n_zeros / reuse_factor;
    typedef model_default_t accum_t;
    typedef conv1d_bias_t bias_t;
    typedef conv1d_weight_t weight_t;
    template<class x_T, class y_T>
    using product = nnet::product::mult<x_T, y_T>;
};

struct config2 : nnet::conv1d_config {
    static const unsigned pad_left = 0;
    static const unsigned pad_right = 0;
    static const unsigned in_width = 120;
    static const unsigned n_chan = 1;
    static const unsigned filt_width = 3;
    static const unsigned kernel_size = filt_width;
    static const unsigned n_filt = 16;
    static const unsigned stride_width = 1;
    static const unsigned dilation = 1;
    static const unsigned out_width = 118;
    static const unsigned reuse_factor = 1;
    static const unsigned n_zeros = 0;
    static const unsigned multiplier_limit =
        ((kernel_size * n_chan * n_filt + reuse_factor - 1) / reuse_factor) - n_zeros / reuse_factor;
    static const bool store_weights_in_bram = false;
    static const unsigned strategy = nnet::latency;
    static const nnet::conv_implementation implementation = nnet::conv_implementation::linebuffer;
    static const unsigned min_width = 120;
    static const ap_uint<filt_width> pixels[min_width];
    static const unsigned n_partitions = 118;
    static const unsigned n_pixels = out_width / n_partitions;
    template<class data_T, class CONFIG_T>
    using fill_buffer = nnet::fill_buffer_2<data_T, CONFIG_T>;
    typedef model_default_t accum_t;
    typedef conv1d_bias_t bias_t;
    typedef conv1d_weight_t weight_t;
    typedef config2_mult mult_config;
    template<unsigned K, unsigned S, unsigned W>
    using scale_index = nnet::scale_index_unscaled<K, S, W>;
};
const ap_uint<config2::filt_width> config2::pixels[] = {0};


struct relu_config3 : nnet::activ_config {
    static const unsigned n_in = 1888;
    static const unsigned table_size = 1024;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned reuse_factor = 1;
    typedef conv1d_relu_table_t table_t;
};


struct config4 : nnet::batchnorm_config {
    static const unsigned n_in = 118*16;
    static const unsigned n_filt = 16;
    static const unsigned n_scale_bias = (n_filt == -1) ? n_in : n_filt;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned reuse_factor = 1;
    static const unsigned multiplier_limit = ((n_in + reuse_factor - 1) / reuse_factor);
    static const bool store_weights_in_bram = false;
    typedef batch_normalization_bias_t bias_t;
    typedef batch_normalization_scale_t scale_t;
    template<class x_T, class y_T>
    using product = nnet::product::mult<x_T, y_T>;
};


struct config5 : nnet::pooling1d_config {
    static const unsigned n_in = 118;
    static const unsigned n_out = 59;
    static const unsigned n_filt = 16;
    static const unsigned pool_width = 2;

    static const unsigned filt_width = pool_width;
    static const unsigned n_chan = n_filt;

    static const unsigned pad_left = 0;
    static const unsigned pad_right = 0;
    static const bool count_pad = false;
    static const unsigned stride_width = 2;
    static const nnet::Pool_Op pool_op = nnet::Max;
    static const nnet::conv_implementation implementation = nnet::conv_implementation::linebuffer;
    static const unsigned reuse_factor = 1;
    typedef model_default_t accum_t;
};


struct config6_mult : nnet::dense_config {
    static const unsigned n_in = 48;
    static const unsigned n_out = 32;
    static const unsigned reuse_factor = 1;
    static const unsigned strategy = nnet::latency;
    static const unsigned n_zeros = 0;
    static const unsigned multiplier_limit = ((n_in * n_out + reuse_factor - 1) / reuse_factor) - n_zeros / reuse_factor;
    typedef model_default_t accum_t;
    typedef conv1d_1_bias_t bias_t;
    typedef conv1d_1_weight_t weight_t;
    template<class x_T, class y_T>
    using product = nnet::product::mult<x_T, y_T>;
};

struct config6 : nnet::conv1d_config {
    static const unsigned pad_left = 0;
    static const unsigned pad_right = 0;
    static const unsigned in_width = 59;
    static const unsigned n_chan = 16;
    static const unsigned filt_width = 3;
    static const unsigned kernel_size = filt_width;
    static const unsigned n_filt = 32;
    static const unsigned stride_width = 1;
    static const unsigned dilation = 1;
    static const unsigned out_width = 57;
    static const unsigned reuse_factor = 1;
    static const unsigned n_zeros = 0;
    static const unsigned multiplier_limit =
        ((kernel_size * n_chan * n_filt + reuse_factor - 1) / reuse_factor) - n_zeros / reuse_factor;
    static const bool store_weights_in_bram = false;
    static const unsigned strategy = nnet::latency;
    static const nnet::conv_implementation implementation = nnet::conv_implementation::linebuffer;
    static const unsigned min_width = 59;
    static const ap_uint<filt_width> pixels[min_width];
    static const unsigned n_partitions = 57;
    static const unsigned n_pixels = out_width / n_partitions;
    template<class data_T, class CONFIG_T>
    using fill_buffer = nnet::fill_buffer_6<data_T, CONFIG_T>;
    typedef model_default_t accum_t;
    typedef conv1d_1_bias_t bias_t;
    typedef conv1d_1_weight_t weight_t;
    typedef config6_mult mult_config;
    template<unsigned K, unsigned S, unsigned W>
    using scale_index = nnet::scale_index_unscaled<K, S, W>;
};
const ap_uint<config6::filt_width> config6::pixels[] = {0};


struct relu_config7 : nnet::activ_config {
    static const unsigned n_in = 1824;
    static const unsigned table_size = 1024;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned reuse_factor = 1;
    typedef conv1d_1_relu_table_t table_t;
};


struct config8 : nnet::batchnorm_config {
    static const unsigned n_in = 57*32;
    static const unsigned n_filt = 32;
    static const unsigned n_scale_bias = (n_filt == -1) ? n_in : n_filt;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned reuse_factor = 1;
    static const unsigned multiplier_limit = ((n_in + reuse_factor - 1) / reuse_factor);
    static const bool store_weights_in_bram = false;
    typedef batch_normalization_1_bias_t bias_t;
    typedef batch_normalization_1_scale_t scale_t;
    template<class x_T, class y_T>
    using product = nnet::product::mult<x_T, y_T>;
};


struct config9 : nnet::pooling1d_config {
    static const unsigned n_in = 57;
    static const unsigned n_out = 28;
    static const unsigned n_filt = 32;
    static const unsigned pool_width = 2;

    static const unsigned filt_width = pool_width;
    static const unsigned n_chan = n_filt;

    static const unsigned pad_left = 0;
    static const unsigned pad_right = 0;
    static const bool count_pad = false;
    static const unsigned stride_width = 2;
    static const nnet::Pool_Op pool_op = nnet::Max;
    static const nnet::conv_implementation implementation = nnet::conv_implementation::linebuffer;
    static const unsigned reuse_factor = 1;
    typedef model_default_t accum_t;
};


struct config11 : nnet::dense_config {
    static const unsigned n_in = 896;
    static const unsigned n_out = 64;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned strategy = nnet::latency;
    static const unsigned reuse_factor = 1;
    static const unsigned n_zeros = 0;
    static const unsigned n_nonzeros = 57344;
    static const unsigned multiplier_limit = ((n_in * n_out + reuse_factor - 1) / reuse_factor) - n_zeros / reuse_factor;
    static const bool store_weights_in_bram = false;
    typedef model_default_t accum_t;
    typedef dense_bias_t bias_t;
    typedef dense_weight_t weight_t;
    typedef layer11_index index_t;
    template<class x_T, class y_T>
    using product = nnet::product::mult<x_T, y_T>;
};


struct relu_config12 : nnet::activ_config {
    static const unsigned n_in = 64;
    static const unsigned table_size = 1024;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned reuse_factor = 1;
    typedef dense_relu_table_t table_t;
};


struct config13 : nnet::batchnorm_config {
    static const unsigned n_in = 64;
    static const unsigned n_filt = -1;
    static const unsigned n_scale_bias = (n_filt == -1) ? n_in : n_filt;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned reuse_factor = 1;
    static const unsigned multiplier_limit = ((n_in + reuse_factor - 1) / reuse_factor);
    static const bool store_weights_in_bram = false;
    typedef batch_normalization_2_bias_t bias_t;
    typedef batch_normalization_2_scale_t scale_t;
    template<class x_T, class y_T>
    using product = nnet::product::mult<x_T, y_T>;
};


struct config14 : nnet::dense_config {
    static const unsigned n_in = 64;
    static const unsigned n_out = 32;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned strategy = nnet::latency;
    static const unsigned reuse_factor = 1;
    static const unsigned n_zeros = 0;
    static const unsigned n_nonzeros = 2048;
    static const unsigned multiplier_limit = ((n_in * n_out + reuse_factor - 1) / reuse_factor) - n_zeros / reuse_factor;
    static const bool store_weights_in_bram = false;
    typedef model_default_t accum_t;
    typedef dense_1_bias_t bias_t;
    typedef dense_1_weight_t weight_t;
    typedef layer14_index index_t;
    template<class x_T, class y_T>
    using product = nnet::product::mult<x_T, y_T>;
};


struct relu_config15 : nnet::activ_config {
    static const unsigned n_in = 32;
    static const unsigned table_size = 1024;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned reuse_factor = 1;
    typedef dense_1_relu_table_t table_t;
};


struct config16 : nnet::batchnorm_config {
    static const unsigned n_in = 32;
    static const unsigned n_filt = -1;
    static const unsigned n_scale_bias = (n_filt == -1) ? n_in : n_filt;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned reuse_factor = 1;
    static const unsigned multiplier_limit = ((n_in + reuse_factor - 1) / reuse_factor);
    static const bool store_weights_in_bram = false;
    typedef batch_normalization_3_bias_t bias_t;
    typedef batch_normalization_3_scale_t scale_t;
    template<class x_T, class y_T>
    using product = nnet::product::mult<x_T, y_T>;
};


struct config17 : nnet::dense_config {
    static const unsigned n_in = 32;
    static const unsigned n_out = 20;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned strategy = nnet::latency;
    static const unsigned reuse_factor = 1;
    static const unsigned n_zeros = 0;
    static const unsigned n_nonzeros = 640;
    static const unsigned multiplier_limit = ((n_in * n_out + reuse_factor - 1) / reuse_factor) - n_zeros / reuse_factor;
    static const bool store_weights_in_bram = false;
    typedef model_default_t accum_t;
    typedef dense_2_bias_t bias_t;
    typedef dense_2_weight_t weight_t;
    typedef layer17_index index_t;
    template<class x_T, class y_T>
    using product = nnet::product::mult<x_T, y_T>;
};


struct softmax_config18 : nnet::activ_config {
    static const unsigned n_in = 20;
    static const unsigned table_size = 1024;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned reuse_factor = 1;
    static const unsigned axis = -1;
    static const nnet::softmax_implementation implementation = nnet::softmax_implementation::stable;
    typedef dense_2_softmax_exp_table_t exp_table_t;
    typedef dense_2_softmax_inv_table_t inv_table_t;
};
# 5 "firmware/myproject.cpp" 2



void myproject(
    input_t input_1[120*1],
    result_t layer18_out[20]
) {


#pragma HLS ARRAY_RESHAPE variable=input_1 complete dim=0
#pragma HLS ARRAY_PARTITION variable=layer18_out complete dim=0
#pragma HLS INTERFACE ap_vld port=input_1,layer18_out
#pragma HLS DATAFLOW


 nnet::load_weights_from_txt<conv1d_weight_t, 48>(w2, "w2.txt");
        nnet::load_weights_from_txt<conv1d_bias_t, 16>(b2, "b2.txt");
        nnet::load_weights_from_txt<batch_normalization_scale_t, 16>(s4, "s4.txt");
        nnet::load_weights_from_txt<batch_normalization_bias_t, 16>(b4, "b4.txt");
        nnet::load_weights_from_txt<conv1d_1_weight_t, 1536>(w6, "w6.txt");
        nnet::load_weights_from_txt<conv1d_1_bias_t, 32>(b6, "b6.txt");
        nnet::load_weights_from_txt<batch_normalization_1_scale_t, 32>(s8, "s8.txt");
        nnet::load_weights_from_txt<batch_normalization_1_bias_t, 32>(b8, "b8.txt");
        nnet::load_weights_from_txt<dense_weight_t, 57344>(w11, "w11.txt");
        nnet::load_weights_from_txt<dense_bias_t, 64>(b11, "b11.txt");
        nnet::load_weights_from_txt<batch_normalization_2_scale_t, 64>(s13, "s13.txt");
        nnet::load_weights_from_txt<batch_normalization_2_bias_t, 64>(b13, "b13.txt");
        nnet::load_weights_from_txt<dense_1_weight_t, 2048>(w14, "w14.txt");
        nnet::load_weights_from_txt<dense_1_bias_t, 32>(b14, "b14.txt");
        nnet::load_weights_from_txt<batch_normalization_3_scale_t, 32>(s16, "s16.txt");
        nnet::load_weights_from_txt<batch_normalization_3_bias_t, 32>(b16, "b16.txt");
        nnet::load_weights_from_txt<dense_2_weight_t, 640>(w17, "w17.txt");
        nnet::load_weights_from_txt<dense_2_bias_t, 20>(b17, "b17.txt");







    layer2_t layer2_out[118*16];
#pragma HLS ARRAY_PARTITION variable=layer2_out complete dim=0
 nnet::conv_1d_cl<input_t, layer2_t, config2>(input_1, layer2_out, w2, b2);

    layer3_t layer3_out[118*16];
#pragma HLS ARRAY_PARTITION variable=layer3_out complete dim=0
 nnet::relu<layer2_t, layer3_t, relu_config3>(layer2_out, layer3_out);

    layer4_t layer4_out[118*16];
#pragma HLS ARRAY_PARTITION variable=layer4_out complete dim=0
 nnet::normalize<layer3_t, layer4_t, config4>(layer3_out, layer4_out, s4, b4);

    layer5_t layer5_out[59*16];
#pragma HLS ARRAY_PARTITION variable=layer5_out complete dim=0
 nnet::pooling1d_cl<layer4_t, layer5_t, config5>(layer4_out, layer5_out);

    layer6_t layer6_out[57*32];
#pragma HLS ARRAY_PARTITION variable=layer6_out complete dim=0
 nnet::conv_1d_cl<layer5_t, layer6_t, config6>(layer5_out, layer6_out, w6, b6);

    layer7_t layer7_out[57*32];
#pragma HLS ARRAY_PARTITION variable=layer7_out complete dim=0
 nnet::relu<layer6_t, layer7_t, relu_config7>(layer6_out, layer7_out);

    layer8_t layer8_out[57*32];
#pragma HLS ARRAY_PARTITION variable=layer8_out complete dim=0
 nnet::normalize<layer7_t, layer8_t, config8>(layer7_out, layer8_out, s8, b8);

    layer9_t layer9_out[28*32];
#pragma HLS ARRAY_PARTITION variable=layer9_out complete dim=0
 nnet::pooling1d_cl<layer8_t, layer9_t, config9>(layer8_out, layer9_out);

    auto& layer10_out = layer9_out;
    layer11_t layer11_out[64];
#pragma HLS ARRAY_PARTITION variable=layer11_out complete dim=0
 nnet::dense<layer9_t, layer11_t, config11>(layer10_out, layer11_out, w11, b11);

    layer12_t layer12_out[64];
#pragma HLS ARRAY_PARTITION variable=layer12_out complete dim=0
 nnet::relu<layer11_t, layer12_t, relu_config12>(layer11_out, layer12_out);

    layer13_t layer13_out[64];
#pragma HLS ARRAY_PARTITION variable=layer13_out complete dim=0
 nnet::normalize<layer12_t, layer13_t, config13>(layer12_out, layer13_out, s13, b13);

    layer14_t layer14_out[32];
#pragma HLS ARRAY_PARTITION variable=layer14_out complete dim=0
 nnet::dense<layer13_t, layer14_t, config14>(layer13_out, layer14_out, w14, b14);

    layer15_t layer15_out[32];
#pragma HLS ARRAY_PARTITION variable=layer15_out complete dim=0
 nnet::relu<layer14_t, layer15_t, relu_config15>(layer14_out, layer15_out);

    layer16_t layer16_out[32];
#pragma HLS ARRAY_PARTITION variable=layer16_out complete dim=0
 nnet::normalize<layer15_t, layer16_t, config16>(layer15_out, layer16_out, s16, b16);

    layer17_t layer17_out[20];
#pragma HLS ARRAY_PARTITION variable=layer17_out complete dim=0
 nnet::dense<layer16_t, layer17_t, config17>(layer16_out, layer17_out, w17, b17);

    nnet::softmax<layer17_t, result_t, softmax_config18>(layer17_out, layer18_out);

}
